/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(1);



/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
	    var StateMan = __webpack_require__(2);
	    var templates = __webpack_require__(57);
	    var dataImport = __webpack_require__(9);
	    var stateman = new StateMan({
	        title: "EasyChart",
	        strict: true
	    });

	    var config = {
	        enter: function(option){
	            console.log("enter: " + this.name + "; param: " + JSON.stringify(option.param))
	        },
	        leave: function(option){
	            console.log("leave: " + this.name + "; param: " + JSON.stringify(option.param))
	        },
	        update: function(option){
	            console.log("update: " + this.name + "; param: " + JSON.stringify(option.param))
	        }
	    };

	    function cfg(o){
	        o.enter = o.enter || config.enter;
	        o.leave = o.leave || config.leave;
	        o.update = o.update || config.update;
	        return o;
	    }

	    stateman.state({
	        "app": config,
	        "app.import":  cfg({
	            enter: function( option ){
	                dataImport.load(document.getElementById('app'));
	            },
	            leave: function(){
	                dataImport.destroy();
	            }
	        }),
	        "app.templates":  cfg({
	            enter: function( option ){
	                var chart = __webpack_require__(19);
	                var doc = document.getElementById('app');
	                doc.innerHTML = '<div id="chart"></div><div id="templates"></div>';
	                chart.load(doc.querySelector('#chart'));
	                templates.load();
	            }
	        }),

	        "app.customise":  cfg({
	            enter: function( option ){
	                var doc = document.getElementById('app');
	                doc.innerHTML = 'customise';
	            }
	        })
	    }).on("notfound", function(){
	        this.go('app.import');
	    });

	    document.addEventListener("DOMContentLoaded", function(event) {
	        stateman.start({});
	    });

	})();


/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	
	var StateMan = __webpack_require__(3);
	StateMan.Histery = __webpack_require__(6);
	StateMan.util = __webpack_require__(5);
	StateMan.State = __webpack_require__(4);

	module.exports = StateMan;


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	var State = __webpack_require__(4),
	  Histery = __webpack_require__(6),
	  brow = __webpack_require__(7),
	  _ = __webpack_require__(5),
	  baseTitle = document.title,
	  stateFn = State.prototype.state;


	function StateMan(options){

	  if(this instanceof StateMan === false){ return new StateMan(options)}
	  options = options || {};
	  // if(options.history) this.history = options.history;

	  this._states = {};
	  this._stashCallback = [];
	  this.strict = options.strict;
	  this.current = this.active = this;
	  this.title = options.title;
	  this.on("end", function(){
	    var cur = this.current,title;
	    while( cur ){
	      title = cur.title;
	      if(title) break; 
	      cur = cur.parent;
	    }
	    document.title = typeof title === "function"? cur.title(): String( title || baseTitle ) ;
	  })

	}


	_.extend( _.emitable( StateMan ), {
	    // keep blank
	    name: '',

	    state: function(stateName, config){

	      var active = this.active;
	      if(typeof stateName === "string" && active){
	         stateName = stateName.replace("~", active.name)
	         if(active.parent) stateName = stateName.replace("^", active.parent.name || "");
	      }
	      // ^ represent current.parent
	      // ~ represent  current
	      // only 
	      return stateFn.apply(this, arguments);

	    },
	    start: function(options){

	      if( !this.history ) this.history = new Histery(options); 
	      if( !this.history.isStart ){
	        this.history.on("change", _.bind(this._afterPathChange, this));
	        this.history.start();
	      } 
	      return this;

	    },
	    stop: function(){
	      this.history.stop();
	    },
	    // @TODO direct go the point state
	    go: function(state, option, callback){
	      option = option || {};
	      if(typeof state === "string") state = this.state(state);

	      if(!state) return;

	      if(typeof option === "function"){
	        callback = option;
	        option = {};
	      }

	      if(option.encode !== false){
	        var url = state.encode(option.param)
	        option.path = url;
	        this.nav(url, {silent: true, replace: option.replace});
	      }

	      this._go(state, option, callback);

	      return this;
	    },
	    nav: function(url, options, callback){
	      if(typeof options === "function"){
	        callback = options;
	        options = {};
	      }
	      options = options || {};

	      options.path = url;

	      this.history.nav( url, _.extend({silent: true}, options));
	      if(!options.silent) this._afterPathChange( _.cleanPath(url) , options , callback)

	      return this;
	    },
	    decode: function(path){

	      var pathAndQuery = path.split("?");
	      var query = this._findQuery(pathAndQuery[1]);
	      path = pathAndQuery[0];
	      var state = this._findState(this, path);
	      if(state) _.extend(state.param, query);
	      return state;

	    },
	    encode: function(stateName, param){
	      var state = this.state(stateName);
	      return state? state.encode(param) : '';
	    },
	    // notify specify state
	    // check the active statename whether to match the passed condition (stateName and param)
	    is: function(stateName, param, isStrict){
	      if(!stateName) return false;
	      var stateName = (stateName.name || stateName);
	      var current = this.current, currentName = current.name;
	      var matchPath = isStrict? currentName === stateName : (currentName + ".").indexOf(stateName + ".")===0;
	      return matchPath && (!param || _.eql(param, this.param)); 
	    },
	    // after pathchange changed
	    // @TODO: afterPathChange need based on decode
	    _afterPathChange: function(path, options ,callback){

	      this.emit("history:change", path);

	      var found = this.decode(path);

	      options = options || {};

	      options.path = path;

	      if(!found){
	        // loc.nav("$default", {silent: true})
	        return this._notfound(options);
	      }

	      options.param = found.param;

	      this._go( found, options, callback );
	    },
	    _notfound: function(options){

	      // var $notfound = this.state("$notfound");

	      // if( $notfound ) this._go($notfound, options);

	      return this.emit("notfound", options);
	    },
	    // goto the state with some option
	    _go: function(state, option, callback){

	      var over;

	      // if(typeof state === "string") state = this.state(state);

	      // if(!state) return _.log("destination is not defined")

	      if(state.hasNext && this.strict) return this._notfound({name: state.name});

	      // not touch the end in previous transtion

	      // if( this.pending ){
	      //   var pendingCurrent = this.pending.current;
	      //   this.pending.stop();
	      //   _.log("naving to [" + pendingCurrent.name + "] will be stoped, trying to ["+state.name+"] now");
	      // }
	      // if(this.active !== this.current){
	      //   // we need return
	      //   _.log("naving to [" + this.current.name + "] will be stoped, trying to ["+state.name+"] now");
	      //   this.current = this.active;
	      //   // back to before
	      // }
	      option.param = option.param || {};

	      var current = this.current,
	        baseState = this._findBase(current, state),
	        prepath = this.path,
	        self = this;


	      if( typeof callback === "function" ) this._stashCallback.push(callback);
	      // if we done the navigating when start
	      function done(success){
	        over = true;
	        if( success !== false ) self.emit("end");
	        self.pending = null;
	        self._popStash(option);
	      }
	      
	      option.previous = current;
	      option.current = state;

	      if(current !== state){
	        option.stop = function(){
	          done(false);
	          self.nav( prepath? prepath: "/", {silent:true});
	        }
	        self.emit("begin", option);

	      }
	      // if we stop it in 'begin' listener
	      if(over === true) return;

	      if(current !== state){
	        // option as transition object.

	        option.phase = 'permission';
	        this._walk(current, state, option, true , _.bind( function( notRejected ){

	          if( notRejected===false ){
	            // if reject in callForPermission, we will return to old 
	            prepath && this.nav( prepath, {silent: true})

	            done(false, 2)

	            return this.emit('abort', option);

	          } 

	          // stop previous pending.
	          if(this.pending) this.pending.stop() 
	          this.pending = option;
	          this.path = option.path;
	          this.current = option.current;
	          this.param = option.param;
	          this.previous = option.previous;
	          option.phase = 'navigation';
	          this._walk(current, state, option, false, _.bind(function( notRejected ){

	            if( notRejected === false ){
	              this.current = this.active;
	              done(false)
	              return this.emit('abort', option);
	            }


	            this.active = option.current;

	            option.phase = 'completion';
	            return done()

	          }, this) )

	        }, this) )

	      }else{
	        self._checkQueryAndParam(baseState, option);
	        this.pending = null;
	        done();
	      }
	      
	    },
	    _popStash: function(option){

	      var stash = this._stashCallback, len = stash.length;

	      this._stashCallback = [];

	      if(!len) return;

	      for(var i = 0; i < len; i++){
	        stash[i].call(this, option)
	      }
	    },

	    // the transition logic  Used in Both canLeave canEnter && leave enter LifeCycle

	    _walk: function(from, to, option, callForPermit , callback){

	      // nothing -> app.state
	      var parent = this._findBase(from , to);


	      option.basckward = true;
	      this._transit( from, parent, option, callForPermit , _.bind( function( notRejected ){

	        if( notRejected === false ) return callback( notRejected );

	        // only actual transiton need update base state;
	        if( !callForPermit )  this._checkQueryAndParam(parent, option)

	        option.basckward = false;
	        this._transit( parent, to, option, callForPermit,  callback)

	      }, this) )

	    },

	    _transit: function(from, to, option, callForPermit, callback){
	      //  touch the ending
	      if( from === to ) return callback();

	      var back = from.name.length > to.name.length;
	      var method = back? 'leave': 'enter';
	      var applied;

	      // use canEnter to detect permission
	      if( callForPermit) method = 'can' + method.replace(/^\w/, function(a){ return a.toUpperCase() });

	      var loop = _.bind(function( notRejected ){


	        // stop transition or touch the end
	        if( applied === to || notRejected === false ) return callback(notRejected);

	        if( !applied ) {

	          applied = back? from : this._computeNext(from, to);

	        }else{

	          applied = this._computeNext(applied, to);
	        }

	        if( (back && applied === to) || !applied )return callback( notRejected )

	        this._moveOn( applied, method, option, loop );

	      }, this);

	      loop();
	    },

	    _moveOn: function( applied, method, option, callback){

	      var isDone = false;
	      var isPending = false;

	      option.async = function(){

	        isPending = true;

	        return done;
	      }

	      function done( notRejected ){
	        if( isDone ) return;
	        isPending = false;
	        isDone = true;
	        callback( notRejected );
	      }

	      

	      option.stop = function(){
	        done( false );
	      }


	      this.active = applied;
	      var retValue = applied[method]? applied[method]( option ): true;

	      if(method === 'enter') applied.visited = true;
	      // promise
	      // need breadk , if we call option.stop first;

	      if( _.isPromise(retValue) ){

	        return this._wrapPromise(retValue, done); 

	      }

	      // if haven't call option.async yet
	      if( !isPending ) done( retValue )

	    },


	    _wrapPromise: function( promise, next ){

	      return promise.then( next, function(){next(false)}) ;

	    },

	    _computeNext: function( from, to ){

	      var fname = from.name;
	      var tname = to.name;

	      var tsplit = tname.split('.')
	      var fsplit = fname.split('.')

	      var tlen = tsplit.length;
	      var flen = fsplit.length;

	      if(fname === '') flen = 0;
	      if(tname === '') tlen = 0;

	      if( flen < tlen ){
	        fsplit[flen] = tsplit[flen];
	      }else{
	        fsplit.pop();
	      }

	      return this.state(fsplit.join('.'))

	    },

	    _findQuery: function(querystr){

	      var queries = querystr && querystr.split("&"), query= {};
	      if(queries){
	        var len = queries.length;
	        var query = {};
	        for(var i =0; i< len; i++){
	          var tmp = queries[i].split("=");
	          query[tmp[0]] = tmp[1];
	        }
	      }
	      return query;

	    },
	    _findState: function(state, path){
	      var states = state._states, found, param;

	      // leaf-state has the high priority upon branch-state
	      if(state.hasNext){
	        for(var i in states) if(states.hasOwnProperty(i)){
	          found = this._findState( states[i], path );
	          if( found ) return found;
	        }
	      }
	      // in strict mode only leaf can be touched
	      // if all children is don. will try it self
	      param = state.regexp && state.decode(path);
	      if(param){
	        state.param = param;
	        return state;
	      }else{
	        return false;
	      }
	    },
	    // find the same branch;
	    _findBase: function(now, before){

	      if(!now || !before || now == this || before == this) return this;
	      var np = now, bp = before, tmp;
	      while(np && bp){
	        tmp = bp;
	        while(tmp){
	          if(np === tmp) return tmp;
	          tmp = tmp.parent;
	        }
	        np = np.parent;
	      }
	    },
	    // check the query and Param
	    _checkQueryAndParam: function(baseState, options){

	      var from = baseState;
	      while( from !== this ){
	        from.update && from.update(options);
	        from = from.parent;
	      }

	    }

	}, true)



	module.exports = StateMan;



/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	var _ = __webpack_require__(5);



	function State(option){
	  this._states = {};
	  this._pending = false;
	  this.visited = false;
	  if(option) this.config(option);
	}


	//regexp cache
	State.rCache = {};

	_.extend( _.emitable( State ), {
	  
	  state: function(stateName, config){
	    if(_.typeOf(stateName) === "object"){
	      for(var i in stateName){
	        this.state(i, stateName[i])
	      }
	      return this;
	    }
	    var current, next, nextName, states = this._states, i=0;

	    if( typeof stateName === "string" ) stateName = stateName.split(".");

	    var slen = stateName.length, current = this;
	    var stack = [];


	    do{
	      nextName = stateName[i];
	      next = states[nextName];
	      stack.push(nextName);
	      if(!next){
	        if(!config) return;
	        next = states[nextName] = new State();
	        _.extend(next, {
	          parent: current,
	          manager: current.manager || current,
	          name: stack.join("."),
	          currentName: nextName
	        })
	        current.hasNext = true;
	        next.configUrl();
	      }
	      current = next;
	      states = next._states;
	    }while((++i) < slen )

	    if(config){
	       next.config(config);
	       return this;
	    } else {
	      return current;
	    }
	  },

	  config: function(configure){

	    configure = this._getConfig(configure);

	    for(var i in configure){
	      var prop = configure[i];
	      switch(i){
	        case "url": 
	          if(typeof prop === "string"){
	            this.url = prop;
	            this.configUrl();
	          }
	          break;
	        case "events": 
	          this.on(prop)
	          break;
	        default:
	          this[i] = prop;
	      }
	    }
	  },

	  // children override
	  _getConfig: function(configure){
	    return typeof configure === "function"? {enter: configure} : configure;
	  },

	  //from url 

	  configUrl: function(){
	    var url = "" , base = this, currentUrl;
	    var _watchedParam = [];

	    while( base ){

	      url = (typeof base.url === "string" ? base.url: (base.currentName || "")) + "/" + url;

	      // means absolute;
	      if(url.indexOf("^/") === 0) {
	        url = url.slice(1);
	        break;
	      }
	      base = base.parent;
	    }
	    this.pattern = _.cleanPath("/" + url);
	    var pathAndQuery = this.pattern.split("?");
	    this.pattern = pathAndQuery[0];
	    // some Query we need watched

	    _.extend(this, _.normalize(this.pattern), true);
	  },
	  encode: function(param){
	    var state = this;
	    param = param || {};
	    
	    var matched = "%";

	    var url = state.matches.replace(/\(([\w-]+)\)/g, function(all, capture){
	      var sec = param[capture] || "";
	      matched+= capture + "%";
	      return sec;
	    }) + "?";

	    // remained is the query, we need concat them after url as query
	    for(var i in param) {
	      if( matched.indexOf("%"+i+"%") === -1) url += i + "=" + param[i] + "&";
	    }
	    return _.cleanPath( url.replace(/(?:\?|&)$/,"") )
	  },
	  decode: function( path ){
	    var matched = this.regexp.exec(path),
	      keys = this.keys;

	    if(matched){

	      var param = {};
	      for(var i =0,len=keys.length;i<len;i++){
	        param[keys[i]] = matched[i+1] 
	      }
	      return param;
	    }else{
	      return false;
	    }
	  },
	  // by default, all lifecycle is permitted

	  async: function(){
	    throw new Error( 'please use option.async instead')
	  }

	})


	module.exports = State;

/***/ },
/* 5 */
/***/ function(module, exports) {

	var _ = module.exports = {};
	var slice = [].slice, o2str = ({}).toString;


	// merge o2's properties to Object o1. 
	_.extend = function(o1, o2, override){
	  for(var i in o2) if(override || o1[i] === undefined){
	    o1[i] = o2[i]
	  }
	  return o1;
	}



	_.slice = function(arr, index){
	  return slice.call(arr, index);
	}

	_.typeOf = function typeOf (o) {
	  return o == null ? String(o) : o2str.call(o).slice(8, -1).toLowerCase();
	}

	//strict eql
	_.eql = function(o1, o2){
	  var t1 = _.typeOf(o1), t2 = _.typeOf(o2);
	  if( t1 !== t2) return false;
	  if(t1 === 'object'){
	    var equal = true;
	    // only check the first's propertie
	    for(var i in o1){
	      if( o1[i] !== o2[i] ) equal = false;
	    }
	    return equal;
	  }
	  return o1 === o2;
	}


	// small emitter 
	_.emitable = (function(){
	  function norm(ev){
	    var eventAndNamespace = (ev||'').split(':');
	    return {event: eventAndNamespace[0], namespace: eventAndNamespace[1]}
	  }
	  var API = {
	    once: function(event, fn){
	      var callback = function(){
	        fn.apply(this, arguments)
	        this.off(event, callback)
	      }
	      return this.on(event, callback)
	    },
	    on: function(event, fn) {
	      if(typeof event === 'object'){
	        for (var i in event) {
	          this.on(i, event[i]);
	        }
	        return this;
	      }
	      var ne = norm(event);
	      event=ne.event;
	      if(event && typeof fn === 'function' ){
	        var handles = this._handles || (this._handles = {}),
	          calls = handles[event] || (handles[event] = []);
	        fn._ns = ne.namespace;
	        calls.push(fn);
	      }
	      return this;
	    },
	    off: function(event, fn) {
	      var ne = norm(event); event = ne.event;
	      if(!event || !this._handles) this._handles = {};

	      var handles = this._handles , calls;

	      if (calls = handles[event]) {
	        if (!fn && !ne.namespace) {
	          handles[event] = [];
	        }else{
	          for (var i = 0, len = calls.length; i < len; i++) {
	            if ( (!fn || fn === calls[i]) && (!ne.namespace || calls[i]._ns === ne.namespace) ) {
	              calls.splice(i, 1);
	              return this;
	            }
	          }
	        }
	      }
	      return this;
	    },
	    emit: function(event){
	      var ne = norm(event); event = ne.event;

	      var args = _.slice(arguments, 1),
	        handles = this._handles, calls;

	      if (!handles || !(calls = handles[event])) return this;
	      for (var i = 0, len = calls.length; i < len; i++) {
	        var fn = calls[i];
	        if( !ne.namespace || fn._ns === ne.namespace ) fn.apply(this, args)
	      }
	      return this;
	    }
	  }
	  return function(obj){
	      obj = typeof obj == "function" ? obj.prototype : obj;
	      return _.extend(obj, API)
	  }
	})();



	_.bind = function(fn, context){
	  return function(){
	    return fn.apply(context, arguments);
	  }
	}

	var rDbSlash = /\/+/g, // double slash
	  rEndSlash = /\/$/;    // end slash

	_.cleanPath = function (path){
	  return ("/" + path).replace( rDbSlash,"/" ).replace( rEndSlash, "" ) || "/";
	}

	// normalize the path
	function normalizePath(path) {
	  // means is from 
	  // (?:\:([\w-]+))?(?:\(([^\/]+?)\))|(\*{2,})|(\*(?!\*)))/g
	  var preIndex = 0;
	  var keys = [];
	  var index = 0;
	  var matches = "";

	  path = _.cleanPath(path);

	  var regStr = path
	    //  :id(capture)? | (capture)   |  ** | * 
	    .replace(/\:([\w-]+)(?:\(([^\/]+?)\))?|(?:\(([^\/]+)\))|(\*{2,})|(\*(?!\*))/g, 
	      function(all, key, keyformat, capture, mwild, swild, startAt) {
	        // move the uncaptured fragment in the path
	        if(startAt > preIndex) matches += path.slice(preIndex, startAt);
	        preIndex = startAt + all.length;
	        if( key ){
	          matches += "(" + key + ")";
	          keys.push(key)
	          return "("+( keyformat || "[\\w-]+")+")";
	        }
	        matches += "(" + index + ")";

	        keys.push( index++ );

	        if( capture ){
	           // sub capture detect
	          return "(" + capture +  ")";
	        } 
	        if(mwild) return "(.*)";
	        if(swild) return "([^\\/]*)";
	    })

	  if(preIndex !== path.length) matches += path.slice(preIndex)

	  return {
	    regexp: new RegExp("^" + regStr +"/?$"),
	    keys: keys,
	    matches: matches || path
	  }
	}

	_.log = function(msg, type){
	  typeof console !== "undefined" && console[type || "log"](msg)
	}

	_.isPromise = function( obj ){

	  return !!obj && (typeof obj === 'object' || typeof obj === 'function') && typeof obj.then === 'function';

	}



	_.normalize = normalizePath;



/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	
	// MIT
	// Thx Backbone.js 1.1.2  and https://github.com/cowboy/jquery-hashchange/blob/master/jquery.ba-hashchange.js
	// for iframe patches in old ie.

	var browser = __webpack_require__(7);
	var _ = __webpack_require__(5);


	// the mode const
	var QUIRK = 3,
	  HASH = 1,
	  HISTORY = 2;



	// extract History for test
	// resolve the conficlt with the Native History
	function Histery(options){
	  options = options || {};

	  // Trick from backbone.history for anchor-faked testcase 
	  this.location = options.location || browser.location;

	  // mode config, you can pass absolute mode (just for test);
	  this.html5 = options.html5;
	  this.mode = options.html5 && browser.history ? HISTORY: HASH; 
	  if( !browser.hash ) this.mode = QUIRK;
	  if(options.mode) this.mode = options.mode;

	  // hash prefix , used for hash or quirk mode
	  this.prefix = "#" + (options.prefix || "") ;
	  this.rPrefix = new RegExp(this.prefix + '(.*)$');
	  this.interval = options.interval || 66;

	  // the root regexp for remove the root for the path. used in History mode
	  this.root = options.root ||  "/" ;
	  this.rRoot = new RegExp("^" +  this.root);

	  this._fixInitState();

	  this.autolink = options.autolink!==false;

	  this.curPath = undefined;
	}

	_.extend( _.emitable(Histery), {
	  // check the 
	  start: function(){
	    var path = this.getPath();
	    this._checkPath = _.bind(this.checkPath, this);

	    if( this.isStart ) return;
	    this.isStart = true;

	    if(this.mode === QUIRK){
	      this._fixHashProbelm(path); 
	    }

	    switch ( this.mode ){
	      case HASH: 
	        browser.on(window, "hashchange", this._checkPath); 
	        break;
	      case HISTORY:
	        browser.on(window, "popstate", this._checkPath);
	        break;
	      case QUIRK:
	        this._checkLoop();
	    }
	    // event delegate
	    this.autolink && this._autolink();

	    this.curPath = path;

	    this.emit("change", path);
	  },
	  // the history teardown
	  stop: function(){

	    browser.off(window, 'hashchange', this._checkPath)  
	    browser.off(window, 'popstate', this._checkPath)  
	    clearTimeout(this.tid);
	    this.isStart = false;
	    this._checkPath = null;
	  },
	  // get the path modify
	  checkPath: function(ev){

	    var path = this.getPath(), curPath = this.curPath;

	    //for oldIE hash history issue
	    if(path === curPath && this.iframe){
	      path = this.getPath(this.iframe.location);
	    }

	    if( path !== curPath ) {
	      this.iframe && this.nav(path, {silent: true});
	      this.curPath = path;
	      this.emit('change', path);
	    }
	  },
	  // get the current path
	  getPath: function(location){
	    var location = location || this.location, tmp;
	    if( this.mode !== HISTORY ){
	      tmp = location.href.match(this.rPrefix);
	      return tmp && tmp[1]? tmp[1]: "";

	    }else{
	      return _.cleanPath(( location.pathname + location.search || "" ).replace( this.rRoot, "/" ))
	    }
	  },

	  nav: function(to, options ){

	    var iframe = this.iframe;

	    options = options || {};

	    to = _.cleanPath(to);

	    if(this.curPath == to) return;

	    // pushState wont trigger the checkPath
	    // but hashchange will
	    // so we need set curPath before to forbit the CheckPath
	    this.curPath = to;

	    // 3 or 1 is matched
	    if( this.mode !== HISTORY ){
	      this._setHash(this.location, to, options.replace)
	      if( iframe && this.getPath(iframe.location) !== to ){
	        if(!options.replace) iframe.document.open().close();
	        this._setHash(this.iframe.location, to, options.replace)
	      }
	    }else{
	      history[options.replace? 'replaceState': 'pushState']( {}, options.title || "" , _.cleanPath( this.root + to ) )
	    }

	    if( !options.silent ) this.emit('change', to);
	  },
	  _autolink: function(){
	    if(this.mode!==HISTORY) return;
	    // only in html5 mode, the autolink is works
	    // if(this.mode !== 2) return;
	    var prefix = this.prefix, self = this;
	    browser.on( document.body, "click", function(ev){

	      var target = ev.target || ev.srcElement;
	      if( target.tagName.toLowerCase() !== "a" ) return;
	      var tmp = (browser.getHref(target)||"").match(self.rPrefix);
	      var hash = tmp && tmp[1]? tmp[1]: "";

	      if(!hash) return;
	      
	      ev.preventDefault && ev.preventDefault();
	      self.nav( hash )
	      return (ev.returnValue = false);
	    } )
	  },
	  _setHash: function(location, path, replace){
	    var href = location.href.replace(/(javascript:|#).*$/, '');
	    if (replace){
	      location.replace(href + this.prefix+ path);
	    }
	    else location.hash = this.prefix+ path;
	  },
	  // for browser that not support onhashchange
	  _checkLoop: function(){
	    var self = this; 
	    this.tid = setTimeout( function(){
	      self._checkPath();
	      self._checkLoop();
	    }, this.interval );
	  },
	  // if we use real url in hash env( browser no history popstate support)
	  // or we use hash in html5supoort mode (when paste url in other url)
	  // then , histery should repara it
	  _fixInitState: function(){
	    var pathname = _.cleanPath(this.location.pathname), hash, hashInPathName;

	    // dont support history popstate but config the html5 mode
	    if( this.mode !== HISTORY && this.html5){

	      hashInPathName = pathname.replace(this.rRoot, "")
	      if(hashInPathName) this.location.replace(this.root + this.prefix + hashInPathName);

	    }else if( this.mode === HISTORY /* && pathname === this.root*/){

	      hash = this.location.hash.replace(this.prefix, "");
	      if(hash) history.replaceState({}, document.title, _.cleanPath(this.root + hash))

	    }
	  },
	  // Thanks for backbone.history and https://github.com/cowboy/jquery-hashchange/blob/master/jquery.ba-hashchange.js
	  // for helping stateman fixing the oldie hash history issues when with iframe hack
	  _fixHashProbelm: function(path){
	    var iframe = document.createElement('iframe'), body = document.body;
	    iframe.src = 'javascript:;';
	    iframe.style.display = 'none';
	    iframe.tabIndex = -1;
	    iframe.title = "";
	    this.iframe = body.insertBefore(iframe, body.firstChild).contentWindow;
	    this.iframe.document.open().close();
	    this.iframe.location.hash = '#' + path;
	  }
	  
	})





	module.exports = Histery;

/***/ },
/* 7 */
/***/ function(module, exports) {

	
	var win = window, 
	  doc = document;

	var b = module.exports = {
	  hash: "onhashchange" in win && (!doc.documentMode || doc.documentMode > 7),
	  history: win.history && "onpopstate" in win,
	  location: win.location,
	  getHref: function(node){
	    return "href" in node ? node.getAttribute("href", 2) : node.getAttribute("href");
	  },
	  on: "addEventListener" in win ?  // IE10 attachEvent is not working when binding the onpopstate, so we need check addEventLister first
	      function(node,type,cb){return node.addEventListener( type, cb )}
	    : function(node,type,cb){return node.attachEvent( "on" + type, cb )},
	    
	  off: "removeEventListener" in win ? 
	      function(node,type,cb){return node.removeEventListener( type, cb )}
	    : function(node,type,cb){return node.detachEvent( "on" + type, cb )}
	}



/***/ },
/* 8 */,
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
	    var Handsontable = __webpack_require__(14);
	    var css = __webpack_require__(10);
	    var dataService = __webpack_require__(17);
	    var that = {};
	    var container;
	    var hot;
	    that.load = function(element) {
	        var data = dataService.get();
	        element.innerHTML = '<div></div>';
	        container = element.firstChild;
	        hot = new Handsontable(container, {
	            startRows: 8,
	            startCols: 5,
	            minSpareRows: 1,
	            rowHeaders: true,
	            colHeaders: true,
	            contextMenu: true,
	            afterChange: function(){
	                dataService.set(this.getData());
	            }
	        });
	        if(!_.isEmpty(data)){
	            hot.updateSettings({data:data})
	        }
	    };

	    that.destroy = function(){
	        hot.destroy();
	    };

	    module.exports = that;
	})();





/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag

	// load the styles
	var content = __webpack_require__(11);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(13)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../node_modules/css-loader/index.js!./handsontable.full.css", function() {
				var newContent = require("!!./../../../node_modules/css-loader/index.js!./handsontable.full.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(12)();
	// imports


	// module
	exports.push([module.id, "/*!\n * Handsontable 0.20.0\n * Handsontable is a JavaScript library for editable tables with basic copy-paste compatibility with Excel and Google Docs\n *\n * Copyright 2015 Handsoncode sp. z o.o. <hello@handsontable.com>\n * Licensed under the MIT license.\n * http://handsontable.com/\n *\n * Date: Tue Nov 03 2015 14:30:34 GMT+0100 (CET)\n */\n\n.handsontable {\n  position: relative;\n}\n\n.handsontable .hide{\n  display: none;\n}\n.handsontable .relative {\n  position: relative;\n}\n\n.handsontable.htAutoSize {\n  visibility: hidden;\n  left: -99000px;\n  position: absolute;\n  top: -99000px;\n}\n\n.handsontable .wtHider {\n  width: 0;\n}\n\n.handsontable .wtSpreader {\n  position: relative;\n  width: 0; /*must be 0, otherwise blank space appears in scroll demo after scrolling max to the right */\n  height: auto;\n}\n\n.handsontable table,\n.handsontable tbody,\n.handsontable thead,\n.handsontable td,\n.handsontable th,\n.handsontable input,\n.handsontable textarea,\n.handsontable div {\n  box-sizing: content-box;\n  -webkit-box-sizing: content-box;\n  -moz-box-sizing: content-box;\n}\n\n.handsontable input,\n.handsontable textarea {\n  min-height: initial;\n}\n\n.handsontable table.htCore {\n  border-collapse: separate;\n  /*it must be separate, otherwise there are offset miscalculations in WebKit: http://stackoverflow.com/questions/2655987/border-collapse-differences-in-ff-and-webkit*/\n  /*this actually only changes appearance of user selection - does not make text unselectable\n  -webkit-user-select: none;\n  -khtml-user-select: none;\n  -moz-user-select: none;\n  -o-user-select: none;\n  -ms-user-select: none;\n  /*user-select: none; /*no browser supports unprefixed version*/\n  border-spacing: 0;\n  margin: 0;\n  border-width: 0;\n  table-layout: fixed;\n  width: 0;\n  outline-width: 0;\n  /* reset bootstrap table style. for more info see: https://github.com/handsontable/handsontable/issues/224 */\n  max-width: none;\n  max-height: none;\n}\n\n.handsontable col {\n  width: 50px;\n}\n\n.handsontable col.rowHeader {\n  width: 50px;\n}\n\n.handsontable th,\n.handsontable td {\n  border-right: 1px solid #CCC;\n  border-bottom: 1px solid #CCC;\n  height: 22px;\n  empty-cells: show;\n  line-height: 21px;\n  padding: 0 4px 0 4px;\n  /* top, bottom padding different than 0 is handled poorly by FF with HTML5 doctype */\n  background-color: #FFF;\n  vertical-align: top;\n  overflow: hidden;\n  outline-width: 0;\n  white-space: pre-line;\n  /* preserve new line character in cell */\n}\n\n.handsontable td.htInvalid {\n  background-color: #ff4c42 !important; /*gives priority over td.area selection background*/\n}\n\n.handsontable td.htNoWrap {\n  white-space: nowrap;\n}\n\n.handsontable th:last-child {\n  /*Foundation framework fix*/\n  border-right: 1px solid #CCC;\n  border-bottom: 1px solid #CCC;\n}\n\n.handsontable tr:first-child th.htNoFrame,\n.handsontable th:first-child.htNoFrame,\n.handsontable th.htNoFrame {\n  border-left-width: 0;\n  background-color: white;\n  border-color: #FFF;\n}\n\n.handsontable th:first-child,\n.handsontable td:first-of-type,\n.handsontable .htNoFrame + th,\n.handsontable .htNoFrame + td {\n  border-left: 1px solid #CCC;\n}\n\n.handsontable.htRowHeaders thead tr th:nth-child(2) {\n  border-left: 1px solid #CCC;\n}\n\n.handsontable tr:first-child th,\n.handsontable tr:first-child td {\n  border-top: 1px solid #CCC;\n}\n\n.ht_master:not(.innerBorderLeft) ~ .handsontable tbody tr th,\n.ht_master:not(.innerBorderLeft) ~ .handsontable:not(.ht_clone_top) thead tr th:first-child\n{\n  border-right-width: 0;\n}\n\n.ht_master:not(.innerBorderTop) thead tr:last-child th,\n.ht_master:not(.innerBorderTop) ~ .handsontable thead tr:last-child th,\n.ht_master:not(.innerBorderTop) thead tr.lastChild th,\n.ht_master:not(.innerBorderTop) ~ .handsontable thead tr.lastChild th {\n  border-bottom-width: 0;\n}\n\n.handsontable th {\n  background-color: #EEE;\n  color: #222;\n  text-align: center;\n  font-weight: normal;\n  white-space: nowrap;\n}\n\n.handsontable thead th {\n  padding: 0;\n}\n\n.handsontable th.active {\n  background-color: #CCC;\n}\n\n.handsontable thead th .relative {\n  padding: 2px 4px;\n}\n\n/* plugins */\n\n.handsontable .manualColumnMover {\n  position: fixed;\n  left: 0;\n  top: 0;\n  background-color: transparent;\n  width: 5px;\n  height: 25px;\n  z-index: 999;\n  cursor: move;\n}\n\n.handsontable .manualRowMover {\n  position: fixed;\n  left: -4px;\n  top: 0;\n  background-color: transparent;\n  height: 5px;\n  width: 50px;\n  z-index: 999;\n  cursor: move;\n}\n\n.handsontable .manualColumnMoverGuide,\n.handsontable .manualRowMoverGuide {\n  position: fixed;\n  left: 0;\n  top: 0;\n  background-color: #CCC;\n  width: 25px;\n  height: 25px;\n  opacity: 0.7;\n  display: none;\n}\n\n.handsontable .manualColumnMoverGuide.active,\n.handsontable .manualRowMoverGuide.active {\n  display: block;\n}\n\n.handsontable .manualColumnMover:hover,\n.handsontable .manualColumnMover.active,\n.handsontable .manualRowMover:hover,\n.handsontable .manualRowMover.active{\n  background-color: #88F;\n}\n\n/* row + column resizer*/\n\n.handsontable .manualColumnResizer {\n  position: fixed;\n  top: 0;\n  cursor: col-resize;\n  z-index: 110;\n  width: 5px;\n  height: 25px;\n}\n\n.handsontable .manualRowResizer {\n  position: fixed;\n  left: 0;\n  cursor: row-resize;\n  z-index: 110;\n  height: 5px;\n  width: 50px;\n}\n\n.handsontable .manualColumnResizer:hover,\n.handsontable .manualColumnResizer.active,\n.handsontable .manualRowResizer:hover,\n.handsontable .manualRowResizer.active {\n  background-color: #AAB;\n}\n\n.handsontable .manualColumnResizerGuide {\n  position: fixed;\n  right: 0;\n  top: 0;\n  background-color: #AAB;\n  display: none;\n  width: 0;\n  border-right: 1px dashed #777;\n  margin-left: 5px;\n}\n\n.handsontable .manualRowResizerGuide {\n  position: fixed;\n  left: 0;\n  bottom: 0;\n  background-color: #AAB;\n  display: none;\n  height: 0;\n  border-bottom: 1px dashed #777;\n  margin-top: 5px;\n}\n\n.handsontable .manualColumnResizerGuide.active,\n.handsontable .manualRowResizerGuide.active {\n  display: block;\n}\n\n.handsontable .columnSorting {\n  position: relative;\n}\n\n.handsontable .columnSorting:hover {\n  text-decoration: underline;\n  cursor: pointer;\n}\n\n.handsontable .columnSorting.ascending::after {\n  content: '\\25B2';\n  color: #5f5f5f;\n  position: absolute;\n  right: -15px;\n}\n\n.handsontable .columnSorting.descending::after {\n  content: '\\25BC';\n  color: #5f5f5f;\n  position: absolute;\n  right: -15px;\n}\n\n.handsontable th.beforeHiddenColumn {\n  position: relative;\n}\n\n.handsontable th.beforeHiddenColumn::after,\n.handsontable th.afterHiddenColumn::before {\n  content: '\\25C0';\n  color: #bbb;\n  position: absolute;\n  right: 1px;\n  top: 2px;\n  font-size: 5pt;\n}\n\n.handsontable th.afterHiddenColumn {\n  position: relative;\n}\n\n.handsontable th.afterHiddenColumn::before {\n  left: 1px;\n  top: 2px;\n  right: auto;\n  content: '\\25B6';\n}\n\n.handsontable td.afterHiddenColumn.firstVisible {\n  border-left: 1px solid #CCC;\n}\n\n.handsontable thead th.hiddenHeader {\n  display: none;\n}\n\n/* border line */\n\n.handsontable .wtBorder {\n  position: absolute;\n  font-size: 0;\n}\n.handsontable .wtBorder.hidden{\n  display:none !important;\n}\n\n.handsontable td.area {\n  background: -moz-linear-gradient(top,  rgba(181,209,255,0.34) 0%, rgba(181,209,255,0.34) 100%); /* FF3.6+ */\n  background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,rgba(181,209,255,0.34)), color-stop(100%,rgba(181,209,255,0.34))); /* Chrome,Safari4+ */\n  background: -webkit-linear-gradient(top,  rgba(181,209,255,0.34) 0%,rgba(181,209,255,0.34) 100%); /* Chrome10+,Safari5.1+ */\n  background: -o-linear-gradient(top,  rgba(181,209,255,0.34) 0%,rgba(181,209,255,0.34) 100%); /* Opera 11.10+ */\n  background: -ms-linear-gradient(top,  rgba(181,209,255,0.34) 0%,rgba(181,209,255,0.34) 100%); /* IE10+ */\n  background: linear-gradient(to bottom,  rgba(181,209,255,0.34) 0%,rgba(181,209,255,0.34) 100%); /* W3C */\n  filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#57b5d1ff', endColorstr='#57b5d1ff',GradientType=0 ); /* IE6-9 */\n  background-color: #fff;\n}\n\n/* fill handle */\n\n.handsontable .wtBorder.corner {\n  font-size: 0;\n  cursor: crosshair;\n}\n\n.handsontable .htBorder.htFillBorder {\n  background: red;\n  width: 1px;\n  height: 1px;\n}\n\n.handsontableInput {\n  border:none;\n  outline-width: 0;\n  margin: 0 ;\n  padding: 1px 5px 0 5px;\n  font-family: inherit;\n  line-height: 21px;\n  font-size: inherit;\n  box-shadow: 0 0 0 2px #5292F7 inset;\n  resize: none;\n  /*below are needed to overwrite stuff added by jQuery UI Bootstrap theme*/\n  display: inline-block;\n  color: #000;\n  border-radius: 0;\n  background-color: #FFF;\n  /*overwrite styles potentionally made by a framework*/\n}\n\n.handsontableInputHolder {\n  position: absolute;\n  top: 0;\n  left: 0;\n  z-index: 100;\n}\n\n.htSelectEditor {\n  -webkit-appearance: menulist-button !important;\n  position: absolute;\n  width: auto;\n}\n\n/*\nTextRenderer readOnly cell\n*/\n\n.handsontable .htDimmed {\n  color: #777;\n}\n\n.handsontable .htSubmenu {\n  position: relative;\n}\n\n.handsontable .htSubmenu :after{\n  content: '\\25B6';\n  color: #777;\n  position: absolute;\n  right: 5px;\n}\n\n\n/*\nTextRenderer horizontal alignment\n*/\n.handsontable .htLeft{\n  text-align: left;\n}\n.handsontable .htCenter{\n  text-align: center;\n}\n.handsontable .htRight{\n  text-align: right;\n}\n.handsontable .htJustify{\n  text-align: justify;\n}\n/*\nTextRenderer vertical alignment\n*/\n.handsontable .htTop{\n  vertical-align: top;\n}\n.handsontable .htMiddle{\n  vertical-align: middle;\n}\n.handsontable .htBottom{\n  vertical-align: bottom;\n}\n\n/*\nTextRenderer placeholder value\n*/\n\n.handsontable .htPlaceholder {\n  color: #999;\n}\n\n/*\nAutocompleteRenderer down arrow\n*/\n\n.handsontable .htAutocompleteArrow {\n  float: right;\n  font-size: 10px;\n  color: #EEE;\n  cursor: default;\n  width: 16px;\n  text-align: center;\n}\n\n.handsontable td .htAutocompleteArrow:hover {\n  color: #777;\n}\n\n.handsontable td.area .htAutocompleteArrow {\n  color: #d3d3d3;\n}\n\n/*\nCheckboxRenderer\n*/\n\n.handsontable .htCheckboxRendererInput.noValue {\n  opacity: 0.5;\n}\n.handsontable .htCheckboxRendererLabel {\n  cursor: pointer;\n  display: inline-block;\n  width: 100%;\n}\n\n/*\nNumericRenderer\n*/\n\n.handsontable .htNumeric {\n  text-align: right;\n}\n\n/*\nComment For Cell\n*/\n.htCommentCell{\n  position: relative;\n}\n.htCommentCell:after{\n  content: '';\n  position: absolute;\n  top: 0;\n  right: 0;\n  border-left: 6px solid transparent;\n  border-top: 6px solid red;\n}\n\n@-webkit-keyframes opacity-hide {\n  from {\n    opacity: 1;\n  }\n  to {\n    opacity: 0;\n    /*display: none;*/\n  }\n}\n@keyframes opacity-hide {\n  from {\n    /*display: block;*/\n    opacity: 1;\n  }\n  to {\n    opacity: 0;\n    /*display: none;*/\n  }\n}\n\n@-webkit-keyframes opacity-show {\n  from {\n    opacity: 0;\n    /*display: none;*/\n  }\n  to {\n    opacity: 1;\n    /*display: block;*/\n  }\n}\n@keyframes opacity-show {\n  from {\n    opacity: 0;\n    /*display: none;*/\n  }\n  to {\n    opacity: 1;\n    /*display: block;*/\n  }\n}\n\n/**\n * Handsontable in Handsontable\n */\n\n.handsontable .handsontable.ht_clone_top .wtHider {\n  padding: 0 0 5px 0;\n}\n\n/* removing shadows, TODO: remove the commented code and this comment  */\n/*.handsontable .handsontable:not(.ht_master) table {*/\n  /*-webkit-box-shadow: 1px 2px 5px rgba(0, 0, 0, 0.4);*/\n  /*box-shadow: 1px 2px 5px rgba(0, 0, 0, 0.4);*/\n/*}*/\n\n/**\n* Autocomplete Editor\n*/\n.handsontable .autocompleteEditor.handsontable {\n  padding-right: 17px;\n}\n.handsontable .autocompleteEditor.handsontable.htMacScroll {\n  padding-right: 15px;\n}\n\n\n/**\n * Handsontable listbox theme\n */\n\n.handsontable.listbox {\n  margin: 0;\n}\n\n.handsontable.listbox .ht_master table {\n  border: 1px solid #ccc;\n  border-collapse: separate;\n  background: white;\n}\n\n.handsontable.listbox th,\n.handsontable.listbox tr:first-child th,\n.handsontable.listbox tr:last-child th,\n.handsontable.listbox tr:first-child td,\n.handsontable.listbox td {\n  border-color: transparent;\n}\n\n.handsontable.listbox th,\n.handsontable.listbox td {\n  white-space: nowrap;\n  text-overflow: ellipsis;\n}\n\n.handsontable.listbox td.htDimmed {\n  cursor: default;\n  color: inherit;\n  font-style: inherit;\n}\n\n.handsontable.listbox .wtBorder {\n  visibility: hidden;\n}\n\n.handsontable.listbox tr td.current,\n.handsontable.listbox tr:hover td {\n  background: #eee;\n}\n\n.ht_clone_top {\n  z-index: 101;\n}\n\n.ht_clone_left {\n  z-index: 102;\n}\n\n.ht_clone_top_left_corner,\n.ht_clone_bottom_left_corner {\n  z-index: 103;\n}\n\n.ht_clone_debug {\n  z-index: 103;\n}\n\n.handsontable td.htSearchResult {\n  background: #fcedd9;\n  color: #583707;\n}\n\n/*\nCell borders\n*/\n.htBordered{\n  /*box-sizing: border-box !important;*/\n  border-width: 1px;\n}\n.htBordered.htTopBorderSolid {\n  border-top-style: solid;\n  border-top-color: #000;\n}\n.htBordered.htRightBorderSolid {\n  border-right-style: solid;\n  border-right-color: #000;\n}\n.htBordered.htBottomBorderSolid {\n  border-bottom-style: solid;\n  border-bottom-color: #000;\n}\n.htBordered.htLeftBorderSolid {\n  border-left-style: solid;\n  border-left-color: #000;\n}\n\n.htCommentTextArea{\n  -moz-box-shadow: 1px 1px 2px #bbb;\n  -webkit-box-shadow: 1px 1px 2px #bbb;\n  background-color: #FFFACD;\n  border: 1px solid #999;\n  box-shadow: 1px 1px 2px #bbb;\n  font-family: 'Arial';\n}\n\n.handsontable tbody tr th:nth-last-child(2) {\n  border-right: 1px solid #CCC;\n}\n\n.handsontable thead tr:nth-last-child(2) th.htGroupIndicatorContainer {\n  border-bottom: 1px solid #CCC;\n  padding-bottom: 5px;\n}\n\n\n.ht_clone_top_left_corner thead tr th:nth-last-child(2) {\n  border-right: 1px solid #CCC;\n}\n\n.htCollapseButton {\n  width: 10px;\n  height: 10px;\n  line-height: 10px;\n  text-align: center;\n  border-radius: 5px;\n  border: 1px solid #f3f3f3;\n  -webkit-box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.4);\n  box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.4);\n  cursor: pointer;\n  margin-bottom: 3px;\n  position: relative;\n}\n\n.htCollapseButton:after {\n  content: \"\";\n  height: 300%;\n  width: 1px;\n  display: block;\n  background: #ccc;\n  margin-left: 4px;\n  position: absolute;\n  /*top: -300%;*/\n  bottom: 10px;\n}\n\n\nthead .htCollapseButton {\n  right: 5px;\n  position: absolute;\n  top: 5px;\n  background: #fff;\n}\n\nthead .htCollapseButton:after {\n  height: 1px;\n  width: 700%;\n  right: 10px;\n  top: 4px;\n}\n\n.handsontable tr th .htExpandButton {\n  position: absolute;\n  width: 10px;\n  height: 10px;\n  line-height: 10px;\n  text-align: center;\n  border-radius: 5px;\n  border: 1px solid #f3f3f3;\n  -webkit-box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.4);\n  box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.4);\n  cursor: pointer;\n  top: 0;\n  display: none;\n}\n\n.handsontable thead tr th .htExpandButton {\n  /*left: 5px;*/\n  top: 5px;\n}\n\n.handsontable tr th .htExpandButton.clickable {\n  display: block;\n}\n\n.collapsibleIndicator {\n  position: absolute;\n  top: 50%;\n  transform: translate(0% ,-50%);\n  right: 5px;\n  border: 1px solid #A6A6A6;\n  line-height: 10px;\n  color: #222;\n  border-radius: 10px;\n  font-size: 10px;\n  width: 10px;\n  height: 10px;\n  cursor: pointer;\n  -webkit-box-shadow: 0px 0px 0px 6px rgba(238,238,238,1);\n  -moz-box-shadow: 0px 0px 0px 6px rgba(238,238,238,1);\n  box-shadow: 0px 0px 0px 6px rgba(238,238,238,1);\n  background: #eee;\n}\n\n.handsontable col.hidden {\n  width: 0 !important;\n}\n\n.handsontable table tr th.lightRightBorder {\n  border-right: 1px solid #E6E6E6;\n}\n\n.handsontable tr.hidden,\n.handsontable tr.hidden td,\n.handsontable tr.hidden th {\n  display: none;\n}\n\n.ht_master,\n.ht_clone_left,\n.ht_clone_top,\n.ht_clone_bottom {\n  overflow: hidden;\n}\n\n.ht_master .wtHolder {\n  overflow: auto;\n}\n\n.ht_clone_left .wtHolder {\n  overflow-x: hidden;\n  overflow-y: auto;\n}\n\n.ht_clone_top .wtHolder,\n.ht_clone_bottom .wtHolder {\n  overflow-x: auto;\n  overflow-y: hidden;\n}\n\n\n/*WalkontableDebugOverlay*/\n\n.wtDebugHidden {\n  display: none;\n}\n\n.wtDebugVisible {\n  display: block;\n  -webkit-animation-duration: 0.5s;\n  -webkit-animation-name: wtFadeInFromNone;\n  animation-duration: 0.5s;\n  animation-name: wtFadeInFromNone;\n}\n\n@keyframes wtFadeInFromNone {\n  0% {\n    display: none;\n    opacity: 0;\n  }\n\n  1% {\n    display: block;\n    opacity: 0;\n  }\n\n  100% {\n    display: block;\n    opacity: 1;\n  }\n}\n\n@-webkit-keyframes wtFadeInFromNone {\n  0% {\n    display: none;\n    opacity: 0;\n  }\n\n  1% {\n    display: block;\n    opacity: 0;\n  }\n\n  100% {\n    display: block;\n    opacity: 1;\n  }\n}\n/*\n\n Handsontable Mobile Text Editor stylesheet\n\n */\n\n.handsontable.mobile,\n.handsontable.mobile .wtHolder {\n  -webkit-touch-callout:none;\n  -webkit-user-select:none;\n  -khtml-user-select:none;\n  -moz-user-select:none;\n  -ms-user-select:none;\n  user-select:none;\n  -webkit-tap-highlight-color:rgba(0,0,0,0);\n  -webkit-overflow-scrolling: touch;\n}\n\n.htMobileEditorContainer {\n  display: none;\n  position: absolute;\n  top: 0;\n  width: 70%;\n  height: 54pt;\n  background: #f8f8f8;\n  border-radius: 20px;\n  border: 1px solid #ebebeb;\n  z-index: 999;\n  box-sizing: border-box;\n  -webkit-box-sizing: border-box;\n  -webkit-text-size-adjust: none;\n}\n\n.topLeftSelectionHandle:not(.ht_master .topLeftSelectionHandle),\n.topLeftSelectionHandle-HitArea:not(.ht_master .topLeftSelectionHandle-HitArea) {\n  z-index: 9999;\n}\n\n/* Initial left/top coordinates - overwritten when actual position is set */\n.topLeftSelectionHandle,\n.topLeftSelectionHandle-HitArea,\n.bottomRightSelectionHandle,\n.bottomRightSelectionHandle-HitArea {\n  left: -10000px;\n  top: -10000px;\n}\n\n.htMobileEditorContainer.active {\n  display: block;\n}\n\n.htMobileEditorContainer .inputs {\n  position: absolute;\n  right: 210pt;\n  bottom: 10pt;\n  top: 10pt;\n  left: 14px;\n  height: 34pt;\n}\n\n.htMobileEditorContainer .inputs textarea {\n  font-size: 13pt;\n  border: 1px solid #a1a1a1;\n  -webkit-appearance: none;\n  -webkit-box-shadow: none;\n  -moz-box-shadow: none;\n  box-shadow: none;\n  position: absolute;\n  left: 14px;\n  right: 14px;\n  top: 0;\n  bottom: 0;\n  padding: 7pt;\n}\n\n.htMobileEditorContainer .cellPointer {\n  position: absolute;\n  top: -13pt;\n  height: 0;\n  width: 0;\n  left: 30px;\n\n  border-left: 13pt solid transparent;\n  border-right: 13pt solid transparent;\n  border-bottom: 13pt solid #ebebeb;\n}\n\n.htMobileEditorContainer .cellPointer.hidden {\n  display: none;\n}\n\n.htMobileEditorContainer .cellPointer:before {\n  content: '';\n  display: block;\n  position: absolute;\n  top: 2px;\n  height: 0;\n  width: 0;\n  left: -13pt;\n\n  border-left: 13pt solid transparent;\n  border-right: 13pt solid transparent;\n  border-bottom: 13pt solid #f8f8f8;\n}\n\n.htMobileEditorContainer .moveHandle {\n  position: absolute;\n  top: 10pt;\n  left: 5px;\n  width: 30px;\n  bottom: 0px;\n  cursor: move;\n  z-index: 9999;\n}\n\n.htMobileEditorContainer .moveHandle:after {\n  content: \"..a..a..a..\";\n  white-space: pre;\n  line-height: 10px;\n  font-size: 20pt;\n  display: inline-block;\n  margin-top: -8px;\n  color: #ebebeb;\n}\n\n.htMobileEditorContainer .positionControls {\n  width: 205pt;\n  position: absolute;\n  right: 5pt;\n  top: 0;\n  bottom: 0;\n}\n\n.htMobileEditorContainer .positionControls > div {\n  width: 50pt;\n  height: 100%;\n  float: left;\n}\n\n.htMobileEditorContainer .positionControls > div:after {\n  content: \" \";\n  display: block;\n  width: 15pt;\n  height: 15pt;\n  text-align: center;\n  line-height: 50pt;\n}\n\n.htMobileEditorContainer .leftButton:after,\n.htMobileEditorContainer .rightButton:after,\n.htMobileEditorContainer .upButton:after,\n.htMobileEditorContainer .downButton:after {\n  transform-origin: 5pt 5pt;\n  -webkit-transform-origin: 5pt 5pt;\n  margin: 21pt 0 0 21pt;\n}\n\n.htMobileEditorContainer .leftButton:after {\n  border-top: 2px solid #288ffe;\n  border-left: 2px solid #288ffe;\n  -webkit-transform: rotate(-45deg);\n  /*margin-top: 17pt;*/\n  /*margin-left: 20pt;*/\n}\n.htMobileEditorContainer .leftButton:active:after {\n  border-color: #cfcfcf;\n}\n\n.htMobileEditorContainer .rightButton:after {\n  border-top: 2px solid #288ffe;\n  border-left: 2px solid #288ffe;\n  -webkit-transform: rotate(135deg);\n  /*margin-top: 17pt;*/\n  /*margin-left: 10pt;*/\n}\n.htMobileEditorContainer .rightButton:active:after {\n  border-color: #cfcfcf;\n}\n\n.htMobileEditorContainer .upButton:after {\n  /*border-top: 2px solid #cfcfcf;*/\n  border-top: 2px solid #288ffe;\n  border-left: 2px solid #288ffe;\n  -webkit-transform: rotate(45deg);\n  /*margin-top: 22pt;*/\n  /*margin-left: 15pt;*/\n}\n.htMobileEditorContainer .upButton:active:after {\n  border-color: #cfcfcf;\n}\n\n.htMobileEditorContainer .downButton:after {\n  border-top: 2px solid #288ffe;\n  border-left: 2px solid #288ffe;\n  -webkit-transform: rotate(225deg);\n  /*margin-top: 15pt;*/\n  /*margin-left: 15pt;*/\n}\n.htMobileEditorContainer .downButton:active:after {\n  border-color: #cfcfcf;\n}\n\n.handsontable.hide-tween {\n  -webkit-animation: opacity-hide 0.3s;\n  animation: opacity-hide 0.3s;\n  animation-fill-mode: forwards;\n  -webkit-animation-fill-mode: forwards;\n}\n\n.handsontable.show-tween {\n  -webkit-animation: opacity-show 0.3s;\n  animation: opacity-show 0.3s;\n  animation-fill-mode: forwards;\n  -webkit-animation-fill-mode: forwards;\n}\n/*!\n * Handsontable ContextMenu\n */\n\n.htContextMenu {\n  display: none;\n  position: absolute;\n  z-index: 1060; /* needs to be higher than 1050 - z-index for Twitter Bootstrap modal (#1569) */\n}\n\n.htContextMenu .ht_clone_top,\n.htContextMenu .ht_clone_left,\n.htContextMenu .ht_clone_corner,\n.htContextMenu .ht_clone_debug {\n  display: none;\n}\n\n.htContextMenu table.htCore {\n  border: 1px solid #bbb;\n  border-bottom-width: 2px;\n  border-right-width: 2px;\n}\n\n.htContextMenu .wtBorder {\n  visibility: hidden;\n}\n\n.htContextMenu table tbody tr td {\n  background: white;\n  border-width: 0;\n  padding: 4px 6px 0 6px;\n  cursor: pointer;\n  overflow: hidden;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n}\n\n.htContextMenu table tbody tr td:first-child {\n  border: 0;\n}\n\n.htContextMenu table tbody tr td.htDimmed {\n  font-style: normal;\n  color: #323232;\n}\n\n.htContextMenu table tbody tr td.current,\n.htContextMenu table tbody tr td.zeroclipboard-is-hover {\n  background: #e9e9e9;\n}\n\n.htContextMenu table tbody tr td.htSeparator {\n  border-top: 1px solid #bbb;\n  height: 0;\n  padding: 0;\n}\n\n.htContextMenu table tbody tr td.htDisabled {\n  color: #999;\n}\n\n.htContextMenu table tbody tr td.htDisabled:hover {\n  background: #fff;\n  color: #999;\n  cursor: default;\n}\n\n.htContextMenu table tbody tr.htHidden {\n  display: none;\n}\n\n.htContextMenu table tbody tr td .htItemWrapper {\n  margin-left: 10px;\n  margin-right: 6px;\n}\n\n.htContextMenu table tbody tr td div span.selected {\n  margin-top: -2px;\n  position: absolute;\n  left: 4px;\n}\n\n.htContextMenu .ht_master .wtHolder {\n  overflow: hidden;\n}\n@charset \"UTF-8\";\n\n/*!\n * Pikaday\n * Copyright © 2014 David Bushell | BSD & MIT license | http://dbushell.com/\n */\n\n.pika-single {\n    z-index: 9999;\n    display: block;\n    position: relative;\n    color: #333;\n    background: #fff;\n    border: 1px solid #ccc;\n    border-bottom-color: #bbb;\n    font-family: \"Helvetica Neue\", Helvetica, Arial, sans-serif;\n}\n\n/*\nclear child float (pika-lendar), using the famous micro clearfix hack\nhttp://nicolasgallagher.com/micro-clearfix-hack/\n*/\n.pika-single:before,\n.pika-single:after {\n    content: \" \";\n    display: table;\n}\n.pika-single:after { clear: both }\n.pika-single { *zoom: 1 }\n\n.pika-single.is-hidden {\n    display: none;\n}\n\n.pika-single.is-bound {\n    position: absolute;\n    box-shadow: 0 5px 15px -5px rgba(0,0,0,.5);\n}\n\n.pika-lendar {\n    float: left;\n    width: 240px;\n    margin: 8px;\n}\n\n.pika-title {\n    position: relative;\n    text-align: center;\n}\n\n.pika-label {\n    display: inline-block;\n    *display: inline;\n    position: relative;\n    z-index: 9999;\n    overflow: hidden;\n    margin: 0;\n    padding: 5px 3px;\n    font-size: 14px;\n    line-height: 20px;\n    font-weight: bold;\n    background-color: #fff;\n}\n.pika-title select {\n    cursor: pointer;\n    position: absolute;\n    z-index: 9998;\n    margin: 0;\n    left: 0;\n    top: 5px;\n    filter: alpha(opacity=0);\n    opacity: 0;\n}\n\n.pika-prev,\n.pika-next {\n    display: block;\n    cursor: pointer;\n    position: relative;\n    outline: none;\n    border: 0;\n    padding: 0;\n    width: 20px;\n    height: 30px;\n    /* hide text using text-indent trick, using width value (it's enough) */\n    text-indent: 20px;\n    white-space: nowrap;\n    overflow: hidden;\n    background-color: transparent;\n    background-position: center center;\n    background-repeat: no-repeat;\n    background-size: 75% 75%;\n    opacity: .5;\n    *position: absolute;\n    *top: 0;\n}\n\n.pika-prev:hover,\n.pika-next:hover {\n    opacity: 1;\n}\n\n.pika-prev,\n.is-rtl .pika-next {\n    float: left;\n    background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAeCAYAAAAsEj5rAAAAUklEQVR42u3VMQoAIBADQf8Pgj+OD9hG2CtONJB2ymQkKe0HbwAP0xucDiQWARITIDEBEnMgMQ8S8+AqBIl6kKgHiXqQqAeJepBo/z38J/U0uAHlaBkBl9I4GwAAAABJRU5ErkJggg==');\n    *left: 0;\n}\n\n.pika-next,\n.is-rtl .pika-prev {\n    float: right;\n    background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAeCAYAAAAsEj5rAAAAU0lEQVR42u3VOwoAMAgE0dwfAnNjU26bYkBCFGwfiL9VVWoO+BJ4Gf3gtsEKKoFBNTCoCAYVwaAiGNQGMUHMkjGbgjk2mIONuXo0nC8XnCf1JXgArVIZAQh5TKYAAAAASUVORK5CYII=');\n    *right: 0;\n}\n\n.pika-prev.is-disabled,\n.pika-next.is-disabled {\n    cursor: default;\n    opacity: .2;\n}\n\n.pika-select {\n    display: inline-block;\n    *display: inline;\n}\n\n.pika-table {\n    width: 100%;\n    border-collapse: collapse;\n    border-spacing: 0;\n    border: 0;\n}\n\n.pika-table th,\n.pika-table td {\n    width: 14.285714285714286%;\n    padding: 0;\n}\n\n.pika-table th {\n    color: #999;\n    font-size: 12px;\n    line-height: 25px;\n    font-weight: bold;\n    text-align: center;\n}\n\n.pika-button {\n    cursor: pointer;\n    display: block;\n    box-sizing: border-box;\n    -moz-box-sizing: border-box;\n    outline: none;\n    border: 0;\n    margin: 0;\n    width: 100%;\n    padding: 5px;\n    color: #666;\n    font-size: 12px;\n    line-height: 15px;\n    text-align: right;\n    background: #f5f5f5;\n}\n\n.pika-week {\n    font-size: 11px;\n    color: #999;\n}\n\n.is-today .pika-button {\n    color: #33aaff;\n    font-weight: bold;\n}\n\n.is-selected .pika-button {\n    color: #fff;\n    font-weight: bold;\n    background: #33aaff;\n    box-shadow: inset 0 1px 3px #178fe5;\n    border-radius: 3px;\n}\n\n.is-inrange .pika-button {\n    background: #D5E9F7;\n}\n\n.is-startrange .pika-button {\n    color: #fff;\n    background: #6CB31D;\n    box-shadow: none;\n    border-radius: 3px;\n}\n\n.is-endrange .pika-button {\n    color: #fff;\n    background: #33aaff;\n    box-shadow: none;\n    border-radius: 3px;\n}\n\n.is-disabled .pika-button {\n    pointer-events: none;\n    cursor: default;\n    color: #999;\n    opacity: .3;\n}\n\n.pika-button:hover {\n    color: #fff;\n    background: #ff8000;\n    box-shadow: none;\n    border-radius: 3px;\n}\n\n/* styling for abbr */\n.pika-table abbr {\n    border-bottom: none;\n    cursor: help;\n}\n\n", ""]);

	// exports


/***/ },
/* 12 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	// css base code, injected by the css-loader
	module.exports = function() {
		var list = [];

		// return the list of modules as css string
		list.toString = function toString() {
			var result = [];
			for(var i = 0; i < this.length; i++) {
				var item = this[i];
				if(item[2]) {
					result.push("@media " + item[2] + "{" + item[1] + "}");
				} else {
					result.push(item[1]);
				}
			}
			return result.join("");
		};

		// import a list of modules into the list
		list.i = function(modules, mediaQuery) {
			if(typeof modules === "string")
				modules = [[null, modules, ""]];
			var alreadyImportedModules = {};
			for(var i = 0; i < this.length; i++) {
				var id = this[i][0];
				if(typeof id === "number")
					alreadyImportedModules[id] = true;
			}
			for(i = 0; i < modules.length; i++) {
				var item = modules[i];
				// skip already imported module
				// this implementation is not 100% perfect for weird media query combinations
				//  when a module is imported multiple times with different media queries.
				//  I hope this will never occur (Hey this way we have smaller bundles)
				if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
					if(mediaQuery && !item[2]) {
						item[2] = mediaQuery;
					} else if(mediaQuery) {
						item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
					}
					list.push(item);
				}
			}
		};
		return list;
	};


/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var stylesInDom = {},
		memoize = function(fn) {
			var memo;
			return function () {
				if (typeof memo === "undefined") memo = fn.apply(this, arguments);
				return memo;
			};
		},
		isOldIE = memoize(function() {
			return /msie [6-9]\b/.test(window.navigator.userAgent.toLowerCase());
		}),
		getHeadElement = memoize(function () {
			return document.head || document.getElementsByTagName("head")[0];
		}),
		singletonElement = null,
		singletonCounter = 0,
		styleElementsInsertedAtTop = [];

	module.exports = function(list, options) {
		if(false) {
			if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
		}

		options = options || {};
		// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
		// tags it will allow on a page
		if (typeof options.singleton === "undefined") options.singleton = isOldIE();

		// By default, add <style> tags to the bottom of <head>.
		if (typeof options.insertAt === "undefined") options.insertAt = "bottom";

		var styles = listToStyles(list);
		addStylesToDom(styles, options);

		return function update(newList) {
			var mayRemove = [];
			for(var i = 0; i < styles.length; i++) {
				var item = styles[i];
				var domStyle = stylesInDom[item.id];
				domStyle.refs--;
				mayRemove.push(domStyle);
			}
			if(newList) {
				var newStyles = listToStyles(newList);
				addStylesToDom(newStyles, options);
			}
			for(var i = 0; i < mayRemove.length; i++) {
				var domStyle = mayRemove[i];
				if(domStyle.refs === 0) {
					for(var j = 0; j < domStyle.parts.length; j++)
						domStyle.parts[j]();
					delete stylesInDom[domStyle.id];
				}
			}
		};
	}

	function addStylesToDom(styles, options) {
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			if(domStyle) {
				domStyle.refs++;
				for(var j = 0; j < domStyle.parts.length; j++) {
					domStyle.parts[j](item.parts[j]);
				}
				for(; j < item.parts.length; j++) {
					domStyle.parts.push(addStyle(item.parts[j], options));
				}
			} else {
				var parts = [];
				for(var j = 0; j < item.parts.length; j++) {
					parts.push(addStyle(item.parts[j], options));
				}
				stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
			}
		}
	}

	function listToStyles(list) {
		var styles = [];
		var newStyles = {};
		for(var i = 0; i < list.length; i++) {
			var item = list[i];
			var id = item[0];
			var css = item[1];
			var media = item[2];
			var sourceMap = item[3];
			var part = {css: css, media: media, sourceMap: sourceMap};
			if(!newStyles[id])
				styles.push(newStyles[id] = {id: id, parts: [part]});
			else
				newStyles[id].parts.push(part);
		}
		return styles;
	}

	function insertStyleElement(options, styleElement) {
		var head = getHeadElement();
		var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];
		if (options.insertAt === "top") {
			if(!lastStyleElementInsertedAtTop) {
				head.insertBefore(styleElement, head.firstChild);
			} else if(lastStyleElementInsertedAtTop.nextSibling) {
				head.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
			} else {
				head.appendChild(styleElement);
			}
			styleElementsInsertedAtTop.push(styleElement);
		} else if (options.insertAt === "bottom") {
			head.appendChild(styleElement);
		} else {
			throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
		}
	}

	function removeStyleElement(styleElement) {
		styleElement.parentNode.removeChild(styleElement);
		var idx = styleElementsInsertedAtTop.indexOf(styleElement);
		if(idx >= 0) {
			styleElementsInsertedAtTop.splice(idx, 1);
		}
	}

	function createStyleElement(options) {
		var styleElement = document.createElement("style");
		styleElement.type = "text/css";
		insertStyleElement(options, styleElement);
		return styleElement;
	}

	function createLinkElement(options) {
		var linkElement = document.createElement("link");
		linkElement.rel = "stylesheet";
		insertStyleElement(options, linkElement);
		return linkElement;
	}

	function addStyle(obj, options) {
		var styleElement, update, remove;

		if (options.singleton) {
			var styleIndex = singletonCounter++;
			styleElement = singletonElement || (singletonElement = createStyleElement(options));
			update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
			remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
		} else if(obj.sourceMap &&
			typeof URL === "function" &&
			typeof URL.createObjectURL === "function" &&
			typeof URL.revokeObjectURL === "function" &&
			typeof Blob === "function" &&
			typeof btoa === "function") {
			styleElement = createLinkElement(options);
			update = updateLink.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
				if(styleElement.href)
					URL.revokeObjectURL(styleElement.href);
			};
		} else {
			styleElement = createStyleElement(options);
			update = applyToTag.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
			};
		}

		update(obj);

		return function updateStyle(newObj) {
			if(newObj) {
				if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
					return;
				update(obj = newObj);
			} else {
				remove();
			}
		};
	}

	var replaceText = (function () {
		var textStore = [];

		return function (index, replacement) {
			textStore[index] = replacement;
			return textStore.filter(Boolean).join('\n');
		};
	})();

	function applyToSingletonTag(styleElement, index, remove, obj) {
		var css = remove ? "" : obj.css;

		if (styleElement.styleSheet) {
			styleElement.styleSheet.cssText = replaceText(index, css);
		} else {
			var cssNode = document.createTextNode(css);
			var childNodes = styleElement.childNodes;
			if (childNodes[index]) styleElement.removeChild(childNodes[index]);
			if (childNodes.length) {
				styleElement.insertBefore(cssNode, childNodes[index]);
			} else {
				styleElement.appendChild(cssNode);
			}
		}
	}

	function applyToTag(styleElement, obj) {
		var css = obj.css;
		var media = obj.media;
		var sourceMap = obj.sourceMap;

		if(media) {
			styleElement.setAttribute("media", media)
		}

		if(styleElement.styleSheet) {
			styleElement.styleSheet.cssText = css;
		} else {
			while(styleElement.firstChild) {
				styleElement.removeChild(styleElement.firstChild);
			}
			styleElement.appendChild(document.createTextNode(css));
		}
	}

	function updateLink(linkElement, obj) {
		var css = obj.css;
		var media = obj.media;
		var sourceMap = obj.sourceMap;

		if(sourceMap) {
			// http://stackoverflow.com/a/26603875
			css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
		}

		var blob = new Blob([css], { type: "text/css" });

		var oldSrc = linkElement.href;

		linkElement.href = URL.createObjectURL(blob);

		if(oldSrc)
			URL.revokeObjectURL(oldSrc);
	}


/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	var require;var require;/* WEBPACK VAR INJECTION */(function(process, global) {/*!
	 * Handsontable 0.20.0
	 * Handsontable is a JavaScript library for editable tables with basic copy-paste compatibility with Excel and Google Docs
	 *
	 * Copyright (c) 2012-2014 Marcin Warpechowski
	 * Copyright 2015 Handsoncode sp. z o.o. <hello@handsontable.com>
	 * Licensed under the MIT license.
	 * http://handsontable.com/
	 *
	 * Date: Tue Nov 03 2015 14:30:34 GMT+0100 (CET)
	 */
	/*jslint white: true, browser: true, plusplus: true, indent: 4, maxerr: 50 */

	window.Handsontable = {
	  version: '0.20.0',
	  buildDate: 'Tue Nov 03 2015 14:30:34 GMT+0100 (CET)',
	};
	(function(f){if(true){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.Handsontable = f()}})(function(){var define,module,exports;return (function init(modules, cache, entry) {
	  (function outer (modules, cache, entry) {
	    // Save the require from previous bundle to this closure if any
	    var previousRequire = typeof require == "function" && require;
	    var globalNS = JSON.parse('{"zeroclipboard":"ZeroClipboard","moment":"moment","pikaday":"Pikaday"}') || {};

	    function newRequire(name, jumped){
	      if(!cache[name]) {

	        if(!modules[name]) {
	          // if we cannot find the the module within our internal map or
	          // cache jump to the current global require ie. the last bundle
	          // that was added to the page.
	          var currentRequire = typeof require == "function" && require;
	          if (!jumped && currentRequire) return require(name, true);

	          // If there are other bundles on this page the require from the
	          // previous one is saved to 'previousRequire'. Repeat this as
	          // many times as there are bundles until the module is found or
	          // we exhaust the require chain.
	          if (previousRequire) return require(name, true);

	          // Try find module from global scope
	          if (globalNS[name] && typeof window[globalNS[name]] !== 'undefined') {
	            return window[globalNS[name]];
	          }

	          var err = new Error('Cannot find module \'' + name + '\'');
	          err.code = 'MODULE_NOT_FOUND';
	          throw err;
	        }
	        var m = cache[name] = {exports:{}};
	        modules[name][0].call(m.exports, function(x){
	          var id = modules[name][1][x];
	          return newRequire(id ? id : x);
	        },m,m.exports,outer,modules,cache,entry);
	      }

	      return cache[name].exports;
	    }
	    for(var i=0;i<entry.length;i++) newRequire(entry[i]);

	    // Override the current require with this new one
	    return newRequire;
	  })(modules, cache, entry);

	  return function() {
	    return Handsontable;
	  };
	})
	({1:[function(require,module,exports){
	"use strict";
	if (window.jQuery) {
	  (function(window, $, Handsontable) {
	    $.fn.handsontable = function(action) {
	      var i,
	          ilen,
	          args,
	          output,
	          userSettings,
	          $this = this.first(),
	          instance = $this.data('handsontable');
	      if (typeof action !== 'string') {
	        userSettings = action || {};
	        if (instance) {
	          instance.updateSettings(userSettings);
	        } else {
	          instance = new Handsontable.Core($this[0], userSettings);
	          $this.data('handsontable', instance);
	          instance.init();
	        }
	        return $this;
	      } else {
	        args = [];
	        if (arguments.length > 1) {
	          for (i = 1, ilen = arguments.length; i < ilen; i++) {
	            args.push(arguments[i]);
	          }
	        }
	        if (instance) {
	          if (typeof instance[action] !== 'undefined') {
	            output = instance[action].apply(instance, args);
	            if (action === 'destroy') {
	              $this.removeData();
	            }
	          } else {
	            throw new Error('Handsontable do not provide action: ' + action);
	          }
	        }
	        return output;
	      }
	    };
	  })(window, jQuery, Handsontable);
	}

	//# 
	},{}],2:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  WalkontableBorder: {get: function() {
	      return WalkontableBorder;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__,
	    $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_event__,
	    $___46__46__47__46__46__47__46__46__47_eventManager__,
	    $__cell_47_coords__,
	    $__overlay_47__95_base_46_js__;
	var $__0 = ($___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ = require("helpers/dom/element"), $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ && $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__}),
	    getComputedStyle = $__0.getComputedStyle,
	    getTrimmingContainer = $__0.getTrimmingContainer,
	    innerWidth = $__0.innerWidth,
	    innerHeight = $__0.innerHeight,
	    offset = $__0.offset,
	    outerHeight = $__0.outerHeight,
	    outerWidth = $__0.outerWidth;
	var stopImmediatePropagation = ($___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_event__ = require("helpers/dom/event"), $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_event__ && $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_event__.__esModule && $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_event__ || {default: $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_event__}).stopImmediatePropagation;
	var EventManager = ($___46__46__47__46__46__47__46__46__47_eventManager__ = require("eventManager"), $___46__46__47__46__46__47__46__46__47_eventManager__ && $___46__46__47__46__46__47__46__46__47_eventManager__.__esModule && $___46__46__47__46__46__47__46__46__47_eventManager__ || {default: $___46__46__47__46__46__47__46__46__47_eventManager__}).EventManager;
	var WalkontableCellCoords = ($__cell_47_coords__ = require("cell/coords"), $__cell_47_coords__ && $__cell_47_coords__.__esModule && $__cell_47_coords__ || {default: $__cell_47_coords__}).WalkontableCellCoords;
	var WalkontableOverlay = ($__overlay_47__95_base_46_js__ = require("overlay/_base.js"), $__overlay_47__95_base_46_js__ && $__overlay_47__95_base_46_js__.__esModule && $__overlay_47__95_base_46_js__ || {default: $__overlay_47__95_base_46_js__}).WalkontableOverlay;
	var WalkontableBorder = function WalkontableBorder(wotInstance, settings) {
	  if (!settings) {
	    return;
	  }
	  this.eventManager = new EventManager(wotInstance);
	  this.instance = wotInstance;
	  this.wot = wotInstance;
	  this.settings = settings;
	  this.mouseDown = false;
	  this.main = null;
	  this.top = null;
	  this.left = null;
	  this.bottom = null;
	  this.right = null;
	  this.topStyle = null;
	  this.leftStyle = null;
	  this.bottomStyle = null;
	  this.rightStyle = null;
	  this.cornerDefaultStyle = {
	    width: '5px',
	    height: '5px',
	    borderWidth: '2px',
	    borderStyle: 'solid',
	    borderColor: '#FFF'
	  };
	  this.corner = null;
	  this.cornerStyle = null;
	  this.createBorders(settings);
	  this.registerListeners();
	};
	($traceurRuntime.createClass)(WalkontableBorder, {
	  registerListeners: function() {
	    var $__5 = this;
	    this.eventManager.addEventListener(document.body, 'mousedown', (function() {
	      return $__5.onMouseDown();
	    }));
	    this.eventManager.addEventListener(document.body, 'mouseup', (function() {
	      return $__5.onMouseUp();
	    }));
	    var $__7 = this,
	        $__8 = function(c, len) {
	          $__7.eventManager.addEventListener($__7.main.childNodes[c], 'mouseenter', (function(event) {
	            return $__5.onMouseEnter(event, $__5.main.childNodes[c]);
	          }));
	        };
	    for (var c = 0,
	        len = this.main.childNodes.length; c < len; c++) {
	      $__8(c, len);
	    }
	  },
	  onMouseDown: function() {
	    this.mouseDown = true;
	  },
	  onMouseUp: function() {
	    this.mouseDown = false;
	  },
	  onMouseEnter: function(event, parentElement) {
	    if (!this.mouseDown || !this.wot.getSetting('hideBorderOnMouseDownOver')) {
	      return;
	    }
	    event.preventDefault();
	    stopImmediatePropagation(event);
	    var _this = this;
	    var bounds = parentElement.getBoundingClientRect();
	    parentElement.style.display = 'none';
	    function isOutside(event) {
	      if (event.clientY < Math.floor(bounds.top)) {
	        return true;
	      }
	      if (event.clientY > Math.ceil(bounds.top + bounds.height)) {
	        return true;
	      }
	      if (event.clientX < Math.floor(bounds.left)) {
	        return true;
	      }
	      if (event.clientX > Math.ceil(bounds.left + bounds.width)) {
	        return true;
	      }
	    }
	    function handler(event) {
	      if (isOutside(event)) {
	        _this.eventManager.removeEventListener(document.body, 'mousemove', handler);
	        parentElement.style.display = 'block';
	      }
	    }
	    this.eventManager.addEventListener(document.body, 'mousemove', handler);
	  },
	  createBorders: function(settings) {
	    this.main = document.createElement('div');
	    var borderDivs = ['top', 'left', 'bottom', 'right', 'corner'];
	    var style = this.main.style;
	    style.position = 'absolute';
	    style.top = 0;
	    style.left = 0;
	    for (var i = 0; i < 5; i++) {
	      var position = borderDivs[i];
	      var div = document.createElement('div');
	      div.className = 'wtBorder ' + (this.settings.className || '');
	      if (this.settings[position] && this.settings[position].hide) {
	        div.className += ' hidden';
	      }
	      style = div.style;
	      style.backgroundColor = (this.settings[position] && this.settings[position].color) ? this.settings[position].color : settings.border.color;
	      style.height = (this.settings[position] && this.settings[position].width) ? this.settings[position].width + 'px' : settings.border.width + 'px';
	      style.width = (this.settings[position] && this.settings[position].width) ? this.settings[position].width + 'px' : settings.border.width + 'px';
	      this.main.appendChild(div);
	    }
	    this.top = this.main.childNodes[0];
	    this.left = this.main.childNodes[1];
	    this.bottom = this.main.childNodes[2];
	    this.right = this.main.childNodes[3];
	    this.topStyle = this.top.style;
	    this.leftStyle = this.left.style;
	    this.bottomStyle = this.bottom.style;
	    this.rightStyle = this.right.style;
	    this.corner = this.main.childNodes[4];
	    this.corner.className += ' corner';
	    this.cornerStyle = this.corner.style;
	    this.cornerStyle.width = this.cornerDefaultStyle.width;
	    this.cornerStyle.height = this.cornerDefaultStyle.height;
	    this.cornerStyle.border = [this.cornerDefaultStyle.borderWidth, this.cornerDefaultStyle.borderStyle, this.cornerDefaultStyle.borderColor].join(' ');
	    if (Handsontable.mobileBrowser) {
	      this.createMultipleSelectorHandles();
	    }
	    this.disappear();
	    if (!this.wot.wtTable.bordersHolder) {
	      this.wot.wtTable.bordersHolder = document.createElement('div');
	      this.wot.wtTable.bordersHolder.className = 'htBorders';
	      this.wot.wtTable.spreader.appendChild(this.wot.wtTable.bordersHolder);
	    }
	    this.wot.wtTable.bordersHolder.insertBefore(this.main, this.wot.wtTable.bordersHolder.firstChild);
	  },
	  createMultipleSelectorHandles: function() {
	    this.selectionHandles = {
	      topLeft: document.createElement('DIV'),
	      topLeftHitArea: document.createElement('DIV'),
	      bottomRight: document.createElement('DIV'),
	      bottomRightHitArea: document.createElement('DIV')
	    };
	    var width = 10;
	    var hitAreaWidth = 40;
	    this.selectionHandles.topLeft.className = 'topLeftSelectionHandle';
	    this.selectionHandles.topLeftHitArea.className = 'topLeftSelectionHandle-HitArea';
	    this.selectionHandles.bottomRight.className = 'bottomRightSelectionHandle';
	    this.selectionHandles.bottomRightHitArea.className = 'bottomRightSelectionHandle-HitArea';
	    this.selectionHandles.styles = {
	      topLeft: this.selectionHandles.topLeft.style,
	      topLeftHitArea: this.selectionHandles.topLeftHitArea.style,
	      bottomRight: this.selectionHandles.bottomRight.style,
	      bottomRightHitArea: this.selectionHandles.bottomRightHitArea.style
	    };
	    var hitAreaStyle = {
	      position: 'absolute',
	      height: hitAreaWidth + 'px',
	      width: hitAreaWidth + 'px',
	      'border-radius': parseInt(hitAreaWidth / 1.5, 10) + 'px'
	    };
	    for (var prop in hitAreaStyle) {
	      if (hitAreaStyle.hasOwnProperty(prop)) {
	        this.selectionHandles.styles.bottomRightHitArea[prop] = hitAreaStyle[prop];
	        this.selectionHandles.styles.topLeftHitArea[prop] = hitAreaStyle[prop];
	      }
	    }
	    var handleStyle = {
	      position: 'absolute',
	      height: width + 'px',
	      width: width + 'px',
	      'border-radius': parseInt(width / 1.5, 10) + 'px',
	      background: '#F5F5FF',
	      border: '1px solid #4285c8'
	    };
	    for (var prop$__9 in handleStyle) {
	      if (handleStyle.hasOwnProperty(prop$__9)) {
	        this.selectionHandles.styles.bottomRight[prop$__9] = handleStyle[prop$__9];
	        this.selectionHandles.styles.topLeft[prop$__9] = handleStyle[prop$__9];
	      }
	    }
	    this.main.appendChild(this.selectionHandles.topLeft);
	    this.main.appendChild(this.selectionHandles.bottomRight);
	    this.main.appendChild(this.selectionHandles.topLeftHitArea);
	    this.main.appendChild(this.selectionHandles.bottomRightHitArea);
	  },
	  isPartRange: function(row, col) {
	    if (this.wot.selections.area.cellRange) {
	      if (row != this.wot.selections.area.cellRange.to.row || col != this.wot.selections.area.cellRange.to.col) {
	        return true;
	      }
	    }
	    return false;
	  },
	  updateMultipleSelectionHandlesPosition: function(row, col, top, left, width, height) {
	    var handleWidth = parseInt(this.selectionHandles.styles.topLeft.width, 10);
	    var hitAreaWidth = parseInt(this.selectionHandles.styles.topLeftHitArea.width, 10);
	    this.selectionHandles.styles.topLeft.top = parseInt(top - handleWidth, 10) + 'px';
	    this.selectionHandles.styles.topLeft.left = parseInt(left - handleWidth, 10) + 'px';
	    this.selectionHandles.styles.topLeftHitArea.top = parseInt(top - (hitAreaWidth / 4) * 3, 10) + 'px';
	    this.selectionHandles.styles.topLeftHitArea.left = parseInt(left - (hitAreaWidth / 4) * 3, 10) + 'px';
	    this.selectionHandles.styles.bottomRight.top = parseInt(top + height, 10) + 'px';
	    this.selectionHandles.styles.bottomRight.left = parseInt(left + width, 10) + 'px';
	    this.selectionHandles.styles.bottomRightHitArea.top = parseInt(top + height - hitAreaWidth / 4, 10) + 'px';
	    this.selectionHandles.styles.bottomRightHitArea.left = parseInt(left + width - hitAreaWidth / 4, 10) + 'px';
	    if (this.settings.border.multipleSelectionHandlesVisible && this.settings.border.multipleSelectionHandlesVisible()) {
	      this.selectionHandles.styles.topLeft.display = 'block';
	      this.selectionHandles.styles.topLeftHitArea.display = 'block';
	      if (this.isPartRange(row, col)) {
	        this.selectionHandles.styles.bottomRight.display = 'none';
	        this.selectionHandles.styles.bottomRightHitArea.display = 'none';
	      } else {
	        this.selectionHandles.styles.bottomRight.display = 'block';
	        this.selectionHandles.styles.bottomRightHitArea.display = 'block';
	      }
	    } else {
	      this.selectionHandles.styles.topLeft.display = 'none';
	      this.selectionHandles.styles.bottomRight.display = 'none';
	      this.selectionHandles.styles.topLeftHitArea.display = 'none';
	      this.selectionHandles.styles.bottomRightHitArea.display = 'none';
	    }
	    if (row == this.wot.wtSettings.getSetting('fixedRowsTop') || col == this.wot.wtSettings.getSetting('fixedColumnsLeft')) {
	      this.selectionHandles.styles.topLeft.zIndex = '9999';
	      this.selectionHandles.styles.topLeftHitArea.zIndex = '9999';
	    } else {
	      this.selectionHandles.styles.topLeft.zIndex = '';
	      this.selectionHandles.styles.topLeftHitArea.zIndex = '';
	    }
	  },
	  appear: function(corners) {
	    if (this.disabled) {
	      return;
	    }
	    var isMultiple,
	        fromTD,
	        toTD,
	        fromOffset,
	        toOffset,
	        containerOffset,
	        top,
	        minTop,
	        left,
	        minLeft,
	        height,
	        width,
	        fromRow,
	        fromColumn,
	        toRow,
	        toColumn,
	        trimmingContainer,
	        cornerOverlappingContainer,
	        ilen;
	    if (WalkontableOverlay.isOverlayTypeOf(this.wot.cloneOverlay, WalkontableOverlay.CLONE_TOP) || WalkontableOverlay.isOverlayTypeOf(this.wot.cloneOverlay, WalkontableOverlay.CLONE_TOP_LEFT_CORNER)) {
	      ilen = this.wot.getSetting('fixedRowsTop');
	    } else if (WalkontableOverlay.isOverlayTypeOf(this.wot.cloneOverlay, WalkontableOverlay.CLONE_BOTTOM) || WalkontableOverlay.isOverlayTypeOf(this.wot.cloneOverlay, WalkontableOverlay.CLONE_BOTTOM_LEFT_CORNER)) {
	      ilen = this.wot.getSetting('fixedRowsBottom');
	    } else {
	      ilen = this.wot.wtTable.getRenderedRowsCount();
	    }
	    for (var i = 0; i < ilen; i++) {
	      var s = this.wot.wtTable.rowFilter.renderedToSource(i);
	      if (s >= corners[0] && s <= corners[2]) {
	        fromRow = s;
	        break;
	      }
	    }
	    for (var i$__10 = ilen - 1; i$__10 >= 0; i$__10--) {
	      var s$__11 = this.wot.wtTable.rowFilter.renderedToSource(i$__10);
	      if (s$__11 >= corners[0] && s$__11 <= corners[2]) {
	        toRow = s$__11;
	        break;
	      }
	    }
	    ilen = this.wot.wtTable.getRenderedColumnsCount();
	    for (var i$__12 = 0; i$__12 < ilen; i$__12++) {
	      var s$__13 = this.wot.wtTable.columnFilter.renderedToSource(i$__12);
	      if (s$__13 >= corners[1] && s$__13 <= corners[3]) {
	        fromColumn = s$__13;
	        break;
	      }
	    }
	    for (var i$__14 = ilen - 1; i$__14 >= 0; i$__14--) {
	      var s$__15 = this.wot.wtTable.columnFilter.renderedToSource(i$__14);
	      if (s$__15 >= corners[1] && s$__15 <= corners[3]) {
	        toColumn = s$__15;
	        break;
	      }
	    }
	    if (fromRow === void 0 || fromColumn === void 0) {
	      this.disappear();
	      return;
	    }
	    isMultiple = (fromRow !== toRow || fromColumn !== toColumn);
	    fromTD = this.wot.wtTable.getCell(new WalkontableCellCoords(fromRow, fromColumn));
	    toTD = isMultiple ? this.wot.wtTable.getCell(new WalkontableCellCoords(toRow, toColumn)) : fromTD;
	    fromOffset = offset(fromTD);
	    toOffset = isMultiple ? offset(toTD) : fromOffset;
	    containerOffset = offset(this.wot.wtTable.TABLE);
	    minTop = fromOffset.top;
	    height = toOffset.top + outerHeight(toTD) - minTop;
	    minLeft = fromOffset.left;
	    width = toOffset.left + outerWidth(toTD) - minLeft;
	    top = minTop - containerOffset.top - 1;
	    left = minLeft - containerOffset.left - 1;
	    var style = getComputedStyle(fromTD);
	    if (parseInt(style.borderTopWidth, 10) > 0) {
	      top += 1;
	      height = height > 0 ? height - 1 : 0;
	    }
	    if (parseInt(style.borderLeftWidth, 10) > 0) {
	      left += 1;
	      width = width > 0 ? width - 1 : 0;
	    }
	    this.topStyle.top = top + 'px';
	    this.topStyle.left = left + 'px';
	    this.topStyle.width = width + 'px';
	    this.topStyle.display = 'block';
	    this.leftStyle.top = top + 'px';
	    this.leftStyle.left = left + 'px';
	    this.leftStyle.height = height + 'px';
	    this.leftStyle.display = 'block';
	    var delta = Math.floor(this.settings.border.width / 2);
	    this.bottomStyle.top = top + height - delta + 'px';
	    this.bottomStyle.left = left + 'px';
	    this.bottomStyle.width = width + 'px';
	    this.bottomStyle.display = 'block';
	    this.rightStyle.top = top + 'px';
	    this.rightStyle.left = left + width - delta + 'px';
	    this.rightStyle.height = height + 1 + 'px';
	    this.rightStyle.display = 'block';
	    if (Handsontable.mobileBrowser || (!this.hasSetting(this.settings.border.cornerVisible) || this.isPartRange(toRow, toColumn))) {
	      this.cornerStyle.display = 'none';
	    } else {
	      this.cornerStyle.top = top + height - 4 + 'px';
	      this.cornerStyle.left = left + width - 4 + 'px';
	      this.cornerStyle.borderRightWidth = this.cornerDefaultStyle.borderWidth;
	      this.cornerStyle.width = this.cornerDefaultStyle.width;
	      this.cornerStyle.display = 'block';
	      trimmingContainer = getTrimmingContainer(this.wot.wtTable.TABLE);
	      if (toColumn === this.wot.getSetting('totalColumns') - 1) {
	        cornerOverlappingContainer = toTD.offsetLeft + outerWidth(toTD) >= innerWidth(trimmingContainer);
	        if (cornerOverlappingContainer) {
	          this.cornerStyle.left = Math.floor(left + width - 3 - parseInt(this.cornerDefaultStyle.width) / 2) + 'px';
	          this.cornerStyle.borderRightWidth = 0;
	        }
	      }
	      if (toRow === this.wot.getSetting('totalRows') - 1) {
	        cornerOverlappingContainer = toTD.offsetTop + outerHeight(toTD) >= innerHeight(trimmingContainer);
	        if (cornerOverlappingContainer) {
	          this.cornerStyle.top = Math.floor(top + height - 3 - parseInt(this.cornerDefaultStyle.height) / 2) + 'px';
	          this.cornerStyle.borderBottomWidth = 0;
	        }
	      }
	    }
	    if (Handsontable.mobileBrowser) {
	      this.updateMultipleSelectionHandlesPosition(fromRow, fromColumn, top, left, width, height);
	    }
	  },
	  disappear: function() {
	    this.topStyle.display = 'none';
	    this.leftStyle.display = 'none';
	    this.bottomStyle.display = 'none';
	    this.rightStyle.display = 'none';
	    this.cornerStyle.display = 'none';
	    if (Handsontable.mobileBrowser) {
	      this.selectionHandles.styles.topLeft.display = 'none';
	      this.selectionHandles.styles.bottomRight.display = 'none';
	    }
	  },
	  hasSetting: function(setting) {
	    if (typeof setting === 'function') {
	      return setting();
	    }
	    return !!setting;
	  }
	}, {});
	;
	window.WalkontableBorder = WalkontableBorder;

	//# 
	},{"cell/coords":5,"eventManager":41,"helpers/dom/element":45,"helpers/dom/event":46,"overlay/_base.js":11}],3:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  WalkontableViewportColumnsCalculator: {get: function() {
	      return WalkontableViewportColumnsCalculator;
	    }},
	  __esModule: {value: true}
	});
	var privatePool = new WeakMap();
	var WalkontableViewportColumnsCalculator = function WalkontableViewportColumnsCalculator(viewportWidth, scrollOffset, totalColumns, columnWidthFn, overrideFn, onlyFullyVisible, stretchH) {
	  privatePool.set(this, {
	    viewportWidth: viewportWidth,
	    scrollOffset: scrollOffset,
	    totalColumns: totalColumns,
	    columnWidthFn: columnWidthFn,
	    overrideFn: overrideFn,
	    onlyFullyVisible: onlyFullyVisible
	  });
	  this.count = 0;
	  this.startColumn = null;
	  this.endColumn = null;
	  this.startPosition = null;
	  this.stretchAllRatio = 0;
	  this.stretchLastWidth = 0;
	  this.stretch = stretchH;
	  this.totalTargetWidth = 0;
	  this.needVerifyLastColumnWidth = true;
	  this.stretchAllColumnsWidth = [];
	  this.calculate();
	};
	var $WalkontableViewportColumnsCalculator = WalkontableViewportColumnsCalculator;
	($traceurRuntime.createClass)(WalkontableViewportColumnsCalculator, {
	  calculate: function() {
	    var sum = 0;
	    var needReverse = true;
	    var startPositions = [];
	    var columnWidth;
	    var priv = privatePool.get(this);
	    var onlyFullyVisible = priv.onlyFullyVisible;
	    var overrideFn = priv.overrideFn;
	    var scrollOffset = priv.scrollOffset;
	    var totalColumns = priv.totalColumns;
	    var viewportWidth = priv.viewportWidth;
	    for (var i = 0; i < totalColumns; i++) {
	      columnWidth = this._getColumnWidth(i);
	      if (sum <= scrollOffset && !onlyFullyVisible) {
	        this.startColumn = i;
	      }
	      if (sum >= scrollOffset && sum + columnWidth <= scrollOffset + viewportWidth) {
	        if (this.startColumn == null) {
	          this.startColumn = i;
	        }
	        this.endColumn = i;
	      }
	      startPositions.push(sum);
	      sum += columnWidth;
	      if (!onlyFullyVisible) {
	        this.endColumn = i;
	      }
	      if (sum >= scrollOffset + viewportWidth) {
	        needReverse = false;
	        break;
	      }
	    }
	    if (this.endColumn === totalColumns - 1 && needReverse) {
	      this.startColumn = this.endColumn;
	      while (this.startColumn > 0) {
	        var viewportSum = startPositions[this.endColumn] + columnWidth - startPositions[this.startColumn - 1];
	        if (viewportSum <= viewportWidth || !onlyFullyVisible) {
	          this.startColumn--;
	        }
	        if (viewportSum > viewportWidth) {
	          break;
	        }
	      }
	    }
	    if (this.startColumn !== null && overrideFn) {
	      overrideFn(this);
	    }
	    this.startPosition = startPositions[this.startColumn];
	    if (this.startPosition == void 0) {
	      this.startPosition = null;
	    }
	    if (this.startColumn !== null) {
	      this.count = this.endColumn - this.startColumn + 1;
	    }
	  },
	  refreshStretching: function(totalWidth) {
	    if (this.stretch === 'none') {
	      return;
	    }
	    var sumAll = 0;
	    var columnWidth;
	    var remainingSize;
	    var priv = privatePool.get(this);
	    var totalColumns = priv.totalColumns;
	    for (var i = 0; i < totalColumns; i++) {
	      columnWidth = this._getColumnWidth(i);
	      sumAll += columnWidth;
	    }
	    this.totalTargetWidth = totalWidth;
	    remainingSize = sumAll - totalWidth;
	    if (this.stretch === 'all' && remainingSize < 0) {
	      this.stretchAllRatio = totalWidth / sumAll;
	      this.stretchAllColumnsWidth = [];
	      this.needVerifyLastColumnWidth = true;
	    } else if (this.stretch === 'last' && totalWidth !== Infinity) {
	      this.stretchLastWidth = -remainingSize + this._getColumnWidth(totalColumns - 1);
	    }
	  },
	  getStretchedColumnWidth: function(column, baseWidth) {
	    var result = null;
	    if (this.stretch === 'all' && this.stretchAllRatio !== 0) {
	      result = this._getStretchedAllColumnWidth(column, baseWidth);
	    } else if (this.stretch === 'last' && this.stretchLastWidth !== 0) {
	      result = this._getStretchedLastColumnWidth(column);
	    }
	    return result;
	  },
	  _getStretchedAllColumnWidth: function(column, baseWidth) {
	    var sumRatioWidth = 0;
	    var priv = privatePool.get(this);
	    var totalColumns = priv.totalColumns;
	    if (!this.stretchAllColumnsWidth[column]) {
	      this.stretchAllColumnsWidth[column] = Math.round(baseWidth * this.stretchAllRatio);
	    }
	    if (this.stretchAllColumnsWidth.length === totalColumns && this.needVerifyLastColumnWidth) {
	      this.needVerifyLastColumnWidth = false;
	      for (var i = 0; i < this.stretchAllColumnsWidth.length; i++) {
	        sumRatioWidth += this.stretchAllColumnsWidth[i];
	      }
	      if (sumRatioWidth !== this.totalTargetWidth) {
	        this.stretchAllColumnsWidth[this.stretchAllColumnsWidth.length - 1] += this.totalTargetWidth - sumRatioWidth;
	      }
	    }
	    return this.stretchAllColumnsWidth[column];
	  },
	  _getStretchedLastColumnWidth: function(column) {
	    var priv = privatePool.get(this);
	    var totalColumns = priv.totalColumns;
	    if (column === totalColumns - 1) {
	      return this.stretchLastWidth;
	    }
	    return null;
	  },
	  _getColumnWidth: function(column) {
	    var width = privatePool.get(this).columnWidthFn(column);
	    if (width === undefined) {
	      width = $WalkontableViewportColumnsCalculator.DEFAULT_WIDTH;
	    }
	    return width;
	  }
	}, {get DEFAULT_WIDTH() {
	    return 50;
	  }});
	;
	window.WalkontableViewportColumnsCalculator = WalkontableViewportColumnsCalculator;

	//# 
	},{}],4:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  WalkontableViewportRowsCalculator: {get: function() {
	      return WalkontableViewportRowsCalculator;
	    }},
	  __esModule: {value: true}
	});
	var privatePool = new WeakMap();
	var WalkontableViewportRowsCalculator = function WalkontableViewportRowsCalculator(viewportHeight, scrollOffset, totalRows, rowHeightFn, overrideFn, onlyFullyVisible, horizontalScrollbarHeight) {
	  privatePool.set(this, {
	    viewportHeight: viewportHeight,
	    scrollOffset: scrollOffset,
	    totalRows: totalRows,
	    rowHeightFn: rowHeightFn,
	    overrideFn: overrideFn,
	    onlyFullyVisible: onlyFullyVisible,
	    horizontalScrollbarHeight: horizontalScrollbarHeight
	  });
	  this.count = 0;
	  this.startRow = null;
	  this.endRow = null;
	  this.startPosition = null;
	  this.calculate();
	};
	var $WalkontableViewportRowsCalculator = WalkontableViewportRowsCalculator;
	($traceurRuntime.createClass)(WalkontableViewportRowsCalculator, {calculate: function() {
	    var sum = 0;
	    var needReverse = true;
	    var startPositions = [];
	    var priv = privatePool.get(this);
	    var onlyFullyVisible = priv.onlyFullyVisible;
	    var overrideFn = priv.overrideFn;
	    var rowHeightFn = priv.rowHeightFn;
	    var scrollOffset = priv.scrollOffset;
	    var totalRows = priv.totalRows;
	    var viewportHeight = priv.viewportHeight;
	    var horizontalScrollbarHeight = priv.horizontalScrollbarHeight || 0;
	    for (var i = 0; i < totalRows; i++) {
	      var rowHeight = rowHeightFn(i);
	      if (rowHeight === undefined) {
	        rowHeight = $WalkontableViewportRowsCalculator.DEFAULT_HEIGHT;
	      }
	      if (sum <= scrollOffset && !onlyFullyVisible) {
	        this.startRow = i;
	      }
	      if (sum >= scrollOffset && sum + rowHeight <= scrollOffset + viewportHeight - horizontalScrollbarHeight) {
	        if (this.startRow === null) {
	          this.startRow = i;
	        }
	        this.endRow = i;
	      }
	      startPositions.push(sum);
	      sum += rowHeight;
	      if (!onlyFullyVisible) {
	        this.endRow = i;
	      }
	      if (sum >= scrollOffset + viewportHeight - horizontalScrollbarHeight) {
	        needReverse = false;
	        break;
	      }
	    }
	    if (this.endRow === totalRows - 1 && needReverse) {
	      this.startRow = this.endRow;
	      while (this.startRow > 0) {
	        var viewportSum = startPositions[this.endRow] + rowHeight - startPositions[this.startRow - 1];
	        if (viewportSum <= viewportHeight - horizontalScrollbarHeight || !onlyFullyVisible) {
	          this.startRow--;
	        }
	        if (viewportSum >= viewportHeight - horizontalScrollbarHeight) {
	          break;
	        }
	      }
	    }
	    if (this.startRow !== null && overrideFn) {
	      overrideFn(this);
	    }
	    this.startPosition = startPositions[this.startRow];
	    if (this.startPosition == void 0) {
	      this.startPosition = null;
	    }
	    if (this.startRow !== null) {
	      this.count = this.endRow - this.startRow + 1;
	    }
	  }}, {get DEFAULT_HEIGHT() {
	    return 23;
	  }});
	;
	window.WalkontableViewportRowsCalculator = WalkontableViewportRowsCalculator;

	//# 
	},{}],5:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  WalkontableCellCoords: {get: function() {
	      return WalkontableCellCoords;
	    }},
	  __esModule: {value: true}
	});
	var WalkontableCellCoords = function WalkontableCellCoords(row, col) {
	  if (typeof row !== 'undefined' && typeof col !== 'undefined') {
	    this.row = row;
	    this.col = col;
	  } else {
	    this.row = null;
	    this.col = null;
	  }
	};
	($traceurRuntime.createClass)(WalkontableCellCoords, {
	  isValid: function(wotInstance) {
	    if (this.row < 0 || this.col < 0) {
	      return false;
	    }
	    if (this.row >= wotInstance.getSetting('totalRows') || this.col >= wotInstance.getSetting('totalColumns')) {
	      return false;
	    }
	    return true;
	  },
	  isEqual: function(cellCoords) {
	    if (cellCoords === this) {
	      return true;
	    }
	    return this.row === cellCoords.row && this.col === cellCoords.col;
	  },
	  isSouthEastOf: function(testedCoords) {
	    return this.row >= testedCoords.row && this.col >= testedCoords.col;
	  },
	  isNorthWestOf: function(testedCoords) {
	    return this.row <= testedCoords.row && this.col <= testedCoords.col;
	  },
	  isSouthWestOf: function(testedCoords) {
	    return this.row >= testedCoords.row && this.col <= testedCoords.col;
	  },
	  isNorthEastOf: function(testedCoords) {
	    return this.row <= testedCoords.row && this.col >= testedCoords.col;
	  }
	}, {});
	;
	window.WalkontableCellCoords = WalkontableCellCoords;

	//# 
	},{}],6:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  WalkontableCellRange: {get: function() {
	      return WalkontableCellRange;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47_cell_47_coords__;
	var WalkontableCellCoords = ($___46__46__47_cell_47_coords__ = require("cell/coords"), $___46__46__47_cell_47_coords__ && $___46__46__47_cell_47_coords__.__esModule && $___46__46__47_cell_47_coords__ || {default: $___46__46__47_cell_47_coords__}).WalkontableCellCoords;
	var WalkontableCellRange = function WalkontableCellRange(highlight, from, to) {
	  this.highlight = highlight;
	  this.from = from;
	  this.to = to;
	};
	var $WalkontableCellRange = WalkontableCellRange;
	($traceurRuntime.createClass)(WalkontableCellRange, {
	  isValid: function(wotInstance) {
	    return this.from.isValid(wotInstance) && this.to.isValid(wotInstance);
	  },
	  isSingle: function() {
	    return this.from.row === this.to.row && this.from.col === this.to.col;
	  },
	  getHeight: function() {
	    return Math.max(this.from.row, this.to.row) - Math.min(this.from.row, this.to.row) + 1;
	  },
	  getWidth: function() {
	    return Math.max(this.from.col, this.to.col) - Math.min(this.from.col, this.to.col) + 1;
	  },
	  includes: function(cellCoords) {
	    var topLeft = this.getTopLeftCorner();
	    var bottomRight = this.getBottomRightCorner();
	    if (cellCoords.row < 0) {
	      cellCoords.row = 0;
	    }
	    if (cellCoords.col < 0) {
	      cellCoords.col = 0;
	    }
	    return topLeft.row <= cellCoords.row && bottomRight.row >= cellCoords.row && topLeft.col <= cellCoords.col && bottomRight.col >= cellCoords.col;
	  },
	  includesRange: function(testedRange) {
	    return this.includes(testedRange.getTopLeftCorner()) && this.includes(testedRange.getBottomRightCorner());
	  },
	  isEqual: function(testedRange) {
	    return (Math.min(this.from.row, this.to.row) == Math.min(testedRange.from.row, testedRange.to.row)) && (Math.max(this.from.row, this.to.row) == Math.max(testedRange.from.row, testedRange.to.row)) && (Math.min(this.from.col, this.to.col) == Math.min(testedRange.from.col, testedRange.to.col)) && (Math.max(this.from.col, this.to.col) == Math.max(testedRange.from.col, testedRange.to.col));
	  },
	  overlaps: function(testedRange) {
	    return testedRange.isSouthEastOf(this.getTopLeftCorner()) && testedRange.isNorthWestOf(this.getBottomRightCorner());
	  },
	  isSouthEastOf: function(testedCoords) {
	    return this.getTopLeftCorner().isSouthEastOf(testedCoords) || this.getBottomRightCorner().isSouthEastOf(testedCoords);
	  },
	  isNorthWestOf: function(testedCoords) {
	    return this.getTopLeftCorner().isNorthWestOf(testedCoords) || this.getBottomRightCorner().isNorthWestOf(testedCoords);
	  },
	  expand: function(cellCoords) {
	    var topLeft = this.getTopLeftCorner();
	    var bottomRight = this.getBottomRightCorner();
	    if (cellCoords.row < topLeft.row || cellCoords.col < topLeft.col || cellCoords.row > bottomRight.row || cellCoords.col > bottomRight.col) {
	      this.from = new WalkontableCellCoords(Math.min(topLeft.row, cellCoords.row), Math.min(topLeft.col, cellCoords.col));
	      this.to = new WalkontableCellCoords(Math.max(bottomRight.row, cellCoords.row), Math.max(bottomRight.col, cellCoords.col));
	      return true;
	    }
	    return false;
	  },
	  expandByRange: function(expandingRange) {
	    if (this.includesRange(expandingRange) || !this.overlaps(expandingRange)) {
	      return false;
	    }
	    var topLeft = this.getTopLeftCorner();
	    var bottomRight = this.getBottomRightCorner();
	    var topRight = this.getTopRightCorner();
	    var bottomLeft = this.getBottomLeftCorner();
	    var expandingTopLeft = expandingRange.getTopLeftCorner();
	    var expandingBottomRight = expandingRange.getBottomRightCorner();
	    var resultTopRow = Math.min(topLeft.row, expandingTopLeft.row);
	    var resultTopCol = Math.min(topLeft.col, expandingTopLeft.col);
	    var resultBottomRow = Math.max(bottomRight.row, expandingBottomRight.row);
	    var resultBottomCol = Math.max(bottomRight.col, expandingBottomRight.col);
	    var finalFrom = new WalkontableCellCoords(resultTopRow, resultTopCol),
	        finalTo = new WalkontableCellCoords(resultBottomRow, resultBottomCol);
	    var isCorner = new $WalkontableCellRange(finalFrom, finalFrom, finalTo).isCorner(this.from, expandingRange),
	        onlyMerge = expandingRange.isEqual(new $WalkontableCellRange(finalFrom, finalFrom, finalTo));
	    if (isCorner && !onlyMerge) {
	      if (this.from.col > finalFrom.col) {
	        finalFrom.col = resultBottomCol;
	        finalTo.col = resultTopCol;
	      }
	      if (this.from.row > finalFrom.row) {
	        finalFrom.row = resultBottomRow;
	        finalTo.row = resultTopRow;
	      }
	    }
	    this.from = finalFrom;
	    this.to = finalTo;
	    return true;
	  },
	  getDirection: function() {
	    if (this.from.isNorthWestOf(this.to)) {
	      return 'NW-SE';
	    } else if (this.from.isNorthEastOf(this.to)) {
	      return 'NE-SW';
	    } else if (this.from.isSouthEastOf(this.to)) {
	      return 'SE-NW';
	    } else if (this.from.isSouthWestOf(this.to)) {
	      return 'SW-NE';
	    }
	  },
	  setDirection: function(direction) {
	    switch (direction) {
	      case 'NW-SE':
	        this.from = this.getTopLeftCorner();
	        this.to = this.getBottomRightCorner();
	        break;
	      case 'NE-SW':
	        this.from = this.getTopRightCorner();
	        this.to = this.getBottomLeftCorner();
	        break;
	      case 'SE-NW':
	        this.from = this.getBottomRightCorner();
	        this.to = this.getTopLeftCorner();
	        break;
	      case 'SW-NE':
	        this.from = this.getBottomLeftCorner();
	        this.to = this.getTopRightCorner();
	        break;
	    }
	  },
	  getTopLeftCorner: function() {
	    return new WalkontableCellCoords(Math.min(this.from.row, this.to.row), Math.min(this.from.col, this.to.col));
	  },
	  getBottomRightCorner: function() {
	    return new WalkontableCellCoords(Math.max(this.from.row, this.to.row), Math.max(this.from.col, this.to.col));
	  },
	  getTopRightCorner: function() {
	    return new WalkontableCellCoords(Math.min(this.from.row, this.to.row), Math.max(this.from.col, this.to.col));
	  },
	  getBottomLeftCorner: function() {
	    return new WalkontableCellCoords(Math.max(this.from.row, this.to.row), Math.min(this.from.col, this.to.col));
	  },
	  isCorner: function(coords, expandedRange) {
	    if (expandedRange) {
	      if (expandedRange.includes(coords)) {
	        if (this.getTopLeftCorner().isEqual(new WalkontableCellCoords(expandedRange.from.row, expandedRange.from.col)) || this.getTopRightCorner().isEqual(new WalkontableCellCoords(expandedRange.from.row, expandedRange.to.col)) || this.getBottomLeftCorner().isEqual(new WalkontableCellCoords(expandedRange.to.row, expandedRange.from.col)) || this.getBottomRightCorner().isEqual(new WalkontableCellCoords(expandedRange.to.row, expandedRange.to.col))) {
	          return true;
	        }
	      }
	    }
	    return coords.isEqual(this.getTopLeftCorner()) || coords.isEqual(this.getTopRightCorner()) || coords.isEqual(this.getBottomLeftCorner()) || coords.isEqual(this.getBottomRightCorner());
	  },
	  getOppositeCorner: function(coords, expandedRange) {
	    if (!(coords instanceof WalkontableCellCoords)) {
	      return false;
	    }
	    if (expandedRange) {
	      if (expandedRange.includes(coords)) {
	        if (this.getTopLeftCorner().isEqual(new WalkontableCellCoords(expandedRange.from.row, expandedRange.from.col))) {
	          return this.getBottomRightCorner();
	        }
	        if (this.getTopRightCorner().isEqual(new WalkontableCellCoords(expandedRange.from.row, expandedRange.to.col))) {
	          return this.getBottomLeftCorner();
	        }
	        if (this.getBottomLeftCorner().isEqual(new WalkontableCellCoords(expandedRange.to.row, expandedRange.from.col))) {
	          return this.getTopRightCorner();
	        }
	        if (this.getBottomRightCorner().isEqual(new WalkontableCellCoords(expandedRange.to.row, expandedRange.to.col))) {
	          return this.getTopLeftCorner();
	        }
	      }
	    }
	    if (coords.isEqual(this.getBottomRightCorner())) {
	      return this.getTopLeftCorner();
	    } else if (coords.isEqual(this.getTopLeftCorner())) {
	      return this.getBottomRightCorner();
	    } else if (coords.isEqual(this.getTopRightCorner())) {
	      return this.getBottomLeftCorner();
	    } else if (coords.isEqual(this.getBottomLeftCorner())) {
	      return this.getTopRightCorner();
	    }
	  },
	  getBordersSharedWith: function(range) {
	    if (!this.includesRange(range)) {
	      return [];
	    }
	    var thisBorders = {
	      top: Math.min(this.from.row, this.to.row),
	      bottom: Math.max(this.from.row, this.to.row),
	      left: Math.min(this.from.col, this.to.col),
	      right: Math.max(this.from.col, this.to.col)
	    };
	    var rangeBorders = {
	      top: Math.min(range.from.row, range.to.row),
	      bottom: Math.max(range.from.row, range.to.row),
	      left: Math.min(range.from.col, range.to.col),
	      right: Math.max(range.from.col, range.to.col)
	    };
	    var result = [];
	    if (thisBorders.top == rangeBorders.top) {
	      result.push('top');
	    }
	    if (thisBorders.right == rangeBorders.right) {
	      result.push('right');
	    }
	    if (thisBorders.bottom == rangeBorders.bottom) {
	      result.push('bottom');
	    }
	    if (thisBorders.left == rangeBorders.left) {
	      result.push('left');
	    }
	    return result;
	  },
	  getInner: function() {
	    var topLeft = this.getTopLeftCorner();
	    var bottomRight = this.getBottomRightCorner();
	    var out = [];
	    for (var r = topLeft.row; r <= bottomRight.row; r++) {
	      for (var c = topLeft.col; c <= bottomRight.col; c++) {
	        if (!(this.from.row === r && this.from.col === c) && !(this.to.row === r && this.to.col === c)) {
	          out.push(new WalkontableCellCoords(r, c));
	        }
	      }
	    }
	    return out;
	  },
	  getAll: function() {
	    var topLeft = this.getTopLeftCorner();
	    var bottomRight = this.getBottomRightCorner();
	    var out = [];
	    for (var r = topLeft.row; r <= bottomRight.row; r++) {
	      for (var c = topLeft.col; c <= bottomRight.col; c++) {
	        if (topLeft.row === r && topLeft.col === c) {
	          out.push(topLeft);
	        } else if (bottomRight.row === r && bottomRight.col === c) {
	          out.push(bottomRight);
	        } else {
	          out.push(new WalkontableCellCoords(r, c));
	        }
	      }
	    }
	    return out;
	  },
	  forAll: function(callback) {
	    var topLeft = this.getTopLeftCorner();
	    var bottomRight = this.getBottomRightCorner();
	    for (var r = topLeft.row; r <= bottomRight.row; r++) {
	      for (var c = topLeft.col; c <= bottomRight.col; c++) {
	        var breakIteration = callback(r, c);
	        if (breakIteration === false) {
	          return;
	        }
	      }
	    }
	  }
	}, {});
	;
	window.WalkontableCellRange = WalkontableCellRange;

	//# 
	},{"cell/coords":5}],7:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  Walkontable: {get: function() {
	      return Walkontable;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__,
	    $___46__46__47__46__46__47__46__46__47_helpers_47_object__,
	    $___46__46__47__46__46__47__46__46__47_helpers_47_string__,
	    $__event__,
	    $__overlays__,
	    $__scroll__,
	    $__settings__,
	    $__table__,
	    $__viewport__,
	    $__overlay_47__95_base_46_js__,
	    $__overlay_47_top_46_js__,
	    $__overlay_47_left_46_js__,
	    $__overlay_47_debug_46_js__,
	    $__overlay_47_topLeftCorner_46_js__;
	var $__0 = ($___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ = require("helpers/dom/element"), $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ && $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__}),
	    addClass = $__0.addClass,
	    fastInnerText = $__0.fastInnerText,
	    isVisible = $__0.isVisible,
	    removeClass = $__0.removeClass;
	var objectEach = ($___46__46__47__46__46__47__46__46__47_helpers_47_object__ = require("helpers/object"), $___46__46__47__46__46__47__46__46__47_helpers_47_object__ && $___46__46__47__46__46__47__46__46__47_helpers_47_object__.__esModule && $___46__46__47__46__46__47__46__46__47_helpers_47_object__ || {default: $___46__46__47__46__46__47__46__46__47_helpers_47_object__}).objectEach;
	var $__2 = ($___46__46__47__46__46__47__46__46__47_helpers_47_string__ = require("helpers/string"), $___46__46__47__46__46__47__46__46__47_helpers_47_string__ && $___46__46__47__46__46__47__46__46__47_helpers_47_string__.__esModule && $___46__46__47__46__46__47__46__46__47_helpers_47_string__ || {default: $___46__46__47__46__46__47__46__46__47_helpers_47_string__}),
	    toUpperCaseFirst = $__2.toUpperCaseFirst,
	    randomString = $__2.randomString;
	var WalkontableEvent = ($__event__ = require("event"), $__event__ && $__event__.__esModule && $__event__ || {default: $__event__}).WalkontableEvent;
	var WalkontableOverlays = ($__overlays__ = require("overlays"), $__overlays__ && $__overlays__.__esModule && $__overlays__ || {default: $__overlays__}).WalkontableOverlays;
	var WalkontableScroll = ($__scroll__ = require("scroll"), $__scroll__ && $__scroll__.__esModule && $__scroll__ || {default: $__scroll__}).WalkontableScroll;
	var WalkontableSettings = ($__settings__ = require("settings"), $__settings__ && $__settings__.__esModule && $__settings__ || {default: $__settings__}).WalkontableSettings;
	var WalkontableTable = ($__table__ = require("table"), $__table__ && $__table__.__esModule && $__table__ || {default: $__table__}).WalkontableTable;
	var WalkontableViewport = ($__viewport__ = require("viewport"), $__viewport__ && $__viewport__.__esModule && $__viewport__ || {default: $__viewport__}).WalkontableViewport;
	var WalkontableOverlay = ($__overlay_47__95_base_46_js__ = require("overlay/_base.js"), $__overlay_47__95_base_46_js__ && $__overlay_47__95_base_46_js__.__esModule && $__overlay_47__95_base_46_js__ || {default: $__overlay_47__95_base_46_js__}).WalkontableOverlay;
	var WalkontableTopOverlay = ($__overlay_47_top_46_js__ = require("overlay/top.js"), $__overlay_47_top_46_js__ && $__overlay_47_top_46_js__.__esModule && $__overlay_47_top_46_js__ || {default: $__overlay_47_top_46_js__}).WalkontableTopOverlay;
	var WalkontableLeftOverlay = ($__overlay_47_left_46_js__ = require("overlay/left.js"), $__overlay_47_left_46_js__ && $__overlay_47_left_46_js__.__esModule && $__overlay_47_left_46_js__ || {default: $__overlay_47_left_46_js__}).WalkontableLeftOverlay;
	var WalkontableDebugOverlay = ($__overlay_47_debug_46_js__ = require("overlay/debug.js"), $__overlay_47_debug_46_js__ && $__overlay_47_debug_46_js__.__esModule && $__overlay_47_debug_46_js__ || {default: $__overlay_47_debug_46_js__}).WalkontableDebugOverlay;
	var WalkontableTopLeftCornerOverlay = ($__overlay_47_topLeftCorner_46_js__ = require("overlay/topLeftCorner.js"), $__overlay_47_topLeftCorner_46_js__ && $__overlay_47_topLeftCorner_46_js__.__esModule && $__overlay_47_topLeftCorner_46_js__ || {default: $__overlay_47_topLeftCorner_46_js__}).WalkontableTopLeftCornerOverlay;
	var Walkontable = function Walkontable(settings) {
	  var originalHeaders = [];
	  this.guid = 'wt_' + randomString();
	  if (settings.cloneSource) {
	    this.cloneSource = settings.cloneSource;
	    this.cloneOverlay = settings.cloneOverlay;
	    this.wtSettings = settings.cloneSource.wtSettings;
	    this.wtTable = new WalkontableTable(this, settings.table, settings.wtRootElement);
	    this.wtScroll = new WalkontableScroll(this);
	    this.wtViewport = settings.cloneSource.wtViewport;
	    this.wtEvent = new WalkontableEvent(this);
	    this.selections = this.cloneSource.selections;
	  } else {
	    this.wtSettings = new WalkontableSettings(this, settings);
	    this.wtTable = new WalkontableTable(this, settings.table);
	    this.wtScroll = new WalkontableScroll(this);
	    this.wtViewport = new WalkontableViewport(this);
	    this.wtEvent = new WalkontableEvent(this);
	    this.selections = this.getSetting('selections');
	    this.wtOverlays = new WalkontableOverlays(this);
	    this.exportSettingsAsClassNames();
	  }
	  if (this.wtTable.THEAD.childNodes.length && this.wtTable.THEAD.childNodes[0].childNodes.length) {
	    for (var c = 0,
	        clen = this.wtTable.THEAD.childNodes[0].childNodes.length; c < clen; c++) {
	      originalHeaders.push(this.wtTable.THEAD.childNodes[0].childNodes[c].innerHTML);
	    }
	    if (!this.getSetting('columnHeaders').length) {
	      this.update('columnHeaders', [function(column, TH) {
	        fastInnerText(TH, originalHeaders[column]);
	      }]);
	    }
	  }
	  this.drawn = false;
	  this.drawInterrupted = false;
	};
	($traceurRuntime.createClass)(Walkontable, {
	  draw: function() {
	    var fastDraw = arguments[0] !== (void 0) ? arguments[0] : false;
	    this.drawInterrupted = false;
	    if (!fastDraw && !isVisible(this.wtTable.TABLE)) {
	      this.drawInterrupted = true;
	    } else {
	      this.wtTable.draw(fastDraw);
	    }
	    return this;
	  },
	  getCell: function(coords) {
	    var topmost = arguments[1] !== (void 0) ? arguments[1] : false;
	    if (!topmost) {
	      return this.wtTable.getCell(coords);
	    }
	    var totalRows = this.wtSettings.getSetting('totalRows');
	    var fixedRowsTop = this.wtSettings.getSetting('fixedRowsTop');
	    var fixedRowsBottom = this.wtSettings.getSetting('fixedRowsBottom');
	    var fixedColumns = this.wtSettings.getSetting('fixedColumnsLeft');
	    if (coords.row < fixedRowsTop && coords.col < fixedColumns) {
	      return this.wtOverlays.topLeftCornerOverlay.clone.wtTable.getCell(coords);
	    } else if (coords.row < fixedRowsTop) {
	      return this.wtOverlays.topOverlay.clone.wtTable.getCell(coords);
	    } else if (coords.col < fixedColumns && coords.row >= totalRows - fixedRowsBottom) {
	      if (this.wtOverlays.bottomLeftCornerOverlay.clone) {
	        return this.wtOverlays.bottomLeftCornerOverlay.clone.wtTable.getCell(coords);
	      }
	    } else if (coords.col < fixedColumns) {
	      return this.wtOverlays.leftOverlay.clone.wtTable.getCell(coords);
	    } else if (coords.row >= totalRows - fixedRowsBottom) {
	      if (this.wtOverlays.bottomOverlay.clone) {
	        return this.wtOverlays.bottomOverlay.clone.wtTable.getCell(coords);
	      }
	    }
	    return this.wtTable.getCell(coords);
	  },
	  update: function(settings, value) {
	    return this.wtSettings.update(settings, value);
	  },
	  scrollVertical: function(row) {
	    this.wtOverlays.topOverlay.scrollTo(row);
	    this.getSetting('onScrollVertically');
	    return this;
	  },
	  scrollHorizontal: function(column) {
	    this.wtOverlays.leftOverlay.scrollTo(column);
	    this.getSetting('onScrollHorizontally');
	    return this;
	  },
	  scrollViewport: function(coords) {
	    this.wtScroll.scrollViewport(coords);
	    return this;
	  },
	  getViewport: function() {
	    return [this.wtTable.getFirstVisibleRow(), this.wtTable.getFirstVisibleColumn(), this.wtTable.getLastVisibleRow(), this.wtTable.getLastVisibleColumn()];
	  },
	  getOverlayName: function() {
	    return this.cloneOverlay ? this.cloneOverlay.type : 'master';
	  },
	  exportSettingsAsClassNames: function() {
	    var $__14 = this;
	    var toExport = {
	      rowHeaders: ['array'],
	      columnHeaders: ['array']
	    };
	    var allClassNames = [];
	    var newClassNames = [];
	    objectEach(toExport, (function(optionType, key) {
	      if (optionType.indexOf('array') > -1 && $__14.getSetting(key).length) {
	        newClassNames.push('ht' + toUpperCaseFirst(key));
	      }
	      allClassNames.push('ht' + toUpperCaseFirst(key));
	    }));
	    removeClass(this.wtTable.wtRootElement.parentNode, allClassNames);
	    addClass(this.wtTable.wtRootElement.parentNode, newClassNames);
	  },
	  getSetting: function(key, param1, param2, param3, param4) {
	    return this.wtSettings.getSetting(key, param1, param2, param3, param4);
	  },
	  hasSetting: function(key) {
	    return this.wtSettings.has(key);
	  },
	  destroy: function() {
	    this.wtOverlays.destroy();
	    this.wtEvent.destroy();
	  }
	}, {});
	;
	window.Walkontable = Walkontable;

	//# 
	},{"event":8,"helpers/dom/element":45,"helpers/object":50,"helpers/string":52,"overlay/_base.js":11,"overlay/debug.js":12,"overlay/left.js":13,"overlay/top.js":14,"overlay/topLeftCorner.js":15,"overlays":16,"scroll":17,"settings":19,"table":20,"viewport":22}],8:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  WalkontableEvent: {get: function() {
	      return WalkontableEvent;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__,
	    $___46__46__47__46__46__47__46__46__47_eventManager__;
	var $__0 = ($___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ = require("helpers/dom/element"), $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ && $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__}),
	    closest = $__0.closest,
	    hasClass = $__0.hasClass,
	    isChildOf = $__0.isChildOf;
	var eventManagerObject = ($___46__46__47__46__46__47__46__46__47_eventManager__ = require("eventManager"), $___46__46__47__46__46__47__46__46__47_eventManager__ && $___46__46__47__46__46__47__46__46__47_eventManager__.__esModule && $___46__46__47__46__46__47__46__46__47_eventManager__ || {default: $___46__46__47__46__46__47__46__46__47_eventManager__}).eventManager;
	function WalkontableEvent(instance) {
	  var that = this;
	  var eventManager = eventManagerObject(instance);
	  this.instance = instance;
	  var dblClickOrigin = [null, null];
	  this.dblClickTimeout = [null, null];
	  var onMouseDown = function(event) {
	    var cell = that.parentCell(event.realTarget);
	    if (hasClass(event.realTarget, 'corner')) {
	      that.instance.getSetting('onCellCornerMouseDown', event, event.realTarget);
	    } else if (cell.TD) {
	      if (that.instance.hasSetting('onCellMouseDown')) {
	        that.instance.getSetting('onCellMouseDown', event, cell.coords, cell.TD, that.instance);
	      }
	    }
	    if (event.button !== 2) {
	      if (cell.TD) {
	        dblClickOrigin[0] = cell.TD;
	        clearTimeout(that.dblClickTimeout[0]);
	        that.dblClickTimeout[0] = setTimeout(function() {
	          dblClickOrigin[0] = null;
	        }, 1000);
	      }
	    }
	  };
	  var onTouchMove = function(event) {
	    that.instance.touchMoving = true;
	  };
	  var longTouchTimeout;
	  var onTouchStart = function(event) {
	    var container = this;
	    eventManager.addEventListener(this, 'touchmove', onTouchMove);
	    that.checkIfTouchMove = setTimeout(function() {
	      if (that.instance.touchMoving === true) {
	        that.instance.touchMoving = void 0;
	        eventManager.removeEventListener('touchmove', onTouchMove, false);
	        return;
	      } else {
	        onMouseDown(event);
	      }
	    }, 30);
	  };
	  var lastMouseOver;
	  var onMouseOver = function(event) {
	    var table,
	        td;
	    if (that.instance.hasSetting('onCellMouseOver')) {
	      table = that.instance.wtTable.TABLE;
	      td = closest(event.realTarget, ['TD', 'TH'], table);
	      if (td && td !== lastMouseOver && isChildOf(td, table)) {
	        lastMouseOver = td;
	        that.instance.getSetting('onCellMouseOver', event, that.instance.wtTable.getCoords(td), td, that.instance);
	      }
	    }
	  };
	  var onMouseUp = function(event) {
	    if (event.button !== 2) {
	      var cell = that.parentCell(event.realTarget);
	      if (cell.TD === dblClickOrigin[0] && cell.TD === dblClickOrigin[1]) {
	        if (hasClass(event.realTarget, 'corner')) {
	          that.instance.getSetting('onCellCornerDblClick', event, cell.coords, cell.TD, that.instance);
	        } else {
	          that.instance.getSetting('onCellDblClick', event, cell.coords, cell.TD, that.instance);
	        }
	        dblClickOrigin[0] = null;
	        dblClickOrigin[1] = null;
	      } else if (cell.TD === dblClickOrigin[0]) {
	        dblClickOrigin[1] = cell.TD;
	        clearTimeout(that.dblClickTimeout[1]);
	        that.dblClickTimeout[1] = setTimeout(function() {
	          dblClickOrigin[1] = null;
	        }, 500);
	      }
	    }
	  };
	  var onTouchEnd = function(event) {
	    clearTimeout(longTouchTimeout);
	    event.preventDefault();
	    onMouseUp(event);
	  };
	  eventManager.addEventListener(this.instance.wtTable.holder, 'mousedown', onMouseDown);
	  eventManager.addEventListener(this.instance.wtTable.TABLE, 'mouseover', onMouseOver);
	  eventManager.addEventListener(this.instance.wtTable.holder, 'mouseup', onMouseUp);
	  if (this.instance.wtTable.holder.parentNode.parentNode && Handsontable.mobileBrowser && !that.instance.wtTable.isWorkingOnClone()) {
	    var classSelector = '.' + this.instance.wtTable.holder.parentNode.className.split(' ').join('.');
	    eventManager.addEventListener(this.instance.wtTable.holder, 'touchstart', function(event) {
	      that.instance.touchApplied = true;
	      if (isChildOf(event.target, classSelector)) {
	        onTouchStart.call(event.target, event);
	      }
	    });
	    eventManager.addEventListener(this.instance.wtTable.holder, 'touchend', function(event) {
	      that.instance.touchApplied = false;
	      if (isChildOf(event.target, classSelector)) {
	        onTouchEnd.call(event.target, event);
	      }
	    });
	    if (!that.instance.momentumScrolling) {
	      that.instance.momentumScrolling = {};
	    }
	    eventManager.addEventListener(this.instance.wtTable.holder, 'scroll', function(event) {
	      clearTimeout(that.instance.momentumScrolling._timeout);
	      if (!that.instance.momentumScrolling.ongoing) {
	        that.instance.getSetting('onBeforeTouchScroll');
	      }
	      that.instance.momentumScrolling.ongoing = true;
	      that.instance.momentumScrolling._timeout = setTimeout(function() {
	        if (!that.instance.touchApplied) {
	          that.instance.momentumScrolling.ongoing = false;
	          that.instance.getSetting('onAfterMomentumScroll');
	        }
	      }, 200);
	    });
	  }
	  eventManager.addEventListener(window, 'resize', function() {
	    if (that.instance.getSetting('stretchH') !== 'none') {
	      that.instance.draw();
	    }
	  });
	  this.destroy = function() {
	    clearTimeout(this.dblClickTimeout[0]);
	    clearTimeout(this.dblClickTimeout[1]);
	    eventManager.destroy();
	  };
	}
	WalkontableEvent.prototype.parentCell = function(elem) {
	  var cell = {};
	  var TABLE = this.instance.wtTable.TABLE;
	  var TD = closest(elem, ['TD', 'TH'], TABLE);
	  if (TD && isChildOf(TD, TABLE)) {
	    cell.coords = this.instance.wtTable.getCoords(TD);
	    cell.TD = TD;
	  } else if (hasClass(elem, 'wtBorder') && hasClass(elem, 'current')) {
	    cell.coords = this.instance.selections.current.cellRange.highlight;
	    cell.TD = this.instance.wtTable.getCell(cell.coords);
	  } else if (hasClass(elem, 'wtBorder') && hasClass(elem, 'area')) {
	    if (this.instance.selections.area.cellRange) {
	      cell.coords = this.instance.selections.area.cellRange.to;
	      cell.TD = this.instance.wtTable.getCell(cell.coords);
	    }
	  }
	  return cell;
	};
	;
	window.WalkontableEvent = WalkontableEvent;

	//# 
	},{"eventManager":41,"helpers/dom/element":45}],9:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  WalkontableColumnFilter: {get: function() {
	      return WalkontableColumnFilter;
	    }},
	  __esModule: {value: true}
	});
	var WalkontableColumnFilter = function WalkontableColumnFilter(offset, total, countTH) {
	  this.offset = offset;
	  this.total = total;
	  this.countTH = countTH;
	};
	($traceurRuntime.createClass)(WalkontableColumnFilter, {
	  offsetted: function(index) {
	    return index + this.offset;
	  },
	  unOffsetted: function(index) {
	    return index - this.offset;
	  },
	  renderedToSource: function(index) {
	    return this.offsetted(index);
	  },
	  sourceToRendered: function(index) {
	    return this.unOffsetted(index);
	  },
	  offsettedTH: function(index) {
	    return index - this.countTH;
	  },
	  unOffsettedTH: function(index) {
	    return index + this.countTH;
	  },
	  visibleRowHeadedColumnToSourceColumn: function(index) {
	    return this.renderedToSource(this.offsettedTH(index));
	  },
	  sourceColumnToVisibleRowHeadedColumn: function(index) {
	    return this.unOffsettedTH(this.sourceToRendered(index));
	  }
	}, {});
	;
	window.WalkontableColumnFilter = WalkontableColumnFilter;

	//# 
	},{}],10:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  WalkontableRowFilter: {get: function() {
	      return WalkontableRowFilter;
	    }},
	  __esModule: {value: true}
	});
	var WalkontableRowFilter = function WalkontableRowFilter(offset, total, countTH) {
	  this.offset = offset;
	  this.total = total;
	  this.countTH = countTH;
	};
	($traceurRuntime.createClass)(WalkontableRowFilter, {
	  offsetted: function(index) {
	    return index + this.offset;
	  },
	  unOffsetted: function(index) {
	    return index - this.offset;
	  },
	  renderedToSource: function(index) {
	    return this.offsetted(index);
	  },
	  sourceToRendered: function(index) {
	    return this.unOffsetted(index);
	  },
	  offsettedTH: function(index) {
	    return index - this.countTH;
	  },
	  unOffsettedTH: function(index) {
	    return index + this.countTH;
	  },
	  visibleColHeadedRowToSourceRow: function(index) {
	    return this.renderedToSource(this.offsettedTH(index));
	  },
	  sourceRowToVisibleColHeadedRow: function(index) {
	    return this.unOffsettedTH(this.sourceToRendered(index));
	  }
	}, {});
	;
	window.WalkontableRowFilter = WalkontableRowFilter;

	//# 
	},{}],11:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  WalkontableOverlay: {get: function() {
	      return WalkontableOverlay;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__,
	    $___46__46__47__46__46__47__46__46__47__46__46__47_helpers_47_object__,
	    $___46__46__47__46__46__47__46__46__47__46__46__47_eventManager__;
	var $__0 = ($___46__46__47__46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ = require("helpers/dom/element"), $___46__46__47__46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ && $___46__46__47__46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47__46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47__46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__}),
	    getScrollableElement = $__0.getScrollableElement,
	    getTrimmingContainer = $__0.getTrimmingContainer;
	var defineGetter = ($___46__46__47__46__46__47__46__46__47__46__46__47_helpers_47_object__ = require("helpers/object"), $___46__46__47__46__46__47__46__46__47__46__46__47_helpers_47_object__ && $___46__46__47__46__46__47__46__46__47__46__46__47_helpers_47_object__.__esModule && $___46__46__47__46__46__47__46__46__47__46__46__47_helpers_47_object__ || {default: $___46__46__47__46__46__47__46__46__47__46__46__47_helpers_47_object__}).defineGetter;
	var eventManagerObject = ($___46__46__47__46__46__47__46__46__47__46__46__47_eventManager__ = require("eventManager"), $___46__46__47__46__46__47__46__46__47__46__46__47_eventManager__ && $___46__46__47__46__46__47__46__46__47__46__46__47_eventManager__.__esModule && $___46__46__47__46__46__47__46__46__47__46__46__47_eventManager__ || {default: $___46__46__47__46__46__47__46__46__47__46__46__47_eventManager__}).eventManager;
	var registeredOverlays = {};
	var WalkontableOverlay = function WalkontableOverlay(wotInstance) {
	  defineGetter(this, 'wot', wotInstance, {writable: false});
	  this.instance = this.wot;
	  this.type = '';
	  this.TABLE = this.wot.wtTable.TABLE;
	  this.hider = this.wot.wtTable.hider;
	  this.spreader = this.wot.wtTable.spreader;
	  this.holder = this.wot.wtTable.holder;
	  this.wtRootElement = this.wot.wtTable.wtRootElement;
	  this.trimmingContainer = getTrimmingContainer(this.hider.parentNode.parentNode);
	  this.mainTableScrollableElement = getScrollableElement(this.wot.wtTable.TABLE);
	  this.needFullRender = this.shouldBeRendered();
	  this.areElementSizesAdjusted = false;
	};
	var $WalkontableOverlay = WalkontableOverlay;
	($traceurRuntime.createClass)(WalkontableOverlay, {
	  shouldBeRendered: function() {
	    return true;
	  },
	  makeClone: function(direction) {
	    if ($WalkontableOverlay.CLONE_TYPES.indexOf(direction) === -1) {
	      throw new Error('Clone type "' + direction + '" is not supported.');
	    }
	    var clone = document.createElement('DIV');
	    var clonedTable = document.createElement('TABLE');
	    clone.className = 'ht_clone_' + direction + ' handsontable';
	    clone.style.position = 'absolute';
	    clone.style.top = 0;
	    clone.style.left = 0;
	    clone.style.overflow = 'hidden';
	    clonedTable.className = this.wot.wtTable.TABLE.className;
	    clone.appendChild(clonedTable);
	    this.type = direction;
	    this.wot.wtTable.wtRootElement.parentNode.appendChild(clone);
	    return new Walkontable({
	      cloneSource: this.wot,
	      cloneOverlay: this,
	      table: clonedTable
	    });
	  },
	  refresh: function() {
	    var fastDraw = arguments[0] !== (void 0) ? arguments[0] : false;
	    var nextCycleRenderFlag = this.shouldBeRendered();
	    if (this.clone && (this.needFullRender || nextCycleRenderFlag)) {
	      this.clone.draw(fastDraw);
	    }
	    this.needFullRender = nextCycleRenderFlag;
	  },
	  destroy: function() {
	    eventManagerObject(this.clone).destroy();
	  }
	}, {
	  get CLONE_TOP() {
	    return 'top';
	  },
	  get CLONE_BOTTOM() {
	    return 'bottom';
	  },
	  get CLONE_LEFT() {
	    return 'left';
	  },
	  get CLONE_TOP_LEFT_CORNER() {
	    return 'top_left_corner';
	  },
	  get CLONE_BOTTOM_LEFT_CORNER() {
	    return 'bottom_left_corner';
	  },
	  get CLONE_DEBUG() {
	    return 'debug';
	  },
	  get CLONE_TYPES() {
	    return [$WalkontableOverlay.CLONE_TOP, $WalkontableOverlay.CLONE_BOTTOM, $WalkontableOverlay.CLONE_LEFT, $WalkontableOverlay.CLONE_TOP_LEFT_CORNER, $WalkontableOverlay.CLONE_BOTTOM_LEFT_CORNER, $WalkontableOverlay.CLONE_DEBUG];
	  },
	  registerOverlay: function(type, overlayClass) {
	    if ($WalkontableOverlay.CLONE_TYPES.indexOf(type) === -1) {
	      throw new Error(("Unsupported overlay (" + type + ")."));
	    }
	    registeredOverlays[type] = overlayClass;
	  },
	  createOverlay: function(type, wot) {
	    return new registeredOverlays[type](wot);
	  },
	  isOverlayTypeOf: function(overlay, type) {
	    if (!overlay || !registeredOverlays[type]) {
	      return false;
	    }
	    return overlay instanceof registeredOverlays[type];
	  }
	});
	;
	window.WalkontableOverlay = WalkontableOverlay;

	//# 
	},{"eventManager":41,"helpers/dom/element":45,"helpers/object":50}],12:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  WalkontableDebugOverlay: {get: function() {
	      return WalkontableDebugOverlay;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__,
	    $___95_base__;
	var addClass = ($___46__46__47__46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ = require("helpers/dom/element"), $___46__46__47__46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ && $___46__46__47__46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47__46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47__46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__}).addClass;
	var WalkontableOverlay = ($___95_base__ = require("_base"), $___95_base__ && $___95_base__.__esModule && $___95_base__ || {default: $___95_base__}).WalkontableOverlay;
	var WalkontableDebugOverlay = function WalkontableDebugOverlay(wotInstance) {
	  $traceurRuntime.superConstructor($WalkontableDebugOverlay).call(this, wotInstance);
	  this.clone = this.makeClone(WalkontableOverlay.CLONE_DEBUG);
	  this.clone.wtTable.holder.style.opacity = 0.4;
	  this.clone.wtTable.holder.style.textShadow = '0 0 2px #ff0000';
	  addClass(this.clone.wtTable.holder.parentNode, 'wtDebugVisible');
	};
	var $WalkontableDebugOverlay = WalkontableDebugOverlay;
	($traceurRuntime.createClass)(WalkontableDebugOverlay, {}, {}, WalkontableOverlay);
	;
	window.WalkontableDebugOverlay = WalkontableDebugOverlay;
	WalkontableOverlay.registerOverlay(WalkontableOverlay.CLONE_DEBUG, WalkontableDebugOverlay);

	//# 
	},{"_base":11,"helpers/dom/element":45}],13:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  WalkontableLeftOverlay: {get: function() {
	      return WalkontableLeftOverlay;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__,
	    $___95_base__;
	var $__0 = ($___46__46__47__46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ = require("helpers/dom/element"), $___46__46__47__46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ && $___46__46__47__46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47__46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47__46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__}),
	    addClass = $__0.addClass,
	    getScrollbarWidth = $__0.getScrollbarWidth,
	    getScrollLeft = $__0.getScrollLeft,
	    getWindowScrollTop = $__0.getWindowScrollTop,
	    hasClass = $__0.hasClass,
	    outerWidth = $__0.outerWidth,
	    removeClass = $__0.removeClass,
	    setOverlayPosition = $__0.setOverlayPosition;
	var WalkontableOverlay = ($___95_base__ = require("_base"), $___95_base__ && $___95_base__.__esModule && $___95_base__ || {default: $___95_base__}).WalkontableOverlay;
	var WalkontableLeftOverlay = function WalkontableLeftOverlay(wotInstance) {
	  $traceurRuntime.superConstructor($WalkontableLeftOverlay).call(this, wotInstance);
	  this.clone = this.makeClone(WalkontableOverlay.CLONE_LEFT);
	};
	var $WalkontableLeftOverlay = WalkontableLeftOverlay;
	($traceurRuntime.createClass)(WalkontableLeftOverlay, {
	  shouldBeRendered: function() {
	    return this.wot.getSetting('fixedColumnsLeft') || this.wot.getSetting('rowHeaders').length ? true : false;
	  },
	  resetFixedPosition: function() {
	    if (!this.needFullRender || !this.wot.wtTable.holder.parentNode) {
	      return;
	    }
	    var overlayRoot = this.clone.wtTable.holder.parentNode;
	    var headerPosition = 0;
	    if (this.trimmingContainer === window) {
	      var box = this.wot.wtTable.hider.getBoundingClientRect();
	      var left = Math.ceil(box.left);
	      var right = Math.ceil(box.right);
	      var finalLeft;
	      var finalTop;
	      finalTop = this.wot.wtTable.hider.style.top;
	      finalTop = finalTop === '' ? 0 : finalTop;
	      if (left < 0 && (right - overlayRoot.offsetWidth) > 0) {
	        finalLeft = -left;
	      } else {
	        finalLeft = 0;
	      }
	      headerPosition = finalLeft;
	      finalLeft = finalLeft + 'px';
	      setOverlayPosition(overlayRoot, finalLeft, finalTop);
	    } else {
	      headerPosition = this.getScrollPosition();
	    }
	    this.adjustHeaderBordersPosition(headerPosition);
	    this.adjustElementsSize();
	  },
	  setScrollPosition: function(pos) {
	    if (this.mainTableScrollableElement === window) {
	      window.scrollTo(pos, getWindowScrollTop());
	    } else {
	      this.mainTableScrollableElement.scrollLeft = pos;
	    }
	  },
	  onScroll: function() {
	    this.wot.getSetting('onScrollHorizontally');
	  },
	  sumCellSizes: function(from, to) {
	    var sum = 0;
	    var defaultColumnWidth = this.wot.wtSettings.defaultColumnWidth;
	    while (from < to) {
	      sum += this.wot.wtTable.getStretchedColumnWidth(from) || defaultColumnWidth;
	      from++;
	    }
	    return sum;
	  },
	  adjustElementsSize: function() {
	    var force = arguments[0] !== (void 0) ? arguments[0] : false;
	    if (this.needFullRender || force) {
	      this.adjustRootElementSize();
	      this.adjustRootChildrenSize();
	      if (!force) {
	        this.areElementSizesAdjusted = true;
	      }
	    }
	  },
	  adjustRootElementSize: function() {
	    var masterHolder = this.wot.wtTable.holder;
	    var scrollbarHeight = masterHolder.clientHeight === masterHolder.offsetHeight ? 0 : getScrollbarWidth();
	    var overlayRoot = this.clone.wtTable.holder.parentNode;
	    var overlayRootStyle = overlayRoot.style;
	    var tableWidth;
	    if (this.trimmingContainer !== window) {
	      overlayRootStyle.height = this.wot.wtViewport.getWorkspaceHeight() - scrollbarHeight + 'px';
	    }
	    this.clone.wtTable.holder.style.height = overlayRootStyle.height;
	    tableWidth = outerWidth(this.clone.wtTable.TABLE);
	    overlayRootStyle.width = (tableWidth === 0 ? tableWidth : tableWidth + 4) + 'px';
	  },
	  adjustRootChildrenSize: function() {
	    var scrollbarWidth = getScrollbarWidth();
	    this.clone.wtTable.hider.style.height = this.hider.style.height;
	    this.clone.wtTable.holder.style.height = this.clone.wtTable.holder.parentNode.style.height;
	    if (scrollbarWidth === 0) {
	      scrollbarWidth = 30;
	    }
	    this.clone.wtTable.holder.style.width = parseInt(this.clone.wtTable.holder.parentNode.style.width, 10) + scrollbarWidth + 'px';
	  },
	  applyToDOM: function() {
	    var total = this.wot.getSetting('totalColumns');
	    if (!this.areElementSizesAdjusted) {
	      this.adjustElementsSize();
	    }
	    if (typeof this.wot.wtViewport.columnsRenderCalculator.startPosition === 'number') {
	      this.spreader.style.left = this.wot.wtViewport.columnsRenderCalculator.startPosition + 'px';
	    } else if (total === 0) {
	      this.spreader.style.left = '0';
	    } else {
	      throw new Error('Incorrect value of the columnsRenderCalculator');
	    }
	    this.spreader.style.right = '';
	    if (this.needFullRender) {
	      this.syncOverlayOffset();
	    }
	  },
	  syncOverlayOffset: function() {
	    if (typeof this.wot.wtViewport.rowsRenderCalculator.startPosition === 'number') {
	      this.clone.wtTable.spreader.style.top = this.wot.wtViewport.rowsRenderCalculator.startPosition + 'px';
	    } else {
	      this.clone.wtTable.spreader.style.top = '';
	    }
	  },
	  scrollTo: function(sourceCol, beyondRendered) {
	    var newX = this.getTableParentOffset();
	    var sourceInstance = this.wot.cloneSource ? this.wot.cloneSource : this.wot;
	    var mainHolder = sourceInstance.wtTable.holder;
	    var scrollbarCompensation = 0;
	    if (beyondRendered && mainHolder.offsetWidth !== mainHolder.clientWidth) {
	      scrollbarCompensation = getScrollbarWidth();
	    }
	    if (beyondRendered) {
	      newX += this.sumCellSizes(0, sourceCol + 1);
	      newX -= this.wot.wtViewport.getViewportWidth();
	    } else {
	      newX += this.sumCellSizes(this.wot.getSetting('fixedColumnsLeft'), sourceCol);
	    }
	    newX += scrollbarCompensation;
	    this.setScrollPosition(newX);
	  },
	  getTableParentOffset: function() {
	    if (this.trimmingContainer === window) {
	      return this.wot.wtTable.holderOffset.left;
	    } else {
	      return 0;
	    }
	  },
	  getScrollPosition: function() {
	    return getScrollLeft(this.mainTableScrollableElement);
	  },
	  adjustHeaderBordersPosition: function(position) {
	    var masterParent = this.wot.wtTable.holder.parentNode;
	    var rowHeaders = this.wot.getSetting('rowHeaders');
	    var fixedColumnsLeft = this.wot.getSetting('fixedColumnsLeft');
	    if (fixedColumnsLeft && !rowHeaders.length) {
	      addClass(masterParent, 'innerBorderLeft');
	    } else if (!fixedColumnsLeft && rowHeaders.length) {
	      var previousState = hasClass(masterParent, 'innerBorderLeft');
	      if (position) {
	        addClass(masterParent, 'innerBorderLeft');
	      } else {
	        removeClass(masterParent, 'innerBorderLeft');
	      }
	      if (!previousState && position || previousState && !position) {
	        this.wot.wtOverlays.adjustElementsSize();
	      }
	    }
	  }
	}, {}, WalkontableOverlay);
	;
	window.WalkontableLeftOverlay = WalkontableLeftOverlay;
	WalkontableOverlay.registerOverlay(WalkontableOverlay.CLONE_LEFT, WalkontableLeftOverlay);

	//# 
	},{"_base":11,"helpers/dom/element":45}],14:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  WalkontableTopOverlay: {get: function() {
	      return WalkontableTopOverlay;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__,
	    $___95_base__;
	var $__0 = ($___46__46__47__46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ = require("helpers/dom/element"), $___46__46__47__46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ && $___46__46__47__46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47__46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47__46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__}),
	    addClass = $__0.addClass,
	    getScrollbarWidth = $__0.getScrollbarWidth,
	    getScrollTop = $__0.getScrollTop,
	    getWindowScrollLeft = $__0.getWindowScrollLeft,
	    hasClass = $__0.hasClass,
	    outerHeight = $__0.outerHeight,
	    removeClass = $__0.removeClass,
	    setOverlayPosition = $__0.setOverlayPosition;
	var WalkontableOverlay = ($___95_base__ = require("_base"), $___95_base__ && $___95_base__.__esModule && $___95_base__ || {default: $___95_base__}).WalkontableOverlay;
	var WalkontableTopOverlay = function WalkontableTopOverlay(wotInstance) {
	  $traceurRuntime.superConstructor($WalkontableTopOverlay).call(this, wotInstance);
	  this.clone = this.makeClone(WalkontableOverlay.CLONE_TOP);
	};
	var $WalkontableTopOverlay = WalkontableTopOverlay;
	($traceurRuntime.createClass)(WalkontableTopOverlay, {
	  shouldBeRendered: function() {
	    return this.wot.getSetting('fixedRowsTop') || this.wot.getSetting('columnHeaders').length ? true : false;
	  },
	  resetFixedPosition: function() {
	    if (!this.needFullRender || !this.wot.wtTable.holder.parentNode) {
	      return;
	    }
	    var overlayRoot = this.clone.wtTable.holder.parentNode;
	    var headerPosition = 0;
	    if (this.wot.wtOverlays.leftOverlay.trimmingContainer === window) {
	      var box = this.wot.wtTable.hider.getBoundingClientRect();
	      var top = Math.ceil(box.top);
	      var bottom = Math.ceil(box.bottom);
	      var finalLeft;
	      var finalTop;
	      finalLeft = this.wot.wtTable.hider.style.left;
	      finalLeft = finalLeft === '' ? 0 : finalLeft;
	      if (top < 0 && (bottom - overlayRoot.offsetHeight) > 0) {
	        finalTop = -top;
	      } else {
	        finalTop = 0;
	      }
	      headerPosition = finalTop;
	      finalTop = finalTop + 'px';
	      setOverlayPosition(overlayRoot, finalLeft, finalTop);
	    } else {
	      headerPosition = this.getScrollPosition();
	    }
	    this.adjustHeaderBordersPosition(headerPosition);
	    this.adjustElementsSize();
	  },
	  setScrollPosition: function(pos) {
	    if (this.mainTableScrollableElement === window) {
	      window.scrollTo(getWindowScrollLeft(), pos);
	    } else {
	      this.mainTableScrollableElement.scrollTop = pos;
	    }
	  },
	  onScroll: function() {
	    this.wot.getSetting('onScrollVertically');
	  },
	  sumCellSizes: function(from, to) {
	    var sum = 0;
	    var defaultRowHeight = this.wot.wtSettings.settings.defaultRowHeight;
	    while (from < to) {
	      var height = this.wot.wtTable.getRowHeight(from);
	      sum += height === void 0 ? defaultRowHeight : height;
	      from++;
	    }
	    return sum;
	  },
	  adjustElementsSize: function() {
	    var force = arguments[0] !== (void 0) ? arguments[0] : false;
	    if (this.needFullRender || force) {
	      this.adjustRootElementSize();
	      this.adjustRootChildrenSize();
	      if (!force) {
	        this.areElementSizesAdjusted = true;
	      }
	    }
	  },
	  adjustRootElementSize: function() {
	    var masterHolder = this.wot.wtTable.holder;
	    var scrollbarWidth = masterHolder.clientWidth === masterHolder.offsetWidth ? 0 : getScrollbarWidth();
	    var overlayRoot = this.clone.wtTable.holder.parentNode;
	    var overlayRootStyle = overlayRoot.style;
	    var tableHeight;
	    if (this.trimmingContainer !== window) {
	      overlayRootStyle.width = this.wot.wtViewport.getWorkspaceWidth() - scrollbarWidth + 'px';
	    }
	    this.clone.wtTable.holder.style.width = overlayRootStyle.width;
	    tableHeight = outerHeight(this.clone.wtTable.TABLE);
	    overlayRootStyle.height = (tableHeight === 0 ? tableHeight : tableHeight + 4) + 'px';
	  },
	  adjustRootChildrenSize: function() {
	    var scrollbarWidth = getScrollbarWidth();
	    this.clone.wtTable.hider.style.width = this.hider.style.width;
	    this.clone.wtTable.holder.style.width = this.clone.wtTable.holder.parentNode.style.width;
	    if (scrollbarWidth === 0) {
	      scrollbarWidth = 30;
	    }
	    this.clone.wtTable.holder.style.height = parseInt(this.clone.wtTable.holder.parentNode.style.height, 10) + scrollbarWidth + 'px';
	  },
	  applyToDOM: function() {
	    var total = this.wot.getSetting('totalRows');
	    if (!this.areElementSizesAdjusted) {
	      this.adjustElementsSize();
	    }
	    if (typeof this.wot.wtViewport.rowsRenderCalculator.startPosition === 'number') {
	      this.spreader.style.top = this.wot.wtViewport.rowsRenderCalculator.startPosition + 'px';
	    } else if (total === 0) {
	      this.spreader.style.top = '0';
	    } else {
	      throw new Error('Incorrect value of the rowsRenderCalculator');
	    }
	    this.spreader.style.bottom = '';
	    if (this.needFullRender) {
	      this.syncOverlayOffset();
	    }
	  },
	  syncOverlayOffset: function() {
	    if (typeof this.wot.wtViewport.columnsRenderCalculator.startPosition === 'number') {
	      this.clone.wtTable.spreader.style.left = this.wot.wtViewport.columnsRenderCalculator.startPosition + 'px';
	    } else {
	      this.clone.wtTable.spreader.style.left = '';
	    }
	  },
	  scrollTo: function(sourceRow, bottomEdge) {
	    var newY = this.getTableParentOffset();
	    var sourceInstance = this.wot.cloneSource ? this.wot.cloneSource : this.wot;
	    var mainHolder = sourceInstance.wtTable.holder;
	    var scrollbarCompensation = 0;
	    if (bottomEdge && mainHolder.offsetHeight !== mainHolder.clientHeight) {
	      scrollbarCompensation = getScrollbarWidth();
	    }
	    if (bottomEdge) {
	      var fixedRowsBottom = this.wot.getSetting('fixedRowsBottom');
	      var fixedRowsTop = this.wot.getSetting('fixedRowsTop');
	      var totalRows = this.wot.getSetting('totalRows');
	      newY += this.sumCellSizes(0, sourceRow + 1);
	      newY -= this.wot.wtViewport.getViewportHeight() - this.sumCellSizes(totalRows - fixedRowsBottom, totalRows);
	      newY += 1;
	    } else {
	      newY += this.sumCellSizes(this.wot.getSetting('fixedRowsTop'), sourceRow);
	    }
	    newY += scrollbarCompensation;
	    this.setScrollPosition(newY);
	  },
	  getTableParentOffset: function() {
	    if (this.mainTableScrollableElement === window) {
	      return this.wot.wtTable.holderOffset.top;
	    } else {
	      return 0;
	    }
	  },
	  getScrollPosition: function() {
	    return getScrollTop(this.mainTableScrollableElement);
	  },
	  adjustHeaderBordersPosition: function(position) {
	    if (this.wot.getSetting('fixedRowsTop') === 0 && this.wot.getSetting('columnHeaders').length > 0) {
	      var masterParent = this.wot.wtTable.holder.parentNode;
	      var previousState = hasClass(masterParent, 'innerBorderTop');
	      if (position) {
	        addClass(masterParent, 'innerBorderTop');
	      } else {
	        removeClass(masterParent, 'innerBorderTop');
	      }
	      if (!previousState && position || previousState && !position) {
	        this.wot.wtOverlays.adjustElementsSize();
	      }
	    }
	    if (this.wot.getSetting('rowHeaders').length === 0) {
	      var secondHeaderCell = this.clone.wtTable.THEAD.querySelectorAll('th:nth-of-type(2)');
	      if (secondHeaderCell) {
	        for (var i = 0; i < secondHeaderCell.length; i++) {
	          secondHeaderCell[i].style['border-left-width'] = 0;
	        }
	      }
	    }
	  }
	}, {}, WalkontableOverlay);
	;
	window.WalkontableTopOverlay = WalkontableTopOverlay;
	WalkontableOverlay.registerOverlay(WalkontableOverlay.CLONE_TOP, WalkontableTopOverlay);

	//# 
	},{"_base":11,"helpers/dom/element":45}],15:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  WalkontableTopLeftCornerOverlay: {get: function() {
	      return WalkontableTopLeftCornerOverlay;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__,
	    $___95_base__;
	var $__0 = ($___46__46__47__46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ = require("helpers/dom/element"), $___46__46__47__46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ && $___46__46__47__46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47__46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47__46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__}),
	    outerHeight = $__0.outerHeight,
	    outerWidth = $__0.outerWidth,
	    setOverlayPosition = $__0.setOverlayPosition;
	var WalkontableOverlay = ($___95_base__ = require("_base"), $___95_base__ && $___95_base__.__esModule && $___95_base__ || {default: $___95_base__}).WalkontableOverlay;
	var WalkontableTopLeftCornerOverlay = function WalkontableTopLeftCornerOverlay(wotInstance) {
	  $traceurRuntime.superConstructor($WalkontableTopLeftCornerOverlay).call(this, wotInstance);
	  this.clone = this.makeClone(WalkontableOverlay.CLONE_TOP_LEFT_CORNER);
	};
	var $WalkontableTopLeftCornerOverlay = WalkontableTopLeftCornerOverlay;
	($traceurRuntime.createClass)(WalkontableTopLeftCornerOverlay, {
	  shouldBeRendered: function() {
	    return (this.wot.getSetting('fixedRowsTop') || this.wot.getSetting('columnHeaders').length) && (this.wot.getSetting('fixedColumnsLeft') || this.wot.getSetting('rowHeaders').length) ? true : false;
	  },
	  resetFixedPosition: function() {
	    if (!this.wot.wtTable.holder.parentNode) {
	      return;
	    }
	    var overlayRoot = this.clone.wtTable.holder.parentNode;
	    var tableHeight = outerHeight(this.clone.wtTable.TABLE);
	    var tableWidth = outerWidth(this.clone.wtTable.TABLE);
	    if (this.trimmingContainer === window) {
	      var box = this.wot.wtTable.hider.getBoundingClientRect();
	      var top = Math.ceil(box.top);
	      var left = Math.ceil(box.left);
	      var bottom = Math.ceil(box.bottom);
	      var right = Math.ceil(box.right);
	      var finalLeft;
	      var finalTop;
	      if (left < 0 && (right - overlayRoot.offsetWidth) > 0) {
	        finalLeft = -left + 'px';
	      } else {
	        finalLeft = '0';
	      }
	      if (top < 0 && (bottom - overlayRoot.offsetHeight) > 0) {
	        finalTop = -top + 'px';
	      } else {
	        finalTop = '0';
	      }
	      setOverlayPosition(overlayRoot, finalLeft, finalTop);
	    }
	    overlayRoot.style.height = (tableHeight === 0 ? tableHeight : tableHeight + 4) + 'px';
	    overlayRoot.style.width = (tableWidth === 0 ? tableWidth : tableWidth + 4) + 'px';
	  }
	}, {}, WalkontableOverlay);
	;
	window.WalkontableTopLeftCornerOverlay = WalkontableTopLeftCornerOverlay;
	WalkontableOverlay.registerOverlay(WalkontableOverlay.CLONE_TOP_LEFT_CORNER, WalkontableTopLeftCornerOverlay);

	//# 
	},{"_base":11,"helpers/dom/element":45}],16:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  WalkontableOverlays: {get: function() {
	      return WalkontableOverlays;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__,
	    $___46__46__47__46__46__47__46__46__47_helpers_47_unicode__,
	    $___46__46__47__46__46__47__46__46__47_eventManager__;
	var $__0 = ($___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ = require("helpers/dom/element"), $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ && $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__}),
	    getScrollableElement = $__0.getScrollableElement,
	    getScrollbarWidth = $__0.getScrollbarWidth,
	    getScrollLeft = $__0.getScrollLeft,
	    getScrollTop = $__0.getScrollTop;
	var isKey = ($___46__46__47__46__46__47__46__46__47_helpers_47_unicode__ = require("helpers/unicode"), $___46__46__47__46__46__47__46__46__47_helpers_47_unicode__ && $___46__46__47__46__46__47__46__46__47_helpers_47_unicode__.__esModule && $___46__46__47__46__46__47__46__46__47_helpers_47_unicode__ || {default: $___46__46__47__46__46__47__46__46__47_helpers_47_unicode__}).isKey;
	var EventManager = ($___46__46__47__46__46__47__46__46__47_eventManager__ = require("eventManager"), $___46__46__47__46__46__47__46__46__47_eventManager__ && $___46__46__47__46__46__47__46__46__47_eventManager__.__esModule && $___46__46__47__46__46__47__46__46__47_eventManager__ || {default: $___46__46__47__46__46__47__46__46__47_eventManager__}).EventManager;
	var WalkontableOverlays = function WalkontableOverlays(wotInstance) {
	  this.wot = wotInstance;
	  this.instance = this.wot;
	  this.eventManager = new EventManager(this.wot);
	  this.wot.update('scrollbarWidth', getScrollbarWidth());
	  this.wot.update('scrollbarHeight', getScrollbarWidth());
	  this.mainTableScrollableElement = getScrollableElement(this.wot.wtTable.TABLE);
	  this.topOverlay = WalkontableOverlay.createOverlay(WalkontableOverlay.CLONE_TOP, this.wot);
	  if (typeof WalkontableBottomOverlay === 'undefined') {
	    this.bottomOverlay = {needFullRender: false};
	  } else {
	    this.bottomOverlay = WalkontableOverlay.createOverlay(WalkontableOverlay.CLONE_BOTTOM, this.wot);
	  }
	  this.leftOverlay = WalkontableOverlay.createOverlay(WalkontableOverlay.CLONE_LEFT, this.wot);
	  if (this.topOverlay.needFullRender && this.leftOverlay.needFullRender) {
	    this.topLeftCornerOverlay = WalkontableOverlay.createOverlay(WalkontableOverlay.CLONE_TOP_LEFT_CORNER, this.wot);
	  }
	  if (this.bottomOverlay.needFullRender && this.leftOverlay.needFullRender && typeof WalkontableBottomLeftCornerOverlay !== 'undefined') {
	    this.bottomLeftCornerOverlay = WalkontableOverlay.createOverlay(WalkontableOverlay.CLONE_BOTTOM_LEFT_CORNER, this.wot);
	  } else {
	    this.bottomLeftCornerOverlay = {needFullRender: false};
	  }
	  if (this.wot.getSetting('debug')) {
	    this.debug = WalkontableOverlay.createOverlay(WalkontableOverlay.CLONE_DEBUG, this.wot);
	  }
	  this.destroyed = false;
	  this.keyPressed = false;
	  this.spreaderLastSize = {
	    width: null,
	    height: null
	  };
	  this.overlayScrollPositions = {
	    master: {
	      top: 0,
	      left: 0
	    },
	    top: {
	      top: null,
	      left: 0
	    },
	    bottom: {
	      top: null,
	      left: 0
	    },
	    left: {
	      top: 0,
	      left: null
	    }
	  };
	  this.registerListeners();
	};
	($traceurRuntime.createClass)(WalkontableOverlays, {
	  refreshAll: function() {
	    if (!this.wot.drawn) {
	      return;
	    }
	    if (!this.wot.wtTable.holder.parentNode) {
	      this.destroy();
	      return;
	    }
	    this.wot.draw(true);
	    this.topOverlay.onScroll();
	    this.leftOverlay.onScroll();
	  },
	  registerListeners: function() {
	    var $__3 = this;
	    this.eventManager.addEventListener(document.documentElement, 'keydown', (function(event) {
	      return $__3.onKeyDown(event);
	    }));
	    this.eventManager.addEventListener(document.documentElement, 'keyup', (function() {
	      return $__3.onKeyUp();
	    }));
	    this.eventManager.addEventListener(document, 'visibilitychange', (function() {
	      return $__3.onKeyUp();
	    }));
	    this.eventManager.addEventListener(this.mainTableScrollableElement, 'scroll', (function(event) {
	      return $__3.onTableScroll(event);
	    }));
	    if (this.topOverlay.needFullRender) {
	      this.eventManager.addEventListener(this.topOverlay.clone.wtTable.holder, 'scroll', (function(event) {
	        return $__3.onTableScroll(event);
	      }));
	      this.eventManager.addEventListener(this.topOverlay.clone.wtTable.holder, 'wheel', (function(event) {
	        return $__3.onTableScroll(event);
	      }));
	    }
	    if (this.bottomOverlay.needFullRender) {
	      this.eventManager.addEventListener(this.bottomOverlay.clone.wtTable.holder, 'scroll', (function(event) {
	        return $__3.onTableScroll(event);
	      }));
	      this.eventManager.addEventListener(this.bottomOverlay.clone.wtTable.holder, 'wheel', (function(event) {
	        return $__3.onTableScroll(event);
	      }));
	    }
	    if (this.leftOverlay.needFullRender) {
	      this.eventManager.addEventListener(this.leftOverlay.clone.wtTable.holder, 'scroll', (function(event) {
	        return $__3.onTableScroll(event);
	      }));
	      this.eventManager.addEventListener(this.leftOverlay.clone.wtTable.holder, 'wheel', (function(event) {
	        return $__3.onTableScroll(event);
	      }));
	    }
	    if (this.topOverlay.trimmingContainer !== window && this.leftOverlay.trimmingContainer !== window) {
	      this.eventManager.addEventListener(window, 'wheel', (function(event) {
	        var overlay;
	        var deltaY = event.wheelDeltaY || event.deltaY;
	        var deltaX = event.wheelDeltaX || event.deltaX;
	        if ($__3.topOverlay.clone.wtTable.holder.contains(event.realTarget)) {
	          overlay = 'top';
	        } else if ($__3.bottomOverlay.clone && $__3.bottomOverlay.clone.wtTable.holder.contains(event.realTarget)) {
	          overlay = 'bottom';
	        } else if ($__3.leftOverlay.clone.wtTable.holder.contains(event.realTarget)) {
	          overlay = 'left';
	        }
	        if (overlay == 'top' && deltaY !== 0) {
	          event.preventDefault();
	        } else if (overlay == 'left' && deltaX !== 0) {
	          event.preventDefault();
	        } else if (overlay == 'bottom' && deltaY !== 0) {
	          event.preventDefault();
	        }
	      }));
	    }
	  },
	  onTableScroll: function(event) {
	    if (Handsontable.mobileBrowser) {
	      return;
	    }
	    if (this.keyPressed && this.mainTableScrollableElement !== window && !event.target.contains(this.mainTableScrollableElement)) {
	      return;
	    }
	    if (event.type === 'scroll') {
	      this.syncScrollPositions(event);
	    } else {
	      this.translateMouseWheelToScroll(event);
	    }
	  },
	  onKeyDown: function(event) {
	    this.keyPressed = isKey(event.keyCode, 'ARROW_UP|ARROW_RIGHT|ARROW_DOWN|ARROW_LEFT');
	  },
	  onKeyUp: function() {
	    this.keyPressed = false;
	  },
	  translateMouseWheelToScroll: function(event) {
	    var topOverlay = this.topOverlay.clone.wtTable.holder;
	    var bottomOverlay = this.bottomOverlay.clone ? this.bottomOverlay.clone.wtTable.holder : null;
	    var leftOverlay = this.leftOverlay.clone.wtTable.holder;
	    var eventMockup = {type: 'wheel'};
	    var tempElem = event.target;
	    var deltaY = event.wheelDeltaY || (-1) * event.deltaY;
	    var deltaX = event.wheelDeltaX || (-1) * event.deltaX;
	    var parentHolder;
	    while (tempElem != document && tempElem != null) {
	      if (tempElem.className.indexOf('wtHolder') > -1) {
	        parentHolder = tempElem;
	        break;
	      }
	      tempElem = tempElem.parentNode;
	    }
	    eventMockup.target = parentHolder;
	    if (parentHolder == topOverlay) {
	      this.syncScrollPositions(eventMockup, (-0.2) * deltaY);
	    } else if (parentHolder == bottomOverlay) {
	      this.syncScrollPositions(eventMockup, (-0.2) * deltaY);
	    } else if (parentHolder == leftOverlay) {
	      this.syncScrollPositions(eventMockup, (-0.2) * deltaX);
	    }
	    return false;
	  },
	  syncScrollPositions: function(event) {
	    var fakeScrollValue = arguments[1] !== (void 0) ? arguments[1] : null;
	    if (this.destroyed) {
	      return;
	    }
	    if (arguments.length === 0) {
	      this.syncScrollWithMaster();
	      return;
	    }
	    var master = this.mainTableScrollableElement;
	    var target = event.target;
	    var tempScrollValue = 0;
	    var scrollValueChanged = false;
	    var topOverlay;
	    var leftOverlay;
	    var bottomOverlay;
	    if (this.topOverlay.needFullRender) {
	      topOverlay = this.topOverlay.clone.wtTable.holder;
	    }
	    if (this.bottomOverlay.needFullRender) {
	      bottomOverlay = this.bottomOverlay.clone.wtTable.holder;
	    }
	    if (this.leftOverlay.needFullRender) {
	      leftOverlay = this.leftOverlay.clone.wtTable.holder;
	    }
	    if (target === document) {
	      target = window;
	    }
	    if (target === master) {
	      tempScrollValue = getScrollLeft(target);
	      if (this.overlayScrollPositions.master.left !== tempScrollValue) {
	        this.overlayScrollPositions.master.left = tempScrollValue;
	        scrollValueChanged = true;
	        if (topOverlay) {
	          topOverlay.scrollLeft = tempScrollValue;
	        }
	        if (bottomOverlay) {
	          bottomOverlay.scrollLeft = tempScrollValue;
	        }
	      }
	      tempScrollValue = getScrollTop(target);
	      if (this.overlayScrollPositions.master.top !== tempScrollValue) {
	        this.overlayScrollPositions.master.top = tempScrollValue;
	        scrollValueChanged = true;
	        if (leftOverlay) {
	          leftOverlay.scrollTop = tempScrollValue;
	        }
	      }
	    } else if (target === bottomOverlay) {
	      tempScrollValue = getScrollLeft(target);
	      if (this.overlayScrollPositions.bottom.left !== tempScrollValue) {
	        this.overlayScrollPositions.bottom.left = tempScrollValue;
	        scrollValueChanged = true;
	        master.scrollLeft = tempScrollValue;
	      }
	      if (fakeScrollValue !== null) {
	        scrollValueChanged = true;
	        master.scrollTop += fakeScrollValue;
	      }
	    } else if (target === topOverlay) {
	      tempScrollValue = getScrollLeft(target);
	      if (this.overlayScrollPositions.top.left !== tempScrollValue) {
	        this.overlayScrollPositions.top.left = tempScrollValue;
	        scrollValueChanged = true;
	        master.scrollLeft = tempScrollValue;
	      }
	      if (fakeScrollValue !== null) {
	        scrollValueChanged = true;
	        master.scrollTop += fakeScrollValue;
	      }
	    } else if (target === leftOverlay) {
	      tempScrollValue = getScrollTop(target);
	      if (this.overlayScrollPositions.left.top !== tempScrollValue) {
	        this.overlayScrollPositions.left.top = tempScrollValue;
	        scrollValueChanged = true;
	        master.scrollTop = tempScrollValue;
	      }
	      if (fakeScrollValue !== null) {
	        scrollValueChanged = true;
	        master.scrollLeft += fakeScrollValue;
	      }
	    }
	    if (!this.keyPressed && scrollValueChanged && event.type === 'scroll') {
	      this.refreshAll();
	    }
	  },
	  syncScrollWithMaster: function() {
	    var master = this.topOverlay.mainTableScrollableElement;
	    if (this.topOverlay.needFullRender) {
	      this.topOverlay.clone.wtTable.holder.scrollLeft = master.scrollLeft;
	    }
	    if (this.leftOverlay.needFullRender) {
	      this.leftOverlay.clone.wtTable.holder.scrollTop = master.scrollTop;
	    }
	  },
	  destroy: function() {
	    this.eventManager.destroy();
	    this.topOverlay.destroy();
	    if (this.bottomOverlay.clone) {
	      this.bottomOverlay.destroy();
	    }
	    this.leftOverlay.destroy();
	    if (this.topLeftCornerOverlay) {
	      this.topLeftCornerOverlay.destroy();
	    }
	    if (this.bottomLeftCornerOverlay && this.bottomLeftCornerOverlay.clone) {
	      this.bottomLeftCornerOverlay.destroy();
	    }
	    if (this.debug) {
	      this.debug.destroy();
	    }
	    this.destroyed = true;
	  },
	  refresh: function() {
	    var fastDraw = arguments[0] !== (void 0) ? arguments[0] : false;
	    if (this.topOverlay.areElementSizesAdjusted && this.leftOverlay.areElementSizesAdjusted) {
	      var container = this.wot.wtTable.wtRootElement.parentNode || this.wot.wtTable.wtRootElement;
	      var width = container.clientWidth;
	      var height = container.clientHeight;
	      if (width !== this.spreaderLastSize.width || height !== this.spreaderLastSize.height) {
	        this.spreaderLastSize.width = width;
	        this.spreaderLastSize.height = height;
	        this.adjustElementsSize();
	      }
	    }
	    if (this.bottomOverlay.clone) {
	      this.bottomOverlay.refresh(fastDraw);
	    }
	    this.leftOverlay.refresh(fastDraw);
	    this.topOverlay.refresh(fastDraw);
	    if (this.topLeftCornerOverlay) {
	      this.topLeftCornerOverlay.refresh(fastDraw);
	    }
	    if (this.bottomLeftCornerOverlay && this.bottomLeftCornerOverlay.clone) {
	      this.bottomLeftCornerOverlay.refresh(fastDraw);
	    }
	    if (this.debug) {
	      this.debug.refresh(fastDraw);
	    }
	  },
	  adjustElementsSize: function() {
	    var force = arguments[0] !== (void 0) ? arguments[0] : false;
	    var totalColumns = this.wot.getSetting('totalColumns');
	    var totalRows = this.wot.getSetting('totalRows');
	    var headerRowSize = this.wot.wtViewport.getRowHeaderWidth();
	    var headerColumnSize = this.wot.wtViewport.getColumnHeaderHeight();
	    var hiderStyle = this.wot.wtTable.hider.style;
	    hiderStyle.width = (headerRowSize + this.leftOverlay.sumCellSizes(0, totalColumns)) + 'px';
	    hiderStyle.height = (headerColumnSize + this.topOverlay.sumCellSizes(0, totalRows) + 1) + 'px';
	    this.topOverlay.adjustElementsSize(force);
	    this.leftOverlay.adjustElementsSize(force);
	    if (this.bottomOverlay.clone) {
	      this.bottomOverlay.adjustElementsSize(force);
	    }
	  },
	  applyToDOM: function() {
	    if (!this.topOverlay.areElementSizesAdjusted || !this.leftOverlay.areElementSizesAdjusted) {
	      this.adjustElementsSize();
	    }
	    this.topOverlay.applyToDOM();
	    if (this.bottomOverlay.clone) {
	      this.bottomOverlay.applyToDOM();
	    }
	    this.leftOverlay.applyToDOM();
	  }
	}, {});
	;
	window.WalkontableOverlays = WalkontableOverlays;

	//# 
	},{"eventManager":41,"helpers/dom/element":45,"helpers/unicode":53}],17:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  WalkontableScroll: {get: function() {
	      return WalkontableScroll;
	    }},
	  __esModule: {value: true}
	});
	var WalkontableScroll = function WalkontableScroll(wotInstance) {
	  this.wot = wotInstance;
	  this.instance = wotInstance;
	};
	($traceurRuntime.createClass)(WalkontableScroll, {scrollViewport: function(coords) {
	    if (!this.wot.drawn) {
	      return;
	    }
	    var totalRows = this.wot.getSetting('totalRows');
	    var totalColumns = this.wot.getSetting('totalColumns');
	    var fixedRowsTop = this.instance.getSetting('fixedRowsTop');
	    var fixedRowsBottom = this.instance.getSetting('fixedRowsBottom');
	    var fixedColumnsLeft = this.instance.getSetting('fixedColumnsLeft');
	    if (coords.row < 0 || coords.row > totalRows - 1) {
	      throw new Error('row ' + coords.row + ' does not exist');
	    }
	    if (coords.col < 0 || coords.col > totalColumns - 1) {
	      throw new Error('column ' + coords.col + ' does not exist');
	    }
	    if (coords.row > this.instance.wtTable.getLastVisibleRow() && coords.row < totalRows - fixedRowsBottom) {
	      this.wot.wtOverlays.topOverlay.scrollTo(coords.row, true);
	    } else if (coords.row >= fixedRowsTop && coords.row < this.instance.wtTable.getFirstVisibleRow()) {
	      this.wot.wtOverlays.topOverlay.scrollTo(coords.row);
	    }
	    if (coords.col > this.instance.wtTable.getLastVisibleColumn()) {
	      this.wot.wtOverlays.leftOverlay.scrollTo(coords.col, true);
	    } else if (coords.col >= fixedColumnsLeft && coords.col < this.instance.wtTable.getFirstVisibleColumn()) {
	      this.wot.wtOverlays.leftOverlay.scrollTo(coords.col);
	    }
	  }}, {});
	;
	window.WalkontableScroll = WalkontableScroll;

	//# 
	},{}],18:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  WalkontableSelection: {get: function() {
	      return WalkontableSelection;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__,
	    $__border__,
	    $__cell_47_coords__,
	    $__cell_47_range__;
	var addClass = ($___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ = require("helpers/dom/element"), $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ && $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__}).addClass;
	var WalkontableBorder = ($__border__ = require("border"), $__border__ && $__border__.__esModule && $__border__ || {default: $__border__}).WalkontableBorder;
	var WalkontableCellCoords = ($__cell_47_coords__ = require("cell/coords"), $__cell_47_coords__ && $__cell_47_coords__.__esModule && $__cell_47_coords__ || {default: $__cell_47_coords__}).WalkontableCellCoords;
	var WalkontableCellRange = ($__cell_47_range__ = require("cell/range"), $__cell_47_range__ && $__cell_47_range__.__esModule && $__cell_47_range__ || {default: $__cell_47_range__}).WalkontableCellRange;
	var WalkontableSelection = function WalkontableSelection(settings, cellRange) {
	  this.settings = settings;
	  this.cellRange = cellRange || null;
	  this.instanceBorders = {};
	};
	($traceurRuntime.createClass)(WalkontableSelection, {
	  getBorder: function(wotInstance) {
	    if (this.instanceBorders[wotInstance.guid]) {
	      return this.instanceBorders[wotInstance.guid];
	    }
	    this.instanceBorders[wotInstance.guid] = new WalkontableBorder(wotInstance, this.settings);
	  },
	  isEmpty: function() {
	    return this.cellRange === null;
	  },
	  add: function(coords) {
	    if (this.isEmpty()) {
	      this.cellRange = new WalkontableCellRange(coords, coords, coords);
	    } else {
	      this.cellRange.expand(coords);
	    }
	  },
	  replace: function(oldCoords, newCoords) {
	    if (!this.isEmpty()) {
	      if (this.cellRange.from.isEqual(oldCoords)) {
	        this.cellRange.from = newCoords;
	        return true;
	      }
	      if (this.cellRange.to.isEqual(oldCoords)) {
	        this.cellRange.to = newCoords;
	        return true;
	      }
	    }
	    return false;
	  },
	  clear: function() {
	    this.cellRange = null;
	  },
	  getCorners: function() {
	    var topLeft = this.cellRange.getTopLeftCorner();
	    var bottomRight = this.cellRange.getBottomRightCorner();
	    return [topLeft.row, topLeft.col, bottomRight.row, bottomRight.col];
	  },
	  addClassAtCoords: function(wotInstance, sourceRow, sourceColumn, className) {
	    var TD = wotInstance.wtTable.getCell(new WalkontableCellCoords(sourceRow, sourceColumn));
	    if (typeof TD === 'object') {
	      addClass(TD, className);
	    }
	  },
	  draw: function(wotInstance) {
	    if (this.isEmpty()) {
	      if (this.settings.border) {
	        var border = this.getBorder(wotInstance);
	        if (border) {
	          border.disappear();
	        }
	      }
	      return;
	    }
	    var renderedRows = wotInstance.wtTable.getRenderedRowsCount();
	    var renderedColumns = wotInstance.wtTable.getRenderedColumnsCount();
	    var corners = this.getCorners();
	    var sourceRow,
	        sourceCol,
	        TH;
	    for (var column = 0; column < renderedColumns; column++) {
	      sourceCol = wotInstance.wtTable.columnFilter.renderedToSource(column);
	      if (sourceCol >= corners[1] && sourceCol <= corners[3]) {
	        TH = wotInstance.wtTable.getColumnHeader(sourceCol);
	        if (TH && this.settings.highlightColumnClassName) {
	          addClass(TH, this.settings.highlightColumnClassName);
	        }
	      }
	    }
	    for (var row = 0; row < renderedRows; row++) {
	      sourceRow = wotInstance.wtTable.rowFilter.renderedToSource(row);
	      if (sourceRow >= corners[0] && sourceRow <= corners[2]) {
	        TH = wotInstance.wtTable.getRowHeader(sourceRow);
	        if (TH && this.settings.highlightRowClassName) {
	          addClass(TH, this.settings.highlightRowClassName);
	        }
	      }
	      for (var column$__5 = 0; column$__5 < renderedColumns; column$__5++) {
	        sourceCol = wotInstance.wtTable.columnFilter.renderedToSource(column$__5);
	        if (sourceRow >= corners[0] && sourceRow <= corners[2] && sourceCol >= corners[1] && sourceCol <= corners[3]) {
	          if (this.settings.className) {
	            this.addClassAtCoords(wotInstance, sourceRow, sourceCol, this.settings.className);
	          }
	        } else if (sourceRow >= corners[0] && sourceRow <= corners[2]) {
	          if (this.settings.highlightRowClassName) {
	            this.addClassAtCoords(wotInstance, sourceRow, sourceCol, this.settings.highlightRowClassName);
	          }
	        } else if (sourceCol >= corners[1] && sourceCol <= corners[3]) {
	          if (this.settings.highlightColumnClassName) {
	            this.addClassAtCoords(wotInstance, sourceRow, sourceCol, this.settings.highlightColumnClassName);
	          }
	        }
	      }
	    }
	    wotInstance.getSetting('onBeforeDrawBorders', corners, this.settings.className);
	    if (this.settings.border) {
	      var border$__6 = this.getBorder(wotInstance);
	      if (border$__6) {
	        border$__6.appear(corners);
	      }
	    }
	  }
	}, {});
	;
	window.WalkontableSelection = WalkontableSelection;

	//# 
	},{"border":2,"cell/coords":5,"cell/range":6,"helpers/dom/element":45}],19:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  WalkontableSettings: {get: function() {
	      return WalkontableSettings;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__;
	var fastInnerText = ($___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ = require("helpers/dom/element"), $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ && $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__}).fastInnerText;
	var WalkontableSettings = function WalkontableSettings(wotInstance, settings) {
	  var $__1 = this;
	  this.wot = wotInstance;
	  this.instance = wotInstance;
	  this.defaults = {
	    table: void 0,
	    debug: false,
	    externalRowCalculator: false,
	    stretchH: 'none',
	    currentRowClassName: null,
	    currentColumnClassName: null,
	    data: void 0,
	    fixedColumnsLeft: 0,
	    fixedRowsTop: 0,
	    fixedRowsBottom: 0,
	    minSpareRows: 0,
	    rowHeaders: function() {
	      return [];
	    },
	    columnHeaders: function() {
	      return [];
	    },
	    totalRows: void 0,
	    totalColumns: void 0,
	    cellRenderer: (function(row, column, TD) {
	      var cellData = $__1.getSetting('data', row, column);
	      fastInnerText(TD, cellData === void 0 || cellData === null ? '' : cellData);
	    }),
	    columnWidth: function(col) {
	      return;
	    },
	    rowHeight: function(row) {
	      return;
	    },
	    defaultRowHeight: 23,
	    defaultColumnWidth: 50,
	    selections: null,
	    hideBorderOnMouseDownOver: false,
	    viewportRowCalculatorOverride: null,
	    viewportColumnCalculatorOverride: null,
	    onCellMouseDown: null,
	    onCellMouseOver: null,
	    onCellDblClick: null,
	    onCellCornerMouseDown: null,
	    onCellCornerDblClick: null,
	    beforeDraw: null,
	    onDraw: null,
	    onBeforeDrawBorders: null,
	    onScrollVertically: null,
	    onScrollHorizontally: null,
	    onBeforeTouchScroll: null,
	    onAfterMomentumScroll: null,
	    scrollbarWidth: 10,
	    scrollbarHeight: 10,
	    renderAllRows: false,
	    groups: false
	  };
	  this.settings = {};
	  for (var i in this.defaults) {
	    if (this.defaults.hasOwnProperty(i)) {
	      if (settings[i] !== void 0) {
	        this.settings[i] = settings[i];
	      } else if (this.defaults[i] === void 0) {
	        throw new Error('A required setting "' + i + '" was not provided');
	      } else {
	        this.settings[i] = this.defaults[i];
	      }
	    }
	  }
	};
	($traceurRuntime.createClass)(WalkontableSettings, {
	  update: function(settings, value) {
	    if (value === void 0) {
	      for (var i in settings) {
	        if (settings.hasOwnProperty(i)) {
	          this.settings[i] = settings[i];
	        }
	      }
	    } else {
	      this.settings[settings] = value;
	    }
	    return this.wot;
	  },
	  getSetting: function(key, param1, param2, param3, param4) {
	    if (typeof this.settings[key] === 'function') {
	      return this.settings[key](param1, param2, param3, param4);
	    } else if (param1 !== void 0 && Array.isArray(this.settings[key])) {
	      return this.settings[key][param1];
	    } else {
	      return this.settings[key];
	    }
	  },
	  has: function(key) {
	    return !!this.settings[key];
	  }
	}, {});
	;
	window.WalkontableSettings = WalkontableSettings;

	//# 
	},{"helpers/dom/element":45}],20:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  WalkontableTable: {get: function() {
	      return WalkontableTable;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__,
	    $__cell_47_coords__,
	    $__cell_47_range__,
	    $__filter_47_column__,
	    $__filter_47_row__,
	    $__tableRenderer__;
	var $__0 = ($___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ = require("helpers/dom/element"), $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ && $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__}),
	    getStyle = $__0.getStyle,
	    getTrimmingContainer = $__0.getTrimmingContainer,
	    hasClass = $__0.hasClass,
	    index = $__0.index,
	    offset = $__0.offset,
	    removeClass = $__0.removeClass,
	    removeTextNodes = $__0.removeTextNodes,
	    overlayContainsElement = $__0.overlayContainsElement;
	var WalkontableCellCoords = ($__cell_47_coords__ = require("cell/coords"), $__cell_47_coords__ && $__cell_47_coords__.__esModule && $__cell_47_coords__ || {default: $__cell_47_coords__}).WalkontableCellCoords;
	var WalkontableCellRange = ($__cell_47_range__ = require("cell/range"), $__cell_47_range__ && $__cell_47_range__.__esModule && $__cell_47_range__ || {default: $__cell_47_range__}).WalkontableCellRange;
	var WalkontableColumnFilter = ($__filter_47_column__ = require("filter/column"), $__filter_47_column__ && $__filter_47_column__.__esModule && $__filter_47_column__ || {default: $__filter_47_column__}).WalkontableColumnFilter;
	var WalkontableRowFilter = ($__filter_47_row__ = require("filter/row"), $__filter_47_row__ && $__filter_47_row__.__esModule && $__filter_47_row__ || {default: $__filter_47_row__}).WalkontableRowFilter;
	var WalkontableTableRenderer = ($__tableRenderer__ = require("tableRenderer"), $__tableRenderer__ && $__tableRenderer__.__esModule && $__tableRenderer__ || {default: $__tableRenderer__}).WalkontableTableRenderer;
	var WalkontableTable = function WalkontableTable(wotInstance, table) {
	  this.wot = wotInstance;
	  this.instance = this.wot;
	  this.TABLE = table;
	  this.TBODY = null;
	  this.THEAD = null;
	  this.COLGROUP = null;
	  this.tableOffset = 0;
	  this.holderOffset = 0;
	  removeTextNodes(this.TABLE);
	  this.spreader = this.createSpreader(this.TABLE);
	  this.hider = this.createHider(this.spreader);
	  this.holder = this.createHolder(this.hider);
	  this.wtRootElement = this.holder.parentNode;
	  this.alignOverlaysWithTrimmingContainer();
	  this.fixTableDomTree();
	  this.colgroupChildrenLength = this.COLGROUP.childNodes.length;
	  this.theadChildrenLength = this.THEAD.firstChild ? this.THEAD.firstChild.childNodes.length : 0;
	  this.tbodyChildrenLength = this.TBODY.childNodes.length;
	  this.rowFilter = null;
	  this.columnFilter = null;
	};
	($traceurRuntime.createClass)(WalkontableTable, {
	  fixTableDomTree: function() {
	    this.TBODY = this.TABLE.querySelector('tbody');
	    if (!this.TBODY) {
	      this.TBODY = document.createElement('tbody');
	      this.TABLE.appendChild(this.TBODY);
	    }
	    this.THEAD = this.TABLE.querySelector('thead');
	    if (!this.THEAD) {
	      this.THEAD = document.createElement('thead');
	      this.TABLE.insertBefore(this.THEAD, this.TBODY);
	    }
	    this.COLGROUP = this.TABLE.querySelector('colgroup');
	    if (!this.COLGROUP) {
	      this.COLGROUP = document.createElement('colgroup');
	      this.TABLE.insertBefore(this.COLGROUP, this.THEAD);
	    }
	    if (this.wot.getSetting('columnHeaders').length && !this.THEAD.childNodes.length) {
	      this.THEAD.appendChild(document.createElement('TR'));
	    }
	  },
	  createSpreader: function(table) {
	    var parent = table.parentNode;
	    var spreader;
	    if (!parent || parent.nodeType !== 1 || !hasClass(parent, 'wtHolder')) {
	      spreader = document.createElement('div');
	      spreader.className = 'wtSpreader';
	      if (parent) {
	        parent.insertBefore(spreader, table);
	      }
	      spreader.appendChild(table);
	    }
	    spreader.style.position = 'relative';
	    return spreader;
	  },
	  createHider: function(spreader) {
	    var parent = spreader.parentNode;
	    var hider;
	    if (!parent || parent.nodeType !== 1 || !hasClass(parent, 'wtHolder')) {
	      hider = document.createElement('div');
	      hider.className = 'wtHider';
	      if (parent) {
	        parent.insertBefore(hider, spreader);
	      }
	      hider.appendChild(spreader);
	    }
	    return hider;
	  },
	  createHolder: function(hider) {
	    var parent = hider.parentNode;
	    var holder;
	    if (!parent || parent.nodeType !== 1 || !hasClass(parent, 'wtHolder')) {
	      holder = document.createElement('div');
	      holder.style.position = 'relative';
	      holder.className = 'wtHolder';
	      if (parent) {
	        parent.insertBefore(holder, hider);
	      }
	      if (!this.isWorkingOnClone()) {
	        holder.parentNode.className += 'ht_master handsontable';
	      }
	      holder.appendChild(hider);
	    }
	    return holder;
	  },
	  alignOverlaysWithTrimmingContainer: function() {
	    var trimmingElement = getTrimmingContainer(this.wtRootElement);
	    if (!this.isWorkingOnClone()) {
	      this.holder.parentNode.style.position = 'relative';
	      if (trimmingElement === window) {
	        this.holder.style.overflow = 'visible';
	        this.wtRootElement.style.overflow = 'visible';
	      } else {
	        this.holder.style.width = getStyle(trimmingElement, 'width');
	        this.holder.style.height = getStyle(trimmingElement, 'height');
	        this.holder.style.overflow = '';
	      }
	    }
	  },
	  isWorkingOnClone: function() {
	    return !!this.wot.cloneSource;
	  },
	  draw: function(fastDraw) {
	    var totalRows = this.instance.getSetting('totalRows');
	    if (!this.isWorkingOnClone()) {
	      this.holderOffset = offset(this.holder);
	      fastDraw = this.wot.wtViewport.createRenderCalculators(fastDraw);
	    }
	    if (fastDraw) {
	      if (!this.isWorkingOnClone()) {
	        this.wot.wtViewport.createVisibleCalculators();
	      }
	      if (this.wot.wtOverlays) {
	        this.wot.wtOverlays.refresh(true);
	      }
	    } else {
	      if (this.isWorkingOnClone()) {
	        this.tableOffset = this.wot.cloneSource.wtTable.tableOffset;
	      } else {
	        this.tableOffset = offset(this.TABLE);
	      }
	      var startRow;
	      if (WalkontableOverlay.isOverlayTypeOf(this.wot.cloneOverlay, WalkontableOverlay.CLONE_DEBUG) || WalkontableOverlay.isOverlayTypeOf(this.wot.cloneOverlay, WalkontableOverlay.CLONE_TOP) || WalkontableOverlay.isOverlayTypeOf(this.wot.cloneOverlay, WalkontableOverlay.CLONE_TOP_LEFT_CORNER)) {
	        startRow = 0;
	      } else if (WalkontableOverlay.isOverlayTypeOf(this.instance.cloneOverlay, WalkontableOverlay.CLONE_BOTTOM) || WalkontableOverlay.isOverlayTypeOf(this.instance.cloneOverlay, WalkontableOverlay.CLONE_BOTTOM_LEFT_CORNER)) {
	        startRow = totalRows - this.wot.getSetting('fixedRowsBottom');
	      } else {
	        startRow = this.wot.wtViewport.rowsRenderCalculator.startRow;
	      }
	      var startColumn;
	      if (WalkontableOverlay.isOverlayTypeOf(this.wot.cloneOverlay, WalkontableOverlay.CLONE_DEBUG) || WalkontableOverlay.isOverlayTypeOf(this.wot.cloneOverlay, WalkontableOverlay.CLONE_LEFT) || WalkontableOverlay.isOverlayTypeOf(this.wot.cloneOverlay, WalkontableOverlay.CLONE_TOP_LEFT_CORNER) || WalkontableOverlay.isOverlayTypeOf(this.wot.cloneOverlay, WalkontableOverlay.CLONE_BOTTOM_LEFT_CORNER)) {
	        startColumn = 0;
	      } else {
	        startColumn = this.wot.wtViewport.columnsRenderCalculator.startColumn;
	      }
	      this.rowFilter = new WalkontableRowFilter(startRow, totalRows, this.wot.getSetting('columnHeaders').length);
	      this.columnFilter = new WalkontableColumnFilter(startColumn, this.wot.getSetting('totalColumns'), this.wot.getSetting('rowHeaders').length);
	      this._doDraw();
	      this.alignOverlaysWithTrimmingContainer();
	    }
	    this.refreshSelections(fastDraw);
	    if (!this.isWorkingOnClone()) {
	      this.wot.wtOverlays.topOverlay.resetFixedPosition();
	      if (this.wot.wtOverlays.bottomOverlay.clone) {
	        this.wot.wtOverlays.bottomOverlay.resetFixedPosition();
	      }
	      this.wot.wtOverlays.leftOverlay.resetFixedPosition();
	      if (this.wot.wtOverlays.topLeftCornerOverlay) {
	        this.wot.wtOverlays.topLeftCornerOverlay.resetFixedPosition();
	      }
	      if (this.instance.wtOverlays.bottomLeftCornerOverlay && this.instance.wtOverlays.bottomLeftCornerOverlay.clone) {
	        this.wot.wtOverlays.bottomLeftCornerOverlay.resetFixedPosition();
	      }
	    }
	    this.wot.drawn = true;
	    return this;
	  },
	  _doDraw: function() {
	    var wtRenderer = new WalkontableTableRenderer(this);
	    wtRenderer.render();
	  },
	  removeClassFromCells: function(className) {
	    var nodes = this.TABLE.querySelectorAll('.' + className);
	    for (var i = 0,
	        len = nodes.length; i < len; i++) {
	      removeClass(nodes[i], className);
	    }
	  },
	  refreshSelections: function(fastDraw) {
	    if (!this.wot.selections) {
	      return;
	    }
	    var len = this.wot.selections.length;
	    if (fastDraw) {
	      for (var i = 0; i < len; i++) {
	        if (this.wot.selections[i].settings.className) {
	          this.removeClassFromCells(this.wot.selections[i].settings.className);
	        }
	        if (this.wot.selections[i].settings.highlightRowClassName) {
	          this.removeClassFromCells(this.wot.selections[i].settings.highlightRowClassName);
	        }
	        if (this.wot.selections[i].settings.highlightColumnClassName) {
	          this.removeClassFromCells(this.wot.selections[i].settings.highlightColumnClassName);
	        }
	      }
	    }
	    for (var i$__7 = 0; i$__7 < len; i$__7++) {
	      this.wot.selections[i$__7].draw(this.wot, fastDraw);
	    }
	  },
	  getCell: function(coords) {
	    if (this.isRowBeforeRenderedRows(coords.row)) {
	      return -1;
	    } else if (this.isRowAfterRenderedRows(coords.row)) {
	      return -2;
	    }
	    var TR = this.TBODY.childNodes[this.rowFilter.sourceToRendered(coords.row)];
	    if (TR) {
	      return TR.childNodes[this.columnFilter.sourceColumnToVisibleRowHeadedColumn(coords.col)];
	    }
	  },
	  getColumnHeader: function(col) {
	    var level = arguments[1] !== (void 0) ? arguments[1] : 0;
	    var TR = this.THEAD.childNodes[level];
	    if (TR) {
	      return TR.childNodes[this.columnFilter.sourceColumnToVisibleRowHeadedColumn(col)];
	    }
	  },
	  getRowHeader: function(row) {
	    if (this.columnFilter.sourceColumnToVisibleRowHeadedColumn(0) === 0) {
	      return null;
	    }
	    var TR = this.TBODY.childNodes[this.rowFilter.sourceToRendered(row)];
	    if (TR) {
	      return TR.childNodes[0];
	    }
	  },
	  getCoords: function(TD) {
	    var TR = TD.parentNode;
	    var row = index(TR);
	    if (TR.parentNode === this.THEAD) {
	      row = this.rowFilter.visibleColHeadedRowToSourceRow(row);
	    } else {
	      row = this.rowFilter.renderedToSource(row);
	    }
	    var col = this.columnFilter.visibleRowHeadedColumnToSourceColumn(TD.cellIndex);
	    return new WalkontableCellCoords(row, col);
	  },
	  getTrForRow: function(row) {
	    return this.TBODY.childNodes[this.rowFilter.sourceToRendered(row)];
	  },
	  getFirstRenderedRow: function() {
	    return this.wot.wtViewport.rowsRenderCalculator.startRow;
	  },
	  getFirstVisibleRow: function() {
	    return this.wot.wtViewport.rowsVisibleCalculator.startRow;
	  },
	  getFirstRenderedColumn: function() {
	    return this.wot.wtViewport.columnsRenderCalculator.startColumn;
	  },
	  getFirstVisibleColumn: function() {
	    return this.wot.wtViewport.columnsVisibleCalculator.startColumn;
	  },
	  getLastRenderedRow: function() {
	    return this.wot.wtViewport.rowsRenderCalculator.endRow;
	  },
	  getLastVisibleRow: function() {
	    return this.wot.wtViewport.rowsVisibleCalculator.endRow;
	  },
	  getLastRenderedColumn: function() {
	    return this.wot.wtViewport.columnsRenderCalculator.endColumn;
	  },
	  getLastVisibleColumn: function() {
	    return this.wot.wtViewport.columnsVisibleCalculator.endColumn;
	  },
	  isRowBeforeRenderedRows: function(row) {
	    return (this.rowFilter.sourceToRendered(row) < 0 && row >= 0);
	  },
	  isRowAfterViewport: function(row) {
	    return (this.rowFilter.sourceToRendered(row) > this.getLastVisibleRow());
	  },
	  isRowAfterRenderedRows: function(row) {
	    return (this.rowFilter.sourceToRendered(row) > this.getLastRenderedRow());
	  },
	  isColumnBeforeViewport: function(column) {
	    return this.columnFilter.sourceToRendered(column) < 0 && column >= 0;
	  },
	  isColumnAfterViewport: function(column) {
	    return (this.columnFilter.sourceToRendered(column) > this.getLastVisibleColumn());
	  },
	  isLastRowFullyVisible: function() {
	    return this.getLastVisibleRow() === this.getLastRenderedRow();
	  },
	  isLastColumnFullyVisible: function() {
	    return this.getLastVisibleColumn() === this.getLastRenderedColumn();
	  },
	  getRenderedColumnsCount: function() {
	    if (WalkontableOverlay.isOverlayTypeOf(this.wot.cloneOverlay, WalkontableOverlay.CLONE_DEBUG)) {
	      return this.wot.getSetting('totalColumns');
	    } else if (WalkontableOverlay.isOverlayTypeOf(this.wot.cloneOverlay, WalkontableOverlay.CLONE_LEFT) || WalkontableOverlay.isOverlayTypeOf(this.wot.cloneOverlay, WalkontableOverlay.CLONE_TOP_LEFT_CORNER) || WalkontableOverlay.isOverlayTypeOf(this.wot.cloneOverlay, WalkontableOverlay.CLONE_BOTTOM_LEFT_CORNER)) {
	      return this.wot.getSetting('fixedColumnsLeft');
	    } else {
	      return this.wot.wtViewport.columnsRenderCalculator.count;
	    }
	  },
	  getRenderedRowsCount: function() {
	    if (WalkontableOverlay.isOverlayTypeOf(this.wot.cloneOverlay, WalkontableOverlay.CLONE_DEBUG)) {
	      return this.wot.getSetting('totalRows');
	    } else if (WalkontableOverlay.isOverlayTypeOf(this.wot.cloneOverlay, WalkontableOverlay.CLONE_TOP) || WalkontableOverlay.isOverlayTypeOf(this.wot.cloneOverlay, WalkontableOverlay.CLONE_TOP_LEFT_CORNER)) {
	      return this.wot.getSetting('fixedRowsTop');
	    } else if (WalkontableOverlay.isOverlayTypeOf(this.wot.cloneOverlay, WalkontableOverlay.CLONE_BOTTOM) || WalkontableOverlay.isOverlayTypeOf(this.wot.cloneOverlay, WalkontableOverlay.CLONE_BOTTOM_LEFT_CORNER)) {
	      return this.instance.getSetting('fixedRowsBottom');
	    }
	    return this.wot.wtViewport.rowsRenderCalculator.count;
	  },
	  getVisibleRowsCount: function() {
	    return this.wot.wtViewport.rowsVisibleCalculator.count;
	  },
	  allRowsInViewport: function() {
	    return this.wot.getSetting('totalRows') == this.getVisibleRowsCount();
	  },
	  getRowHeight: function(sourceRow) {
	    var height = this.wot.wtSettings.settings.rowHeight(sourceRow);
	    var oversizedHeight = this.wot.wtViewport.oversizedRows[sourceRow];
	    if (oversizedHeight !== void 0) {
	      height = height === void 0 ? oversizedHeight : Math.max(height, oversizedHeight);
	    }
	    return height;
	  },
	  getColumnHeaderHeight: function(level) {
	    var height = this.wot.wtSettings.settings.defaultRowHeight;
	    var oversizedHeight = this.wot.wtViewport.oversizedColumnHeaders[level];
	    if (oversizedHeight !== void 0) {
	      height = height ? Math.max(height, oversizedHeight) : oversizedHeight;
	    }
	    return height;
	  },
	  getVisibleColumnsCount: function() {
	    return this.wot.wtViewport.columnsVisibleCalculator.count;
	  },
	  allColumnsInViewport: function() {
	    return this.wot.getSetting('totalColumns') == this.getVisibleColumnsCount();
	  },
	  getColumnWidth: function(sourceColumn) {
	    var width = this.wot.wtSettings.settings.columnWidth;
	    if (typeof width === 'function') {
	      width = width(sourceColumn);
	    } else if (typeof width === 'object') {
	      width = width[sourceColumn];
	    }
	    return width || this.wot.wtSettings.settings.defaultColumnWidth;
	  },
	  getStretchedColumnWidth: function(sourceColumn) {
	    var columnWidth = this.getColumnWidth(sourceColumn);
	    var width = [void 0, null].indexOf(columnWidth) === -1 ? columnWidth : this.instance.wtSettings.settings.defaultColumnWidth;
	    var calculator = this.wot.wtViewport.columnsRenderCalculator;
	    if (calculator) {
	      var stretchedWidth = calculator.getStretchedColumnWidth(sourceColumn, width);
	      if (stretchedWidth) {
	        width = stretchedWidth;
	      }
	    }
	    return width;
	  }
	}, {});
	;
	window.WalkontableTable = WalkontableTable;

	//# 
	},{"cell/coords":5,"cell/range":6,"filter/column":9,"filter/row":10,"helpers/dom/element":45,"tableRenderer":21}],21:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  WalkontableTableRenderer: {get: function() {
	      return WalkontableTableRenderer;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__;
	var $__0 = ($___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ = require("helpers/dom/element"), $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ && $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__}),
	    addClass = $__0.addClass,
	    empty = $__0.empty,
	    getScrollbarWidth = $__0.getScrollbarWidth,
	    hasClass = $__0.hasClass,
	    innerHeight = $__0.innerHeight;
	var WalkontableTableRenderer = function WalkontableTableRenderer(wtTable) {
	  this.wtTable = wtTable;
	  this.wot = wtTable.instance;
	  this.instance = wtTable.instance;
	  this.rowFilter = wtTable.rowFilter;
	  this.columnFilter = wtTable.columnFilter;
	  this.TABLE = wtTable.TABLE;
	  this.THEAD = wtTable.THEAD;
	  this.TBODY = wtTable.TBODY;
	  this.COLGROUP = wtTable.COLGROUP;
	  this.rowHeaders = [];
	  this.rowHeaderCount = 0;
	  this.columnHeaders = [];
	  this.columnHeaderCount = 0;
	  this.fixedRowsTop = 0;
	  this.fixedRowsBottom = 0;
	};
	($traceurRuntime.createClass)(WalkontableTableRenderer, {
	  render: function() {
	    if (!this.wtTable.isWorkingOnClone()) {
	      this.wot.getSetting('beforeDraw', true);
	    }
	    this.rowHeaders = this.wot.getSetting('rowHeaders');
	    this.rowHeaderCount = this.rowHeaders.length;
	    this.fixedRowsTop = this.wot.getSetting('fixedRowsTop');
	    this.fixedRowsBottom = this.wot.getSetting('fixedRowsBottom');
	    this.columnHeaders = this.wot.getSetting('columnHeaders');
	    this.columnHeaderCount = this.columnHeaders.length;
	    var columnsToRender = this.wtTable.getRenderedColumnsCount();
	    var rowsToRender = this.wtTable.getRenderedRowsCount();
	    var totalColumns = this.wot.getSetting('totalColumns');
	    var totalRows = this.wot.getSetting('totalRows');
	    var workspaceWidth;
	    var adjusted = false;
	    if (WalkontableOverlay.isOverlayTypeOf(this.wot.cloneOverlay, WalkontableOverlay.CLONE_BOTTOM) || WalkontableOverlay.isOverlayTypeOf(this.wot.cloneOverlay, WalkontableOverlay.CLONE_BOTTOM_LEFT_CORNER)) {
	      this.columnHeaders = [];
	      this.columnHeaderCount = 0;
	    }
	    if (totalColumns > 0) {
	      this.adjustAvailableNodes();
	      adjusted = true;
	      this.renderColumnHeaders();
	      this.renderRows(totalRows, rowsToRender, columnsToRender);
	      if (!this.wtTable.isWorkingOnClone()) {
	        workspaceWidth = this.wot.wtViewport.getWorkspaceWidth();
	        this.wot.wtViewport.containerWidth = null;
	      }
	      this.adjustColumnHeaderHeights();
	      this.adjustColumnWidths(columnsToRender);
	      this.markOversizedColumns();
	    }
	    if (!adjusted) {
	      this.adjustAvailableNodes();
	    }
	    this.removeRedundantRows(rowsToRender);
	    if (!this.wtTable.isWorkingOnClone()) {
	      this.markOversizedRows();
	      this.wot.wtViewport.createVisibleCalculators();
	      this.wot.wtOverlays.refresh(false);
	      this.wot.wtOverlays.applyToDOM();
	      if (workspaceWidth !== this.wot.wtViewport.getWorkspaceWidth()) {
	        this.wot.wtViewport.containerWidth = null;
	        var firstRendered = this.wtTable.getFirstRenderedColumn();
	        var lastRendered = this.wtTable.getLastRenderedColumn();
	        for (var i = firstRendered; i < lastRendered; i++) {
	          var width = this.wtTable.getStretchedColumnWidth(i);
	          var renderedIndex = this.columnFilter.sourceToRendered(i);
	          this.COLGROUP.childNodes[renderedIndex + this.rowHeaderCount].style.width = width + 'px';
	        }
	      }
	      this.wot.getSetting('onDraw', true);
	    } else if (WalkontableOverlay.isOverlayTypeOf(this.wot.cloneOverlay, WalkontableOverlay.CLONE_BOTTOM)) {
	      var masterOverlay = this.wot.cloneOverlay.instance;
	      this.wot.cloneOverlay.markOversizedFixedBottomRows();
	      masterOverlay.wtOverlays.adjustElementsSize();
	    }
	  },
	  removeRedundantRows: function(renderedRowsCount) {
	    while (this.wtTable.tbodyChildrenLength > renderedRowsCount) {
	      this.TBODY.removeChild(this.TBODY.lastChild);
	      this.wtTable.tbodyChildrenLength--;
	    }
	  },
	  renderRows: function(totalRows, rowsToRender, columnsToRender) {
	    var lastTD,
	        TR;
	    var visibleRowIndex = 0;
	    var sourceRowIndex = this.rowFilter.renderedToSource(visibleRowIndex);
	    var isWorkingOnClone = this.wtTable.isWorkingOnClone();
	    while (sourceRowIndex < totalRows && sourceRowIndex >= 0) {
	      if (visibleRowIndex > 1000) {
	        console.error('Security brake: Too much TRs. Please define height for your table, which will enforce scrollbars.');
	      }
	      if (rowsToRender !== void 0 && visibleRowIndex === rowsToRender) {
	        break;
	      }
	      TR = this.getOrCreateTrForRow(visibleRowIndex, TR);
	      this.renderRowHeaders(sourceRowIndex, TR);
	      this.adjustColumns(TR, columnsToRender + this.rowHeaderCount);
	      lastTD = this.renderCells(sourceRowIndex, TR, columnsToRender);
	      if (!isWorkingOnClone || WalkontableOverlay.isOverlayTypeOf(this.wot.cloneOverlay, WalkontableOverlay.CLONE_BOTTOM)) {
	        this.resetOversizedRow(sourceRowIndex);
	      }
	      if (TR.firstChild) {
	        var height = this.wot.wtTable.getRowHeight(sourceRowIndex);
	        if (height) {
	          height--;
	          TR.firstChild.style.height = height + 'px';
	        } else {
	          TR.firstChild.style.height = '';
	        }
	      }
	      visibleRowIndex++;
	      sourceRowIndex = this.rowFilter.renderedToSource(visibleRowIndex);
	    }
	  },
	  resetOversizedRow: function(sourceRow) {
	    if (this.wot.getSetting('externalRowCalculator')) {
	      return;
	    }
	    if (this.wot.wtViewport.oversizedRows && this.wot.wtViewport.oversizedRows[sourceRow]) {
	      this.wot.wtViewport.oversizedRows[sourceRow] = void 0;
	    }
	  },
	  markOversizedRows: function() {
	    if (this.wot.getSetting('externalRowCalculator')) {
	      return;
	    }
	    var rowCount = this.instance.wtTable.TBODY.childNodes.length;
	    var expectedTableHeight = rowCount * this.instance.wtSettings.settings.defaultRowHeight;
	    var actualTableHeight = innerHeight(this.instance.wtTable.TBODY) - 1;
	    var previousRowHeight;
	    var rowInnerHeight;
	    var sourceRowIndex;
	    var currentTr;
	    var rowHeader;
	    var totalRows = this.instance.getSetting('totalRows');
	    if (expectedTableHeight === actualTableHeight && !this.instance.getSetting('fixedRowsBottom')) {
	      return;
	    }
	    while (rowCount) {
	      rowCount--;
	      sourceRowIndex = this.instance.wtTable.rowFilter.renderedToSource(rowCount);
	      previousRowHeight = this.instance.wtTable.getRowHeight(sourceRowIndex);
	      currentTr = this.instance.wtTable.getTrForRow(sourceRowIndex);
	      rowHeader = currentTr.querySelector('th');
	      if (rowHeader) {
	        rowInnerHeight = innerHeight(rowHeader);
	      } else {
	        rowInnerHeight = innerHeight(currentTr) - 1;
	      }
	      if ((!previousRowHeight && this.instance.wtSettings.settings.defaultRowHeight < rowInnerHeight || previousRowHeight < rowInnerHeight)) {
	        this.instance.wtViewport.oversizedRows[sourceRowIndex] = ++rowInnerHeight;
	      }
	    }
	  },
	  markOversizedColumns: function() {
	    var overlayName = this.wot.getOverlayName();
	    if (!this.columnHeaderCount || this.wot.wtViewport.isMarkedOversizedColumn[overlayName] || this.wtTable.isWorkingOnClone()) {
	      return;
	    }
	    var columnCount = this.wtTable.getRenderedColumnsCount();
	    for (var i = 0; i < this.columnHeaderCount; i++) {
	      for (var renderedColumnIndex = (-1) * this.rowHeaderCount; renderedColumnIndex < columnCount; renderedColumnIndex++) {
	        this.markIfOversizedColumnHeader(renderedColumnIndex);
	      }
	    }
	    this.wot.wtViewport.isMarkedOversizedColumn[overlayName] = true;
	  },
	  adjustColumnHeaderHeights: function() {
	    var columnHeaders = this.wot.getSetting('columnHeaders');
	    var childs = this.wot.wtTable.THEAD.childNodes;
	    var oversizedCols = this.wot.wtViewport.oversizedColumnHeaders;
	    for (var i = 0,
	        len = columnHeaders.length; i < len; i++) {
	      if (oversizedCols[i]) {
	        if (childs[i].childNodes.length === 0) {
	          return;
	        }
	        childs[i].childNodes[0].style.height = oversizedCols[i] + 'px';
	      }
	    }
	  },
	  markIfOversizedColumnHeader: function(col) {
	    var sourceColIndex = this.wot.wtTable.columnFilter.renderedToSource(col);
	    var level = this.columnHeaderCount;
	    var defaultRowHeight = this.wot.wtSettings.settings.defaultRowHeight;
	    var previousColHeaderHeight;
	    var currentHeader;
	    var currentHeaderHeight;
	    while (level) {
	      level--;
	      previousColHeaderHeight = this.wot.wtTable.getColumnHeaderHeight(level);
	      currentHeader = this.wot.wtTable.getColumnHeader(sourceColIndex, level);
	      if (!currentHeader) {
	        continue;
	      }
	      currentHeaderHeight = innerHeight(currentHeader);
	      if (!previousColHeaderHeight && defaultRowHeight < currentHeaderHeight || previousColHeaderHeight < currentHeaderHeight) {
	        this.wot.wtViewport.oversizedColumnHeaders[level] = currentHeaderHeight;
	      }
	    }
	  },
	  renderCells: function(sourceRowIndex, TR, columnsToRender) {
	    var TD;
	    var sourceColIndex;
	    for (var visibleColIndex = 0; visibleColIndex < columnsToRender; visibleColIndex++) {
	      sourceColIndex = this.columnFilter.renderedToSource(visibleColIndex);
	      if (visibleColIndex === 0) {
	        TD = TR.childNodes[this.columnFilter.sourceColumnToVisibleRowHeadedColumn(sourceColIndex)];
	      } else {
	        TD = TD.nextSibling;
	      }
	      if (TD.nodeName == 'TH') {
	        TD = replaceThWithTd(TD, TR);
	      }
	      if (!hasClass(TD, 'hide')) {
	        TD.className = '';
	      }
	      TD.removeAttribute('style');
	      this.wot.wtSettings.settings.cellRenderer(sourceRowIndex, sourceColIndex, TD);
	    }
	    return TD;
	  },
	  adjustColumnWidths: function(columnsToRender) {
	    var scrollbarCompensation = 0;
	    var sourceInstance = this.wot.cloneSource ? this.wot.cloneSource : this.wot;
	    var mainHolder = sourceInstance.wtTable.holder;
	    if (mainHolder.offsetHeight < mainHolder.scrollHeight) {
	      scrollbarCompensation = getScrollbarWidth();
	    }
	    this.wot.wtViewport.columnsRenderCalculator.refreshStretching(this.wot.wtViewport.getViewportWidth() - scrollbarCompensation);
	    for (var renderedColIndex = 0; renderedColIndex < columnsToRender; renderedColIndex++) {
	      var width = this.wtTable.getStretchedColumnWidth(this.columnFilter.renderedToSource(renderedColIndex));
	      this.COLGROUP.childNodes[renderedColIndex + this.rowHeaderCount].style.width = width + 'px';
	    }
	  },
	  appendToTbody: function(TR) {
	    this.TBODY.appendChild(TR);
	    this.wtTable.tbodyChildrenLength++;
	  },
	  getOrCreateTrForRow: function(rowIndex, currentTr) {
	    var TR;
	    if (rowIndex >= this.wtTable.tbodyChildrenLength) {
	      TR = this.createRow();
	      this.appendToTbody(TR);
	    } else if (rowIndex === 0) {
	      TR = this.TBODY.firstChild;
	    } else {
	      TR = currentTr.nextSibling;
	    }
	    if (TR.className) {
	      TR.removeAttribute('class');
	    }
	    return TR;
	  },
	  createRow: function() {
	    var TR = document.createElement('TR');
	    for (var visibleColIndex = 0; visibleColIndex < this.rowHeaderCount; visibleColIndex++) {
	      TR.appendChild(document.createElement('TH'));
	    }
	    return TR;
	  },
	  renderRowHeader: function(row, col, TH) {
	    TH.className = '';
	    TH.removeAttribute('style');
	    this.rowHeaders[col](row, TH, col);
	  },
	  renderRowHeaders: function(row, TR) {
	    for (var TH = TR.firstChild,
	        visibleColIndex = 0; visibleColIndex < this.rowHeaderCount; visibleColIndex++) {
	      if (!TH) {
	        TH = document.createElement('TH');
	        TR.appendChild(TH);
	      } else if (TH.nodeName == 'TD') {
	        TH = replaceTdWithTh(TH, TR);
	      }
	      this.renderRowHeader(row, visibleColIndex, TH);
	      TH = TH.nextSibling;
	    }
	  },
	  adjustAvailableNodes: function() {
	    this.adjustColGroups();
	    this.adjustThead();
	  },
	  renderColumnHeaders: function() {
	    var overlayName = this.wot.getOverlayName();
	    if (!this.columnHeaderCount) {
	      return;
	    }
	    var columnCount = this.wtTable.getRenderedColumnsCount();
	    for (var i = 0; i < this.columnHeaderCount; i++) {
	      var TR = this.getTrForColumnHeaders(i);
	      for (var renderedColumnIndex = (-1) * this.rowHeaderCount; renderedColumnIndex < columnCount; renderedColumnIndex++) {
	        var sourceCol = this.columnFilter.renderedToSource(renderedColumnIndex);
	        this.renderColumnHeader(i, sourceCol, TR.childNodes[renderedColumnIndex + this.rowHeaderCount]);
	      }
	    }
	  },
	  adjustColGroups: function() {
	    var columnCount = this.wtTable.getRenderedColumnsCount();
	    while (this.wtTable.colgroupChildrenLength < columnCount + this.rowHeaderCount) {
	      this.COLGROUP.appendChild(document.createElement('COL'));
	      this.wtTable.colgroupChildrenLength++;
	    }
	    while (this.wtTable.colgroupChildrenLength > columnCount + this.rowHeaderCount) {
	      this.COLGROUP.removeChild(this.COLGROUP.lastChild);
	      this.wtTable.colgroupChildrenLength--;
	    }
	    if (this.rowHeaderCount) {
	      addClass(this.COLGROUP.childNodes[0], 'rowHeader');
	    }
	  },
	  adjustThead: function() {
	    var columnCount = this.wtTable.getRenderedColumnsCount();
	    var TR = this.THEAD.firstChild;
	    if (this.columnHeaders.length) {
	      for (var i = 0,
	          len = this.columnHeaders.length; i < len; i++) {
	        TR = this.THEAD.childNodes[i];
	        if (!TR) {
	          TR = document.createElement('TR');
	          this.THEAD.appendChild(TR);
	        }
	        this.theadChildrenLength = TR.childNodes.length;
	        while (this.theadChildrenLength < columnCount + this.rowHeaderCount) {
	          TR.appendChild(document.createElement('TH'));
	          this.theadChildrenLength++;
	        }
	        while (this.theadChildrenLength > columnCount + this.rowHeaderCount) {
	          TR.removeChild(TR.lastChild);
	          this.theadChildrenLength--;
	        }
	      }
	      var theadChildrenLength = this.THEAD.childNodes.length;
	      if (theadChildrenLength > this.columnHeaders.length) {
	        for (var i$__2 = this.columnHeaders.length; i$__2 < theadChildrenLength; i$__2++) {
	          this.THEAD.removeChild(this.THEAD.lastChild);
	        }
	      }
	    } else if (TR) {
	      empty(TR);
	    }
	  },
	  getTrForColumnHeaders: function(index) {
	    return this.THEAD.childNodes[index];
	  },
	  renderColumnHeader: function(row, col, TH) {
	    TH.className = '';
	    TH.removeAttribute('style');
	    return this.columnHeaders[row](col, TH, row);
	  },
	  adjustColumns: function(TR, desiredCount) {
	    var count = TR.childNodes.length;
	    while (count < desiredCount) {
	      var TD = document.createElement('TD');
	      TR.appendChild(TD);
	      count++;
	    }
	    while (count > desiredCount) {
	      TR.removeChild(TR.lastChild);
	      count--;
	    }
	  },
	  removeRedundantColumns: function(columnsToRender) {
	    while (this.wtTable.tbodyChildrenLength > columnsToRender) {
	      this.TBODY.removeChild(this.TBODY.lastChild);
	      this.wtTable.tbodyChildrenLength--;
	    }
	  }
	}, {});
	function replaceTdWithTh(TD, TR) {
	  var TH = document.createElement('TH');
	  TR.insertBefore(TH, TD);
	  TR.removeChild(TD);
	  return TH;
	}
	function replaceThWithTd(TH, TR) {
	  var TD = document.createElement('TD');
	  TR.insertBefore(TD, TH);
	  TR.removeChild(TH);
	  return TD;
	}
	;
	window.WalkontableTableRenderer = WalkontableTableRenderer;

	//# 
	},{"helpers/dom/element":45}],22:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  WalkontableViewport: {get: function() {
	      return WalkontableViewport;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__,
	    $___46__46__47__46__46__47__46__46__47_eventManager__,
	    $__calculator_47_viewportColumns__,
	    $__calculator_47_viewportRows__;
	var $__0 = ($___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ = require("helpers/dom/element"), $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ && $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47__46__46__47__46__46__47_helpers_47_dom_47_element__}),
	    getScrollbarWidth = $__0.getScrollbarWidth,
	    getScrollTop = $__0.getScrollTop,
	    getStyle = $__0.getStyle,
	    offset = $__0.offset,
	    outerHeight = $__0.outerHeight,
	    outerWidth = $__0.outerWidth;
	var EventManager = ($___46__46__47__46__46__47__46__46__47_eventManager__ = require("eventManager"), $___46__46__47__46__46__47__46__46__47_eventManager__ && $___46__46__47__46__46__47__46__46__47_eventManager__.__esModule && $___46__46__47__46__46__47__46__46__47_eventManager__ || {default: $___46__46__47__46__46__47__46__46__47_eventManager__}).EventManager;
	var WalkontableViewportColumnsCalculator = ($__calculator_47_viewportColumns__ = require("calculator/viewportColumns"), $__calculator_47_viewportColumns__ && $__calculator_47_viewportColumns__.__esModule && $__calculator_47_viewportColumns__ || {default: $__calculator_47_viewportColumns__}).WalkontableViewportColumnsCalculator;
	var WalkontableViewportRowsCalculator = ($__calculator_47_viewportRows__ = require("calculator/viewportRows"), $__calculator_47_viewportRows__ && $__calculator_47_viewportRows__.__esModule && $__calculator_47_viewportRows__ || {default: $__calculator_47_viewportRows__}).WalkontableViewportRowsCalculator;
	var WalkontableViewport = function WalkontableViewport(wotInstance) {
	  var $__4 = this;
	  this.wot = wotInstance;
	  this.instance = this.wot;
	  this.oversizedRows = [];
	  this.oversizedColumnHeaders = [];
	  this.isMarkedOversizedColumn = {};
	  this.clientHeight = 0;
	  this.containerWidth = NaN;
	  this.rowHeaderWidth = NaN;
	  this.rowsVisibleCalculator = null;
	  this.columnsVisibleCalculator = null;
	  this.eventManager = new EventManager(this.wot);
	  this.eventManager.addEventListener(window, 'resize', (function() {
	    $__4.clientHeight = $__4.getWorkspaceHeight();
	  }));
	};
	($traceurRuntime.createClass)(WalkontableViewport, {
	  getWorkspaceHeight: function() {
	    var trimmingContainer = this.instance.wtOverlays.topOverlay.trimmingContainer;
	    var elemHeight;
	    var height = 0;
	    if (trimmingContainer === window) {
	      height = document.documentElement.clientHeight;
	    } else {
	      elemHeight = outerHeight(trimmingContainer);
	      height = (elemHeight > 0 && trimmingContainer.clientHeight > 0) ? trimmingContainer.clientHeight : Infinity;
	    }
	    return height;
	  },
	  getWorkspaceWidth: function() {
	    var width;
	    var totalColumns = this.instance.getSetting('totalColumns');
	    var trimmingContainer = this.instance.wtOverlays.leftOverlay.trimmingContainer;
	    var overflow;
	    var stretchSetting = this.instance.getSetting('stretchH');
	    var docOffsetWidth = document.documentElement.offsetWidth;
	    if (Handsontable.freezeOverlays) {
	      width = Math.min(docOffsetWidth - this.getWorkspaceOffset().left, docOffsetWidth);
	    } else {
	      width = Math.min(this.getContainerFillWidth(), docOffsetWidth - this.getWorkspaceOffset().left, docOffsetWidth);
	    }
	    if (trimmingContainer === window && totalColumns > 0 && this.sumColumnWidths(0, totalColumns - 1) > width) {
	      return document.documentElement.clientWidth;
	    }
	    if (trimmingContainer !== window) {
	      overflow = getStyle(this.instance.wtOverlays.leftOverlay.trimmingContainer, 'overflow');
	      if (overflow == 'scroll' || overflow == 'hidden' || overflow == 'auto') {
	        return Math.max(width, trimmingContainer.clientWidth);
	      }
	    }
	    if (stretchSetting === 'none' || !stretchSetting) {
	      return Math.max(width, outerWidth(this.instance.wtTable.TABLE));
	    } else {
	      return width;
	    }
	  },
	  hasVerticalScroll: function() {
	    return this.getWorkspaceActualHeight() > this.getWorkspaceHeight();
	  },
	  hasHorizontalScroll: function() {
	    return this.getWorkspaceActualWidth() > this.getWorkspaceWidth();
	  },
	  sumColumnWidths: function(from, length) {
	    var sum = 0;
	    while (from < length) {
	      sum += this.wot.wtTable.getColumnWidth(from);
	      from++;
	    }
	    return sum;
	  },
	  getContainerFillWidth: function() {
	    if (this.containerWidth) {
	      return this.containerWidth;
	    }
	    var mainContainer = this.instance.wtTable.holder;
	    var fillWidth;
	    var dummyElement;
	    dummyElement = document.createElement('div');
	    dummyElement.style.width = '100%';
	    dummyElement.style.height = '1px';
	    mainContainer.appendChild(dummyElement);
	    fillWidth = dummyElement.offsetWidth;
	    this.containerWidth = fillWidth;
	    mainContainer.removeChild(dummyElement);
	    return fillWidth;
	  },
	  getWorkspaceOffset: function() {
	    return offset(this.wot.wtTable.TABLE);
	  },
	  getWorkspaceActualHeight: function() {
	    return outerHeight(this.wot.wtTable.TABLE);
	  },
	  getWorkspaceActualWidth: function() {
	    return outerWidth(this.wot.wtTable.TABLE) || outerWidth(this.wot.wtTable.TBODY) || outerWidth(this.wot.wtTable.THEAD);
	  },
	  getColumnHeaderHeight: function() {
	    if (isNaN(this.columnHeaderHeight)) {
	      this.columnHeaderHeight = outerHeight(this.wot.wtTable.THEAD);
	    }
	    return this.columnHeaderHeight;
	  },
	  getViewportHeight: function() {
	    var containerHeight = this.getWorkspaceHeight();
	    var columnHeaderHeight;
	    if (containerHeight === Infinity) {
	      return containerHeight;
	    }
	    columnHeaderHeight = this.getColumnHeaderHeight();
	    if (columnHeaderHeight > 0) {
	      containerHeight -= columnHeaderHeight;
	    }
	    return containerHeight;
	  },
	  getRowHeaderWidth: function() {
	    if (this.wot.cloneSource) {
	      return this.wot.cloneSource.wtViewport.getRowHeaderWidth();
	    }
	    if (isNaN(this.rowHeaderWidth)) {
	      var rowHeaders = this.instance.getSetting('rowHeaders');
	      if (rowHeaders.length) {
	        var TH = this.instance.wtTable.TABLE.querySelector('TH');
	        this.rowHeaderWidth = 0;
	        for (var i = 0,
	            len = rowHeaders.length; i < len; i++) {
	          if (TH) {
	            this.rowHeaderWidth += outerWidth(TH);
	            TH = TH.nextSibling;
	          } else {
	            this.rowHeaderWidth += 50;
	          }
	        }
	      } else {
	        this.rowHeaderWidth = 0;
	      }
	    }
	    return this.rowHeaderWidth;
	  },
	  getViewportWidth: function() {
	    var containerWidth = this.getWorkspaceWidth();
	    var rowHeaderWidth;
	    if (containerWidth === Infinity) {
	      return containerWidth;
	    }
	    rowHeaderWidth = this.getRowHeaderWidth();
	    if (rowHeaderWidth > 0) {
	      return containerWidth - rowHeaderWidth;
	    }
	    return containerWidth;
	  },
	  createRowsCalculator: function() {
	    var visible = arguments[0] !== (void 0) ? arguments[0] : false;
	    var $__4 = this;
	    var height;
	    var pos;
	    var fixedRowsTop;
	    var scrollbarHeight;
	    var fixedRowsBottom;
	    var fixedRowsHeight;
	    var totalRows;
	    this.rowHeaderWidth = NaN;
	    if (this.wot.wtSettings.settings.renderAllRows) {
	      height = Infinity;
	    } else {
	      height = this.getViewportHeight();
	    }
	    pos = getScrollTop(this.wot.wtOverlays.mainTableScrollableElement) - this.wot.wtOverlays.topOverlay.getTableParentOffset();
	    if (pos < 0) {
	      pos = 0;
	    }
	    fixedRowsTop = this.wot.getSetting('fixedRowsTop');
	    fixedRowsBottom = this.wot.getSetting('fixedRowsBottom');
	    totalRows = this.wot.getSetting('totalRows');
	    if (fixedRowsTop) {
	      fixedRowsHeight = this.wot.wtOverlays.topOverlay.sumCellSizes(0, fixedRowsTop);
	      pos += fixedRowsHeight;
	      height -= fixedRowsHeight;
	    }
	    if (fixedRowsBottom && this.wot.wtOverlays.bottomOverlay.clone) {
	      fixedRowsHeight = this.wot.wtOverlays.bottomOverlay.sumCellSizes(totalRows - fixedRowsBottom, totalRows);
	      height -= fixedRowsHeight;
	    }
	    if (this.wot.wtTable.holder.clientHeight === this.wot.wtTable.holder.offsetHeight) {
	      scrollbarHeight = 0;
	    } else {
	      scrollbarHeight = getScrollbarWidth();
	    }
	    return new WalkontableViewportRowsCalculator(height, pos, this.wot.getSetting('totalRows'), (function(sourceRow) {
	      return $__4.wot.wtTable.getRowHeight(sourceRow);
	    }), visible ? null : this.wot.wtSettings.settings.viewportRowCalculatorOverride, visible, scrollbarHeight);
	  },
	  createColumnsCalculator: function() {
	    var visible = arguments[0] !== (void 0) ? arguments[0] : false;
	    var $__4 = this;
	    var width = this.getViewportWidth();
	    var pos;
	    var fixedColumnsLeft;
	    this.columnHeaderHeight = NaN;
	    pos = this.wot.wtOverlays.leftOverlay.getScrollPosition() - this.wot.wtOverlays.leftOverlay.getTableParentOffset();
	    if (pos < 0) {
	      pos = 0;
	    }
	    fixedColumnsLeft = this.wot.getSetting('fixedColumnsLeft');
	    if (fixedColumnsLeft) {
	      var fixedColumnsWidth = this.wot.wtOverlays.leftOverlay.sumCellSizes(0, fixedColumnsLeft);
	      pos += fixedColumnsWidth;
	      width -= fixedColumnsWidth;
	    }
	    if (this.wot.wtTable.holder.clientWidth !== this.wot.wtTable.holder.offsetWidth) {
	      width -= getScrollbarWidth();
	    }
	    return new WalkontableViewportColumnsCalculator(width, pos, this.wot.getSetting('totalColumns'), (function(sourceCol) {
	      return $__4.wot.wtTable.getColumnWidth(sourceCol);
	    }), visible ? null : this.wot.wtSettings.settings.viewportColumnCalculatorOverride, visible, this.wot.getSetting('stretchH'));
	  },
	  createRenderCalculators: function() {
	    var fastDraw = arguments[0] !== (void 0) ? arguments[0] : false;
	    if (fastDraw) {
	      var proposedRowsVisibleCalculator = this.createRowsCalculator(true);
	      var proposedColumnsVisibleCalculator = this.createColumnsCalculator(true);
	      if (!(this.areAllProposedVisibleRowsAlreadyRendered(proposedRowsVisibleCalculator) && this.areAllProposedVisibleColumnsAlreadyRendered(proposedColumnsVisibleCalculator))) {
	        fastDraw = false;
	      }
	    }
	    if (!fastDraw) {
	      this.rowsRenderCalculator = this.createRowsCalculator();
	      this.columnsRenderCalculator = this.createColumnsCalculator();
	    }
	    this.rowsVisibleCalculator = null;
	    this.columnsVisibleCalculator = null;
	    return fastDraw;
	  },
	  createVisibleCalculators: function() {
	    this.rowsVisibleCalculator = this.createRowsCalculator(true);
	    this.columnsVisibleCalculator = this.createColumnsCalculator(true);
	  },
	  areAllProposedVisibleRowsAlreadyRendered: function(proposedRowsVisibleCalculator) {
	    if (this.rowsVisibleCalculator) {
	      if (proposedRowsVisibleCalculator.startRow < this.rowsRenderCalculator.startRow || (proposedRowsVisibleCalculator.startRow === this.rowsRenderCalculator.startRow && proposedRowsVisibleCalculator.startRow > 0)) {
	        return false;
	      } else if (proposedRowsVisibleCalculator.endRow > this.rowsRenderCalculator.endRow || (proposedRowsVisibleCalculator.endRow === this.rowsRenderCalculator.endRow && proposedRowsVisibleCalculator.endRow < this.wot.getSetting('totalRows') - 1)) {
	        return false;
	      } else {
	        return true;
	      }
	    }
	    return false;
	  },
	  areAllProposedVisibleColumnsAlreadyRendered: function(proposedColumnsVisibleCalculator) {
	    if (this.columnsVisibleCalculator) {
	      if (proposedColumnsVisibleCalculator.startColumn < this.columnsRenderCalculator.startColumn || (proposedColumnsVisibleCalculator.startColumn === this.columnsRenderCalculator.startColumn && proposedColumnsVisibleCalculator.startColumn > 0)) {
	        return false;
	      } else if (proposedColumnsVisibleCalculator.endColumn > this.columnsRenderCalculator.endColumn || (proposedColumnsVisibleCalculator.endColumn === this.columnsRenderCalculator.endColumn && proposedColumnsVisibleCalculator.endColumn < this.wot.getSetting('totalColumns') - 1)) {
	        return false;
	      } else {
	        return true;
	      }
	    }
	    return false;
	  }
	}, {});
	;
	window.WalkontableViewport = WalkontableViewport;

	//# 
	},{"calculator/viewportColumns":3,"calculator/viewportRows":4,"eventManager":41,"helpers/dom/element":45}],23:[function(require,module,exports){
	"use strict";
	var $__shims_47_classes__,
	    $__es6collections__,
	    $__pluginHooks__,
	    $__core__,
	    $__renderers_47__95_cellDecorator__,
	    $__cellTypes__,
	    $___46__46__47_plugins_47_jqueryHandsontable__,
	    $__helpers_47_array__,
	    $__helpers_47_browser__,
	    $__helpers_47_data__,
	    $__helpers_47_function__,
	    $__helpers_47_mixed__,
	    $__helpers_47_number__,
	    $__helpers_47_object__,
	    $__helpers_47_setting__,
	    $__helpers_47_string__,
	    $__helpers_47_unicode__,
	    $__helpers_47_dom_47_element__,
	    $__helpers_47_dom_47_event__;
	var version = Handsontable.version;
	var buildDate = Handsontable.buildDate;
	window.Handsontable = function Handsontable(rootElement, userSettings) {
	  var instance = new Handsontable.Core(rootElement, userSettings || {});
	  instance.init();
	  return instance;
	};
	Handsontable.version = version;
	Handsontable.buildDate = buildDate;
	($__shims_47_classes__ = require("shims/classes"), $__shims_47_classes__ && $__shims_47_classes__.__esModule && $__shims_47_classes__ || {default: $__shims_47_classes__});
	($__es6collections__ = require("es6collections"), $__es6collections__ && $__es6collections__.__esModule && $__es6collections__ || {default: $__es6collections__});
	Handsontable.plugins = {};
	var Hooks = ($__pluginHooks__ = require("pluginHooks"), $__pluginHooks__ && $__pluginHooks__.__esModule && $__pluginHooks__ || {default: $__pluginHooks__}).Hooks;
	if (!Handsontable.hooks) {
	  Handsontable.hooks = new Hooks();
	}
	($__core__ = require("core"), $__core__ && $__core__.__esModule && $__core__ || {default: $__core__});
	($__renderers_47__95_cellDecorator__ = require("renderers/_cellDecorator"), $__renderers_47__95_cellDecorator__ && $__renderers_47__95_cellDecorator__.__esModule && $__renderers_47__95_cellDecorator__ || {default: $__renderers_47__95_cellDecorator__});
	($__cellTypes__ = require("cellTypes"), $__cellTypes__ && $__cellTypes__.__esModule && $__cellTypes__ || {default: $__cellTypes__});
	($___46__46__47_plugins_47_jqueryHandsontable__ = require("plugins/jqueryHandsontable"), $___46__46__47_plugins_47_jqueryHandsontable__ && $___46__46__47_plugins_47_jqueryHandsontable__.__esModule && $___46__46__47_plugins_47_jqueryHandsontable__ || {default: $___46__46__47_plugins_47_jqueryHandsontable__});
	var arrayHelpers = ($__helpers_47_array__ = require("helpers/array"), $__helpers_47_array__ && $__helpers_47_array__.__esModule && $__helpers_47_array__ || {default: $__helpers_47_array__});
	var browserHelpers = ($__helpers_47_browser__ = require("helpers/browser"), $__helpers_47_browser__ && $__helpers_47_browser__.__esModule && $__helpers_47_browser__ || {default: $__helpers_47_browser__});
	var dataHelpers = ($__helpers_47_data__ = require("helpers/data"), $__helpers_47_data__ && $__helpers_47_data__.__esModule && $__helpers_47_data__ || {default: $__helpers_47_data__});
	var functionHelpers = ($__helpers_47_function__ = require("helpers/function"), $__helpers_47_function__ && $__helpers_47_function__.__esModule && $__helpers_47_function__ || {default: $__helpers_47_function__});
	var mixedHelpers = ($__helpers_47_mixed__ = require("helpers/mixed"), $__helpers_47_mixed__ && $__helpers_47_mixed__.__esModule && $__helpers_47_mixed__ || {default: $__helpers_47_mixed__});
	var numberHelpers = ($__helpers_47_number__ = require("helpers/number"), $__helpers_47_number__ && $__helpers_47_number__.__esModule && $__helpers_47_number__ || {default: $__helpers_47_number__});
	var objectHelpers = ($__helpers_47_object__ = require("helpers/object"), $__helpers_47_object__ && $__helpers_47_object__.__esModule && $__helpers_47_object__ || {default: $__helpers_47_object__});
	var settingHelpers = ($__helpers_47_setting__ = require("helpers/setting"), $__helpers_47_setting__ && $__helpers_47_setting__.__esModule && $__helpers_47_setting__ || {default: $__helpers_47_setting__});
	var stringHelpers = ($__helpers_47_string__ = require("helpers/string"), $__helpers_47_string__ && $__helpers_47_string__.__esModule && $__helpers_47_string__ || {default: $__helpers_47_string__});
	var unicodeHelpers = ($__helpers_47_unicode__ = require("helpers/unicode"), $__helpers_47_unicode__ && $__helpers_47_unicode__.__esModule && $__helpers_47_unicode__ || {default: $__helpers_47_unicode__});
	var helpers = [arrayHelpers, browserHelpers, dataHelpers, functionHelpers, mixedHelpers, numberHelpers, objectHelpers, settingHelpers, stringHelpers, unicodeHelpers];
	Handsontable.helper = {};
	arrayHelpers.arrayEach(helpers, (function(helper) {
	  arrayHelpers.arrayEach(Object.getOwnPropertyNames(helper), (function(key) {
	    if (key.charAt(0) !== '_') {
	      Handsontable.helper[key] = helper[key];
	    }
	  }));
	}));
	var domHelpers = ($__helpers_47_dom_47_element__ = require("helpers/dom/element"), $__helpers_47_dom_47_element__ && $__helpers_47_dom_47_element__.__esModule && $__helpers_47_dom_47_element__ || {default: $__helpers_47_dom_47_element__});
	var domEventHelpers = ($__helpers_47_dom_47_event__ = require("helpers/dom/event"), $__helpers_47_dom_47_event__ && $__helpers_47_dom_47_event__.__esModule && $__helpers_47_dom_47_event__ || {default: $__helpers_47_dom_47_event__});
	Handsontable.dom = {};
	Handsontable.Dom = Handsontable.dom;
	arrayHelpers.arrayEach([domHelpers, domEventHelpers], (function(helper) {
	  arrayHelpers.arrayEach(Object.getOwnPropertyNames(helper), (function(key) {
	    if (key.charAt(0) !== '_') {
	      Handsontable.dom[key] = helper[key];
	    }
	  }));
	}));

	//# 
	},{"cellTypes":24,"core":25,"es6collections":"es6collections","helpers/array":42,"helpers/browser":43,"helpers/data":44,"helpers/dom/element":45,"helpers/dom/event":46,"helpers/function":47,"helpers/mixed":48,"helpers/number":49,"helpers/object":50,"helpers/setting":51,"helpers/string":52,"helpers/unicode":53,"pluginHooks":56,"plugins/jqueryHandsontable":1,"renderers/_cellDecorator":89,"shims/classes":96}],24:[function(require,module,exports){
	"use strict";
	var $__helpers_47_browser__,
	    $__editors__,
	    $__renderers__,
	    $__editors_47_autocompleteEditor__,
	    $__editors_47_checkboxEditor__,
	    $__editors_47_dateEditor__,
	    $__editors_47_dropdownEditor__,
	    $__editors_47_handsontableEditor__,
	    $__editors_47_mobileTextEditor__,
	    $__editors_47_numericEditor__,
	    $__editors_47_passwordEditor__,
	    $__editors_47_selectEditor__,
	    $__editors_47_textEditor__,
	    $__renderers_47_autocompleteRenderer__,
	    $__renderers_47_checkboxRenderer__,
	    $__renderers_47_htmlRenderer__,
	    $__renderers_47_numericRenderer__,
	    $__renderers_47_passwordRenderer__,
	    $__renderers_47_textRenderer__,
	    $__validators_47_autocompleteValidator__,
	    $__validators_47_dateValidator__,
	    $__validators_47_numericValidator__;
	var isMobileBrowser = ($__helpers_47_browser__ = require("helpers/browser"), $__helpers_47_browser__ && $__helpers_47_browser__.__esModule && $__helpers_47_browser__ || {default: $__helpers_47_browser__}).isMobileBrowser;
	var getEditorConstructor = ($__editors__ = require("editors"), $__editors__ && $__editors__.__esModule && $__editors__ || {default: $__editors__}).getEditorConstructor;
	var getRenderer = ($__renderers__ = require("renderers"), $__renderers__ && $__renderers__.__esModule && $__renderers__ || {default: $__renderers__}).getRenderer;
	var AutocompleteEditor = ($__editors_47_autocompleteEditor__ = require("editors/autocompleteEditor"), $__editors_47_autocompleteEditor__ && $__editors_47_autocompleteEditor__.__esModule && $__editors_47_autocompleteEditor__ || {default: $__editors_47_autocompleteEditor__}).AutocompleteEditor;
	var CheckboxEditor = ($__editors_47_checkboxEditor__ = require("editors/checkboxEditor"), $__editors_47_checkboxEditor__ && $__editors_47_checkboxEditor__.__esModule && $__editors_47_checkboxEditor__ || {default: $__editors_47_checkboxEditor__}).CheckboxEditor;
	var DateEditor = ($__editors_47_dateEditor__ = require("editors/dateEditor"), $__editors_47_dateEditor__ && $__editors_47_dateEditor__.__esModule && $__editors_47_dateEditor__ || {default: $__editors_47_dateEditor__}).DateEditor;
	var DropdownEditor = ($__editors_47_dropdownEditor__ = require("editors/dropdownEditor"), $__editors_47_dropdownEditor__ && $__editors_47_dropdownEditor__.__esModule && $__editors_47_dropdownEditor__ || {default: $__editors_47_dropdownEditor__}).DropdownEditor;
	var HandsontableEditor = ($__editors_47_handsontableEditor__ = require("editors/handsontableEditor"), $__editors_47_handsontableEditor__ && $__editors_47_handsontableEditor__.__esModule && $__editors_47_handsontableEditor__ || {default: $__editors_47_handsontableEditor__}).HandsontableEditor;
	var MobileTextEditor = ($__editors_47_mobileTextEditor__ = require("editors/mobileTextEditor"), $__editors_47_mobileTextEditor__ && $__editors_47_mobileTextEditor__.__esModule && $__editors_47_mobileTextEditor__ || {default: $__editors_47_mobileTextEditor__}).MobileTextEditor;
	var NumericEditor = ($__editors_47_numericEditor__ = require("editors/numericEditor"), $__editors_47_numericEditor__ && $__editors_47_numericEditor__.__esModule && $__editors_47_numericEditor__ || {default: $__editors_47_numericEditor__}).NumericEditor;
	var PasswordEditor = ($__editors_47_passwordEditor__ = require("editors/passwordEditor"), $__editors_47_passwordEditor__ && $__editors_47_passwordEditor__.__esModule && $__editors_47_passwordEditor__ || {default: $__editors_47_passwordEditor__}).PasswordEditor;
	var SelectEditor = ($__editors_47_selectEditor__ = require("editors/selectEditor"), $__editors_47_selectEditor__ && $__editors_47_selectEditor__.__esModule && $__editors_47_selectEditor__ || {default: $__editors_47_selectEditor__}).SelectEditor;
	var TextEditor = ($__editors_47_textEditor__ = require("editors/textEditor"), $__editors_47_textEditor__ && $__editors_47_textEditor__.__esModule && $__editors_47_textEditor__ || {default: $__editors_47_textEditor__}).TextEditor;
	var AutocompleteRenderer = ($__renderers_47_autocompleteRenderer__ = require("renderers/autocompleteRenderer"), $__renderers_47_autocompleteRenderer__ && $__renderers_47_autocompleteRenderer__.__esModule && $__renderers_47_autocompleteRenderer__ || {default: $__renderers_47_autocompleteRenderer__}).AutocompleteRenderer;
	var CheckboxRenderer = ($__renderers_47_checkboxRenderer__ = require("renderers/checkboxRenderer"), $__renderers_47_checkboxRenderer__ && $__renderers_47_checkboxRenderer__.__esModule && $__renderers_47_checkboxRenderer__ || {default: $__renderers_47_checkboxRenderer__}).CheckboxRenderer;
	var HtmlRenderer = ($__renderers_47_htmlRenderer__ = require("renderers/htmlRenderer"), $__renderers_47_htmlRenderer__ && $__renderers_47_htmlRenderer__.__esModule && $__renderers_47_htmlRenderer__ || {default: $__renderers_47_htmlRenderer__}).HtmlRenderer;
	var NumericRenderer = ($__renderers_47_numericRenderer__ = require("renderers/numericRenderer"), $__renderers_47_numericRenderer__ && $__renderers_47_numericRenderer__.__esModule && $__renderers_47_numericRenderer__ || {default: $__renderers_47_numericRenderer__}).NumericRenderer;
	var PasswordRenderer = ($__renderers_47_passwordRenderer__ = require("renderers/passwordRenderer"), $__renderers_47_passwordRenderer__ && $__renderers_47_passwordRenderer__.__esModule && $__renderers_47_passwordRenderer__ || {default: $__renderers_47_passwordRenderer__}).PasswordRenderer;
	var TextRenderer = ($__renderers_47_textRenderer__ = require("renderers/textRenderer"), $__renderers_47_textRenderer__ && $__renderers_47_textRenderer__.__esModule && $__renderers_47_textRenderer__ || {default: $__renderers_47_textRenderer__}).TextRenderer;
	var AutocompleteValidator = ($__validators_47_autocompleteValidator__ = require("validators/autocompleteValidator"), $__validators_47_autocompleteValidator__ && $__validators_47_autocompleteValidator__.__esModule && $__validators_47_autocompleteValidator__ || {default: $__validators_47_autocompleteValidator__}).AutocompleteValidator;
	var DateValidator = ($__validators_47_dateValidator__ = require("validators/dateValidator"), $__validators_47_dateValidator__ && $__validators_47_dateValidator__.__esModule && $__validators_47_dateValidator__ || {default: $__validators_47_dateValidator__}).DateValidator;
	var NumericValidator = ($__validators_47_numericValidator__ = require("validators/numericValidator"), $__validators_47_numericValidator__ && $__validators_47_numericValidator__.__esModule && $__validators_47_numericValidator__ || {default: $__validators_47_numericValidator__}).NumericValidator;
	Handsontable.mobileBrowser = isMobileBrowser();
	Handsontable.AutocompleteCell = {
	  editor: getEditorConstructor('autocomplete'),
	  renderer: getRenderer('autocomplete'),
	  validator: Handsontable.AutocompleteValidator
	};
	Handsontable.CheckboxCell = {
	  editor: getEditorConstructor('checkbox'),
	  renderer: getRenderer('checkbox')
	};
	Handsontable.TextCell = {
	  editor: Handsontable.mobileBrowser ? getEditorConstructor('mobile') : getEditorConstructor('text'),
	  renderer: getRenderer('text')
	};
	Handsontable.NumericCell = {
	  editor: getEditorConstructor('numeric'),
	  renderer: getRenderer('numeric'),
	  validator: Handsontable.NumericValidator,
	  dataType: 'number'
	};
	Handsontable.DateCell = {
	  editor: getEditorConstructor('date'),
	  validator: Handsontable.DateValidator,
	  renderer: getRenderer('autocomplete')
	};
	Handsontable.HandsontableCell = {
	  editor: getEditorConstructor('handsontable'),
	  renderer: getRenderer('autocomplete')
	};
	Handsontable.PasswordCell = {
	  editor: getEditorConstructor('password'),
	  renderer: getRenderer('password'),
	  copyable: false
	};
	Handsontable.DropdownCell = {
	  editor: getEditorConstructor('dropdown'),
	  renderer: getRenderer('autocomplete'),
	  validator: Handsontable.AutocompleteValidator
	};
	Handsontable.cellTypes = {
	  text: Handsontable.TextCell,
	  date: Handsontable.DateCell,
	  numeric: Handsontable.NumericCell,
	  checkbox: Handsontable.CheckboxCell,
	  autocomplete: Handsontable.AutocompleteCell,
	  handsontable: Handsontable.HandsontableCell,
	  password: Handsontable.PasswordCell,
	  dropdown: Handsontable.DropdownCell
	};
	Handsontable.cellLookup = {validator: {
	    numeric: Handsontable.NumericValidator,
	    autocomplete: Handsontable.AutocompleteValidator
	  }};

	//# 
	},{"editors":29,"editors/autocompleteEditor":31,"editors/checkboxEditor":32,"editors/dateEditor":33,"editors/dropdownEditor":34,"editors/handsontableEditor":35,"editors/mobileTextEditor":36,"editors/numericEditor":37,"editors/passwordEditor":38,"editors/selectEditor":39,"editors/textEditor":40,"helpers/browser":43,"renderers":88,"renderers/autocompleteRenderer":90,"renderers/checkboxRenderer":91,"renderers/htmlRenderer":92,"renderers/numericRenderer":93,"renderers/passwordRenderer":94,"renderers/textRenderer":95,"validators/autocompleteValidator":100,"validators/dateValidator":101,"validators/numericValidator":102}],25:[function(require,module,exports){
	"use strict";
	var $__numeral__,
	    $__helpers_47_dom_47_element__,
	    $__helpers_47_setting__,
	    $__dataMap__,
	    $__editorManager__,
	    $__eventManager__,
	    $__helpers_47_object__,
	    $__helpers_47_array__,
	    $__plugins__,
	    $__renderers__,
	    $__helpers_47_string__,
	    $__helpers_47_number__,
	    $__tableView__,
	    $__dataSource__,
	    $__helpers_47_data__,
	    $__3rdparty_47_walkontable_47_src_47_cell_47_coords__,
	    $__3rdparty_47_walkontable_47_src_47_cell_47_range__,
	    $__3rdparty_47_walkontable_47_src_47_selection__,
	    $__3rdparty_47_walkontable_47_src_47_calculator_47_viewportColumns__;
	var numeral = ($__numeral__ = require("numeral"), $__numeral__ && $__numeral__.__esModule && $__numeral__ || {default: $__numeral__}).default;
	var $__1 = ($__helpers_47_dom_47_element__ = require("helpers/dom/element"), $__helpers_47_dom_47_element__ && $__helpers_47_dom_47_element__.__esModule && $__helpers_47_dom_47_element__ || {default: $__helpers_47_dom_47_element__}),
	    addClass = $__1.addClass,
	    empty = $__1.empty,
	    isChildOfWebComponentTable = $__1.isChildOfWebComponentTable,
	    removeClass = $__1.removeClass;
	var columnFactory = ($__helpers_47_setting__ = require("helpers/setting"), $__helpers_47_setting__ && $__helpers_47_setting__.__esModule && $__helpers_47_setting__ || {default: $__helpers_47_setting__}).columnFactory;
	var DataMap = ($__dataMap__ = require("dataMap"), $__dataMap__ && $__dataMap__.__esModule && $__dataMap__ || {default: $__dataMap__}).DataMap;
	var EditorManager = ($__editorManager__ = require("editorManager"), $__editorManager__ && $__editorManager__.__esModule && $__editorManager__ || {default: $__editorManager__}).EditorManager;
	var eventManagerObject = ($__eventManager__ = require("eventManager"), $__eventManager__ && $__eventManager__.__esModule && $__eventManager__ || {default: $__eventManager__}).eventManager;
	var $__6 = ($__helpers_47_object__ = require("helpers/object"), $__helpers_47_object__ && $__helpers_47_object__.__esModule && $__helpers_47_object__ || {default: $__helpers_47_object__}),
	    extend = $__6.extend,
	    duckSchema = $__6.duckSchema,
	    isObjectEquals = $__6.isObjectEquals,
	    deepClone = $__6.deepClone;
	var arrayFlatten = ($__helpers_47_array__ = require("helpers/array"), $__helpers_47_array__ && $__helpers_47_array__.__esModule && $__helpers_47_array__ || {default: $__helpers_47_array__}).arrayFlatten;
	var getPlugin = ($__plugins__ = require("plugins"), $__plugins__ && $__plugins__.__esModule && $__plugins__ || {default: $__plugins__}).getPlugin;
	var getRenderer = ($__renderers__ = require("renderers"), $__renderers__ && $__renderers__.__esModule && $__renderers__ || {default: $__renderers__}).getRenderer;
	var randomString = ($__helpers_47_string__ = require("helpers/string"), $__helpers_47_string__ && $__helpers_47_string__.__esModule && $__helpers_47_string__ || {default: $__helpers_47_string__}).randomString;
	var rangeEach = ($__helpers_47_number__ = require("helpers/number"), $__helpers_47_number__ && $__helpers_47_number__.__esModule && $__helpers_47_number__ || {default: $__helpers_47_number__}).rangeEach;
	var TableView = ($__tableView__ = require("tableView"), $__tableView__ && $__tableView__.__esModule && $__tableView__ || {default: $__tableView__}).TableView;
	var DataSource = ($__dataSource__ = require("dataSource"), $__dataSource__ && $__dataSource__.__esModule && $__dataSource__ || {default: $__dataSource__}).DataSource;
	var $__14 = ($__helpers_47_data__ = require("helpers/data"), $__helpers_47_data__ && $__helpers_47_data__.__esModule && $__helpers_47_data__ || {default: $__helpers_47_data__}),
	    translateRowsToColumns = $__14.translateRowsToColumns,
	    cellMethodLookupFactory = $__14.cellMethodLookupFactory,
	    spreadsheetColumnLabel = $__14.spreadsheetColumnLabel;
	var WalkontableCellCoords = ($__3rdparty_47_walkontable_47_src_47_cell_47_coords__ = require("3rdparty/walkontable/src/cell/coords"), $__3rdparty_47_walkontable_47_src_47_cell_47_coords__ && $__3rdparty_47_walkontable_47_src_47_cell_47_coords__.__esModule && $__3rdparty_47_walkontable_47_src_47_cell_47_coords__ || {default: $__3rdparty_47_walkontable_47_src_47_cell_47_coords__}).WalkontableCellCoords;
	var WalkontableCellRange = ($__3rdparty_47_walkontable_47_src_47_cell_47_range__ = require("3rdparty/walkontable/src/cell/range"), $__3rdparty_47_walkontable_47_src_47_cell_47_range__ && $__3rdparty_47_walkontable_47_src_47_cell_47_range__.__esModule && $__3rdparty_47_walkontable_47_src_47_cell_47_range__ || {default: $__3rdparty_47_walkontable_47_src_47_cell_47_range__}).WalkontableCellRange;
	var WalkontableSelection = ($__3rdparty_47_walkontable_47_src_47_selection__ = require("3rdparty/walkontable/src/selection"), $__3rdparty_47_walkontable_47_src_47_selection__ && $__3rdparty_47_walkontable_47_src_47_selection__.__esModule && $__3rdparty_47_walkontable_47_src_47_selection__ || {default: $__3rdparty_47_walkontable_47_src_47_selection__}).WalkontableSelection;
	var WalkontableViewportColumnsCalculator = ($__3rdparty_47_walkontable_47_src_47_calculator_47_viewportColumns__ = require("3rdparty/walkontable/src/calculator/viewportColumns"), $__3rdparty_47_walkontable_47_src_47_calculator_47_viewportColumns__ && $__3rdparty_47_walkontable_47_src_47_calculator_47_viewportColumns__.__esModule && $__3rdparty_47_walkontable_47_src_47_calculator_47_viewportColumns__ || {default: $__3rdparty_47_walkontable_47_src_47_calculator_47_viewportColumns__}).WalkontableViewportColumnsCalculator;
	Handsontable.activeGuid = null;
	Handsontable.Core = function Core(rootElement, userSettings) {
	  var priv,
	      datamap,
	      dataSource,
	      grid,
	      selection,
	      editorManager,
	      instance = this,
	      GridSettings = function() {},
	      eventManager = eventManagerObject(instance);
	  extend(GridSettings.prototype, DefaultSettings.prototype);
	  extend(GridSettings.prototype, userSettings);
	  extend(GridSettings.prototype, expandType(userSettings));
	  this.rootElement = rootElement;
	  this.isHotTableEnv = isChildOfWebComponentTable(this.rootElement);
	  Handsontable.eventManager.isHotTableEnv = this.isHotTableEnv;
	  this.container = document.createElement('DIV');
	  this.renderCall = false;
	  rootElement.insertBefore(this.container, rootElement.firstChild);
	  this.guid = 'ht_' + randomString();
	  if (!this.rootElement.id || this.rootElement.id.substring(0, 3) === 'ht_') {
	    this.rootElement.id = this.guid;
	  }
	  priv = {
	    cellSettings: [],
	    columnSettings: [],
	    columnsSettingConflicts: ['data', 'width'],
	    settings: new GridSettings(),
	    selRange: null,
	    isPopulated: null,
	    scrollable: null,
	    firstRun: true
	  };
	  grid = {
	    alter: function(action, index, amount, source, keepEmptyRows) {
	      var delta;
	      amount = amount || 1;
	      switch (action) {
	        case 'insert_row':
	          if (instance.getSettings().maxRows === instance.countSourceRows()) {
	            return;
	          }
	          delta = datamap.createRow(index, amount);
	          if (delta) {
	            if (selection.isSelected() && priv.selRange.from.row >= index) {
	              priv.selRange.from.row = priv.selRange.from.row + delta;
	              selection.transformEnd(delta, 0);
	            } else {
	              selection.refreshBorders();
	            }
	          }
	          break;
	        case 'insert_col':
	          delta = datamap.createCol(index, amount);
	          if (delta) {
	            if (Array.isArray(instance.getSettings().colHeaders)) {
	              var spliceArray = [index, 0];
	              spliceArray.length += delta;
	              Array.prototype.splice.apply(instance.getSettings().colHeaders, spliceArray);
	            }
	            if (selection.isSelected() && priv.selRange.from.col >= index) {
	              priv.selRange.from.col = priv.selRange.from.col + delta;
	              selection.transformEnd(0, delta);
	            } else {
	              selection.refreshBorders();
	            }
	          }
	          break;
	        case 'remove_row':
	          datamap.removeRow(index, amount);
	          priv.cellSettings.splice(index, amount);
	          var totalRows = instance.countRows();
	          var fixedRowsTop = instance.getSettings().fixedRowsTop;
	          if (fixedRowsTop >= index + 1) {
	            instance.getSettings().fixedRowsTop -= Math.min(amount, fixedRowsTop - index);
	          }
	          var fixedRowsBottom = instance.getSettings().fixedRowsBottom;
	          if (fixedRowsBottom && totalRows - fixedRowsBottom <= index + 1) {
	            instance.getSettings().fixedRowsBottom -= Math.min(amount, fixedRowsBottom - index);
	          }
	          grid.adjustRowsAndCols();
	          selection.refreshBorders();
	          break;
	        case 'remove_col':
	          datamap.removeCol(index, amount);
	          for (var row = 0,
	              len = datamap.getAll().length; row < len; row++) {
	            if (row in priv.cellSettings) {
	              priv.cellSettings[row].splice(index, amount);
	            }
	          }
	          var fixedColumnsLeft = instance.getSettings().fixedColumnsLeft;
	          if (fixedColumnsLeft >= index + 1) {
	            instance.getSettings().fixedColumnsLeft -= Math.min(amount, fixedColumnsLeft - index);
	          }
	          if (Array.isArray(instance.getSettings().colHeaders)) {
	            if (typeof index == 'undefined') {
	              index = -1;
	            }
	            instance.getSettings().colHeaders.splice(index, amount);
	          }
	          grid.adjustRowsAndCols();
	          selection.refreshBorders();
	          break;
	        default:
	          throw new Error('There is no such action "' + action + '"');
	          break;
	      }
	      if (!keepEmptyRows) {
	        grid.adjustRowsAndCols();
	      }
	    },
	    adjustRowsAndCols: function() {
	      if (priv.settings.minRows) {
	        var rows = instance.countRows();
	        if (rows < priv.settings.minRows) {
	          for (var r = 0,
	              minRows = priv.settings.minRows; r < minRows - rows; r++) {
	            datamap.createRow(instance.countRows(), 1, true);
	          }
	        }
	      }
	      if (priv.settings.minSpareRows) {
	        var emptyRows = instance.countEmptyRows(true);
	        if (emptyRows < priv.settings.minSpareRows) {
	          for (; emptyRows < priv.settings.minSpareRows && instance.countRows() < priv.settings.maxRows; emptyRows++) {
	            datamap.createRow(instance.countRows(), 1, true);
	          }
	        }
	      }
	      {
	        var emptyCols;
	        if (priv.settings.minCols || priv.settings.minSpareCols) {
	          emptyCols = instance.countEmptyCols(true);
	        }
	        if (priv.settings.minCols && !priv.settings.columns && instance.countCols() < priv.settings.minCols) {
	          for (; instance.countCols() < priv.settings.minCols; emptyCols++) {
	            datamap.createCol(instance.countCols(), 1, true);
	          }
	        }
	        if (priv.settings.minSpareCols && !priv.settings.columns && instance.dataType === 'array' && emptyCols < priv.settings.minSpareCols) {
	          for (; emptyCols < priv.settings.minSpareCols && instance.countCols() < priv.settings.maxCols; emptyCols++) {
	            datamap.createCol(instance.countCols(), 1, true);
	          }
	        }
	      }
	      var rowCount = instance.countRows();
	      var colCount = instance.countCols();
	      if (rowCount === 0 || colCount === 0) {
	        selection.deselect();
	      }
	      if (selection.isSelected()) {
	        var selectionChanged = false;
	        var fromRow = priv.selRange.from.row;
	        var fromCol = priv.selRange.from.col;
	        var toRow = priv.selRange.to.row;
	        var toCol = priv.selRange.to.col;
	        if (fromRow > rowCount - 1) {
	          fromRow = rowCount - 1;
	          selectionChanged = true;
	          if (toRow > fromRow) {
	            toRow = fromRow;
	          }
	        } else if (toRow > rowCount - 1) {
	          toRow = rowCount - 1;
	          selectionChanged = true;
	          if (fromRow > toRow) {
	            fromRow = toRow;
	          }
	        }
	        if (fromCol > colCount - 1) {
	          fromCol = colCount - 1;
	          selectionChanged = true;
	          if (toCol > fromCol) {
	            toCol = fromCol;
	          }
	        } else if (toCol > colCount - 1) {
	          toCol = colCount - 1;
	          selectionChanged = true;
	          if (fromCol > toCol) {
	            fromCol = toCol;
	          }
	        }
	        if (selectionChanged) {
	          instance.selectCell(fromRow, fromCol, toRow, toCol);
	        }
	      }
	      if (instance.view) {
	        instance.view.wt.wtOverlays.adjustElementsSize();
	      }
	    },
	    populateFromArray: function(start, input, end, source, method, direction, deltas) {
	      var r,
	          rlen,
	          c,
	          clen,
	          setData = [],
	          current = {};
	      rlen = input.length;
	      if (rlen === 0) {
	        return false;
	      }
	      var repeatCol,
	          repeatRow,
	          cmax,
	          rmax,
	          baseEnd = {
	            row: end === null ? null : end.row,
	            col: end === null ? null : end.col
	          };
	      switch (method) {
	        case 'shift_down':
	          repeatCol = end ? end.col - start.col + 1 : 0;
	          repeatRow = end ? end.row - start.row + 1 : 0;
	          input = translateRowsToColumns(input);
	          for (c = 0, clen = input.length, cmax = Math.max(clen, repeatCol); c < cmax; c++) {
	            if (c < clen) {
	              for (r = 0, rlen = input[c].length; r < repeatRow - rlen; r++) {
	                input[c].push(input[c][r % rlen]);
	              }
	              input[c].unshift(start.col + c, start.row, 0);
	              instance.spliceCol.apply(instance, input[c]);
	            } else {
	              input[c % clen][0] = start.col + c;
	              instance.spliceCol.apply(instance, input[c % clen]);
	            }
	          }
	          break;
	        case 'shift_right':
	          repeatCol = end ? end.col - start.col + 1 : 0;
	          repeatRow = end ? end.row - start.row + 1 : 0;
	          for (r = 0, rlen = input.length, rmax = Math.max(rlen, repeatRow); r < rmax; r++) {
	            if (r < rlen) {
	              for (c = 0, clen = input[r].length; c < repeatCol - clen; c++) {
	                input[r].push(input[r][c % clen]);
	              }
	              input[r].unshift(start.row + r, start.col, 0);
	              instance.spliceRow.apply(instance, input[r]);
	            } else {
	              input[r % rlen][0] = start.row + r;
	              instance.spliceRow.apply(instance, input[r % rlen]);
	            }
	          }
	          break;
	        case 'overwrite':
	        default:
	          current.row = start.row;
	          current.col = start.col;
	          var selected = {
	            row: (end && start) ? (end.row - start.row + 1) : 1,
	            col: (end && start) ? (end.col - start.col + 1) : 1
	          };
	          var skippedRow = 0;
	          var skippedColumn = 0;
	          var pushData = true;
	          var cellMeta;
	          var getInputValue = function getInputValue(row) {
	            var col = arguments[1] !== (void 0) ? arguments[1] : null;
	            var rowValue = input[row % input.length];
	            if (col !== null) {
	              return rowValue[col % rowValue.length];
	            }
	            return rowValue;
	          };
	          var rowInputLength = input.length;
	          var rowSelectionLength = end ? end.row - start.row + 1 : 0;
	          if (end) {
	            rlen = rowSelectionLength;
	          } else {
	            rlen = Math.max(rowInputLength, rowSelectionLength);
	          }
	          for (r = 0; r < rlen; r++) {
	            if ((end && current.row > end.row && rowSelectionLength > rowInputLength) || (!priv.settings.allowInsertRow && current.row > instance.countRows() - 1) || (current.row >= priv.settings.maxRows)) {
	              break;
	            }
	            var logicalRow = r - skippedRow;
	            var colInputLength = getInputValue(logicalRow).length;
	            var colSelectionLength = end ? end.col - start.col + 1 : 0;
	            if (end) {
	              clen = colSelectionLength;
	            } else {
	              clen = Math.max(colInputLength, colSelectionLength);
	            }
	            current.col = start.col;
	            cellMeta = instance.getCellMeta(current.row, current.col);
	            if ((source === 'paste' || source === 'autofill') && cellMeta.skipRowOnPaste) {
	              skippedRow++;
	              current.row++;
	              rlen++;
	              continue;
	            }
	            skippedColumn = 0;
	            for (c = 0; c < clen; c++) {
	              if ((end && current.col > end.col && colSelectionLength > colInputLength) || (!priv.settings.allowInsertColumn && current.col > instance.countCols() - 1) || (current.col >= priv.settings.maxCols)) {
	                break;
	              }
	              cellMeta = instance.getCellMeta(current.row, current.col);
	              if ((source === 'paste' || source === 'autofill') && cellMeta.skipColumnOnPaste) {
	                skippedColumn++;
	                current.col++;
	                clen++;
	                continue;
	              }
	              if (cellMeta.readOnly) {
	                current.col++;
	                continue;
	              }
	              var logicalColumn = c - skippedColumn;
	              var value = getInputValue(logicalRow, logicalColumn);
	              var orgValue = instance.getDataAtCell(current.row, current.col);
	              var index = {
	                row: logicalRow,
	                col: logicalColumn
	              };
	              if (source === 'autofill') {
	                var result = instance.runHooks('beforeAutofillInsidePopulate', index, direction, input, deltas, {}, selected);
	                if (result) {
	                  value = typeof(result.value) === 'undefined' ? value : result.value;
	                }
	              }
	              if (value !== null && typeof value === 'object') {
	                if (orgValue === null || typeof orgValue !== 'object') {
	                  pushData = false;
	                } else {
	                  var orgValueSchema = duckSchema(orgValue[0] || orgValue);
	                  var valueSchema = duckSchema(value[0] || value);
	                  if (isObjectEquals(orgValueSchema, valueSchema)) {
	                    value = deepClone(value);
	                  } else {
	                    pushData = false;
	                  }
	                }
	              } else if (orgValue !== null && typeof orgValue === 'object') {
	                pushData = false;
	              }
	              if (pushData) {
	                setData.push([current.row, current.col, value]);
	              }
	              pushData = true;
	              current.col++;
	            }
	            current.row++;
	          }
	          instance.setDataAtCell(setData, null, null, source || 'populateFromArray');
	          break;
	      }
	    }
	  };
	  this.selection = selection = {
	    inProgress: false,
	    selectedHeader: {
	      cols: false,
	      rows: false
	    },
	    setSelectedHeaders: function(rows, cols) {
	      instance.selection.selectedHeader.rows = rows;
	      instance.selection.selectedHeader.cols = cols;
	    },
	    begin: function() {
	      instance.selection.inProgress = true;
	    },
	    finish: function() {
	      var sel = instance.getSelected();
	      Handsontable.hooks.run(instance, 'afterSelectionEnd', sel[0], sel[1], sel[2], sel[3]);
	      Handsontable.hooks.run(instance, 'afterSelectionEndByProp', sel[0], instance.colToProp(sel[1]), sel[2], instance.colToProp(sel[3]));
	      instance.selection.inProgress = false;
	    },
	    isInProgress: function() {
	      return instance.selection.inProgress;
	    },
	    setRangeStart: function(coords, keepEditorOpened) {
	      Handsontable.hooks.run(instance, 'beforeSetRangeStart', coords);
	      priv.selRange = new WalkontableCellRange(coords, coords, coords);
	      selection.setRangeEnd(coords, null, keepEditorOpened);
	    },
	    setRangeEnd: function(coords, scrollToCell, keepEditorOpened) {
	      if (priv.selRange === null) {
	        return;
	      }
	      var disableVisualSelection,
	          isHeaderSelected = false,
	          areCoordsPositive = true;
	      var firstVisibleRow = instance.view.wt.wtTable.getFirstVisibleRow();
	      var firstVisibleColumn = instance.view.wt.wtTable.getFirstVisibleColumn();
	      var newRangeCoords = {
	        row: null,
	        col: null
	      };
	      Handsontable.hooks.run(instance, 'beforeSetRangeEnd', coords);
	      instance.selection.begin();
	      newRangeCoords.row = coords.row < 0 ? firstVisibleRow : coords.row;
	      newRangeCoords.col = coords.col < 0 ? firstVisibleColumn : coords.col;
	      priv.selRange.to = new WalkontableCellCoords(newRangeCoords.row, newRangeCoords.col);
	      if (!priv.settings.multiSelect) {
	        priv.selRange.from = coords;
	      }
	      instance.view.wt.selections.current.clear();
	      disableVisualSelection = instance.getCellMeta(priv.selRange.highlight.row, priv.selRange.highlight.col).disableVisualSelection;
	      if (typeof disableVisualSelection === 'string') {
	        disableVisualSelection = [disableVisualSelection];
	      }
	      if (disableVisualSelection === false || Array.isArray(disableVisualSelection) && disableVisualSelection.indexOf('current') === -1) {
	        instance.view.wt.selections.current.add(priv.selRange.highlight);
	      }
	      instance.view.wt.selections.area.clear();
	      if ((disableVisualSelection === false || Array.isArray(disableVisualSelection) && disableVisualSelection.indexOf('area') === -1) && selection.isMultiple()) {
	        instance.view.wt.selections.area.add(priv.selRange.from);
	        instance.view.wt.selections.area.add(priv.selRange.to);
	      }
	      if (priv.settings.currentRowClassName || priv.settings.currentColClassName) {
	        instance.view.wt.selections.highlight.clear();
	        instance.view.wt.selections.highlight.add(priv.selRange.from);
	        instance.view.wt.selections.highlight.add(priv.selRange.to);
	      }
	      Handsontable.hooks.run(instance, 'afterSelection', priv.selRange.from.row, priv.selRange.from.col, priv.selRange.to.row, priv.selRange.to.col);
	      Handsontable.hooks.run(instance, 'afterSelectionByProp', priv.selRange.from.row, datamap.colToProp(priv.selRange.from.col), priv.selRange.to.row, datamap.colToProp(priv.selRange.to.col));
	      if ((priv.selRange.from.row === 0 && priv.selRange.to.row === instance.countRows() - 1 && instance.countRows() > 1) || (priv.selRange.from.col === 0 && priv.selRange.to.col === instance.countCols() - 1 && instance.countCols() > 1)) {
	        isHeaderSelected = true;
	      }
	      if (coords.row < 0 || coords.col < 0) {
	        areCoordsPositive = false;
	      }
	      if (scrollToCell !== false && !isHeaderSelected && areCoordsPositive) {
	        if (priv.selRange.from && !selection.isMultiple()) {
	          instance.view.scrollViewport(priv.selRange.from);
	        } else {
	          instance.view.scrollViewport(coords);
	        }
	      }
	      selection.refreshBorders(null, keepEditorOpened);
	    },
	    refreshBorders: function(revertOriginal, keepEditor) {
	      if (!keepEditor) {
	        editorManager.destroyEditor(revertOriginal);
	      }
	      instance.view.render();
	      if (selection.isSelected() && !keepEditor) {
	        editorManager.prepareEditor();
	      }
	    },
	    isMultiple: function() {
	      var isMultiple = !(priv.selRange.to.col === priv.selRange.from.col && priv.selRange.to.row === priv.selRange.from.row),
	          modifier = Handsontable.hooks.run(instance, 'afterIsMultipleSelection', isMultiple);
	      if (isMultiple) {
	        return modifier;
	      }
	    },
	    transformStart: function(rowDelta, colDelta, force, keepEditorOpened) {
	      var delta = new WalkontableCellCoords(rowDelta, colDelta),
	          rowTransformDir = 0,
	          colTransformDir = 0,
	          totalRows,
	          totalCols,
	          coords,
	          fixedRowsBottom;
	      instance.runHooks('modifyTransformStart', delta);
	      totalRows = instance.countRows();
	      totalCols = instance.countCols();
	      fixedRowsBottom = instance.getSettings().fixedRowsBottom;
	      if (priv.selRange.highlight.row + rowDelta > totalRows - 1) {
	        if (force && priv.settings.minSpareRows > 0 && !(fixedRowsBottom && priv.selRange.highlight.row >= totalRows - fixedRowsBottom - 1)) {
	          instance.alter('insert_row', totalRows);
	          totalRows = instance.countRows();
	        } else if (priv.settings.autoWrapCol) {
	          delta.row = 1 - totalRows;
	          delta.col = priv.selRange.highlight.col + delta.col == totalCols - 1 ? 1 - totalCols : 1;
	        }
	      } else if (priv.settings.autoWrapCol && priv.selRange.highlight.row + delta.row < 0 && priv.selRange.highlight.col + delta.col >= 0) {
	        delta.row = totalRows - 1;
	        delta.col = priv.selRange.highlight.col + delta.col == 0 ? totalCols - 1 : -1;
	      }
	      if (priv.selRange.highlight.col + delta.col > totalCols - 1) {
	        if (force && priv.settings.minSpareCols > 0) {
	          instance.alter('insert_col', totalCols);
	          totalCols = instance.countCols();
	        } else if (priv.settings.autoWrapRow) {
	          delta.row = priv.selRange.highlight.row + delta.row == totalRows - 1 ? 1 - totalRows : 1;
	          delta.col = 1 - totalCols;
	        }
	      } else if (priv.settings.autoWrapRow && priv.selRange.highlight.col + delta.col < 0 && priv.selRange.highlight.row + delta.row >= 0) {
	        delta.row = priv.selRange.highlight.row + delta.row == 0 ? totalRows - 1 : -1;
	        delta.col = totalCols - 1;
	      }
	      coords = new WalkontableCellCoords(priv.selRange.highlight.row + delta.row, priv.selRange.highlight.col + delta.col);
	      if (coords.row < 0) {
	        rowTransformDir = -1;
	        coords.row = 0;
	      } else if (coords.row > 0 && coords.row >= totalRows) {
	        rowTransformDir = 1;
	        coords.row = totalRows - 1;
	      }
	      if (coords.col < 0) {
	        colTransformDir = -1;
	        coords.col = 0;
	      } else if (coords.col > 0 && coords.col >= totalCols) {
	        colTransformDir = 1;
	        coords.col = totalCols - 1;
	      }
	      instance.runHooks('afterModifyTransformStart', coords, rowTransformDir, colTransformDir);
	      selection.setRangeStart(coords, keepEditorOpened);
	    },
	    transformEnd: function(rowDelta, colDelta) {
	      var delta = new WalkontableCellCoords(rowDelta, colDelta),
	          rowTransformDir = 0,
	          colTransformDir = 0,
	          totalRows,
	          totalCols,
	          coords;
	      instance.runHooks('modifyTransformEnd', delta);
	      totalRows = instance.countRows();
	      totalCols = instance.countCols();
	      coords = new WalkontableCellCoords(priv.selRange.to.row + delta.row, priv.selRange.to.col + delta.col);
	      if (coords.row < 0) {
	        rowTransformDir = -1;
	        coords.row = 0;
	      } else if (coords.row > 0 && coords.row >= totalRows) {
	        rowTransformDir = 1;
	        coords.row = totalRows - 1;
	      }
	      if (coords.col < 0) {
	        colTransformDir = -1;
	        coords.col = 0;
	      } else if (coords.col > 0 && coords.col >= totalCols) {
	        colTransformDir = 1;
	        coords.col = totalCols - 1;
	      }
	      instance.runHooks('afterModifyTransformEnd', coords, rowTransformDir, colTransformDir);
	      selection.setRangeEnd(coords, true);
	    },
	    isSelected: function() {
	      return (priv.selRange !== null);
	    },
	    inInSelection: function(coords) {
	      if (!selection.isSelected()) {
	        return false;
	      }
	      return priv.selRange.includes(coords);
	    },
	    deselect: function() {
	      if (!selection.isSelected()) {
	        return;
	      }
	      instance.selection.inProgress = false;
	      priv.selRange = null;
	      instance.view.wt.selections.current.clear();
	      instance.view.wt.selections.area.clear();
	      if (priv.settings.currentRowClassName || priv.settings.currentColClassName) {
	        instance.view.wt.selections.highlight.clear();
	      }
	      editorManager.destroyEditor();
	      selection.refreshBorders();
	      Handsontable.hooks.run(instance, 'afterDeselect');
	    },
	    selectAll: function() {
	      if (!priv.settings.multiSelect) {
	        return;
	      }
	      selection.setRangeStart(new WalkontableCellCoords(0, 0));
	      selection.setRangeEnd(new WalkontableCellCoords(instance.countRows() - 1, instance.countCols() - 1), false);
	    },
	    empty: function() {
	      if (!selection.isSelected()) {
	        return;
	      }
	      var topLeft = priv.selRange.getTopLeftCorner();
	      var bottomRight = priv.selRange.getBottomRightCorner();
	      var r,
	          c,
	          changes = [];
	      for (r = topLeft.row; r <= bottomRight.row; r++) {
	        for (c = topLeft.col; c <= bottomRight.col; c++) {
	          if (!instance.getCellMeta(r, c).readOnly) {
	            changes.push([r, c, '']);
	          }
	        }
	      }
	      instance.setDataAtCell(changes);
	    }
	  };
	  this.init = function() {
	    dataSource = new DataSource(instance, priv.settings.data);
	    Handsontable.hooks.run(instance, 'beforeInit');
	    if (Handsontable.mobileBrowser) {
	      addClass(instance.rootElement, 'mobile');
	    }
	    this.updateSettings(priv.settings, true);
	    this.view = new TableView(this);
	    editorManager = new EditorManager(instance, priv, selection, datamap);
	    this.forceFullRender = true;
	    Handsontable.hooks.run(instance, 'init');
	    this.view.render();
	    if (typeof priv.firstRun === 'object') {
	      Handsontable.hooks.run(instance, 'afterChange', priv.firstRun[0], priv.firstRun[1]);
	      priv.firstRun = false;
	    }
	    Handsontable.hooks.run(instance, 'afterInit');
	  };
	  function ValidatorsQueue() {
	    var resolved = false;
	    return {
	      validatorsInQueue: 0,
	      valid: true,
	      addValidatorToQueue: function() {
	        this.validatorsInQueue++;
	        resolved = false;
	      },
	      removeValidatorFormQueue: function() {
	        this.validatorsInQueue = this.validatorsInQueue - 1 < 0 ? 0 : this.validatorsInQueue - 1;
	        this.checkIfQueueIsEmpty();
	      },
	      onQueueEmpty: function(valid) {},
	      checkIfQueueIsEmpty: function() {
	        if (this.validatorsInQueue == 0 && resolved == false) {
	          resolved = true;
	          this.onQueueEmpty(this.valid);
	        }
	      }
	    };
	  }
	  function validateChanges(changes, source, callback) {
	    var waitingForValidator = new ValidatorsQueue();
	    waitingForValidator.onQueueEmpty = resolve;
	    for (var i = changes.length - 1; i >= 0; i--) {
	      if (changes[i] === null) {
	        changes.splice(i, 1);
	      } else {
	        var row = changes[i][0];
	        var col = datamap.propToCol(changes[i][1]);
	        var logicalCol = instance.runHooks('modifyCol', col);
	        var cellProperties = instance.getCellMeta(row, logicalCol);
	        if (cellProperties.type === 'numeric' && typeof changes[i][3] === 'string') {
	          if (changes[i][3].length > 0 && (/^-?[\d\s]*(\.|\,)?\d*$/.test(changes[i][3]) || cellProperties.format)) {
	            var len = changes[i][3].length;
	            if (typeof cellProperties.language == 'undefined') {
	              numeral.language('en');
	            } else if (changes[i][3].indexOf('.') === len - 3 && changes[i][3].indexOf(',') === -1) {
	              numeral.language('en');
	            } else {
	              numeral.language(cellProperties.language);
	            }
	            if (numeral.validate(changes[i][3])) {
	              changes[i][3] = numeral().unformat(changes[i][3]);
	            }
	          }
	        }
	        if (instance.getCellValidator(cellProperties)) {
	          waitingForValidator.addValidatorToQueue();
	          instance.validateCell(changes[i][3], cellProperties, (function(i, cellProperties) {
	            return function(result) {
	              if (typeof result !== 'boolean') {
	                throw new Error('Validation error: result is not boolean');
	              }
	              if (result === false && cellProperties.allowInvalid === false) {
	                changes.splice(i, 1);
	                cellProperties.valid = true;
	                --i;
	              }
	              waitingForValidator.removeValidatorFormQueue();
	            };
	          })(i, cellProperties), source);
	        }
	      }
	    }
	    waitingForValidator.checkIfQueueIsEmpty();
	    function resolve() {
	      var beforeChangeResult;
	      if (changes.length) {
	        beforeChangeResult = Handsontable.hooks.run(instance, 'beforeChange', changes, source);
	        if (typeof beforeChangeResult === 'function') {
	          console.warn('Your beforeChange callback returns a function. It\'s not supported since Handsontable 0.12.1 (and the returned function will not be executed).');
	        } else if (beforeChangeResult === false) {
	          changes.splice(0, changes.length);
	        }
	      }
	      callback();
	    }
	  }
	  function applyChanges(changes, source) {
	    var i = changes.length - 1;
	    if (i < 0) {
	      return;
	    }
	    for (; 0 <= i; i--) {
	      if (changes[i] === null) {
	        changes.splice(i, 1);
	        continue;
	      }
	      if (changes[i][2] == null && changes[i][3] == null) {
	        continue;
	      }
	      if (priv.settings.allowInsertRow) {
	        while (changes[i][0] > instance.countRows() - 1) {
	          datamap.createRow();
	        }
	      }
	      if (instance.dataType === 'array' && priv.settings.allowInsertColumn) {
	        while (datamap.propToCol(changes[i][1]) > instance.countCols() - 1) {
	          datamap.createCol();
	        }
	      }
	      datamap.set(changes[i][0], changes[i][1], changes[i][3]);
	    }
	    instance.forceFullRender = true;
	    grid.adjustRowsAndCols();
	    Handsontable.hooks.run(instance, 'beforeChangeRender', changes, source);
	    selection.refreshBorders(null, true);
	    instance.view.wt.wtOverlays.adjustElementsSize();
	    Handsontable.hooks.run(instance, 'afterChange', changes, source || 'edit');
	  }
	  this.validateCell = function(value, cellProperties, callback, source) {
	    var validator = instance.getCellValidator(cellProperties);
	    function done(valid) {
	      var col = cellProperties.physicalCol,
	          row = cellProperties.physicalRow,
	          td = instance.getCell(row, col, true);
	      if (td) {
	        instance.view.wt.wtSettings.settings.cellRenderer(row, col, td);
	      }
	      callback(valid);
	    }
	    if (Object.prototype.toString.call(validator) === '[object RegExp]') {
	      validator = (function(validator) {
	        return function(value, callback) {
	          callback(validator.test(value));
	        };
	      })(validator);
	    }
	    if (typeof validator == 'function') {
	      value = Handsontable.hooks.run(instance, 'beforeValidate', value, cellProperties.row, cellProperties.prop, source);
	      instance._registerTimeout(setTimeout(function() {
	        validator.call(cellProperties, value, function(valid) {
	          valid = Handsontable.hooks.run(instance, 'afterValidate', valid, value, cellProperties.row, cellProperties.prop, source);
	          cellProperties.valid = valid;
	          done(valid);
	          Handsontable.hooks.run(instance, 'postAfterValidate', valid, value, cellProperties.row, cellProperties.prop, source);
	        });
	      }, 0));
	    } else {
	      cellProperties.valid = true;
	      done(cellProperties.valid);
	    }
	  };
	  function setDataInputToArray(row, propOrCol, value) {
	    if (typeof row === 'object') {
	      return row;
	    } else {
	      return [[row, propOrCol, value]];
	    }
	  }
	  this.setDataAtCell = function(row, col, value, source) {
	    var input = setDataInputToArray(row, col, value),
	        i,
	        ilen,
	        changes = [],
	        prop;
	    for (i = 0, ilen = input.length; i < ilen; i++) {
	      if (typeof input[i] !== 'object') {
	        throw new Error('Method `setDataAtCell` accepts row number or changes array of arrays as its first parameter');
	      }
	      if (typeof input[i][1] !== 'number') {
	        throw new Error('Method `setDataAtCell` accepts row and column number as its parameters. If you want to use object property name, use method `setDataAtRowProp`');
	      }
	      prop = datamap.colToProp(input[i][1]);
	      changes.push([input[i][0], prop, datamap.get(input[i][0], prop), input[i][2]]);
	    }
	    if (!source && typeof row === 'object') {
	      source = col;
	    }
	    validateChanges(changes, source, function() {
	      applyChanges(changes, source);
	    });
	  };
	  this.setDataAtRowProp = function(row, prop, value, source) {
	    var input = setDataInputToArray(row, prop, value),
	        i,
	        ilen,
	        changes = [];
	    for (i = 0, ilen = input.length; i < ilen; i++) {
	      changes.push([input[i][0], input[i][1], datamap.get(input[i][0], input[i][1]), input[i][2]]);
	    }
	    if (!source && typeof row === 'object') {
	      source = prop;
	    }
	    validateChanges(changes, source, function() {
	      applyChanges(changes, source);
	    });
	  };
	  this.listen = function() {
	    Handsontable.activeGuid = instance.guid;
	  };
	  this.unlisten = function() {
	    Handsontable.activeGuid = null;
	  };
	  this.isListening = function() {
	    return Handsontable.activeGuid === instance.guid;
	  };
	  this.destroyEditor = function(revertOriginal) {
	    selection.refreshBorders(revertOriginal);
	  };
	  this.populateFromArray = function(row, col, input, endRow, endCol, source, method, direction, deltas) {
	    var c;
	    if (!(typeof input === 'object' && typeof input[0] === 'object')) {
	      throw new Error('populateFromArray parameter `input` must be an array of arrays');
	    }
	    c = typeof endRow === 'number' ? new WalkontableCellCoords(endRow, endCol) : null;
	    return grid.populateFromArray(new WalkontableCellCoords(row, col), input, c, source, method, direction, deltas);
	  };
	  this.spliceCol = function(col, index, amount) {
	    return datamap.spliceCol.apply(datamap, arguments);
	  };
	  this.spliceRow = function(row, index, amount) {
	    return datamap.spliceRow.apply(datamap, arguments);
	  };
	  this.getSelected = function() {
	    if (selection.isSelected()) {
	      return [priv.selRange.from.row, priv.selRange.from.col, priv.selRange.to.row, priv.selRange.to.col];
	    }
	  };
	  this.getSelectedRange = function() {
	    if (selection.isSelected()) {
	      return priv.selRange;
	    }
	  };
	  this.render = function() {
	    if (instance.view) {
	      instance.renderCall = true;
	      instance.forceFullRender = true;
	      selection.refreshBorders(null, true);
	    }
	  };
	  this.loadData = function(data) {
	    if (typeof data === 'object' && data !== null) {
	      if (!(data.push && data.splice)) {
	        data = [data];
	      }
	    } else if (data === null) {
	      data = [];
	      var row;
	      for (var r = 0,
	          rlen = priv.settings.startRows; r < rlen; r++) {
	        row = [];
	        for (var c = 0,
	            clen = priv.settings.startCols; c < clen; c++) {
	          row.push(null);
	        }
	        data.push(row);
	      }
	    } else {
	      throw new Error('loadData only accepts array of objects or array of arrays (' + typeof data + ' given)');
	    }
	    priv.isPopulated = false;
	    GridSettings.prototype.data = data;
	    if (Array.isArray(priv.settings.dataSchema) || Array.isArray(data[0])) {
	      instance.dataType = 'array';
	    } else if (typeof priv.settings.dataSchema === 'function') {
	      instance.dataType = 'function';
	    } else {
	      instance.dataType = 'object';
	    }
	    datamap = new DataMap(instance, priv, GridSettings);
	    dataSource.data = data;
	    dataSource.dataType = instance.dataType;
	    dataSource.colToProp = datamap.colToProp.bind(datamap);
	    dataSource.propToCol = datamap.propToCol.bind(datamap);
	    clearCellSettingCache();
	    grid.adjustRowsAndCols();
	    Handsontable.hooks.run(instance, 'afterLoadData', priv.firstRun);
	    if (priv.firstRun) {
	      priv.firstRun = [null, 'loadData'];
	    } else {
	      Handsontable.hooks.run(instance, 'afterChange', null, 'loadData');
	      instance.render();
	    }
	    priv.isPopulated = true;
	    function clearCellSettingCache() {
	      priv.cellSettings.length = 0;
	    }
	  };
	  this.getData = function(r, c, r2, c2) {
	    if (typeof r === 'undefined') {
	      return datamap.getAll();
	    } else {
	      return datamap.getRange(new WalkontableCellCoords(r, c), new WalkontableCellCoords(r2, c2), datamap.DESTINATION_RENDERER);
	    }
	  };
	  this.getCopyableText = function(startRow, startCol, endRow, endCol) {
	    return datamap.getCopyableText(new WalkontableCellCoords(startRow, startCol), new WalkontableCellCoords(endRow, endCol));
	  };
	  this.getCopyableData = function(row, column) {
	    return datamap.getCopyable(row, datamap.colToProp(column));
	  };
	  this.getSchema = function() {
	    return datamap.getSchema();
	  };
	  this.updateSettings = function(settings, init) {
	    var i,
	        clen;
	    if (typeof settings.rows !== 'undefined') {
	      throw new Error('"rows" setting is no longer supported. do you mean startRows, minRows or maxRows?');
	    }
	    if (typeof settings.cols !== 'undefined') {
	      throw new Error('"cols" setting is no longer supported. do you mean startCols, minCols or maxCols?');
	    }
	    for (i in settings) {
	      if (i === 'data') {
	        continue;
	      } else {
	        if (Handsontable.hooks.getRegistered().indexOf(i) > -1) {
	          if (typeof settings[i] === 'function' || Array.isArray(settings[i])) {
	            instance.addHook(i, settings[i]);
	          }
	        } else {
	          if (!init && settings.hasOwnProperty(i)) {
	            GridSettings.prototype[i] = settings[i];
	          }
	        }
	      }
	    }
	    if (settings.data === void 0 && priv.settings.data === void 0) {
	      instance.loadData(null);
	    } else if (settings.data !== void 0) {
	      instance.loadData(settings.data);
	    } else if (settings.columns !== void 0) {
	      datamap.createMap();
	    }
	    clen = instance.countCols();
	    priv.cellSettings.length = 0;
	    if (clen > 0) {
	      var proto,
	          column;
	      for (i = 0; i < clen; i++) {
	        priv.columnSettings[i] = columnFactory(GridSettings, priv.columnsSettingConflicts);
	        proto = priv.columnSettings[i].prototype;
	        if (GridSettings.prototype.columns) {
	          column = GridSettings.prototype.columns[i];
	          extend(proto, column);
	          extend(proto, expandType(column));
	        }
	      }
	    }
	    if (typeof settings.cell !== 'undefined') {
	      for (i in settings.cell) {
	        if (settings.cell.hasOwnProperty(i)) {
	          var cell = settings.cell[i];
	          instance.setCellMetaObject(cell.row, cell.col, cell);
	        }
	      }
	    }
	    Handsontable.hooks.run(instance, 'afterCellMetaReset');
	    if (typeof settings.className !== 'undefined') {
	      if (GridSettings.prototype.className) {
	        removeClass(instance.rootElement, GridSettings.prototype.className);
	      }
	      if (settings.className) {
	        addClass(instance.rootElement, settings.className);
	      }
	    }
	    if (typeof settings.height != 'undefined') {
	      var height = settings.height;
	      if (typeof height == 'function') {
	        height = height();
	      }
	      instance.rootElement.style.height = height + 'px';
	    }
	    if (typeof settings.width != 'undefined') {
	      var width = settings.width;
	      if (typeof width == 'function') {
	        width = width();
	      }
	      instance.rootElement.style.width = width + 'px';
	    }
	    if (height) {
	      instance.rootElement.style.overflow = 'hidden';
	    }
	    if (!init) {
	      Handsontable.hooks.run(instance, 'afterUpdateSettings');
	    }
	    grid.adjustRowsAndCols();
	    if (instance.view && !priv.firstRun) {
	      instance.forceFullRender = true;
	      selection.refreshBorders(null, true);
	    }
	  };
	  this.getValue = function() {
	    var sel = instance.getSelected();
	    if (GridSettings.prototype.getValue) {
	      if (typeof GridSettings.prototype.getValue === 'function') {
	        return GridSettings.prototype.getValue.call(instance);
	      } else if (sel) {
	        return instance.getData()[sel[0]][GridSettings.prototype.getValue];
	      }
	    } else if (sel) {
	      return instance.getDataAtCell(sel[0], sel[1]);
	    }
	  };
	  function expandType(obj) {
	    if (!obj.hasOwnProperty('type')) {
	      return;
	    }
	    var type,
	        expandedType = {};
	    if (typeof obj.type === 'object') {
	      type = obj.type;
	    } else if (typeof obj.type === 'string') {
	      type = Handsontable.cellTypes[obj.type];
	      if (type === void 0) {
	        throw new Error('You declared cell type "' + obj.type + '" as a string that is not mapped to a known object. Cell type must be an object or a string mapped to an object in Handsontable.cellTypes');
	      }
	    }
	    for (var i in type) {
	      if (type.hasOwnProperty(i) && !obj.hasOwnProperty(i)) {
	        expandedType[i] = type[i];
	      }
	    }
	    return expandedType;
	  }
	  this.getSettings = function() {
	    return priv.settings;
	  };
	  this.clear = function() {
	    selection.selectAll();
	    selection.empty();
	  };
	  this.alter = function(action, index, amount, source, keepEmptyRows) {
	    grid.alter(action, index, amount, source, keepEmptyRows);
	  };
	  this.getCell = function(row, col, topmost) {
	    return instance.view.getCellAtCoords(new WalkontableCellCoords(row, col), topmost);
	  };
	  this.getCoords = function(elem) {
	    return this.view.wt.wtTable.getCoords.call(this.view.wt.wtTable, elem);
	  };
	  this.colToProp = function(col) {
	    return datamap.colToProp(col);
	  };
	  this.propToCol = function(prop) {
	    return datamap.propToCol(prop);
	  };
	  this.getDataAtCell = function(row, col) {
	    return datamap.get(row, datamap.colToProp(col));
	  };
	  this.getDataAtRowProp = function(row, prop) {
	    return datamap.get(row, prop);
	  };
	  this.getDataAtCol = function(col) {
	    var out = [];
	    return out.concat.apply(out, datamap.getRange(new WalkontableCellCoords(0, col), new WalkontableCellCoords(priv.settings.data.length - 1, col), datamap.DESTINATION_RENDERER));
	  };
	  this.getDataAtProp = function(prop) {
	    var out = [],
	        range;
	    range = datamap.getRange(new WalkontableCellCoords(0, datamap.propToCol(prop)), new WalkontableCellCoords(priv.settings.data.length - 1, datamap.propToCol(prop)), datamap.DESTINATION_RENDERER);
	    return out.concat.apply(out, range);
	  };
	  this.getSourceData = function(r, c, r2, c2) {
	    var data;
	    if (r === void 0) {
	      data = dataSource.getData();
	    } else {
	      data = dataSource.getByRange(new WalkontableCellCoords(r, c), new WalkontableCellCoords(r2, c2));
	    }
	    return data;
	  };
	  this.getSourceDataAtCol = function(column) {
	    return dataSource.getAtColumn(column);
	  };
	  this.getSourceDataAtRow = function(row) {
	    return dataSource.getAtRow(row);
	  };
	  this.getSourceDataAtCell = function(row, column) {
	    return dataSource.getAtCell(row, column);
	  };
	  this.getDataAtRow = function(row) {
	    var data = datamap.getRange(new WalkontableCellCoords(row, 0), new WalkontableCellCoords(row, this.countCols() - 1), datamap.DESTINATION_RENDERER);
	    return data[0];
	  };
	  this.getDataType = function(rowFrom, columnFrom, rowTo, columnTo) {
	    var $__19 = this;
	    var previousType = null;
	    var currentType = null;
	    if (rowFrom === void 0) {
	      rowFrom = 0;
	      rowTo = this.countRows();
	      columnFrom = 0;
	      columnTo = this.countCols();
	    }
	    if (rowTo === void 0) {
	      rowTo = rowFrom;
	    }
	    if (columnTo === void 0) {
	      columnTo = columnFrom;
	    }
	    var type = 'mixed';
	    rangeEach(Math.min(rowFrom, rowTo), Math.max(rowFrom, rowTo), (function(row) {
	      var isTypeEqual = true;
	      rangeEach(Math.min(columnFrom, columnTo), Math.max(columnFrom, columnTo), (function(column) {
	        var cellType = $__19.getCellMeta(row, column);
	        currentType = cellType.type;
	        if (previousType) {
	          isTypeEqual = previousType === currentType;
	        } else {
	          previousType = currentType;
	        }
	        return isTypeEqual;
	      }));
	      type = isTypeEqual ? currentType : 'mixed';
	      return isTypeEqual;
	    }));
	    return type;
	  };
	  this.removeCellMeta = function(row, col, key) {
	    var cellMeta = instance.getCellMeta(row, col);
	    if (cellMeta[key] != undefined) {
	      delete priv.cellSettings[row][col][key];
	    }
	  };
	  this.setCellMetaObject = function(row, col, prop) {
	    if (typeof prop === 'object') {
	      for (var key in prop) {
	        if (prop.hasOwnProperty(key)) {
	          var value = prop[key];
	          this.setCellMeta(row, col, key, value);
	        }
	      }
	    }
	  };
	  this.setCellMeta = function(row, col, key, val) {
	    if (!priv.cellSettings[row]) {
	      priv.cellSettings[row] = [];
	    }
	    if (!priv.cellSettings[row][col]) {
	      priv.cellSettings[row][col] = new priv.columnSettings[col]();
	    }
	    priv.cellSettings[row][col][key] = val;
	    Handsontable.hooks.run(instance, 'afterSetCellMeta', row, col, key, val);
	  };
	  this.getCellsMeta = function() {
	    return arrayFlatten(priv.cellSettings);
	  };
	  this.getCellMeta = function(row, col) {
	    var prop = datamap.colToProp(col),
	        cellProperties;
	    var physicalRow = row;
	    var physicalCol = col;
	    row = translateRowIndex(row);
	    col = translateColIndex(col);
	    if (!priv.columnSettings[col]) {
	      priv.columnSettings[col] = columnFactory(GridSettings, priv.columnsSettingConflicts);
	    }
	    if (!priv.cellSettings[row]) {
	      priv.cellSettings[row] = [];
	    }
	    if (!priv.cellSettings[row][col]) {
	      priv.cellSettings[row][col] = new priv.columnSettings[col]();
	    }
	    cellProperties = priv.cellSettings[row][col];
	    cellProperties.row = row;
	    cellProperties.col = col;
	    cellProperties.physicalRow = physicalRow;
	    cellProperties.physicalCol = physicalCol;
	    cellProperties.prop = prop;
	    cellProperties.instance = instance;
	    Handsontable.hooks.run(instance, 'beforeGetCellMeta', row, col, cellProperties);
	    extend(cellProperties, expandType(cellProperties));
	    if (cellProperties.cells) {
	      var settings = cellProperties.cells.call(cellProperties, row, col, prop);
	      if (settings) {
	        extend(cellProperties, settings);
	        extend(cellProperties, expandType(settings));
	      }
	    }
	    Handsontable.hooks.run(instance, 'afterGetCellMeta', row, col, cellProperties);
	    return cellProperties;
	  };
	  this.isColumnModificationAllowed = function() {
	    return !(instance.dataType === 'object' || instance.getSettings().columns);
	  };
	  function translateRowIndex(row) {
	    return Handsontable.hooks.run(instance, 'modifyRow', row);
	  }
	  function translateColIndex(col) {
	    return Handsontable.hooks.run(instance, 'modifyCol', col);
	  }
	  var rendererLookup = cellMethodLookupFactory('renderer');
	  this.getCellRenderer = function(row, col) {
	    var renderer = rendererLookup.call(this, row, col);
	    return getRenderer(renderer);
	  };
	  this.getCellEditor = cellMethodLookupFactory('editor');
	  this.getCellValidator = cellMethodLookupFactory('validator');
	  this.validateCells = function(callback) {
	    var waitingForValidator = new ValidatorsQueue();
	    waitingForValidator.onQueueEmpty = callback;
	    var i = instance.countRows() - 1;
	    while (i >= 0) {
	      var j = instance.countCols() - 1;
	      while (j >= 0) {
	        waitingForValidator.addValidatorToQueue();
	        instance.validateCell(instance.getDataAtCell(i, j), instance.getCellMeta(i, j), function(result) {
	          if (typeof result !== 'boolean') {
	            throw new Error('Validation error: result is not boolean');
	          }
	          if (result === false) {
	            waitingForValidator.valid = false;
	          }
	          waitingForValidator.removeValidatorFormQueue();
	        }, 'validateCells');
	        j--;
	      }
	      i--;
	    }
	    waitingForValidator.checkIfQueueIsEmpty();
	  };
	  this.getRowHeader = function(row) {
	    var rowHeader = priv.settings.rowHeaders;
	    if (row !== void 0) {
	      row = Handsontable.hooks.run(instance, 'modifyRowHeader', row);
	    }
	    if (row === void 0) {
	      rowHeader = [];
	      rangeEach(instance.countRows() - 1, (function(i) {
	        rowHeader.push(instance.getRowHeader(i));
	      }));
	    } else if (Array.isArray(rowHeader) && rowHeader[row] !== void 0) {
	      rowHeader = rowHeader[row];
	    } else if (typeof rowHeader === 'function') {
	      rowHeader = rowHeader(row);
	    } else if (rowHeader && typeof rowHeader !== 'string' && typeof rowHeader !== 'number') {
	      rowHeader = row + 1;
	    }
	    return rowHeader;
	  };
	  this.hasRowHeaders = function() {
	    return !!priv.settings.rowHeaders;
	  };
	  this.hasColHeaders = function() {
	    if (priv.settings.colHeaders !== void 0 && priv.settings.colHeaders !== null) {
	      return !!priv.settings.colHeaders;
	    }
	    for (var i = 0,
	        ilen = instance.countCols(); i < ilen; i++) {
	      if (instance.getColHeader(i)) {
	        return true;
	      }
	    }
	    return false;
	  };
	  this.getColHeader = function(col) {
	    col = Handsontable.hooks.run(instance, 'modifyColHeader', col);
	    if (col === void 0) {
	      var out = [];
	      for (var i = 0,
	          ilen = instance.countCols(); i < ilen; i++) {
	        out.push(instance.getColHeader(i));
	      }
	      return out;
	    } else {
	      var baseCol = col;
	      col = Handsontable.hooks.run(instance, 'modifyCol', col);
	      if (priv.settings.columns && priv.settings.columns[col] && priv.settings.columns[col].title) {
	        return priv.settings.columns[col].title;
	      } else if (Array.isArray(priv.settings.colHeaders) && priv.settings.colHeaders[col] !== void 0) {
	        return priv.settings.colHeaders[col];
	      } else if (typeof priv.settings.colHeaders === 'function') {
	        return priv.settings.colHeaders(col);
	      } else if (priv.settings.colHeaders && typeof priv.settings.colHeaders !== 'string' && typeof priv.settings.colHeaders !== 'number') {
	        return spreadsheetColumnLabel(baseCol);
	      } else {
	        return priv.settings.colHeaders;
	      }
	    }
	  };
	  this._getColWidthFromSettings = function(col) {
	    var cellProperties = instance.getCellMeta(0, col);
	    var width = cellProperties.width;
	    if (width === void 0 || width === priv.settings.width) {
	      width = cellProperties.colWidths;
	    }
	    if (width !== void 0 && width !== null) {
	      switch (typeof width) {
	        case 'object':
	          width = width[col];
	          break;
	        case 'function':
	          width = width(col);
	          break;
	      }
	      if (typeof width === 'string') {
	        width = parseInt(width, 10);
	      }
	    }
	    return width;
	  };
	  this.getColWidth = function(col) {
	    var width = instance._getColWidthFromSettings(col);
	    width = Handsontable.hooks.run(instance, 'modifyColWidth', width, col);
	    if (width === void 0) {
	      width = WalkontableViewportColumnsCalculator.DEFAULT_WIDTH;
	    }
	    return width;
	  };
	  this._getRowHeightFromSettings = function(row) {
	    var height = priv.settings.rowHeights;
	    if (height !== void 0 && height !== null) {
	      switch (typeof height) {
	        case 'object':
	          height = height[row];
	          break;
	        case 'function':
	          height = height(row);
	          break;
	      }
	      if (typeof height === 'string') {
	        height = parseInt(height, 10);
	      }
	    }
	    return height;
	  };
	  this.getRowHeight = function(row) {
	    var height = instance._getRowHeightFromSettings(row);
	    height = Handsontable.hooks.run(instance, 'modifyRowHeight', height, row);
	    return height;
	  };
	  this.countSourceRows = function() {
	    return instance.getSourceData() ? instance.getSourceData().length : 0;
	  };
	  this.countRows = function() {
	    return datamap.getLength();
	  };
	  this.countCols = function() {
	    if (instance.dataType === 'object' || instance.dataType === 'function') {
	      if (priv.settings.columns && priv.settings.columns.length) {
	        return priv.settings.columns.length;
	      } else {
	        return datamap.colToPropCache.length;
	      }
	    } else if (instance.dataType === 'array') {
	      if (priv.settings.columns && priv.settings.columns.length) {
	        return priv.settings.columns.length;
	      } else if (priv.settings.data && priv.settings.data[0] && priv.settings.data[0].length) {
	        return priv.settings.data[0].length;
	      } else {
	        return 0;
	      }
	    }
	  };
	  this.getColspanOffset = function(col, level) {
	    var colspanSum = 0;
	    if (instance.colspanArray) {
	      for (var i = 0; i < col; i++) {
	        colspanSum += instance.colspanArray[level][i] - 1 || 0;
	      }
	      return colspanSum;
	    }
	    var colspanSum = 0;
	    var TRindex = instance.view.wt.wtTable.THEAD.childNodes.length - level - 1;
	    var TR = instance.view.wt.wtTable.THEAD.querySelector('tr:nth-child(' + parseInt(TRindex + 1, 10) + ')');
	    var rowHeadersCount = instance.view.wt.wtSettings.settings.rowHeaders().length;
	    for (var i = rowHeadersCount; i < rowHeadersCount + col; i++) {
	      if (TR.childNodes[i].hasAttribute('colspan')) {
	        colspanSum += parseInt(TR.childNodes[i].getAttribute('colspan'), 10) - 1;
	      }
	    }
	    return colspanSum;
	  };
	  this.getHeaderColspan = function(col, level) {
	    var TRindex = instance.view.wt.wtTable.THEAD.childNodes.length - level - 1;
	    var rowHeadersCount = instance.view.wt.wtSettings.settings.rowHeaders().length;
	    var TR = instance.view.wt.wtTable.THEAD.querySelector('tr:nth-child(' + parseInt(TRindex + 1, 10) + ')');
	    var offsettedColIndex = rowHeadersCount + col - instance.view.wt.wtViewport.columnsRenderCalculator.startColumn;
	    if (TR.childNodes[offsettedColIndex].hasAttribute('colspan')) {
	      return parseInt(TR.childNodes[offsettedColIndex].getAttribute('colspan'), 10);
	    }
	    return 0;
	  };
	  this.rowOffset = function() {
	    return instance.view.wt.wtTable.getFirstRenderedRow();
	  };
	  this.colOffset = function() {
	    return instance.view.wt.wtTable.getFirstRenderedColumn();
	  };
	  this.countRenderedRows = function() {
	    return instance.view.wt.drawn ? instance.view.wt.wtTable.getRenderedRowsCount() : -1;
	  };
	  this.countVisibleRows = function() {
	    return instance.view.wt.drawn ? instance.view.wt.wtTable.getVisibleRowsCount() : -1;
	  };
	  this.countRenderedCols = function() {
	    return instance.view.wt.drawn ? instance.view.wt.wtTable.getRenderedColumnsCount() : -1;
	  };
	  this.countVisibleCols = function() {
	    return instance.view.wt.drawn ? instance.view.wt.wtTable.getVisibleColumnsCount() : -1;
	  };
	  this.countEmptyRows = function(ending) {
	    var i = instance.countRows() - 1,
	        empty = 0,
	        row;
	    while (i >= 0) {
	      row = Handsontable.hooks.run(this, 'modifyRow', i);
	      if (instance.isEmptyRow(row)) {
	        empty++;
	      } else if (ending) {
	        break;
	      }
	      i--;
	    }
	    return empty;
	  };
	  this.countEmptyCols = function(ending) {
	    if (instance.countRows() < 1) {
	      return 0;
	    }
	    var i = instance.countCols() - 1,
	        empty = 0;
	    while (i >= 0) {
	      if (instance.isEmptyCol(i)) {
	        empty++;
	      } else if (ending) {
	        break;
	      }
	      i--;
	    }
	    return empty;
	  };
	  this.isEmptyRow = function(row) {
	    return priv.settings.isEmptyRow.call(instance, row);
	  };
	  this.isEmptyCol = function(col) {
	    return priv.settings.isEmptyCol.call(instance, col);
	  };
	  this.selectCell = function(row, col, endRow, endCol, scrollToCell, changeListener) {
	    var coords;
	    changeListener = typeof changeListener === 'undefined' || changeListener === true;
	    if (typeof row !== 'number' || row < 0 || row >= instance.countRows()) {
	      return false;
	    }
	    if (typeof col !== 'number' || col < 0 || col >= instance.countCols()) {
	      return false;
	    }
	    if (typeof endRow !== 'undefined') {
	      if (typeof endRow !== 'number' || endRow < 0 || endRow >= instance.countRows()) {
	        return false;
	      }
	      if (typeof endCol !== 'number' || endCol < 0 || endCol >= instance.countCols()) {
	        return false;
	      }
	    }
	    coords = new WalkontableCellCoords(row, col);
	    priv.selRange = new WalkontableCellRange(coords, coords, coords);
	    if (changeListener) {
	      instance.listen();
	    }
	    if (typeof endRow === 'undefined') {
	      selection.setRangeEnd(priv.selRange.from, scrollToCell);
	    } else {
	      selection.setRangeEnd(new WalkontableCellCoords(endRow, endCol), scrollToCell);
	    }
	    instance.selection.finish();
	    return true;
	  };
	  this.selectCellByProp = function(row, prop, endRow, endProp, scrollToCell) {
	    arguments[1] = datamap.propToCol(arguments[1]);
	    if (typeof arguments[3] !== 'undefined') {
	      arguments[3] = datamap.propToCol(arguments[3]);
	    }
	    return instance.selectCell.apply(instance, arguments);
	  };
	  this.deselectCell = function() {
	    selection.deselect();
	  };
	  this.destroy = function() {
	    instance._clearTimeouts();
	    if (instance.view) {
	      instance.view.destroy();
	    }
	    if (dataSource) {
	      dataSource.destroy();
	    }
	    dataSource = null;
	    empty(instance.rootElement);
	    eventManager.destroy();
	    Handsontable.hooks.run(instance, 'afterDestroy');
	    Handsontable.hooks.destroy(instance);
	    for (var i in instance) {
	      if (instance.hasOwnProperty(i)) {
	        if (typeof instance[i] === 'function') {
	          instance[i] = postMortem;
	        } else if (i !== 'guid') {
	          instance[i] = null;
	        }
	      }
	    }
	    priv = null;
	    datamap = null;
	    grid = null;
	    selection = null;
	    editorManager = null;
	    instance = null;
	    GridSettings = null;
	  };
	  function postMortem() {
	    throw new Error('This method cannot be called because this Handsontable instance has been destroyed');
	  }
	  this.getActiveEditor = function() {
	    return editorManager.getActiveEditor();
	  };
	  this.getPlugin = function(pluginName) {
	    return getPlugin(this, pluginName);
	  };
	  this.getInstance = function() {
	    return instance;
	  };
	  this.addHook = function(key, callback) {
	    Handsontable.hooks.add(key, callback, instance);
	  };
	  this.addHookOnce = function(key, callback) {
	    Handsontable.hooks.once(key, callback, instance);
	  };
	  this.removeHook = function(key, callback) {
	    Handsontable.hooks.remove(key, callback, instance);
	  };
	  this.runHooks = function(key, p1, p2, p3, p4, p5, p6) {
	    return Handsontable.hooks.run(instance, key, p1, p2, p3, p4, p5, p6);
	  };
	  this.timeouts = [];
	  this._registerTimeout = function(handle) {
	    this.timeouts.push(handle);
	  };
	  this._clearTimeouts = function() {
	    for (var i = 0,
	        ilen = this.timeouts.length; i < ilen; i++) {
	      clearTimeout(this.timeouts[i]);
	    }
	  };
	  this.version = Handsontable.version;
	  Handsontable.hooks.run(instance, 'construct');
	};
	var DefaultSettings = function() {};
	DefaultSettings.prototype = {
	  data: void 0,
	  dataSchema: void 0,
	  width: void 0,
	  height: void 0,
	  startRows: 5,
	  startCols: 5,
	  rowHeaders: null,
	  colHeaders: null,
	  colWidths: void 0,
	  columns: void 0,
	  cells: void 0,
	  cell: [],
	  comments: false,
	  customBorders: false,
	  minRows: 0,
	  minCols: 0,
	  maxRows: Infinity,
	  maxCols: Infinity,
	  minSpareRows: 0,
	  minSpareCols: 0,
	  allowInsertRow: true,
	  allowInsertColumn: true,
	  allowRemoveRow: true,
	  allowRemoveColumn: true,
	  multiSelect: true,
	  fillHandle: true,
	  fixedRowsTop: 0,
	  fixedRowsBottom: 0,
	  fixedColumnsLeft: 0,
	  outsideClickDeselects: true,
	  enterBeginsEditing: true,
	  enterMoves: {
	    row: 1,
	    col: 0
	  },
	  tabMoves: {
	    row: 0,
	    col: 1
	  },
	  autoWrapRow: false,
	  autoWrapCol: false,
	  copyRowsLimit: 1000,
	  copyColsLimit: 1000,
	  pasteMode: 'overwrite',
	  persistentState: false,
	  currentRowClassName: void 0,
	  currentColClassName: void 0,
	  className: void 0,
	  tableClassName: void 0,
	  stretchH: 'none',
	  isEmptyRow: function(row) {
	    var col,
	        colLen,
	        value,
	        meta;
	    for (col = 0, colLen = this.countCols(); col < colLen; col++) {
	      value = this.getDataAtCell(row, col);
	      if (value !== '' && value !== null && typeof value !== 'undefined') {
	        if (typeof value === 'object') {
	          meta = this.getCellMeta(row, col);
	          return isObjectEquals(this.getSchema()[meta.prop], value);
	        }
	        return false;
	      }
	    }
	    return true;
	  },
	  isEmptyCol: function(col) {
	    var row,
	        rowLen,
	        value;
	    for (row = 0, rowLen = this.countRows(); row < rowLen; row++) {
	      value = this.getDataAtCell(row, col);
	      if (value !== '' && value !== null && typeof value !== 'undefined') {
	        return false;
	      }
	    }
	    return true;
	  },
	  observeDOMVisibility: true,
	  allowInvalid: true,
	  invalidCellClassName: 'htInvalid',
	  placeholder: false,
	  placeholderCellClassName: 'htPlaceholder',
	  readOnlyCellClassName: 'htDimmed',
	  renderer: void 0,
	  commentedCellClassName: 'htCommentCell',
	  fragmentSelection: false,
	  readOnly: false,
	  skipColumnOnPaste: false,
	  search: false,
	  type: 'text',
	  copyable: true,
	  editor: void 0,
	  autoComplete: void 0,
	  visibleRows: 10,
	  trimDropdown: true,
	  debug: false,
	  wordWrap: true,
	  noWordWrapClassName: 'htNoWrap',
	  contextMenu: void 0,
	  contextMenuCopyPaste: void 0,
	  copyPaste: void 0,
	  undo: void 0,
	  columnSorting: void 0,
	  manualColumnMove: void 0,
	  manualColumnResize: void 0,
	  manualRowMove: void 0,
	  manualRowResize: void 0,
	  mergeCells: false,
	  viewportRowRenderingOffset: 'auto',
	  viewportColumnRenderingOffset: 'auto',
	  validator: void 0,
	  disableVisualSelection: false,
	  sortIndicator: false,
	  manualColumnFreeze: void 0,
	  trimWhitespace: true,
	  settings: void 0,
	  source: void 0,
	  title: void 0,
	  checkedTemplate: void 0,
	  uncheckedTemplate: void 0,
	  label: void 0,
	  format: void 0,
	  language: void 0,
	  selectOptions: void 0,
	  autoColumnSize: void 0,
	  autoRowSize: void 0,
	  dateFormat: void 0,
	  correctFormat: false,
	  defaultDate: void 0,
	  strict: void 0,
	  renderAllRows: void 0
	};
	Handsontable.DefaultSettings = DefaultSettings;

	//# 
	},{"3rdparty/walkontable/src/calculator/viewportColumns":3,"3rdparty/walkontable/src/cell/coords":5,"3rdparty/walkontable/src/cell/range":6,"3rdparty/walkontable/src/selection":18,"dataMap":26,"dataSource":27,"editorManager":28,"eventManager":41,"helpers/array":42,"helpers/data":44,"helpers/dom/element":45,"helpers/number":49,"helpers/object":50,"helpers/setting":51,"helpers/string":52,"numeral":"numeral","plugins":57,"renderers":88,"tableView":97}],26:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  DataMap: {get: function() {
	      return DataMap;
	    }},
	  __esModule: {value: true}
	});
	var $__SheetClip__,
	    $__helpers_47_data__,
	    $__helpers_47_setting__,
	    $__helpers_47_object__,
	    $__helpers_47_array__,
	    $__helpers_47_number__,
	    $__multiMap__;
	var SheetClip = ($__SheetClip__ = require("SheetClip"), $__SheetClip__ && $__SheetClip__.__esModule && $__SheetClip__ || {default: $__SheetClip__}).default;
	var cellMethodLookupFactory = ($__helpers_47_data__ = require("helpers/data"), $__helpers_47_data__ && $__helpers_47_data__.__esModule && $__helpers_47_data__ || {default: $__helpers_47_data__}).cellMethodLookupFactory;
	var columnFactory = ($__helpers_47_setting__ = require("helpers/setting"), $__helpers_47_setting__ && $__helpers_47_setting__.__esModule && $__helpers_47_setting__ || {default: $__helpers_47_setting__}).columnFactory;
	var $__3 = ($__helpers_47_object__ = require("helpers/object"), $__helpers_47_object__ && $__helpers_47_object__.__esModule && $__helpers_47_object__ || {default: $__helpers_47_object__}),
	    duckSchema = $__3.duckSchema,
	    deepExtend = $__3.deepExtend;
	var $__4 = ($__helpers_47_array__ = require("helpers/array"), $__helpers_47_array__ && $__helpers_47_array__.__esModule && $__helpers_47_array__ || {default: $__helpers_47_array__}),
	    extendArray = $__4.extendArray,
	    to2dArray = $__4.to2dArray;
	var rangeEach = ($__helpers_47_number__ = require("helpers/number"), $__helpers_47_number__ && $__helpers_47_number__.__esModule && $__helpers_47_number__ || {default: $__helpers_47_number__}).rangeEach;
	var MultiMap = ($__multiMap__ = require("multiMap"), $__multiMap__ && $__multiMap__.__esModule && $__multiMap__ || {default: $__multiMap__}).MultiMap;
	function DataMap(instance, priv, GridSettings) {
	  this.instance = instance;
	  this.priv = priv;
	  this.GridSettings = GridSettings;
	  this.dataSource = this.instance.getSettings().data;
	  if (this.dataSource[0]) {
	    this.duckSchema = this.recursiveDuckSchema(this.dataSource[0]);
	  } else {
	    this.duckSchema = {};
	  }
	  this.createMap();
	}
	DataMap.prototype.DESTINATION_RENDERER = 1;
	DataMap.prototype.DESTINATION_CLIPBOARD_GENERATOR = 2;
	DataMap.prototype.recursiveDuckSchema = function(object) {
	  return duckSchema(object);
	};
	DataMap.prototype.recursiveDuckColumns = function(schema, lastCol, parent) {
	  var prop,
	      i;
	  if (typeof lastCol === 'undefined') {
	    lastCol = 0;
	    parent = '';
	  }
	  if (typeof schema === 'object' && !Array.isArray(schema)) {
	    for (i in schema) {
	      if (schema.hasOwnProperty(i)) {
	        if (schema[i] === null) {
	          prop = parent + i;
	          this.colToPropCache.push(prop);
	          this.propToColCache.set(prop, lastCol);
	          lastCol++;
	        } else {
	          lastCol = this.recursiveDuckColumns(schema[i], lastCol, i + '.');
	        }
	      }
	    }
	  }
	  return lastCol;
	};
	DataMap.prototype.createMap = function() {
	  var i,
	      ilen,
	      schema = this.getSchema();
	  if (typeof schema === 'undefined') {
	    throw new Error('trying to create `columns` definition but you didnt\' provide `schema` nor `data`');
	  }
	  this.colToPropCache = [];
	  this.propToColCache = new MultiMap();
	  var columns = this.instance.getSettings().columns;
	  if (columns) {
	    for (i = 0, ilen = columns.length; i < ilen; i++) {
	      if (typeof columns[i].data != 'undefined') {
	        this.colToPropCache[i] = columns[i].data;
	        this.propToColCache.set(columns[i].data, i);
	      }
	    }
	  } else {
	    this.recursiveDuckColumns(schema);
	  }
	};
	DataMap.prototype.colToProp = function(col) {
	  col = Handsontable.hooks.run(this.instance, 'modifyCol', col);
	  if (this.colToPropCache && typeof this.colToPropCache[col] !== 'undefined') {
	    return this.colToPropCache[col];
	  }
	  return col;
	};
	DataMap.prototype.propToCol = function(prop) {
	  var col;
	  if (typeof this.propToColCache.get(prop) === 'undefined') {
	    col = prop;
	  } else {
	    col = this.propToColCache.get(prop);
	  }
	  col = Handsontable.hooks.run(this.instance, 'modifyCol', col);
	  return col;
	};
	DataMap.prototype.getSchema = function() {
	  var schema = this.instance.getSettings().dataSchema;
	  if (schema) {
	    if (typeof schema === 'function') {
	      return schema();
	    }
	    return schema;
	  }
	  return this.duckSchema;
	};
	DataMap.prototype.createRow = function(index, amount, createdAutomatically) {
	  var row,
	      colCount = this.instance.countCols(),
	      numberOfCreatedRows = 0,
	      currentIndex;
	  if (!amount) {
	    amount = 1;
	  }
	  if (typeof index !== 'number' || index >= this.instance.countSourceRows()) {
	    index = this.instance.countSourceRows();
	  }
	  currentIndex = index;
	  var maxRows = this.instance.getSettings().maxRows;
	  while (numberOfCreatedRows < amount && this.instance.countSourceRows() < maxRows) {
	    if (this.instance.dataType === 'array') {
	      row = [];
	      for (var c = 0; c < colCount; c++) {
	        row.push(null);
	      }
	    } else if (this.instance.dataType === 'function') {
	      row = this.instance.getSettings().dataSchema(index);
	    } else {
	      row = {};
	      deepExtend(row, this.getSchema());
	    }
	    if (index === this.instance.countSourceRows()) {
	      this.dataSource.push(row);
	    } else {
	      this.dataSource.splice(index, 0, row);
	    }
	    numberOfCreatedRows++;
	    currentIndex++;
	  }
	  Handsontable.hooks.run(this.instance, 'afterCreateRow', index, numberOfCreatedRows, createdAutomatically);
	  this.instance.forceFullRender = true;
	  return numberOfCreatedRows;
	};
	DataMap.prototype.createCol = function(index, amount, createdAutomatically) {
	  if (!this.instance.isColumnModificationAllowed()) {
	    throw new Error('Cannot create new column. When data source in an object, ' + 'you can only have as much columns as defined in first data row, data schema or in the \'columns\' setting.' + 'If you want to be able to add new columns, you have to use array datasource.');
	  }
	  var rlen = this.instance.countSourceRows(),
	      data = this.dataSource,
	      constructor,
	      numberOfCreatedCols = 0,
	      currentIndex;
	  if (!amount) {
	    amount = 1;
	  }
	  currentIndex = index;
	  var maxCols = this.instance.getSettings().maxCols;
	  while (numberOfCreatedCols < amount && this.instance.countCols() < maxCols) {
	    constructor = columnFactory(this.GridSettings, this.priv.columnsSettingConflicts);
	    if (typeof index !== 'number' || index >= this.instance.countCols()) {
	      for (var r = 0; r < rlen; r++) {
	        if (typeof data[r] === 'undefined') {
	          data[r] = [];
	        }
	        data[r].push(null);
	      }
	      this.priv.columnSettings.push(constructor);
	    } else {
	      for (var r = 0; r < rlen; r++) {
	        data[r].splice(currentIndex, 0, null);
	      }
	      this.priv.columnSettings.splice(currentIndex, 0, constructor);
	    }
	    numberOfCreatedCols++;
	    currentIndex++;
	  }
	  Handsontable.hooks.run(this.instance, 'afterCreateCol', index, numberOfCreatedCols, createdAutomatically);
	  this.instance.forceFullRender = true;
	  return numberOfCreatedCols;
	};
	DataMap.prototype.removeRow = function(index, amount) {
	  if (!amount) {
	    amount = 1;
	  }
	  if (typeof index !== 'number') {
	    index = -amount;
	  }
	  index = (this.instance.countSourceRows() + index) % this.instance.countSourceRows();
	  var logicRows = this.physicalRowsToLogical(index, amount);
	  var actionWasNotCancelled = Handsontable.hooks.run(this.instance, 'beforeRemoveRow', index, amount, logicRows);
	  if (actionWasNotCancelled === false) {
	    return;
	  }
	  var data = this.dataSource;
	  var newData = data.filter(function(row, index) {
	    return logicRows.indexOf(index) == -1;
	  });
	  data.length = 0;
	  Array.prototype.push.apply(data, newData);
	  Handsontable.hooks.run(this.instance, 'afterRemoveRow', index, amount, logicRows);
	  this.instance.forceFullRender = true;
	};
	DataMap.prototype.removeCol = function(index, amount) {
	  if (this.instance.dataType === 'object' || this.instance.getSettings().columns) {
	    throw new Error('cannot remove column with object data source or columns option specified');
	  }
	  if (!amount) {
	    amount = 1;
	  }
	  if (typeof index !== 'number') {
	    index = -amount;
	  }
	  index = (this.instance.countCols() + index) % this.instance.countCols();
	  var actionWasNotCancelled = Handsontable.hooks.run(this.instance, 'beforeRemoveCol', index, amount);
	  if (actionWasNotCancelled === false) {
	    return;
	  }
	  var data = this.dataSource;
	  for (var r = 0,
	      rlen = this.instance.countSourceRows(); r < rlen; r++) {
	    data[r].splice(index, amount);
	  }
	  this.priv.columnSettings.splice(index, amount);
	  Handsontable.hooks.run(this.instance, 'afterRemoveCol', index, amount);
	  this.instance.forceFullRender = true;
	};
	DataMap.prototype.spliceCol = function(col, index, amount) {
	  var elements = 4 <= arguments.length ? [].slice.call(arguments, 3) : [];
	  var colData = this.instance.getDataAtCol(col);
	  var removed = colData.slice(index, index + amount);
	  var after = colData.slice(index + amount);
	  extendArray(elements, after);
	  var i = 0;
	  while (i < amount) {
	    elements.push(null);
	    i++;
	  }
	  to2dArray(elements);
	  this.instance.populateFromArray(index, col, elements, null, null, 'spliceCol');
	  return removed;
	};
	DataMap.prototype.spliceRow = function(row, index, amount) {
	  var elements = 4 <= arguments.length ? [].slice.call(arguments, 3) : [];
	  var rowData = this.instance.getSourceDataAtRow(row);
	  var removed = rowData.slice(index, index + amount);
	  var after = rowData.slice(index + amount);
	  extendArray(elements, after);
	  var i = 0;
	  while (i < amount) {
	    elements.push(null);
	    i++;
	  }
	  this.instance.populateFromArray(row, index, [elements], null, null, 'spliceRow');
	  return removed;
	};
	DataMap.prototype.get = function(row, prop) {
	  row = Handsontable.hooks.run(this.instance, 'modifyRow', row);
	  if (typeof prop === 'string' && prop.indexOf('.') > -1) {
	    var sliced = prop.split('.');
	    var out = this.dataSource[row];
	    if (!out) {
	      return null;
	    }
	    for (var i = 0,
	        ilen = sliced.length; i < ilen; i++) {
	      out = out[sliced[i]];
	      if (typeof out === 'undefined') {
	        return null;
	      }
	    }
	    return out;
	  } else if (typeof prop === 'function') {
	    return prop(this.dataSource.slice(row, row + 1)[0]);
	  }
	  if (this.dataSource[row] && this.dataSource[row].hasOwnProperty && this.dataSource[row].hasOwnProperty(prop)) {
	    return this.dataSource[row][prop];
	  }
	  return null;
	};
	var copyableLookup = cellMethodLookupFactory('copyable', false);
	DataMap.prototype.getCopyable = function(row, prop) {
	  if (copyableLookup.call(this.instance, row, this.propToCol(prop))) {
	    return this.get(row, prop);
	  }
	  return '';
	};
	DataMap.prototype.set = function(row, prop, value, source) {
	  row = Handsontable.hooks.run(this.instance, 'modifyRow', row, source || 'datamapGet');
	  if (typeof prop === 'string' && prop.indexOf('.') > -1) {
	    var sliced = prop.split('.');
	    var out = this.dataSource[row];
	    for (var i = 0,
	        ilen = sliced.length - 1; i < ilen; i++) {
	      if (typeof out[sliced[i]] === 'undefined') {
	        out[sliced[i]] = {};
	      }
	      out = out[sliced[i]];
	    }
	    out[sliced[i]] = value;
	  } else if (typeof prop === 'function') {
	    prop(this.dataSource.slice(row, row + 1)[0], value);
	  } else {
	    this.dataSource[row][prop] = value;
	  }
	};
	DataMap.prototype.physicalRowsToLogical = function(index, amount) {
	  var totalRows = this.instance.countSourceRows();
	  var physicRow = (totalRows + index) % totalRows;
	  var logicRows = [];
	  var rowsToRemove = amount;
	  var row;
	  while (physicRow < totalRows && rowsToRemove) {
	    row = Handsontable.hooks.run(this.instance, 'modifyRow', physicRow);
	    logicRows.push(row);
	    rowsToRemove--;
	    physicRow++;
	  }
	  return logicRows;
	};
	DataMap.prototype.clear = function() {
	  for (var r = 0; r < this.instance.countSourceRows(); r++) {
	    for (var c = 0; c < this.instance.countCols(); c++) {
	      this.set(r, this.colToProp(c), '');
	    }
	  }
	};
	DataMap.prototype.getLength = function() {
	  var $__7 = this;
	  var length = this.instance.countSourceRows();
	  if (Handsontable.hooks.has('modifyRow', this.instance)) {
	    rangeEach(this.instance.countSourceRows() - 1, (function(row) {
	      row = Handsontable.hooks.run($__7.instance, 'modifyRow', row);
	      if (row === null) {
	        length--;
	      }
	    }));
	  }
	  return length;
	};
	DataMap.prototype.getAll = function() {
	  var start = {
	    row: 0,
	    col: 0
	  };
	  var end = {
	    row: Math.max(this.instance.countSourceRows() - 1, 0),
	    col: Math.max(this.instance.countCols() - 1, 0)
	  };
	  if (start.row - end.row === 0 && !this.instance.countSourceRows()) {
	    return [];
	  }
	  return this.getRange(start, end, DataMap.prototype.DESTINATION_RENDERER);
	};
	DataMap.prototype.getRange = function(start, end, destination) {
	  var r,
	      rlen,
	      c,
	      clen,
	      output = [],
	      row,
	      rowExists;
	  var getFn = destination === this.DESTINATION_CLIPBOARD_GENERATOR ? this.getCopyable : this.get;
	  rlen = Math.max(start.row, end.row);
	  clen = Math.max(start.col, end.col);
	  for (r = Math.min(start.row, end.row); r <= rlen; r++) {
	    row = [];
	    var physicalRow = Handsontable.hooks.run(this.instance, 'modifyRow', r);
	    for (c = Math.min(start.col, end.col); c <= clen; c++) {
	      var rowValue;
	      if (physicalRow === null) {
	        break;
	      }
	      row.push(getFn.call(this, r, this.colToProp(c)));
	    }
	    if (physicalRow !== null) {
	      output.push(row);
	    }
	  }
	  return output;
	};
	DataMap.prototype.getText = function(start, end) {
	  return SheetClip.stringify(this.getRange(start, end, this.DESTINATION_RENDERER));
	};
	DataMap.prototype.getCopyableText = function(start, end) {
	  return SheetClip.stringify(this.getRange(start, end, this.DESTINATION_CLIPBOARD_GENERATOR));
	};
	;
	Handsontable.DataMap = DataMap;

	//# 
	},{"SheetClip":"SheetClip","helpers/array":42,"helpers/data":44,"helpers/number":49,"helpers/object":50,"helpers/setting":51,"multiMap":55}],27:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  DataSource: {get: function() {
	      return DataSource;
	    }},
	  __esModule: {value: true}
	});
	var $__helpers_47_data__,
	    $__helpers_47_setting__,
	    $__helpers_47_object__,
	    $__helpers_47_array__,
	    $__helpers_47_number__;
	var cellMethodLookupFactory = ($__helpers_47_data__ = require("helpers/data"), $__helpers_47_data__ && $__helpers_47_data__.__esModule && $__helpers_47_data__ || {default: $__helpers_47_data__}).cellMethodLookupFactory;
	var columnFactory = ($__helpers_47_setting__ = require("helpers/setting"), $__helpers_47_setting__ && $__helpers_47_setting__.__esModule && $__helpers_47_setting__ || {default: $__helpers_47_setting__}).columnFactory;
	var $__2 = ($__helpers_47_object__ = require("helpers/object"), $__helpers_47_object__ && $__helpers_47_object__.__esModule && $__helpers_47_object__ || {default: $__helpers_47_object__}),
	    duckSchema = $__2.duckSchema,
	    deepExtend = $__2.deepExtend,
	    getProperty = $__2.getProperty;
	var $__3 = ($__helpers_47_array__ = require("helpers/array"), $__helpers_47_array__ && $__helpers_47_array__.__esModule && $__helpers_47_array__ || {default: $__helpers_47_array__}),
	    extendArray = $__3.extendArray,
	    arrayEach = $__3.arrayEach;
	var rangeEach = ($__helpers_47_number__ = require("helpers/number"), $__helpers_47_number__ && $__helpers_47_number__.__esModule && $__helpers_47_number__ || {default: $__helpers_47_number__}).rangeEach;
	var DataSource = function DataSource(hotInstance, dataSource) {
	  this.hot = hotInstance;
	  this.data = dataSource;
	  this.dataType = 'array';
	  this.colToProp = (function() {});
	  this.propToCol = (function() {});
	};
	($traceurRuntime.createClass)(DataSource, {
	  getData: function() {
	    return this.data;
	  },
	  getAtColumn: function(column) {
	    var $__5 = this;
	    var result = [];
	    arrayEach(this.data, (function(row) {
	      var property = $__5.colToProp(column);
	      if (typeof property === 'string') {
	        row = getProperty(row, property);
	      } else {
	        row = row[property];
	      }
	      result.push(row);
	    }));
	    return result;
	  },
	  getAtRow: function(row) {
	    return this.data[row];
	  },
	  getAtCell: function(row, column) {
	    return this.data[row][this.colToProp(column)];
	  },
	  getByRange: function(start, end) {
	    var $__5 = this;
	    var startRow = Math.min(start.row, end.row);
	    var startCol = Math.min(start.col, end.col);
	    var endRow = Math.max(start.row, end.row);
	    var endCol = Math.max(start.col, end.col);
	    var result = [];
	    rangeEach(startRow, endRow, (function(currentRow) {
	      var row = $__5.getAtRow(currentRow);
	      var newRow;
	      if ($__5.dataType === 'array') {
	        newRow = row.slice(startCol, endCol);
	      } else if ($__5.dataType === 'object') {
	        newRow = {};
	        rangeEach(startCol, endCol, (function(column) {
	          var prop = $__5.colToProp(column);
	          newRow[prop] = row[prop];
	        }));
	      }
	      result.push(newRow);
	    }));
	    return result;
	  },
	  destroy: function() {
	    this.data = null;
	    this.hot = null;
	  }
	}, {});
	;

	//# 
	},{"helpers/array":42,"helpers/data":44,"helpers/number":49,"helpers/object":50,"helpers/setting":51}],28:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  EditorManager: {get: function() {
	      return EditorManager;
	    }},
	  __esModule: {value: true}
	});
	var $__3rdparty_47_walkontable_47_src_47_cell_47_coords__,
	    $__helpers_47_unicode__,
	    $__helpers_47_dom_47_event__,
	    $__editors__,
	    $__eventManager__;
	var WalkontableCellCoords = ($__3rdparty_47_walkontable_47_src_47_cell_47_coords__ = require("3rdparty/walkontable/src/cell/coords"), $__3rdparty_47_walkontable_47_src_47_cell_47_coords__ && $__3rdparty_47_walkontable_47_src_47_cell_47_coords__.__esModule && $__3rdparty_47_walkontable_47_src_47_cell_47_coords__ || {default: $__3rdparty_47_walkontable_47_src_47_cell_47_coords__}).WalkontableCellCoords;
	var $__1 = ($__helpers_47_unicode__ = require("helpers/unicode"), $__helpers_47_unicode__ && $__helpers_47_unicode__.__esModule && $__helpers_47_unicode__ || {default: $__helpers_47_unicode__}),
	    KEY_CODES = $__1.KEY_CODES,
	    isMetaKey = $__1.isMetaKey,
	    isCtrlKey = $__1.isCtrlKey;
	var $__2 = ($__helpers_47_dom_47_event__ = require("helpers/dom/event"), $__helpers_47_dom_47_event__ && $__helpers_47_dom_47_event__.__esModule && $__helpers_47_dom_47_event__ || {default: $__helpers_47_dom_47_event__}),
	    stopPropagation = $__2.stopPropagation,
	    stopImmediatePropagation = $__2.stopImmediatePropagation,
	    isImmediatePropagationStopped = $__2.isImmediatePropagationStopped;
	var getEditor = ($__editors__ = require("editors"), $__editors__ && $__editors__.__esModule && $__editors__ || {default: $__editors__}).getEditor;
	var eventManagerObject = ($__eventManager__ = require("eventManager"), $__eventManager__ && $__eventManager__.__esModule && $__eventManager__ || {default: $__eventManager__}).eventManager;
	;
	Handsontable.EditorManager = EditorManager;
	function EditorManager(instance, priv, selection) {
	  var _this = this,
	      destroyed = false,
	      eventManager,
	      activeEditor;
	  eventManager = eventManagerObject(instance);
	  function moveSelectionAfterEnter(shiftKey) {
	    var enterMoves = typeof priv.settings.enterMoves === 'function' ? priv.settings.enterMoves(event) : priv.settings.enterMoves;
	    if (shiftKey) {
	      selection.transformStart(-enterMoves.row, -enterMoves.col);
	    } else {
	      selection.transformStart(enterMoves.row, enterMoves.col, true);
	    }
	  }
	  function moveSelectionUp(shiftKey) {
	    if (shiftKey) {
	      selection.transformEnd(-1, 0);
	    } else {
	      selection.transformStart(-1, 0);
	    }
	  }
	  function moveSelectionDown(shiftKey) {
	    if (shiftKey) {
	      selection.transformEnd(1, 0);
	    } else {
	      selection.transformStart(1, 0);
	    }
	  }
	  function moveSelectionRight(shiftKey) {
	    if (shiftKey) {
	      selection.transformEnd(0, 1);
	    } else {
	      selection.transformStart(0, 1);
	    }
	  }
	  function moveSelectionLeft(shiftKey) {
	    if (shiftKey) {
	      selection.transformEnd(0, -1);
	    } else {
	      selection.transformStart(0, -1);
	    }
	  }
	  function onKeyDown(event) {
	    var ctrlDown,
	        rangeModifier;
	    if (!instance.isListening()) {
	      return;
	    }
	    Handsontable.hooks.run(instance, 'beforeKeyDown', event);
	    if (destroyed) {
	      return;
	    }
	    if (isImmediatePropagationStopped(event)) {
	      return;
	    }
	    priv.lastKeyCode = event.keyCode;
	    if (!selection.isSelected()) {
	      return;
	    }
	    ctrlDown = (event.ctrlKey || event.metaKey) && !event.altKey;
	    if (activeEditor && !activeEditor.isWaiting()) {
	      if (!isMetaKey(event.keyCode) && !isCtrlKey(event.keyCode) && !ctrlDown && !_this.isEditorOpened()) {
	        _this.openEditor('', event);
	        return;
	      }
	    }
	    rangeModifier = event.shiftKey ? selection.setRangeEnd : selection.setRangeStart;
	    switch (event.keyCode) {
	      case KEY_CODES.A:
	        if (!_this.isEditorOpened() && ctrlDown) {
	          selection.selectAll();
	          event.preventDefault();
	          stopPropagation(event);
	        }
	        break;
	      case KEY_CODES.ARROW_UP:
	        if (_this.isEditorOpened() && !activeEditor.isWaiting()) {
	          _this.closeEditorAndSaveChanges(ctrlDown);
	        }
	        moveSelectionUp(event.shiftKey);
	        event.preventDefault();
	        stopPropagation(event);
	        break;
	      case KEY_CODES.ARROW_DOWN:
	        if (_this.isEditorOpened() && !activeEditor.isWaiting()) {
	          _this.closeEditorAndSaveChanges(ctrlDown);
	        }
	        moveSelectionDown(event.shiftKey);
	        event.preventDefault();
	        stopPropagation(event);
	        break;
	      case KEY_CODES.ARROW_RIGHT:
	        if (_this.isEditorOpened() && !activeEditor.isWaiting()) {
	          _this.closeEditorAndSaveChanges(ctrlDown);
	        }
	        moveSelectionRight(event.shiftKey);
	        event.preventDefault();
	        stopPropagation(event);
	        break;
	      case KEY_CODES.ARROW_LEFT:
	        if (_this.isEditorOpened() && !activeEditor.isWaiting()) {
	          _this.closeEditorAndSaveChanges(ctrlDown);
	        }
	        moveSelectionLeft(event.shiftKey);
	        event.preventDefault();
	        stopPropagation(event);
	        break;
	      case KEY_CODES.TAB:
	        var tabMoves = typeof priv.settings.tabMoves === 'function' ? priv.settings.tabMoves(event) : priv.settings.tabMoves;
	        if (event.shiftKey) {
	          selection.transformStart(-tabMoves.row, -tabMoves.col);
	        } else {
	          selection.transformStart(tabMoves.row, tabMoves.col, true);
	        }
	        event.preventDefault();
	        stopPropagation(event);
	        break;
	      case KEY_CODES.BACKSPACE:
	      case KEY_CODES.DELETE:
	        selection.empty(event);
	        _this.prepareEditor();
	        event.preventDefault();
	        break;
	      case KEY_CODES.F2:
	        _this.openEditor(null, event);
	        if (activeEditor) {
	          activeEditor.enableFullEditMode();
	        }
	        event.preventDefault();
	        break;
	      case KEY_CODES.ENTER:
	        if (_this.isEditorOpened()) {
	          if (activeEditor && activeEditor.state !== Handsontable.EditorState.WAITING) {
	            _this.closeEditorAndSaveChanges(ctrlDown);
	          }
	          moveSelectionAfterEnter(event.shiftKey);
	        } else {
	          if (instance.getSettings().enterBeginsEditing) {
	            _this.openEditor(null, event);
	            if (activeEditor) {
	              activeEditor.enableFullEditMode();
	            }
	          } else {
	            moveSelectionAfterEnter(event.shiftKey);
	          }
	        }
	        event.preventDefault();
	        stopImmediatePropagation(event);
	        break;
	      case KEY_CODES.ESCAPE:
	        if (_this.isEditorOpened()) {
	          _this.closeEditorAndRestoreOriginalValue(ctrlDown);
	        }
	        event.preventDefault();
	        break;
	      case KEY_CODES.HOME:
	        if (event.ctrlKey || event.metaKey) {
	          rangeModifier(new WalkontableCellCoords(0, priv.selRange.from.col));
	        } else {
	          rangeModifier(new WalkontableCellCoords(priv.selRange.from.row, 0));
	        }
	        event.preventDefault();
	        stopPropagation(event);
	        break;
	      case KEY_CODES.END:
	        if (event.ctrlKey || event.metaKey) {
	          rangeModifier(new WalkontableCellCoords(instance.countRows() - 1, priv.selRange.from.col));
	        } else {
	          rangeModifier(new WalkontableCellCoords(priv.selRange.from.row, instance.countCols() - 1));
	        }
	        event.preventDefault();
	        stopPropagation(event);
	        break;
	      case KEY_CODES.PAGE_UP:
	        selection.transformStart(-instance.countVisibleRows(), 0);
	        event.preventDefault();
	        stopPropagation(event);
	        break;
	      case KEY_CODES.PAGE_DOWN:
	        selection.transformStart(instance.countVisibleRows(), 0);
	        event.preventDefault();
	        stopPropagation(event);
	        break;
	    }
	  }
	  function init() {
	    instance.addHook('afterDocumentKeyDown', onKeyDown);
	    eventManager.addEventListener(document.documentElement, 'keydown', function(event) {
	      instance.runHooks('afterDocumentKeyDown', event);
	    });
	    function onDblClick(event, coords, elem) {
	      if (elem.nodeName == 'TD') {
	        _this.openEditor();
	        if (activeEditor) {
	          activeEditor.enableFullEditMode();
	        }
	      }
	    }
	    instance.view.wt.update('onCellDblClick', onDblClick);
	    instance.addHook('afterDestroy', function() {
	      destroyed = true;
	    });
	  }
	  this.destroyEditor = function(revertOriginal) {
	    this.closeEditor(revertOriginal);
	  };
	  this.getActiveEditor = function() {
	    return activeEditor;
	  };
	  this.prepareEditor = function() {
	    var row,
	        col,
	        prop,
	        td,
	        originalValue,
	        cellProperties,
	        editorClass;
	    if (activeEditor && activeEditor.isWaiting()) {
	      this.closeEditor(false, false, function(dataSaved) {
	        if (dataSaved) {
	          _this.prepareEditor();
	        }
	      });
	      return;
	    }
	    row = priv.selRange.highlight.row;
	    col = priv.selRange.highlight.col;
	    prop = instance.colToProp(col);
	    td = instance.getCell(row, col);
	    originalValue = instance.getDataAtCell(row, col);
	    cellProperties = instance.getCellMeta(row, col);
	    editorClass = instance.getCellEditor(cellProperties);
	    if (editorClass) {
	      activeEditor = Handsontable.editors.getEditor(editorClass, instance);
	      activeEditor.prepare(row, col, prop, td, originalValue, cellProperties);
	    } else {
	      activeEditor = void 0;
	    }
	  };
	  this.isEditorOpened = function() {
	    return activeEditor && activeEditor.isOpened();
	  };
	  this.openEditor = function(initialValue, event) {
	    if (activeEditor && !activeEditor.cellProperties.readOnly) {
	      activeEditor.beginEditing(initialValue, event);
	    } else if (activeEditor && activeEditor.cellProperties.readOnly) {
	      if (event && event.keyCode === KEY_CODES.ENTER) {
	        moveSelectionAfterEnter();
	      }
	    }
	  };
	  this.closeEditor = function(restoreOriginalValue, ctrlDown, callback) {
	    if (activeEditor) {
	      activeEditor.finishEditing(restoreOriginalValue, ctrlDown, callback);
	    } else {
	      if (callback) {
	        callback(false);
	      }
	    }
	  };
	  this.closeEditorAndSaveChanges = function(ctrlDown) {
	    return this.closeEditor(false, ctrlDown);
	  };
	  this.closeEditorAndRestoreOriginalValue = function(ctrlDown) {
	    return this.closeEditor(true, ctrlDown);
	  };
	  init();
	}

	//# 
	},{"3rdparty/walkontable/src/cell/coords":5,"editors":29,"eventManager":41,"helpers/dom/event":46,"helpers/unicode":53}],29:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  registerEditor: {get: function() {
	      return registerEditor;
	    }},
	  getEditor: {get: function() {
	      return getEditor;
	    }},
	  hasEditor: {get: function() {
	      return hasEditor;
	    }},
	  getEditorConstructor: {get: function() {
	      return getEditorConstructor;
	    }},
	  __esModule: {value: true}
	});
	var $__helpers_47_string__;
	var toUpperCaseFirst = ($__helpers_47_string__ = require("helpers/string"), $__helpers_47_string__ && $__helpers_47_string__.__esModule && $__helpers_47_string__ || {default: $__helpers_47_string__}).toUpperCaseFirst;
	;
	var registeredEditorNames = {},
	    registeredEditorClasses = new WeakMap();
	Handsontable.editors = Handsontable.editors || {};
	Handsontable.editors.registerEditor = registerEditor;
	Handsontable.editors.getEditor = getEditor;
	function RegisteredEditor(editorClass) {
	  var Clazz,
	      instances;
	  instances = {};
	  Clazz = editorClass;
	  this.getConstructor = function() {
	    return editorClass;
	  };
	  this.getInstance = function(hotInstance) {
	    if (!(hotInstance.guid in instances)) {
	      instances[hotInstance.guid] = new Clazz(hotInstance);
	    }
	    return instances[hotInstance.guid];
	  };
	}
	function registerEditor(editorName, editorClass) {
	  var editor = new RegisteredEditor(editorClass);
	  if (typeof editorName === 'string') {
	    registeredEditorNames[editorName] = editor;
	    Handsontable.editors[toUpperCaseFirst(editorName) + 'Editor'] = editorClass;
	  }
	  registeredEditorClasses.set(editorClass, editor);
	}
	function getEditor(editorName, hotInstance) {
	  var editor;
	  if (typeof editorName == 'function') {
	    if (!(registeredEditorClasses.get(editorName))) {
	      registerEditor(null, editorName);
	    }
	    editor = registeredEditorClasses.get(editorName);
	  } else if (typeof editorName == 'string') {
	    editor = registeredEditorNames[editorName];
	  } else {
	    throw Error('Only strings and functions can be passed as "editor" parameter ');
	  }
	  if (!editor) {
	    throw Error('No editor registered under name "' + editorName + '"');
	  }
	  return editor.getInstance(hotInstance);
	}
	function getEditorConstructor(editorName) {
	  var editor;
	  if (typeof editorName == 'string') {
	    editor = registeredEditorNames[editorName];
	  } else {
	    throw Error('Only strings and functions can be passed as "editor" parameter ');
	  }
	  if (!editor) {
	    throw Error('No editor registered under name "' + editorName + '"');
	  }
	  return editor.getConstructor();
	}
	function hasEditor(editorName) {
	  return registeredEditorNames[editorName] ? true : false;
	}

	//# 
	},{"helpers/string":52}],30:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  BaseEditor: {get: function() {
	      return BaseEditor;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47_helpers_47_mixed__,
	    $___46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_coords__;
	var stringify = ($___46__46__47_helpers_47_mixed__ = require("helpers/mixed"), $___46__46__47_helpers_47_mixed__ && $___46__46__47_helpers_47_mixed__.__esModule && $___46__46__47_helpers_47_mixed__ || {default: $___46__46__47_helpers_47_mixed__}).stringify;
	var WalkontableCellCoords = ($___46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_coords__ = require("3rdparty/walkontable/src/cell/coords"), $___46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_coords__ && $___46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_coords__.__esModule && $___46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_coords__ || {default: $___46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_coords__}).WalkontableCellCoords;
	;
	Handsontable.editors = Handsontable.editors || {};
	Handsontable.editors.BaseEditor = BaseEditor;
	Handsontable.EditorState = {
	  VIRGIN: 'STATE_VIRGIN',
	  EDITING: 'STATE_EDITING',
	  WAITING: 'STATE_WAITING',
	  FINISHED: 'STATE_FINISHED'
	};
	function BaseEditor(instance) {
	  this.instance = instance;
	  this.state = Handsontable.EditorState.VIRGIN;
	  this._opened = false;
	  this._fullEditMode = false;
	  this._closeCallback = null;
	  this.init();
	}
	BaseEditor.prototype._fireCallbacks = function(result) {
	  if (this._closeCallback) {
	    this._closeCallback(result);
	    this._closeCallback = null;
	  }
	};
	BaseEditor.prototype.init = function() {};
	BaseEditor.prototype.getValue = function() {
	  throw Error('Editor getValue() method unimplemented');
	};
	BaseEditor.prototype.setValue = function(newValue) {
	  throw Error('Editor setValue() method unimplemented');
	};
	BaseEditor.prototype.open = function() {
	  throw Error('Editor open() method unimplemented');
	};
	BaseEditor.prototype.close = function() {
	  throw Error('Editor close() method unimplemented');
	};
	BaseEditor.prototype.prepare = function(row, col, prop, td, originalValue, cellProperties) {
	  this.TD = td;
	  this.row = row;
	  this.col = col;
	  this.prop = prop;
	  this.originalValue = originalValue;
	  this.cellProperties = cellProperties;
	  this.state = Handsontable.EditorState.VIRGIN;
	};
	BaseEditor.prototype.extend = function() {
	  var baseClass = this.constructor;
	  function Editor() {
	    baseClass.apply(this, arguments);
	  }
	  function inherit(Child, Parent) {
	    function Bridge() {}
	    Bridge.prototype = Parent.prototype;
	    Child.prototype = new Bridge();
	    Child.prototype.constructor = Child;
	    return Child;
	  }
	  return inherit(Editor, baseClass);
	};
	BaseEditor.prototype.saveValue = function(val, ctrlDown) {
	  var sel,
	      tmp;
	  if (ctrlDown) {
	    sel = this.instance.getSelected();
	    if (sel[0] > sel[2]) {
	      tmp = sel[0];
	      sel[0] = sel[2];
	      sel[2] = tmp;
	    }
	    if (sel[1] > sel[3]) {
	      tmp = sel[1];
	      sel[1] = sel[3];
	      sel[3] = tmp;
	    }
	    this.instance.populateFromArray(sel[0], sel[1], val, sel[2], sel[3], 'edit');
	  } else {
	    this.instance.populateFromArray(this.row, this.col, val, null, null, 'edit');
	  }
	};
	BaseEditor.prototype.beginEditing = function(initialValue, event) {
	  if (this.state != Handsontable.EditorState.VIRGIN) {
	    return;
	  }
	  this.instance.view.scrollViewport(new WalkontableCellCoords(this.row, this.col));
	  this.instance.view.render();
	  this.state = Handsontable.EditorState.EDITING;
	  initialValue = typeof initialValue == 'string' ? initialValue : this.originalValue;
	  this.setValue(stringify(initialValue));
	  this.open(event);
	  this._opened = true;
	  this.focus();
	  this.instance.view.render();
	};
	BaseEditor.prototype.finishEditing = function(restoreOriginalValue, ctrlDown, callback) {
	  var _this = this,
	      val;
	  if (callback) {
	    var previousCloseCallback = this._closeCallback;
	    this._closeCallback = function(result) {
	      if (previousCloseCallback) {
	        previousCloseCallback(result);
	      }
	      callback(result);
	    };
	  }
	  if (this.isWaiting()) {
	    return;
	  }
	  if (this.state == Handsontable.EditorState.VIRGIN) {
	    this.instance._registerTimeout(setTimeout(function() {
	      _this._fireCallbacks(true);
	    }, 0));
	    return;
	  }
	  if (this.state == Handsontable.EditorState.EDITING) {
	    if (restoreOriginalValue) {
	      this.cancelChanges();
	      this.instance.view.render();
	      return;
	    }
	    if (this.instance.getSettings().trimWhitespace) {
	      val = [[typeof this.getValue() === 'string' ? String.prototype.trim.call(this.getValue() || '') : this.getValue()]];
	    } else {
	      val = [[this.getValue()]];
	    }
	    this.state = Handsontable.EditorState.WAITING;
	    this.saveValue(val, ctrlDown);
	    if (this.instance.getCellValidator(this.cellProperties)) {
	      this.instance.addHookOnce('postAfterValidate', function(result) {
	        _this.state = Handsontable.EditorState.FINISHED;
	        _this.discardEditor(result);
	      });
	    } else {
	      this.state = Handsontable.EditorState.FINISHED;
	      this.discardEditor(true);
	    }
	  }
	};
	BaseEditor.prototype.cancelChanges = function() {
	  this.state = Handsontable.EditorState.FINISHED;
	  this.discardEditor();
	};
	BaseEditor.prototype.discardEditor = function(result) {
	  if (this.state !== Handsontable.EditorState.FINISHED) {
	    return;
	  }
	  if (result === false && this.cellProperties.allowInvalid !== true) {
	    this.instance.selectCell(this.row, this.col);
	    this.focus();
	    this.state = Handsontable.EditorState.EDITING;
	    this._fireCallbacks(false);
	  } else {
	    this.close();
	    this._opened = false;
	    this._fullEditMode = false;
	    this.state = Handsontable.EditorState.VIRGIN;
	    this._fireCallbacks(true);
	  }
	};
	BaseEditor.prototype.enableFullEditMode = function() {
	  this._fullEditMode = true;
	};
	BaseEditor.prototype.isInFullEditMode = function() {
	  return this._fullEditMode;
	};
	BaseEditor.prototype.isOpened = function() {
	  return this._opened;
	};
	BaseEditor.prototype.isWaiting = function() {
	  return this.state === Handsontable.EditorState.WAITING;
	};
	BaseEditor.prototype.checkEditorSection = function() {
	  var totalRows = this.instance.countRows();
	  var section = '';
	  if (this.row < this.instance.getSettings().fixedRowsTop) {
	    if (this.col < this.instance.getSettings().fixedColumnsLeft) {
	      section = 'top-left-corner';
	    } else {
	      section = 'top';
	    }
	  } else if (this.instance.getSettings().fixedRowsBottom && this.row >= totalRows - this.instance.getSettings().fixedRowsBottom) {
	    if (this.col < this.instance.getSettings().fixedColumnsLeft) {
	      section = 'bottom-left-corner';
	    } else {
	      section = 'bottom';
	    }
	  } else {
	    if (this.col < this.instance.getSettings().fixedColumnsLeft) {
	      section = 'left';
	    }
	  }
	  return section;
	};

	//# 
	},{"3rdparty/walkontable/src/cell/coords":5,"helpers/mixed":48}],31:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  AutocompleteEditor: {get: function() {
	      return AutocompleteEditor;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47_helpers_47_unicode__,
	    $___46__46__47_helpers_47_mixed__,
	    $___46__46__47_helpers_47_array__,
	    $___46__46__47_helpers_47_dom_47_element__,
	    $___46__46__47_editors__,
	    $__handsontableEditor__;
	var $__0 = ($___46__46__47_helpers_47_unicode__ = require("helpers/unicode"), $___46__46__47_helpers_47_unicode__ && $___46__46__47_helpers_47_unicode__.__esModule && $___46__46__47_helpers_47_unicode__ || {default: $___46__46__47_helpers_47_unicode__}),
	    KEY_CODES = $__0.KEY_CODES,
	    isPrintableChar = $__0.isPrintableChar;
	var stringify = ($___46__46__47_helpers_47_mixed__ = require("helpers/mixed"), $___46__46__47_helpers_47_mixed__ && $___46__46__47_helpers_47_mixed__.__esModule && $___46__46__47_helpers_47_mixed__ || {default: $___46__46__47_helpers_47_mixed__}).stringify;
	var pivot = ($___46__46__47_helpers_47_array__ = require("helpers/array"), $___46__46__47_helpers_47_array__ && $___46__46__47_helpers_47_array__.__esModule && $___46__46__47_helpers_47_array__ || {default: $___46__46__47_helpers_47_array__}).pivot;
	var $__3 = ($___46__46__47_helpers_47_dom_47_element__ = require("helpers/dom/element"), $___46__46__47_helpers_47_dom_47_element__ && $___46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47_helpers_47_dom_47_element__}),
	    addClass = $__3.addClass,
	    getCaretPosition = $__3.getCaretPosition,
	    getScrollbarWidth = $__3.getScrollbarWidth,
	    getSelectionEndPosition = $__3.getSelectionEndPosition,
	    outerWidth = $__3.outerWidth,
	    setCaretPosition = $__3.setCaretPosition;
	var $__4 = ($___46__46__47_editors__ = require("editors"), $___46__46__47_editors__ && $___46__46__47_editors__.__esModule && $___46__46__47_editors__ || {default: $___46__46__47_editors__}),
	    getEditorConstructor = $__4.getEditorConstructor,
	    registerEditor = $__4.registerEditor;
	var HandsontableEditor = ($__handsontableEditor__ = require("handsontableEditor"), $__handsontableEditor__ && $__handsontableEditor__.__esModule && $__handsontableEditor__ || {default: $__handsontableEditor__}).HandsontableEditor;
	var AutocompleteEditor = HandsontableEditor.prototype.extend();
	AutocompleteEditor.prototype.init = function() {
	  HandsontableEditor.prototype.init.apply(this, arguments);
	  this.query = null;
	  this.choices = [];
	};
	AutocompleteEditor.prototype.createElements = function() {
	  HandsontableEditor.prototype.createElements.apply(this, arguments);
	  addClass(this.htContainer, 'autocompleteEditor');
	  addClass(this.htContainer, window.navigator.platform.indexOf('Mac') === -1 ? '' : 'htMacScroll');
	};
	var skipOne = false;
	function onBeforeKeyDown(event) {
	  skipOne = false;
	  var editor = this.getActiveEditor();
	  if (isPrintableChar(event.keyCode) || event.keyCode === KEY_CODES.BACKSPACE || event.keyCode === KEY_CODES.DELETE || event.keyCode === KEY_CODES.INSERT) {
	    var timeOffset = 0;
	    if (event.keyCode === KEY_CODES.C && (event.ctrlKey || event.metaKey)) {
	      return;
	    }
	    if (!editor.isOpened()) {
	      timeOffset += 10;
	    }
	    if (editor.htEditor) {
	      editor.instance._registerTimeout(setTimeout(function() {
	        editor.queryChoices(editor.TEXTAREA.value);
	        skipOne = true;
	      }, timeOffset));
	    }
	  }
	}
	AutocompleteEditor.prototype.prepare = function() {
	  this.instance.addHook('beforeKeyDown', onBeforeKeyDown);
	  HandsontableEditor.prototype.prepare.apply(this, arguments);
	};
	AutocompleteEditor.prototype.open = function() {
	  this.TEXTAREA_PARENT.style.overflow = 'auto';
	  HandsontableEditor.prototype.open.apply(this, arguments);
	  this.TEXTAREA_PARENT.style.overflow = '';
	  var choicesListHot = this.htEditor.getInstance();
	  var that = this;
	  var trimDropdown = this.cellProperties.trimDropdown === void 0 ? true : this.cellProperties.trimDropdown;
	  this.TEXTAREA.style.visibility = 'visible';
	  this.focus();
	  choicesListHot.updateSettings({
	    colWidths: trimDropdown ? [outerWidth(this.TEXTAREA) - 2] : void 0,
	    width: trimDropdown ? outerWidth(this.TEXTAREA) + getScrollbarWidth() + 2 : void 0,
	    afterRenderer: function(TD, row, col, prop, value) {
	      var caseSensitive = this.getCellMeta(row, col).filteringCaseSensitive === true,
	          indexOfMatch,
	          match,
	          value = stringify(value);
	      if (value) {
	        indexOfMatch = caseSensitive ? value.indexOf(this.query) : value.toLowerCase().indexOf(that.query.toLowerCase());
	        if (indexOfMatch != -1) {
	          match = value.substr(indexOfMatch, that.query.length);
	          TD.innerHTML = value.replace(match, '<strong>' + match + '</strong>');
	        }
	      }
	    },
	    autoColumnSize: true,
	    modifyColWidth: function(width, col) {
	      var autoWidths = this.getPlugin('autoColumnSize').widths;
	      if (autoWidths[col]) {
	        width = autoWidths[col];
	      }
	      return trimDropdown ? width : width + 15;
	    }
	  });
	  this.htEditor.view.wt.wtTable.holder.parentNode.style['padding-right'] = getScrollbarWidth() + 2 + 'px';
	  if (skipOne) {
	    skipOne = false;
	  }
	  that.instance._registerTimeout(setTimeout(function() {
	    that.queryChoices(that.TEXTAREA.value);
	  }, 0));
	};
	AutocompleteEditor.prototype.close = function() {
	  HandsontableEditor.prototype.close.apply(this, arguments);
	};
	AutocompleteEditor.prototype.queryChoices = function(query) {
	  this.query = query;
	  if (typeof this.cellProperties.source == 'function') {
	    var that = this;
	    this.cellProperties.source(query, function(choices) {
	      that.updateChoicesList(choices);
	    });
	  } else if (Array.isArray(this.cellProperties.source)) {
	    var choices;
	    if (!query || this.cellProperties.filter === false) {
	      choices = this.cellProperties.source;
	    } else {
	      var filteringCaseSensitive = this.cellProperties.filteringCaseSensitive === true;
	      var lowerCaseQuery = query.toLowerCase();
	      choices = this.cellProperties.source.filter(function(choice) {
	        if (filteringCaseSensitive) {
	          return choice.indexOf(query) != -1;
	        } else {
	          return choice.toLowerCase().indexOf(lowerCaseQuery) != -1;
	        }
	      });
	    }
	    this.updateChoicesList(choices);
	  } else {
	    this.updateChoicesList([]);
	  }
	};
	AutocompleteEditor.prototype.updateChoicesList = function(choices) {
	  var pos = getCaretPosition(this.TEXTAREA),
	      endPos = getSelectionEndPosition(this.TEXTAREA);
	  var orderByRelevance = AutocompleteEditor.sortByRelevance(this.getValue(), choices, this.cellProperties.filteringCaseSensitive);
	  var highlightIndex;
	  if (this.cellProperties.filter == false) {
	    highlightIndex = orderByRelevance[0];
	  } else {
	    var sorted = [];
	    for (var i = 0,
	        choicesCount = orderByRelevance.length; i < choicesCount; i++) {
	      sorted.push(choices[orderByRelevance[i]]);
	    }
	    highlightIndex = 0;
	    choices = sorted;
	  }
	  this.choices = choices;
	  this.htEditor.loadData(pivot([choices]));
	  this.updateDropdownHeight();
	  if (this.cellProperties.strict === true) {
	    this.highlightBestMatchingChoice(highlightIndex);
	  }
	  this.instance.listen();
	  this.TEXTAREA.focus();
	  setCaretPosition(this.TEXTAREA, pos, (pos == endPos ? void 0 : endPos));
	};
	AutocompleteEditor.prototype.updateDropdownHeight = function() {
	  var currentDropdownWidth = this.htEditor.getColWidth(0) + getScrollbarWidth() + 2;
	  var trimDropdown = this.cellProperties.trimDropdown === void 0 ? true : this.cellProperties.trimDropdown;
	  this.htEditor.updateSettings({
	    height: this.getDropdownHeight(),
	    width: trimDropdown ? void 0 : currentDropdownWidth
	  });
	  this.htEditor.view.wt.wtTable.alignOverlaysWithTrimmingContainer();
	};
	AutocompleteEditor.prototype.finishEditing = function(restoreOriginalValue) {
	  if (!restoreOriginalValue) {
	    this.instance.removeHook('beforeKeyDown', onBeforeKeyDown);
	  }
	  HandsontableEditor.prototype.finishEditing.apply(this, arguments);
	};
	AutocompleteEditor.prototype.highlightBestMatchingChoice = function(index) {
	  if (typeof index === 'number') {
	    this.htEditor.selectCell(index, 0);
	  } else {
	    this.htEditor.deselectCell();
	  }
	};
	AutocompleteEditor.sortByRelevance = function(value, choices, caseSensitive) {
	  var choicesRelevance = [],
	      currentItem,
	      valueLength = value.length,
	      valueIndex,
	      charsLeft,
	      result = [],
	      i,
	      choicesCount;
	  if (valueLength === 0) {
	    for (i = 0, choicesCount = choices.length; i < choicesCount; i++) {
	      result.push(i);
	    }
	    return result;
	  }
	  for (i = 0, choicesCount = choices.length; i < choicesCount; i++) {
	    currentItem = stringify(choices[i]);
	    if (caseSensitive) {
	      valueIndex = currentItem.indexOf(value);
	    } else {
	      valueIndex = currentItem.toLowerCase().indexOf(value.toLowerCase());
	    }
	    if (valueIndex == -1) {
	      continue;
	    }
	    charsLeft = currentItem.length - valueIndex - valueLength;
	    choicesRelevance.push({
	      baseIndex: i,
	      index: valueIndex,
	      charsLeft: charsLeft,
	      value: currentItem
	    });
	  }
	  choicesRelevance.sort(function(a, b) {
	    if (b.index === -1) {
	      return -1;
	    }
	    if (a.index === -1) {
	      return 1;
	    }
	    if (a.index < b.index) {
	      return -1;
	    } else if (b.index < a.index) {
	      return 1;
	    } else if (a.index === b.index) {
	      if (a.charsLeft < b.charsLeft) {
	        return -1;
	      } else if (a.charsLeft > b.charsLeft) {
	        return 1;
	      } else {
	        return 0;
	      }
	    }
	  });
	  for (i = 0, choicesCount = choicesRelevance.length; i < choicesCount; i++) {
	    result.push(choicesRelevance[i].baseIndex);
	  }
	  return result;
	};
	AutocompleteEditor.prototype.getDropdownHeight = function() {
	  var firstRowHeight = this.htEditor.getInstance().getRowHeight(0) || 23;
	  var _visibleRows = this.cellProperties.visibleRows;
	  return this.choices.length >= _visibleRows ? _visibleRows * firstRowHeight : this.choices.length * firstRowHeight + 8;
	};
	AutocompleteEditor.prototype.allowKeyEventPropagation = function(keyCode) {
	  var selected = {row: this.htEditor.getSelectedRange() ? this.htEditor.getSelectedRange().from.row : -1};
	  var allowed = false;
	  if (keyCode === KEY_CODES.ARROW_DOWN && selected.row < this.htEditor.countRows() - 1) {
	    allowed = true;
	  }
	  if (keyCode === KEY_CODES.ARROW_UP && selected.row > -1) {
	    allowed = true;
	  }
	  return allowed;
	};
	;
	registerEditor('autocomplete', AutocompleteEditor);

	//# 
	},{"editors":29,"handsontableEditor":35,"helpers/array":42,"helpers/dom/element":45,"helpers/mixed":48,"helpers/unicode":53}],32:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  CheckboxEditor: {get: function() {
	      return CheckboxEditor;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47_editors__,
	    $___95_baseEditor__,
	    $___46__46__47_helpers_47_dom_47_element__;
	var registerEditor = ($___46__46__47_editors__ = require("editors"), $___46__46__47_editors__ && $___46__46__47_editors__.__esModule && $___46__46__47_editors__ || {default: $___46__46__47_editors__}).registerEditor;
	var BaseEditor = ($___95_baseEditor__ = require("_baseEditor"), $___95_baseEditor__ && $___95_baseEditor__.__esModule && $___95_baseEditor__ || {default: $___95_baseEditor__}).BaseEditor;
	var hasClass = ($___46__46__47_helpers_47_dom_47_element__ = require("helpers/dom/element"), $___46__46__47_helpers_47_dom_47_element__ && $___46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47_helpers_47_dom_47_element__}).hasClass;
	var CheckboxEditor = function CheckboxEditor() {
	  $traceurRuntime.superConstructor($CheckboxEditor).apply(this, arguments);
	};
	var $CheckboxEditor = CheckboxEditor;
	($traceurRuntime.createClass)(CheckboxEditor, {
	  beginEditing: function() {
	    var checkbox = this.TD.querySelector('input[type="checkbox"]');
	    if (!hasClass(checkbox, 'htBadValue')) {
	      checkbox.click();
	    }
	  },
	  finishEditing: function() {},
	  init: function() {},
	  open: function() {},
	  close: function() {},
	  getValue: function() {},
	  setValue: function() {},
	  focus: function() {}
	}, {}, BaseEditor);
	;
	registerEditor('checkbox', CheckboxEditor);

	//# 
	},{"_baseEditor":30,"editors":29,"helpers/dom/element":45}],33:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  DateEditor: {get: function() {
	      return DateEditor;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47_helpers_47_dom_47_element__,
	    $___46__46__47_helpers_47_object__,
	    $___46__46__47_eventManager__,
	    $___46__46__47_editors__,
	    $___46__46__47_helpers_47_unicode__,
	    $___46__46__47_helpers_47_dom_47_event__,
	    $__textEditor__,
	    $__moment__,
	    $__pikaday__;
	var $__0 = ($___46__46__47_helpers_47_dom_47_element__ = require("helpers/dom/element"), $___46__46__47_helpers_47_dom_47_element__ && $___46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47_helpers_47_dom_47_element__}),
	    addClass = $__0.addClass,
	    outerHeight = $__0.outerHeight;
	var deepExtend = ($___46__46__47_helpers_47_object__ = require("helpers/object"), $___46__46__47_helpers_47_object__ && $___46__46__47_helpers_47_object__.__esModule && $___46__46__47_helpers_47_object__ || {default: $___46__46__47_helpers_47_object__}).deepExtend;
	var EventManager = ($___46__46__47_eventManager__ = require("eventManager"), $___46__46__47_eventManager__ && $___46__46__47_eventManager__.__esModule && $___46__46__47_eventManager__ || {default: $___46__46__47_eventManager__}).EventManager;
	var $__3 = ($___46__46__47_editors__ = require("editors"), $___46__46__47_editors__ && $___46__46__47_editors__.__esModule && $___46__46__47_editors__ || {default: $___46__46__47_editors__}),
	    getEditor = $__3.getEditor,
	    registerEditor = $__3.registerEditor;
	var isMetaKey = ($___46__46__47_helpers_47_unicode__ = require("helpers/unicode"), $___46__46__47_helpers_47_unicode__ && $___46__46__47_helpers_47_unicode__.__esModule && $___46__46__47_helpers_47_unicode__ || {default: $___46__46__47_helpers_47_unicode__}).isMetaKey;
	var stopPropagation = ($___46__46__47_helpers_47_dom_47_event__ = require("helpers/dom/event"), $___46__46__47_helpers_47_dom_47_event__ && $___46__46__47_helpers_47_dom_47_event__.__esModule && $___46__46__47_helpers_47_dom_47_event__ || {default: $___46__46__47_helpers_47_dom_47_event__}).stopPropagation;
	var TextEditor = ($__textEditor__ = require("textEditor"), $__textEditor__ && $__textEditor__.__esModule && $__textEditor__ || {default: $__textEditor__}).TextEditor;
	var moment = ($__moment__ = require("moment"), $__moment__ && $__moment__.__esModule && $__moment__ || {default: $__moment__}).default;
	var Pikaday = ($__pikaday__ = require("pikaday"), $__pikaday__ && $__pikaday__.__esModule && $__pikaday__ || {default: $__pikaday__}).default;
	Handsontable.editors = Handsontable.editors || {};
	Handsontable.editors.DateEditor = DateEditor;
	var DateEditor = function DateEditor(hotInstance) {
	  this.$datePicker = null;
	  this.datePicker = null;
	  this.datePickerStyle = null;
	  this.defaultDateFormat = 'DD/MM/YYYY';
	  this.isCellEdited = false;
	  this.parentDestroyed = false;
	  $traceurRuntime.superConstructor($DateEditor).call(this, hotInstance);
	};
	var $DateEditor = DateEditor;
	($traceurRuntime.createClass)(DateEditor, {
	  init: function() {
	    var $__9 = this;
	    if (typeof moment !== 'function') {
	      throw new Error('You need to include moment.js to your project.');
	    }
	    if (typeof Pikaday !== 'function') {
	      throw new Error('You need to include Pikaday to your project.');
	    }
	    $traceurRuntime.superGet(this, $DateEditor.prototype, "init").call(this);
	    this.instance.addHook('afterDestroy', (function() {
	      $__9.parentDestroyed = true;
	      $__9.destroyElements();
	    }));
	  },
	  createElements: function() {
	    $traceurRuntime.superGet(this, $DateEditor.prototype, "createElements").call(this);
	    this.datePicker = document.createElement('DIV');
	    this.datePickerStyle = this.datePicker.style;
	    this.datePickerStyle.position = 'absolute';
	    this.datePickerStyle.top = 0;
	    this.datePickerStyle.left = 0;
	    this.datePickerStyle.zIndex = 9999;
	    addClass(this.datePicker, 'htDatepickerHolder');
	    document.body.appendChild(this.datePicker);
	    this.$datePicker = new Pikaday(this.getDatePickerConfig());
	    var eventManager = new EventManager(this);
	    eventManager.addEventListener(this.datePicker, 'mousedown', (function(event) {
	      return stopPropagation(event);
	    }));
	    this.hideDatepicker();
	  },
	  destroyElements: function() {
	    this.$datePicker.destroy();
	  },
	  prepare: function(row, col, prop, td, originalValue, cellProperties) {
	    this._opened = false;
	    $traceurRuntime.superGet(this, $DateEditor.prototype, "prepare").call(this, row, col, prop, td, originalValue, cellProperties);
	  },
	  open: function() {
	    var event = arguments[0] !== (void 0) ? arguments[0] : null;
	    $traceurRuntime.superGet(this, $DateEditor.prototype, "open").call(this);
	    this.showDatepicker(event);
	  },
	  close: function() {
	    var $__9 = this;
	    this._opened = false;
	    this.instance._registerTimeout(setTimeout((function() {
	      $__9.instance.selection.refreshBorders();
	    }), 0));
	    $traceurRuntime.superGet(this, $DateEditor.prototype, "close").call(this);
	  },
	  finishEditing: function() {
	    var isCancelled = arguments[0] !== (void 0) ? arguments[0] : false;
	    var ctrlDown = arguments[1] !== (void 0) ? arguments[1] : false;
	    if (isCancelled) {
	      var value = this.originalValue;
	      if (value !== void 0) {
	        this.setValue(value);
	      }
	    }
	    this.hideDatepicker();
	    $traceurRuntime.superGet(this, $DateEditor.prototype, "finishEditing").call(this, isCancelled, ctrlDown);
	  },
	  showDatepicker: function(event) {
	    this.$datePicker.config(this.getDatePickerConfig());
	    var offset = this.TD.getBoundingClientRect();
	    var dateFormat = this.cellProperties.dateFormat || this.defaultDateFormat;
	    var datePickerConfig = this.$datePicker.config();
	    var dateStr;
	    var isMouseDown = this.instance.view.isMouseDown();
	    var isMeta = event ? isMetaKey(event.keyCode) : false;
	    this.datePickerStyle.top = (window.pageYOffset + offset.top + outerHeight(this.TD)) + 'px';
	    this.datePickerStyle.left = (window.pageXOffset + offset.left) + 'px';
	    this.$datePicker._onInputFocus = function() {};
	    datePickerConfig.format = dateFormat;
	    if (this.originalValue) {
	      dateStr = this.originalValue;
	      if (moment(dateStr, dateFormat, true).isValid()) {
	        this.$datePicker.setMoment(moment(dateStr, dateFormat), true);
	      }
	      if (!isMeta && !isMouseDown) {
	        this.setValue('');
	      }
	    } else {
	      if (this.cellProperties.defaultDate) {
	        dateStr = this.cellProperties.defaultDate;
	        datePickerConfig.defaultDate = dateStr;
	        if (moment(dateStr, dateFormat, true).isValid()) {
	          this.$datePicker.setMoment(moment(dateStr, dateFormat), true);
	        }
	        if (!isMeta && !isMouseDown) {
	          this.setValue('');
	        }
	      } else {
	        this.$datePicker.gotoToday();
	      }
	    }
	    this.datePickerStyle.display = 'block';
	    this.$datePicker.show();
	  },
	  hideDatepicker: function() {
	    this.datePickerStyle.display = 'none';
	    this.$datePicker.hide();
	  },
	  getDatePickerConfig: function() {
	    var $__9 = this;
	    var htInput = this.TEXTAREA;
	    var options = {};
	    if (this.cellProperties && this.cellProperties.datePickerConfig) {
	      deepExtend(options, this.cellProperties.datePickerConfig);
	    }
	    var origOnSelect = options.onSelect;
	    var origOnClose = options.onClose;
	    options.field = htInput;
	    options.trigger = htInput;
	    options.container = this.datePicker;
	    options.bound = false;
	    options.format = options.format || this.defaultDateFormat;
	    options.reposition = options.reposition || false;
	    options.onSelect = (function(dateStr) {
	      if (!isNaN(dateStr.getTime())) {
	        dateStr = moment(dateStr).format($__9.cellProperties.dateFormat || $__9.defaultDateFormat);
	      }
	      $__9.setValue(dateStr);
	      $__9.hideDatepicker();
	      if (origOnSelect) {
	        origOnSelect();
	      }
	    });
	    options.onClose = (function() {
	      if (!$__9.parentDestroyed) {
	        $__9.finishEditing(false);
	      }
	      if (origOnClose) {
	        origOnClose();
	      }
	    });
	    return options;
	  }
	}, {}, TextEditor);
	;
	registerEditor('date', DateEditor);

	//# 
	},{"editors":29,"eventManager":41,"helpers/dom/element":45,"helpers/dom/event":46,"helpers/object":50,"helpers/unicode":53,"moment":"moment","pikaday":"pikaday","textEditor":40}],34:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  DropdownEditor: {get: function() {
	      return DropdownEditor;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47_editors__,
	    $__autocompleteEditor__;
	var $__0 = ($___46__46__47_editors__ = require("editors"), $___46__46__47_editors__ && $___46__46__47_editors__.__esModule && $___46__46__47_editors__ || {default: $___46__46__47_editors__}),
	    getEditor = $__0.getEditor,
	    registerEditor = $__0.registerEditor;
	var AutocompleteEditor = ($__autocompleteEditor__ = require("autocompleteEditor"), $__autocompleteEditor__ && $__autocompleteEditor__.__esModule && $__autocompleteEditor__ || {default: $__autocompleteEditor__}).AutocompleteEditor;
	var DropdownEditor = function DropdownEditor() {
	  $traceurRuntime.superConstructor($DropdownEditor).apply(this, arguments);
	};
	var $DropdownEditor = DropdownEditor;
	($traceurRuntime.createClass)(DropdownEditor, {prepare: function(row, col, prop, td, originalValue, cellProperties) {
	    $traceurRuntime.superGet(this, $DropdownEditor.prototype, "prepare").call(this, row, col, prop, td, originalValue, cellProperties);
	    this.cellProperties.filter = false;
	    this.cellProperties.strict = true;
	  }}, {}, AutocompleteEditor);
	Handsontable.hooks.add('beforeValidate', function(value, row, col, source) {
	  var cellMeta = this.getCellMeta(row, col);
	  if (cellMeta.editor === Handsontable.editors.DropdownEditor) {
	    if (cellMeta.strict === void 0) {
	      cellMeta.filter = false;
	      cellMeta.strict = true;
	    }
	  }
	});
	;
	registerEditor('dropdown', DropdownEditor);

	//# 
	},{"autocompleteEditor":31,"editors":29}],35:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  HandsontableEditor: {get: function() {
	      return HandsontableEditor;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47_helpers_47_unicode__,
	    $___46__46__47_helpers_47_object__,
	    $___46__46__47_helpers_47_dom_47_element__,
	    $___46__46__47_helpers_47_dom_47_event__,
	    $___46__46__47_editors__,
	    $__textEditor__;
	var KEY_CODES = ($___46__46__47_helpers_47_unicode__ = require("helpers/unicode"), $___46__46__47_helpers_47_unicode__ && $___46__46__47_helpers_47_unicode__.__esModule && $___46__46__47_helpers_47_unicode__ || {default: $___46__46__47_helpers_47_unicode__}).KEY_CODES;
	var extend = ($___46__46__47_helpers_47_object__ = require("helpers/object"), $___46__46__47_helpers_47_object__ && $___46__46__47_helpers_47_object__.__esModule && $___46__46__47_helpers_47_object__ || {default: $___46__46__47_helpers_47_object__}).extend;
	var setCaretPosition = ($___46__46__47_helpers_47_dom_47_element__ = require("helpers/dom/element"), $___46__46__47_helpers_47_dom_47_element__ && $___46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47_helpers_47_dom_47_element__}).setCaretPosition;
	var $__3 = ($___46__46__47_helpers_47_dom_47_event__ = require("helpers/dom/event"), $___46__46__47_helpers_47_dom_47_event__ && $___46__46__47_helpers_47_dom_47_event__.__esModule && $___46__46__47_helpers_47_dom_47_event__ || {default: $___46__46__47_helpers_47_dom_47_event__}),
	    stopImmediatePropagation = $__3.stopImmediatePropagation,
	    isImmediatePropagationStopped = $__3.isImmediatePropagationStopped;
	var $__4 = ($___46__46__47_editors__ = require("editors"), $___46__46__47_editors__ && $___46__46__47_editors__.__esModule && $___46__46__47_editors__ || {default: $___46__46__47_editors__}),
	    getEditor = $__4.getEditor,
	    registerEditor = $__4.registerEditor;
	var TextEditor = ($__textEditor__ = require("textEditor"), $__textEditor__ && $__textEditor__.__esModule && $__textEditor__ || {default: $__textEditor__}).TextEditor;
	var HandsontableEditor = TextEditor.prototype.extend();
	HandsontableEditor.prototype.createElements = function() {
	  TextEditor.prototype.createElements.apply(this, arguments);
	  var DIV = document.createElement('DIV');
	  DIV.className = 'handsontableEditor';
	  this.TEXTAREA_PARENT.appendChild(DIV);
	  this.htContainer = DIV;
	  this.assignHooks();
	};
	HandsontableEditor.prototype.prepare = function(td, row, col, prop, value, cellProperties) {
	  TextEditor.prototype.prepare.apply(this, arguments);
	  var parent = this;
	  var options = {
	    startRows: 0,
	    startCols: 0,
	    minRows: 0,
	    minCols: 0,
	    className: 'listbox',
	    copyPaste: false,
	    autoColumnSize: false,
	    autoRowSize: false,
	    readOnly: true,
	    fillHandle: false,
	    afterOnCellMouseDown: function() {
	      var value = this.getValue();
	      if (value !== void 0) {
	        parent.setValue(value);
	      }
	      parent.instance.destroyEditor();
	    }
	  };
	  if (this.cellProperties.handsontable) {
	    extend(options, cellProperties.handsontable);
	  }
	  this.htOptions = options;
	};
	var onBeforeKeyDown = function(event) {
	  if (isImmediatePropagationStopped(event)) {
	    return;
	  }
	  var editor = this.getActiveEditor();
	  var innerHOT = editor.htEditor.getInstance();
	  var rowToSelect;
	  if (event.keyCode == KEY_CODES.ARROW_DOWN) {
	    if (innerHOT.getSelected()) {
	      var selectedRow = innerHOT.getSelected()[0];
	      var lastRow = innerHOT.countRows() - 1;
	      rowToSelect = Math.min(lastRow, selectedRow + 1);
	    } else {
	      rowToSelect = 0;
	    }
	  } else if (event.keyCode == KEY_CODES.ARROW_UP) {
	    if (innerHOT.getSelected()) {
	      var selectedRow = innerHOT.getSelected()[0];
	      rowToSelect = selectedRow - 1;
	    }
	  }
	  if (rowToSelect !== void 0) {
	    if (rowToSelect < 0) {
	      innerHOT.deselectCell();
	    } else {
	      innerHOT.selectCell(rowToSelect, 0);
	    }
	    if (innerHOT.getData().length) {
	      event.preventDefault();
	      stopImmediatePropagation(event);
	      editor.instance.listen();
	      editor.TEXTAREA.focus();
	    }
	  }
	};
	HandsontableEditor.prototype.open = function() {
	  this.instance.addHook('beforeKeyDown', onBeforeKeyDown);
	  TextEditor.prototype.open.apply(this, arguments);
	  if (this.htEditor) {
	    this.htEditor.destroy();
	  }
	  this.htEditor = new Handsontable(this.htContainer, this.htOptions);
	  if (this.cellProperties.strict) {
	    this.htEditor.selectCell(0, 0);
	    this.TEXTAREA.style.visibility = 'hidden';
	  } else {
	    this.htEditor.deselectCell();
	    this.TEXTAREA.style.visibility = 'visible';
	  }
	  setCaretPosition(this.TEXTAREA, 0, this.TEXTAREA.value.length);
	};
	HandsontableEditor.prototype.close = function() {
	  this.instance.removeHook('beforeKeyDown', onBeforeKeyDown);
	  this.instance.listen();
	  TextEditor.prototype.close.apply(this, arguments);
	};
	HandsontableEditor.prototype.focus = function() {
	  this.instance.listen();
	  TextEditor.prototype.focus.apply(this, arguments);
	};
	HandsontableEditor.prototype.beginEditing = function(initialValue) {
	  var onBeginEditing = this.instance.getSettings().onBeginEditing;
	  if (onBeginEditing && onBeginEditing() === false) {
	    return;
	  }
	  TextEditor.prototype.beginEditing.apply(this, arguments);
	};
	HandsontableEditor.prototype.finishEditing = function(isCancelled, ctrlDown) {
	  if (this.htEditor && this.htEditor.isListening()) {
	    this.instance.listen();
	  }
	  if (this.htEditor && this.htEditor.getSelected()) {
	    var value = this.htEditor.getInstance().getValue();
	    if (value !== void 0) {
	      this.setValue(value);
	    }
	  }
	  return TextEditor.prototype.finishEditing.apply(this, arguments);
	};
	HandsontableEditor.prototype.assignHooks = function() {
	  var _this = this;
	  this.instance.addHook('afterDestroy', function() {
	    if (_this.htEditor) {
	      _this.htEditor.destroy();
	    }
	  });
	};
	;
	registerEditor('handsontable', HandsontableEditor);

	//# 
	},{"editors":29,"helpers/dom/element":45,"helpers/dom/event":46,"helpers/object":50,"helpers/unicode":53,"textEditor":40}],36:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  MobileTextEditor: {get: function() {
	      return MobileTextEditor;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47_helpers_47_unicode__,
	    $___46__46__47_helpers_47_dom_47_event__,
	    $___46__46__47_helpers_47_dom_47_element__,
	    $___46__46__47_editors__,
	    $___95_baseEditor__,
	    $___46__46__47_eventManager__;
	var KEY_CODES = ($___46__46__47_helpers_47_unicode__ = require("helpers/unicode"), $___46__46__47_helpers_47_unicode__ && $___46__46__47_helpers_47_unicode__.__esModule && $___46__46__47_helpers_47_unicode__ || {default: $___46__46__47_helpers_47_unicode__}).KEY_CODES;
	var $__1 = ($___46__46__47_helpers_47_dom_47_event__ = require("helpers/dom/event"), $___46__46__47_helpers_47_dom_47_event__ && $___46__46__47_helpers_47_dom_47_event__.__esModule && $___46__46__47_helpers_47_dom_47_event__ || {default: $___46__46__47_helpers_47_dom_47_event__}),
	    stopImmediatePropagation = $__1.stopImmediatePropagation,
	    isImmediatePropagationStopped = $__1.isImmediatePropagationStopped;
	var $__2 = ($___46__46__47_helpers_47_dom_47_element__ = require("helpers/dom/element"), $___46__46__47_helpers_47_dom_47_element__ && $___46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47_helpers_47_dom_47_element__}),
	    addClass = $__2.addClass,
	    getScrollLeft = $__2.getScrollLeft,
	    getScrollTop = $__2.getScrollTop,
	    hasClass = $__2.hasClass,
	    isChildOf = $__2.isChildOf,
	    offset = $__2.offset,
	    outerHeight = $__2.outerHeight,
	    outerWidth = $__2.outerWidth,
	    removeClass = $__2.removeClass,
	    setCaretPosition = $__2.setCaretPosition;
	var $__3 = ($___46__46__47_editors__ = require("editors"), $___46__46__47_editors__ && $___46__46__47_editors__.__esModule && $___46__46__47_editors__ || {default: $___46__46__47_editors__}),
	    getEditor = $__3.getEditor,
	    registerEditor = $__3.registerEditor;
	var BaseEditor = ($___95_baseEditor__ = require("_baseEditor"), $___95_baseEditor__ && $___95_baseEditor__.__esModule && $___95_baseEditor__ || {default: $___95_baseEditor__}).BaseEditor;
	var eventManagerObject = ($___46__46__47_eventManager__ = require("eventManager"), $___46__46__47_eventManager__ && $___46__46__47_eventManager__.__esModule && $___46__46__47_eventManager__ || {default: $___46__46__47_eventManager__}).eventManager;
	var MobileTextEditor = BaseEditor.prototype.extend(),
	    domDimensionsCache = {};
	var createControls = function() {
	  this.controls = {};
	  this.controls.leftButton = document.createElement('DIV');
	  this.controls.leftButton.className = 'leftButton';
	  this.controls.rightButton = document.createElement('DIV');
	  this.controls.rightButton.className = 'rightButton';
	  this.controls.upButton = document.createElement('DIV');
	  this.controls.upButton.className = 'upButton';
	  this.controls.downButton = document.createElement('DIV');
	  this.controls.downButton.className = 'downButton';
	  for (var button in this.controls) {
	    if (this.controls.hasOwnProperty(button)) {
	      this.positionControls.appendChild(this.controls[button]);
	    }
	  }
	};
	MobileTextEditor.prototype.valueChanged = function() {
	  return this.initValue != this.getValue();
	};
	MobileTextEditor.prototype.init = function() {
	  var that = this;
	  this.eventManager = eventManagerObject(this.instance);
	  this.createElements();
	  this.bindEvents();
	  this.instance.addHook('afterDestroy', function() {
	    that.destroy();
	  });
	};
	MobileTextEditor.prototype.getValue = function() {
	  return this.TEXTAREA.value;
	};
	MobileTextEditor.prototype.setValue = function(newValue) {
	  this.initValue = newValue;
	  this.TEXTAREA.value = newValue;
	};
	MobileTextEditor.prototype.createElements = function() {
	  this.editorContainer = document.createElement('DIV');
	  this.editorContainer.className = 'htMobileEditorContainer';
	  this.cellPointer = document.createElement('DIV');
	  this.cellPointer.className = 'cellPointer';
	  this.moveHandle = document.createElement('DIV');
	  this.moveHandle.className = 'moveHandle';
	  this.inputPane = document.createElement('DIV');
	  this.inputPane.className = 'inputs';
	  this.positionControls = document.createElement('DIV');
	  this.positionControls.className = 'positionControls';
	  this.TEXTAREA = document.createElement('TEXTAREA');
	  addClass(this.TEXTAREA, 'handsontableInput');
	  this.inputPane.appendChild(this.TEXTAREA);
	  this.editorContainer.appendChild(this.cellPointer);
	  this.editorContainer.appendChild(this.moveHandle);
	  this.editorContainer.appendChild(this.inputPane);
	  this.editorContainer.appendChild(this.positionControls);
	  createControls.call(this);
	  document.body.appendChild(this.editorContainer);
	};
	MobileTextEditor.prototype.onBeforeKeyDown = function(event) {
	  var instance = this;
	  var that = instance.getActiveEditor();
	  if (event.target !== that.TEXTAREA || isImmediatePropagationStopped(event)) {
	    return;
	  }
	  switch (event.keyCode) {
	    case KEY_CODES.ENTER:
	      that.close();
	      event.preventDefault();
	      break;
	    case KEY_CODES.BACKSPACE:
	      stopImmediatePropagation(event);
	      break;
	  }
	};
	MobileTextEditor.prototype.open = function() {
	  this.instance.addHook('beforeKeyDown', this.onBeforeKeyDown);
	  addClass(this.editorContainer, 'active');
	  removeClass(this.cellPointer, 'hidden');
	  this.updateEditorPosition();
	};
	MobileTextEditor.prototype.focus = function() {
	  this.TEXTAREA.focus();
	  setCaretPosition(this.TEXTAREA, this.TEXTAREA.value.length);
	};
	MobileTextEditor.prototype.close = function() {
	  this.TEXTAREA.blur();
	  this.instance.removeHook('beforeKeyDown', this.onBeforeKeyDown);
	  removeClass(this.editorContainer, 'active');
	};
	MobileTextEditor.prototype.scrollToView = function() {
	  var coords = this.instance.getSelectedRange().highlight;
	  this.instance.view.scrollViewport(coords);
	};
	MobileTextEditor.prototype.hideCellPointer = function() {
	  if (!hasClass(this.cellPointer, 'hidden')) {
	    addClass(this.cellPointer, 'hidden');
	  }
	};
	MobileTextEditor.prototype.updateEditorPosition = function(x, y) {
	  if (x && y) {
	    x = parseInt(x, 10);
	    y = parseInt(y, 10);
	    this.editorContainer.style.top = y + 'px';
	    this.editorContainer.style.left = x + 'px';
	  } else {
	    var selection = this.instance.getSelected(),
	        selectedCell = this.instance.getCell(selection[0], selection[1]);
	    if (!domDimensionsCache.cellPointer) {
	      domDimensionsCache.cellPointer = {
	        height: outerHeight(this.cellPointer),
	        width: outerWidth(this.cellPointer)
	      };
	    }
	    if (!domDimensionsCache.editorContainer) {
	      domDimensionsCache.editorContainer = {width: outerWidth(this.editorContainer)};
	    }
	    if (selectedCell !== undefined) {
	      var scrollLeft = this.instance.view.wt.wtOverlays.leftOverlay.trimmingContainer == window ? 0 : getScrollLeft(this.instance.view.wt.wtOverlays.leftOverlay.holder);
	      var scrollTop = this.instance.view.wt.wtOverlays.topOverlay.trimmingContainer == window ? 0 : getScrollTop(this.instance.view.wt.wtOverlays.topOverlay.holder);
	      var selectedCellOffset = offset(selectedCell),
	          selectedCellWidth = outerWidth(selectedCell),
	          currentScrollPosition = {
	            x: scrollLeft,
	            y: scrollTop
	          };
	      this.editorContainer.style.top = parseInt(selectedCellOffset.top + outerHeight(selectedCell) - currentScrollPosition.y + domDimensionsCache.cellPointer.height, 10) + 'px';
	      this.editorContainer.style.left = parseInt((window.innerWidth / 2) - (domDimensionsCache.editorContainer.width / 2), 10) + 'px';
	      if (selectedCellOffset.left + selectedCellWidth / 2 > parseInt(this.editorContainer.style.left, 10) + domDimensionsCache.editorContainer.width) {
	        this.editorContainer.style.left = window.innerWidth - domDimensionsCache.editorContainer.width + 'px';
	      } else if (selectedCellOffset.left + selectedCellWidth / 2 < parseInt(this.editorContainer.style.left, 10) + 20) {
	        this.editorContainer.style.left = 0 + 'px';
	      }
	      this.cellPointer.style.left = parseInt(selectedCellOffset.left - (domDimensionsCache.cellPointer.width / 2) - offset(this.editorContainer).left + (selectedCellWidth / 2) - currentScrollPosition.x, 10) + 'px';
	    }
	  }
	};
	MobileTextEditor.prototype.updateEditorData = function() {
	  var selected = this.instance.getSelected(),
	      selectedValue = this.instance.getDataAtCell(selected[0], selected[1]);
	  this.row = selected[0];
	  this.col = selected[1];
	  this.setValue(selectedValue);
	  this.updateEditorPosition();
	};
	MobileTextEditor.prototype.prepareAndSave = function() {
	  var val;
	  if (!this.valueChanged()) {
	    return true;
	  }
	  if (this.instance.getSettings().trimWhitespace) {
	    val = [[String.prototype.trim.call(this.getValue())]];
	  } else {
	    val = [[this.getValue()]];
	  }
	  this.saveValue(val);
	};
	MobileTextEditor.prototype.bindEvents = function() {
	  var that = this;
	  this.eventManager.addEventListener(this.controls.leftButton, 'touchend', function(event) {
	    that.prepareAndSave();
	    that.instance.selection.transformStart(0, -1, null, true);
	    that.updateEditorData();
	    event.preventDefault();
	  });
	  this.eventManager.addEventListener(this.controls.rightButton, 'touchend', function(event) {
	    that.prepareAndSave();
	    that.instance.selection.transformStart(0, 1, null, true);
	    that.updateEditorData();
	    event.preventDefault();
	  });
	  this.eventManager.addEventListener(this.controls.upButton, 'touchend', function(event) {
	    that.prepareAndSave();
	    that.instance.selection.transformStart(-1, 0, null, true);
	    that.updateEditorData();
	    event.preventDefault();
	  });
	  this.eventManager.addEventListener(this.controls.downButton, 'touchend', function(event) {
	    that.prepareAndSave();
	    that.instance.selection.transformStart(1, 0, null, true);
	    that.updateEditorData();
	    event.preventDefault();
	  });
	  this.eventManager.addEventListener(this.moveHandle, 'touchstart', function(event) {
	    if (event.touches.length == 1) {
	      var touch = event.touches[0],
	          onTouchPosition = {
	            x: that.editorContainer.offsetLeft,
	            y: that.editorContainer.offsetTop
	          },
	          onTouchOffset = {
	            x: touch.pageX - onTouchPosition.x,
	            y: touch.pageY - onTouchPosition.y
	          };
	      that.eventManager.addEventListener(this, 'touchmove', function(event) {
	        var touch = event.touches[0];
	        that.updateEditorPosition(touch.pageX - onTouchOffset.x, touch.pageY - onTouchOffset.y);
	        that.hideCellPointer();
	        event.preventDefault();
	      });
	    }
	  });
	  this.eventManager.addEventListener(document.body, 'touchend', function(event) {
	    if (!isChildOf(event.target, that.editorContainer) && !isChildOf(event.target, that.instance.rootElement)) {
	      that.close();
	    }
	  });
	  this.eventManager.addEventListener(this.instance.view.wt.wtOverlays.leftOverlay.holder, 'scroll', function(event) {
	    if (that.instance.view.wt.wtOverlays.leftOverlay.trimmingContainer != window) {
	      that.hideCellPointer();
	    }
	  });
	  this.eventManager.addEventListener(this.instance.view.wt.wtOverlays.topOverlay.holder, 'scroll', function(event) {
	    if (that.instance.view.wt.wtOverlays.topOverlay.trimmingContainer != window) {
	      that.hideCellPointer();
	    }
	  });
	};
	MobileTextEditor.prototype.destroy = function() {
	  this.eventManager.clear();
	  this.editorContainer.parentNode.removeChild(this.editorContainer);
	};
	;
	registerEditor('mobile', MobileTextEditor);

	//# 
	},{"_baseEditor":30,"editors":29,"eventManager":41,"helpers/dom/element":45,"helpers/dom/event":46,"helpers/unicode":53}],37:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  NumericEditor: {get: function() {
	      return NumericEditor;
	    }},
	  __esModule: {value: true}
	});
	var $__numeral__,
	    $___46__46__47_editors__,
	    $__textEditor__;
	var numeral = ($__numeral__ = require("numeral"), $__numeral__ && $__numeral__.__esModule && $__numeral__ || {default: $__numeral__}).default;
	var $__1 = ($___46__46__47_editors__ = require("editors"), $___46__46__47_editors__ && $___46__46__47_editors__.__esModule && $___46__46__47_editors__ || {default: $___46__46__47_editors__}),
	    getEditor = $__1.getEditor,
	    registerEditor = $__1.registerEditor;
	var TextEditor = ($__textEditor__ = require("textEditor"), $__textEditor__ && $__textEditor__.__esModule && $__textEditor__ || {default: $__textEditor__}).TextEditor;
	var NumericEditor = function NumericEditor() {
	  $traceurRuntime.superConstructor($NumericEditor).apply(this, arguments);
	};
	var $NumericEditor = NumericEditor;
	($traceurRuntime.createClass)(NumericEditor, {beginEditing: function(initialValue) {
	    if (typeof initialValue === 'undefined' && this.originalValue) {
	      if (typeof this.cellProperties.language !== 'undefined') {
	        numeral.language(this.cellProperties.language);
	      }
	      var decimalDelimiter = numeral.languageData().delimiters.decimal;
	      initialValue = ('' + this.originalValue).replace('.', decimalDelimiter);
	    }
	    $traceurRuntime.superGet(this, $NumericEditor.prototype, "beginEditing").call(this, initialValue);
	  }}, {}, TextEditor);
	;
	registerEditor('numeric', NumericEditor);

	//# 
	},{"editors":29,"numeral":"numeral","textEditor":40}],38:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  PasswordEditor: {get: function() {
	      return PasswordEditor;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47_helpers_47_dom_47_element__,
	    $___46__46__47_editors__,
	    $__textEditor__;
	var empty = ($___46__46__47_helpers_47_dom_47_element__ = require("helpers/dom/element"), $___46__46__47_helpers_47_dom_47_element__ && $___46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47_helpers_47_dom_47_element__}).empty;
	var $__1 = ($___46__46__47_editors__ = require("editors"), $___46__46__47_editors__ && $___46__46__47_editors__.__esModule && $___46__46__47_editors__ || {default: $___46__46__47_editors__}),
	    getEditor = $__1.getEditor,
	    registerEditor = $__1.registerEditor;
	var TextEditor = ($__textEditor__ = require("textEditor"), $__textEditor__ && $__textEditor__.__esModule && $__textEditor__ || {default: $__textEditor__}).TextEditor;
	var PasswordEditor = function PasswordEditor() {
	  $traceurRuntime.superConstructor($PasswordEditor).apply(this, arguments);
	};
	var $PasswordEditor = PasswordEditor;
	($traceurRuntime.createClass)(PasswordEditor, {createElements: function() {
	    $traceurRuntime.superGet(this, $PasswordEditor.prototype, "createElements").call(this);
	    this.TEXTAREA = document.createElement('input');
	    this.TEXTAREA.setAttribute('type', 'password');
	    this.TEXTAREA.className = 'handsontableInput';
	    this.textareaStyle = this.TEXTAREA.style;
	    this.textareaStyle.width = 0;
	    this.textareaStyle.height = 0;
	    empty(this.TEXTAREA_PARENT);
	    this.TEXTAREA_PARENT.appendChild(this.TEXTAREA);
	  }}, {}, TextEditor);
	;
	registerEditor('password', PasswordEditor);

	//# 
	},{"editors":29,"helpers/dom/element":45,"textEditor":40}],39:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  SelectEditor: {get: function() {
	      return SelectEditor;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47_helpers_47_dom_47_element__,
	    $___46__46__47_helpers_47_dom_47_event__,
	    $___46__46__47_helpers_47_unicode__,
	    $___46__46__47_editors__,
	    $___95_baseEditor__;
	var $__0 = ($___46__46__47_helpers_47_dom_47_element__ = require("helpers/dom/element"), $___46__46__47_helpers_47_dom_47_element__ && $___46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47_helpers_47_dom_47_element__}),
	    addClass = $__0.addClass,
	    empty = $__0.empty,
	    fastInnerHTML = $__0.fastInnerHTML,
	    getComputedStyle = $__0.getComputedStyle,
	    getCssTransform = $__0.getCssTransform,
	    getScrollableElement = $__0.getScrollableElement,
	    offset = $__0.offset,
	    outerHeight = $__0.outerHeight,
	    outerWidth = $__0.outerWidth,
	    resetCssTransform = $__0.resetCssTransform;
	var stopImmediatePropagation = ($___46__46__47_helpers_47_dom_47_event__ = require("helpers/dom/event"), $___46__46__47_helpers_47_dom_47_event__ && $___46__46__47_helpers_47_dom_47_event__.__esModule && $___46__46__47_helpers_47_dom_47_event__ || {default: $___46__46__47_helpers_47_dom_47_event__}).stopImmediatePropagation;
	var KEY_CODES = ($___46__46__47_helpers_47_unicode__ = require("helpers/unicode"), $___46__46__47_helpers_47_unicode__ && $___46__46__47_helpers_47_unicode__.__esModule && $___46__46__47_helpers_47_unicode__ || {default: $___46__46__47_helpers_47_unicode__}).KEY_CODES;
	var $__3 = ($___46__46__47_editors__ = require("editors"), $___46__46__47_editors__ && $___46__46__47_editors__.__esModule && $___46__46__47_editors__ || {default: $___46__46__47_editors__}),
	    getEditor = $__3.getEditor,
	    registerEditor = $__3.registerEditor;
	var BaseEditor = ($___95_baseEditor__ = require("_baseEditor"), $___95_baseEditor__ && $___95_baseEditor__.__esModule && $___95_baseEditor__ || {default: $___95_baseEditor__}).BaseEditor;
	var SelectEditor = BaseEditor.prototype.extend();
	SelectEditor.prototype.init = function() {
	  this.select = document.createElement('SELECT');
	  addClass(this.select, 'htSelectEditor');
	  this.select.style.display = 'none';
	  this.instance.rootElement.appendChild(this.select);
	  this.registerHooks();
	};
	SelectEditor.prototype.registerHooks = function() {
	  var $__5 = this;
	  this.instance.addHook('afterScrollVertically', (function() {
	    return $__5.refreshDimensions();
	  }));
	  this.instance.addHook('afterColumnResize', (function() {
	    return $__5.refreshDimensions();
	  }));
	  this.instance.addHook('afterRowResize', (function() {
	    return $__5.refreshDimensions();
	  }));
	};
	SelectEditor.prototype.prepare = function() {
	  BaseEditor.prototype.prepare.apply(this, arguments);
	  var selectOptions = this.cellProperties.selectOptions;
	  var options;
	  if (typeof selectOptions == 'function') {
	    options = this.prepareOptions(selectOptions(this.row, this.col, this.prop));
	  } else {
	    options = this.prepareOptions(selectOptions);
	  }
	  empty(this.select);
	  for (var option in options) {
	    if (options.hasOwnProperty(option)) {
	      var optionElement = document.createElement('OPTION');
	      optionElement.value = option;
	      fastInnerHTML(optionElement, options[option]);
	      this.select.appendChild(optionElement);
	    }
	  }
	};
	SelectEditor.prototype.prepareOptions = function(optionsToPrepare) {
	  var preparedOptions = {};
	  if (Array.isArray(optionsToPrepare)) {
	    for (var i = 0,
	        len = optionsToPrepare.length; i < len; i++) {
	      preparedOptions[optionsToPrepare[i]] = optionsToPrepare[i];
	    }
	  } else if (typeof optionsToPrepare == 'object') {
	    preparedOptions = optionsToPrepare;
	  }
	  return preparedOptions;
	};
	SelectEditor.prototype.getValue = function() {
	  return this.select.value;
	};
	SelectEditor.prototype.setValue = function(value) {
	  this.select.value = value;
	};
	var onBeforeKeyDown = function(event) {
	  var instance = this;
	  var editor = instance.getActiveEditor();
	  switch (event.keyCode) {
	    case KEY_CODES.ARROW_UP:
	      var previousOptionIndex = editor.select.selectedIndex - 1;
	      if (previousOptionIndex >= 0) {
	        editor.select[previousOptionIndex].selected = true;
	      }
	      stopImmediatePropagation(event);
	      event.preventDefault();
	      break;
	    case KEY_CODES.ARROW_DOWN:
	      var nextOptionIndex = editor.select.selectedIndex + 1;
	      if (nextOptionIndex <= editor.select.length - 1) {
	        editor.select[nextOptionIndex].selected = true;
	      }
	      stopImmediatePropagation(event);
	      event.preventDefault();
	      break;
	  }
	};
	SelectEditor.prototype.open = function() {
	  this._opened = true;
	  this.refreshDimensions();
	  this.select.style.display = '';
	  this.instance.addHook('beforeKeyDown', onBeforeKeyDown);
	};
	SelectEditor.prototype.close = function() {
	  this._opened = false;
	  this.select.style.display = 'none';
	  this.instance.removeHook('beforeKeyDown', onBeforeKeyDown);
	};
	SelectEditor.prototype.focus = function() {
	  this.select.focus();
	};
	SelectEditor.prototype.refreshDimensions = function() {
	  if (this.state !== Handsontable.EditorState.EDITING) {
	    return;
	  }
	  this.TD = this.getEditedCell();
	  if (!this.TD) {
	    this.close();
	    return;
	  }
	  var width = outerWidth(this.TD) + 1,
	      height = outerHeight(this.TD) + 1,
	      currentOffset = offset(this.TD),
	      containerOffset = offset(this.instance.rootElement),
	      scrollableContainer = getScrollableElement(this.TD),
	      editTop = currentOffset.top - containerOffset.top - 1 - (scrollableContainer.scrollTop || 0),
	      editLeft = currentOffset.left - containerOffset.left - 1 - (scrollableContainer.scrollLeft || 0),
	      editorSection = this.checkEditorSection(),
	      cssTransformOffset;
	  var settings = this.instance.getSettings();
	  var rowHeadersCount = settings.rowHeaders ? 1 : 0;
	  var colHeadersCount = settings.colHeaders ? 1 : 0;
	  switch (editorSection) {
	    case 'top':
	      cssTransformOffset = getCssTransform(this.instance.view.wt.wtOverlays.topOverlay.clone.wtTable.holder.parentNode);
	      break;
	    case 'left':
	      cssTransformOffset = getCssTransform(this.instance.view.wt.wtOverlays.leftOverlay.clone.wtTable.holder.parentNode);
	      break;
	    case 'top-left-corner':
	      cssTransformOffset = getCssTransform(this.instance.view.wt.wtOverlays.topLeftCornerOverlay.clone.wtTable.holder.parentNode);
	      break;
	    case 'bottom-left-corner':
	      cssTransformOffset = getCssTransform(this.instance.view.wt.wtOverlays.bottomLeftCornerOverlay.clone.wtTable.holder.parentNode);
	      break;
	    case 'bottom':
	      cssTransformOffset = getCssTransform(this.instance.view.wt.wtOverlays.bottomOverlay.clone.wtTable.holder.parentNode);
	      break;
	  }
	  if (this.instance.getSelected()[0] === 0) {
	    editTop += 1;
	  }
	  if (this.instance.getSelected()[1] === 0) {
	    editLeft += 1;
	  }
	  var selectStyle = this.select.style;
	  if (cssTransformOffset && cssTransformOffset != -1) {
	    selectStyle[cssTransformOffset[0]] = cssTransformOffset[1];
	  } else {
	    resetCssTransform(this.select);
	  }
	  var cellComputedStyle = getComputedStyle(this.TD);
	  if (parseInt(cellComputedStyle.borderTopWidth, 10) > 0) {
	    height -= 1;
	  }
	  if (parseInt(cellComputedStyle.borderLeftWidth, 10) > 0) {
	    width -= 1;
	  }
	  selectStyle.height = height + 'px';
	  selectStyle.minWidth = width + 'px';
	  selectStyle.top = editTop + 'px';
	  selectStyle.left = editLeft + 'px';
	  selectStyle.margin = '0px';
	};
	SelectEditor.prototype.getEditedCell = function() {
	  var editorSection = this.checkEditorSection(),
	      editedCell;
	  switch (editorSection) {
	    case 'top':
	      editedCell = this.instance.view.wt.wtOverlays.topOverlay.clone.wtTable.getCell({
	        row: this.row,
	        col: this.col
	      });
	      this.select.style.zIndex = 101;
	      break;
	    case 'corner':
	      editedCell = this.instance.view.wt.wtOverlays.topLeftCornerOverlay.clone.wtTable.getCell({
	        row: this.row,
	        col: this.col
	      });
	      this.select.style.zIndex = 103;
	      break;
	    case 'left':
	      editedCell = this.instance.view.wt.wtOverlays.leftOverlay.clone.wtTable.getCell({
	        row: this.row,
	        col: this.col
	      });
	      this.select.style.zIndex = 102;
	      break;
	    default:
	      editedCell = this.instance.getCell(this.row, this.col);
	      this.select.style.zIndex = '';
	      break;
	  }
	  return editedCell != -1 && editedCell != -2 ? editedCell : void 0;
	};
	;
	registerEditor('select', SelectEditor);

	//# 
	},{"_baseEditor":30,"editors":29,"helpers/dom/element":45,"helpers/dom/event":46,"helpers/unicode":53}],40:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  TextEditor: {get: function() {
	      return TextEditor;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47_helpers_47_dom_47_element__,
	    $__autoResize__,
	    $___95_baseEditor__,
	    $___46__46__47_eventManager__,
	    $___46__46__47_editors__,
	    $___46__46__47_helpers_47_unicode__,
	    $___46__46__47_helpers_47_dom_47_event__;
	var $__0 = ($___46__46__47_helpers_47_dom_47_element__ = require("helpers/dom/element"), $___46__46__47_helpers_47_dom_47_element__ && $___46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47_helpers_47_dom_47_element__}),
	    addClass = $__0.addClass,
	    getCaretPosition = $__0.getCaretPosition,
	    getComputedStyle = $__0.getComputedStyle,
	    getCssTransform = $__0.getCssTransform,
	    getScrollableElement = $__0.getScrollableElement,
	    innerWidth = $__0.innerWidth,
	    offset = $__0.offset,
	    resetCssTransform = $__0.resetCssTransform,
	    setCaretPosition = $__0.setCaretPosition;
	var autoResize = ($__autoResize__ = require("autoResize"), $__autoResize__ && $__autoResize__.__esModule && $__autoResize__ || {default: $__autoResize__}).default;
	var BaseEditor = ($___95_baseEditor__ = require("_baseEditor"), $___95_baseEditor__ && $___95_baseEditor__.__esModule && $___95_baseEditor__ || {default: $___95_baseEditor__}).BaseEditor;
	var eventManagerObject = ($___46__46__47_eventManager__ = require("eventManager"), $___46__46__47_eventManager__ && $___46__46__47_eventManager__.__esModule && $___46__46__47_eventManager__ || {default: $___46__46__47_eventManager__}).eventManager;
	var $__4 = ($___46__46__47_editors__ = require("editors"), $___46__46__47_editors__ && $___46__46__47_editors__.__esModule && $___46__46__47_editors__ || {default: $___46__46__47_editors__}),
	    getEditor = $__4.getEditor,
	    registerEditor = $__4.registerEditor;
	var KEY_CODES = ($___46__46__47_helpers_47_unicode__ = require("helpers/unicode"), $___46__46__47_helpers_47_unicode__ && $___46__46__47_helpers_47_unicode__.__esModule && $___46__46__47_helpers_47_unicode__ || {default: $___46__46__47_helpers_47_unicode__}).KEY_CODES;
	var $__6 = ($___46__46__47_helpers_47_dom_47_event__ = require("helpers/dom/event"), $___46__46__47_helpers_47_dom_47_event__ && $___46__46__47_helpers_47_dom_47_event__.__esModule && $___46__46__47_helpers_47_dom_47_event__ || {default: $___46__46__47_helpers_47_dom_47_event__}),
	    stopPropagation = $__6.stopPropagation,
	    stopImmediatePropagation = $__6.stopImmediatePropagation,
	    isImmediatePropagationStopped = $__6.isImmediatePropagationStopped;
	var TextEditor = BaseEditor.prototype.extend();
	TextEditor.prototype.init = function() {
	  var that = this;
	  this.createElements();
	  this.eventManager = eventManagerObject(this);
	  this.bindEvents();
	  this.autoResize = autoResize();
	  this.instance.addHook('afterDestroy', function() {
	    that.destroy();
	  });
	};
	TextEditor.prototype.getValue = function() {
	  return this.TEXTAREA.value;
	};
	TextEditor.prototype.setValue = function(newValue) {
	  this.TEXTAREA.value = newValue;
	};
	var onBeforeKeyDown = function onBeforeKeyDown(event) {
	  var instance = this,
	      that = instance.getActiveEditor(),
	      ctrlDown;
	  ctrlDown = (event.ctrlKey || event.metaKey) && !event.altKey;
	  if (event.target !== that.TEXTAREA || isImmediatePropagationStopped(event)) {
	    return;
	  }
	  if (event.keyCode === 17 || event.keyCode === 224 || event.keyCode === 91 || event.keyCode === 93) {
	    stopImmediatePropagation(event);
	    return;
	  }
	  switch (event.keyCode) {
	    case KEY_CODES.ARROW_RIGHT:
	      if (that.isInFullEditMode()) {
	        if ((!that.isWaiting() && !that.allowKeyEventPropagation) || (!that.isWaiting() && that.allowKeyEventPropagation && !that.allowKeyEventPropagation(event.keyCode))) {
	          stopImmediatePropagation(event);
	        }
	      }
	      break;
	    case KEY_CODES.ARROW_LEFT:
	      if (that.isInFullEditMode()) {
	        if ((!that.isWaiting() && !that.allowKeyEventPropagation) || (!that.isWaiting() && that.allowKeyEventPropagation && !that.allowKeyEventPropagation(event.keyCode))) {
	          stopImmediatePropagation(event);
	        }
	      }
	      break;
	    case KEY_CODES.ARROW_UP:
	    case KEY_CODES.ARROW_DOWN:
	      if (that.isInFullEditMode()) {
	        if ((!that.isWaiting() && !that.allowKeyEventPropagation) || (!that.isWaiting() && that.allowKeyEventPropagation && !that.allowKeyEventPropagation(event.keyCode))) {
	          stopImmediatePropagation(event);
	        }
	      }
	      break;
	    case KEY_CODES.ENTER:
	      var selected = that.instance.getSelected();
	      var isMultipleSelection = !(selected[0] === selected[2] && selected[1] === selected[3]);
	      if ((ctrlDown && !isMultipleSelection) || event.altKey) {
	        if (that.isOpened()) {
	          var caretPosition = getCaretPosition(that.TEXTAREA),
	              value = that.getValue();
	          var newValue = value.slice(0, caretPosition) + '\n' + value.slice(caretPosition);
	          that.setValue(newValue);
	          setCaretPosition(that.TEXTAREA, caretPosition + 1);
	        } else {
	          that.beginEditing(that.originalValue + '\n');
	        }
	        stopImmediatePropagation(event);
	      }
	      event.preventDefault();
	      break;
	    case KEY_CODES.A:
	    case KEY_CODES.X:
	    case KEY_CODES.C:
	    case KEY_CODES.V:
	      if (ctrlDown) {
	        stopImmediatePropagation(event);
	      }
	      break;
	    case KEY_CODES.BACKSPACE:
	    case KEY_CODES.DELETE:
	    case KEY_CODES.HOME:
	    case KEY_CODES.END:
	      stopImmediatePropagation(event);
	      break;
	  }
	  if ([KEY_CODES.ARROW_UP, KEY_CODES.ARROW_RIGHT, KEY_CODES.ARROW_DOWN, KEY_CODES.ARROW_LEFT].indexOf(event.keyCode) === -1) {
	    that.autoResize.resize(String.fromCharCode(event.keyCode));
	  }
	};
	TextEditor.prototype.open = function() {
	  this.refreshDimensions();
	  this.instance.addHook('beforeKeyDown', onBeforeKeyDown);
	};
	TextEditor.prototype.close = function(tdOutside) {
	  this.textareaParentStyle.display = 'none';
	  this.autoResize.unObserve();
	  if (document.activeElement === this.TEXTAREA) {
	    this.instance.listen();
	  }
	  this.instance.removeHook('beforeKeyDown', onBeforeKeyDown);
	};
	TextEditor.prototype.focus = function() {
	  this.TEXTAREA.focus();
	  setCaretPosition(this.TEXTAREA, this.TEXTAREA.value.length);
	};
	TextEditor.prototype.createElements = function() {
	  this.TEXTAREA = document.createElement('TEXTAREA');
	  addClass(this.TEXTAREA, 'handsontableInput');
	  this.textareaStyle = this.TEXTAREA.style;
	  this.textareaStyle.width = 0;
	  this.textareaStyle.height = 0;
	  this.TEXTAREA_PARENT = document.createElement('DIV');
	  addClass(this.TEXTAREA_PARENT, 'handsontableInputHolder');
	  this.textareaParentStyle = this.TEXTAREA_PARENT.style;
	  this.textareaParentStyle.top = 0;
	  this.textareaParentStyle.left = 0;
	  this.textareaParentStyle.display = 'none';
	  this.TEXTAREA_PARENT.appendChild(this.TEXTAREA);
	  this.instance.rootElement.appendChild(this.TEXTAREA_PARENT);
	  var that = this;
	  this.instance._registerTimeout(setTimeout(function() {
	    that.refreshDimensions();
	  }, 0));
	};
	TextEditor.prototype.getEditedCell = function() {
	  var editorSection = this.checkEditorSection(),
	      editedCell;
	  switch (editorSection) {
	    case 'top':
	      editedCell = this.instance.view.wt.wtOverlays.topOverlay.clone.wtTable.getCell({
	        row: this.row,
	        col: this.col
	      });
	      this.textareaParentStyle.zIndex = 101;
	      break;
	    case 'top-left-corner':
	      editedCell = this.instance.view.wt.wtOverlays.topLeftCornerOverlay.clone.wtTable.getCell({
	        row: this.row,
	        col: this.col
	      });
	      this.textareaParentStyle.zIndex = 103;
	      break;
	    case 'bottom-left-corner':
	      editedCell = this.instance.view.wt.wtOverlays.bottomLeftCornerOverlay.clone.wtTable.getCell({
	        row: this.row,
	        col: this.col
	      });
	      this.textareaParentStyle.zIndex = 103;
	      break;
	    case 'left':
	      editedCell = this.instance.view.wt.wtOverlays.leftOverlay.clone.wtTable.getCell({
	        row: this.row,
	        col: this.col
	      });
	      this.textareaParentStyle.zIndex = 102;
	      break;
	    case 'bottom':
	      editedCell = this.instance.view.wt.wtOverlays.bottomOverlay.clone.wtTable.getCell({
	        row: this.row,
	        col: this.col
	      });
	      this.textareaParentStyle.zIndex = 102;
	      break;
	    default:
	      editedCell = this.instance.getCell(this.row, this.col);
	      this.textareaParentStyle.zIndex = '';
	      break;
	  }
	  return editedCell != -1 && editedCell != -2 ? editedCell : void 0;
	};
	TextEditor.prototype.refreshDimensions = function() {
	  if (this.state !== Handsontable.EditorState.EDITING) {
	    return;
	  }
	  this.TD = this.getEditedCell();
	  if (!this.TD) {
	    this.close(true);
	    return;
	  }
	  var currentOffset = offset(this.TD),
	      containerOffset = offset(this.instance.rootElement),
	      scrollableContainer = getScrollableElement(this.TD),
	      totalRowsCount = this.instance.countRows(),
	      editTop = currentOffset.top - containerOffset.top - 1 - (scrollableContainer.scrollTop || 0),
	      editLeft = currentOffset.left - containerOffset.left - 1 - (scrollableContainer.scrollLeft || 0),
	      settings = this.instance.getSettings(),
	      rowHeadersCount = settings.rowHeaders ? 1 : 0,
	      colHeadersCount = settings.colHeaders ? 1 : 0,
	      editorSection = this.checkEditorSection(),
	      backgroundColor = this.TD.style.backgroundColor,
	      cssTransformOffset;
	  switch (editorSection) {
	    case 'top':
	      cssTransformOffset = getCssTransform(this.instance.view.wt.wtOverlays.topOverlay.clone.wtTable.holder.parentNode);
	      break;
	    case 'left':
	      cssTransformOffset = getCssTransform(this.instance.view.wt.wtOverlays.leftOverlay.clone.wtTable.holder.parentNode);
	      break;
	    case 'top-left-corner':
	      cssTransformOffset = getCssTransform(this.instance.view.wt.wtOverlays.topLeftCornerOverlay.clone.wtTable.holder.parentNode);
	      break;
	    case 'bottom-left-corner':
	      cssTransformOffset = getCssTransform(this.instance.view.wt.wtOverlays.bottomLeftCornerOverlay.clone.wtTable.holder.parentNode);
	      break;
	    case 'bottom':
	      cssTransformOffset = getCssTransform(this.instance.view.wt.wtOverlays.bottomOverlay.clone.wtTable.holder.parentNode);
	      break;
	  }
	  if (colHeadersCount && this.instance.getSelected()[0] === 0 || (settings.fixedRowsBottom && this.instance.getSelected()[0] === totalRowsCount - settings.fixedRowsBottom)) {
	    editTop += 1;
	  }
	  if (this.instance.getSelected()[1] === 0) {
	    editLeft += 1;
	  }
	  if (cssTransformOffset && cssTransformOffset != -1) {
	    this.textareaParentStyle[cssTransformOffset[0]] = cssTransformOffset[1];
	  } else {
	    resetCssTransform(this.textareaParentStyle);
	  }
	  this.textareaParentStyle.top = editTop + 'px';
	  this.textareaParentStyle.left = editLeft + 'px';
	  var cellTopOffset = this.TD.offsetTop - this.instance.view.wt.wtOverlays.topOverlay.getScrollPosition(),
	      cellLeftOffset = this.TD.offsetLeft - this.instance.view.wt.wtOverlays.leftOverlay.getScrollPosition();
	  var width = innerWidth(this.TD) - 8;
	  var maxWidth = this.instance.view.maximumVisibleElementWidth(cellLeftOffset) - 9;
	  var height = this.TD.scrollHeight + 1;
	  var maxHeight = Math.max(this.instance.view.maximumVisibleElementHeight(cellTopOffset) - 2, 23);
	  var cellComputedStyle = getComputedStyle(this.TD);
	  this.TEXTAREA.style.fontSize = cellComputedStyle.fontSize;
	  this.TEXTAREA.style.fontFamily = cellComputedStyle.fontFamily;
	  this.TEXTAREA.style.backgroundColor = '';
	  this.TEXTAREA.style.backgroundColor = backgroundColor ? backgroundColor : getComputedStyle(this.TEXTAREA).backgroundColor;
	  this.autoResize.init(this.TEXTAREA, {
	    minHeight: Math.min(height, maxHeight),
	    maxHeight: maxHeight,
	    minWidth: Math.min(width, maxWidth),
	    maxWidth: maxWidth
	  }, true);
	  this.textareaParentStyle.display = 'block';
	};
	TextEditor.prototype.bindEvents = function() {
	  var editor = this;
	  this.eventManager.addEventListener(this.TEXTAREA, 'cut', function(event) {
	    stopPropagation(event);
	  });
	  this.eventManager.addEventListener(this.TEXTAREA, 'paste', function(event) {
	    stopPropagation(event);
	  });
	  this.instance.addHook('afterScrollVertically', function() {
	    editor.refreshDimensions();
	  });
	  this.instance.addHook('afterColumnResize', function() {
	    editor.refreshDimensions();
	    editor.focus();
	  });
	  this.instance.addHook('afterRowResize', function() {
	    editor.refreshDimensions();
	    editor.focus();
	  });
	  this.instance.addHook('afterDestroy', function() {
	    editor.eventManager.destroy();
	  });
	};
	TextEditor.prototype.destroy = function() {
	  this.eventManager.destroy();
	};
	;
	registerEditor('text', TextEditor);

	//# 
	},{"_baseEditor":30,"autoResize":"autoResize","editors":29,"eventManager":41,"helpers/dom/element":45,"helpers/dom/event":46,"helpers/unicode":53}],41:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  EventManager: {get: function() {
	      return EventManager;
	    }},
	  eventManager: {get: function() {
	      return eventManager;
	    }},
	  __esModule: {value: true}
	});
	var $__helpers_47_dom_47_element__,
	    $__helpers_47_browser__;
	var $__0 = ($__helpers_47_dom_47_element__ = require("helpers/dom/element"), $__helpers_47_dom_47_element__ && $__helpers_47_dom_47_element__.__esModule && $__helpers_47_dom_47_element__ || {default: $__helpers_47_dom_47_element__}),
	    polymerWrap = $__0.polymerWrap,
	    closest = $__0.closest;
	var isWebComponentSupportedNatively = ($__helpers_47_browser__ = require("helpers/browser"), $__helpers_47_browser__ && $__helpers_47_browser__.__esModule && $__helpers_47_browser__ || {default: $__helpers_47_browser__}).isWebComponentSupportedNatively;
	var EventManager = function EventManager() {
	  var context = arguments[0] !== (void 0) ? arguments[0] : null;
	  this.context = context || this;
	  if (!this.context.eventListeners) {
	    this.context.eventListeners = [];
	  }
	};
	($traceurRuntime.createClass)(EventManager, {
	  addEventListener: function(element, eventName, callback) {
	    var $__2 = this;
	    var context = this.context;
	    function callbackProxy(event) {
	      if (event.target == void 0 && event.srcElement != void 0) {
	        if (event.definePoperty) {
	          event.definePoperty('target', {value: event.srcElement});
	        } else {
	          event.target = event.srcElement;
	        }
	      }
	      if (event.preventDefault == void 0) {
	        if (event.definePoperty) {
	          event.definePoperty('preventDefault', {value: function() {
	              this.returnValue = false;
	            }});
	        } else {
	          event.preventDefault = function() {
	            this.returnValue = false;
	          };
	        }
	      }
	      event = extendEvent(context, event);
	      callback.call(this, event);
	    }
	    this.context.eventListeners.push({
	      element: element,
	      event: eventName,
	      callback: callback,
	      callbackProxy: callbackProxy
	    });
	    if (window.addEventListener) {
	      element.addEventListener(eventName, callbackProxy, false);
	    } else {
	      element.attachEvent('on' + eventName, callbackProxy);
	    }
	    Handsontable.countEventManagerListeners++;
	    return (function() {
	      $__2.removeEventListener(element, eventName, callback);
	    });
	  },
	  removeEventListener: function(element, eventName, callback) {
	    var len = this.context.eventListeners.length;
	    var tmpEvent;
	    while (len--) {
	      tmpEvent = this.context.eventListeners[len];
	      if (tmpEvent.event == eventName && tmpEvent.element == element) {
	        if (callback && callback != tmpEvent.callback) {
	          continue;
	        }
	        this.context.eventListeners.splice(len, 1);
	        if (tmpEvent.element.removeEventListener) {
	          tmpEvent.element.removeEventListener(tmpEvent.event, tmpEvent.callbackProxy, false);
	        } else {
	          tmpEvent.element.detachEvent('on' + tmpEvent.event, tmpEvent.callbackProxy);
	        }
	        Handsontable.countEventManagerListeners--;
	      }
	    }
	  },
	  clearEvents: function() {
	    if (!this.context) {
	      return;
	    }
	    var len = this.context.eventListeners.length;
	    while (len--) {
	      var event = this.context.eventListeners[len];
	      if (event) {
	        this.removeEventListener(event.element, event.event, event.callback);
	      }
	    }
	  },
	  clear: function() {
	    this.clearEvents();
	  },
	  destroy: function() {
	    this.clearEvents();
	    this.context = null;
	  },
	  fireEvent: function(element, eventName) {
	    var options = {
	      bubbles: true,
	      cancelable: (eventName !== 'mousemove'),
	      view: window,
	      detail: 0,
	      screenX: 0,
	      screenY: 0,
	      clientX: 1,
	      clientY: 1,
	      ctrlKey: false,
	      altKey: false,
	      shiftKey: false,
	      metaKey: false,
	      button: 0,
	      relatedTarget: undefined
	    };
	    var event;
	    if (document.createEvent) {
	      event = document.createEvent('MouseEvents');
	      event.initMouseEvent(eventName, options.bubbles, options.cancelable, options.view, options.detail, options.screenX, options.screenY, options.clientX, options.clientY, options.ctrlKey, options.altKey, options.shiftKey, options.metaKey, options.button, options.relatedTarget || document.body.parentNode);
	    } else {
	      event = document.createEventObject();
	    }
	    if (element.dispatchEvent) {
	      element.dispatchEvent(event);
	    } else {
	      element.fireEvent('on' + eventName, event);
	    }
	  }
	}, {});
	function extendEvent(context, event) {
	  var componentName = 'HOT-TABLE';
	  var isHotTableSpotted;
	  var fromElement;
	  var realTarget;
	  var target;
	  var len;
	  event.isTargetWebComponent = false;
	  event.realTarget = event.target;
	  if (!Handsontable.eventManager.isHotTableEnv) {
	    return event;
	  }
	  event = polymerWrap(event);
	  len = event.path ? event.path.length : 0;
	  while (len--) {
	    if (event.path[len].nodeName === componentName) {
	      isHotTableSpotted = true;
	    } else if (isHotTableSpotted && event.path[len].shadowRoot) {
	      target = event.path[len];
	      break;
	    }
	    if (len === 0 && !target) {
	      target = event.path[len];
	    }
	  }
	  if (!target) {
	    target = event.target;
	  }
	  event.isTargetWebComponent = true;
	  if (isWebComponentSupportedNatively()) {
	    event.realTarget = event.srcElement || event.toElement;
	  } else if (context instanceof Handsontable.Core || context instanceof Walkontable) {
	    if (context instanceof Handsontable.Core) {
	      fromElement = context.view ? context.view.wt.wtTable.TABLE : null;
	    } else if (context instanceof Walkontable) {
	      fromElement = context.wtTable.TABLE.parentNode.parentNode;
	    }
	    realTarget = closest(event.target, [componentName], fromElement);
	    if (realTarget) {
	      event.realTarget = fromElement.querySelector(componentName) || event.target;
	    } else {
	      event.realTarget = event.target;
	    }
	  }
	  Object.defineProperty(event, 'target', {
	    get: function() {
	      return polymerWrap(target);
	    },
	    enumerable: true,
	    configurable: true
	  });
	  return event;
	}
	;
	window.Handsontable = window.Handsontable || {};
	Handsontable.countEventManagerListeners = 0;
	Handsontable.eventManager = eventManager;
	function eventManager(context) {
	  return new EventManager(context);
	}

	//# 
	},{"helpers/browser":43,"helpers/dom/element":45}],42:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  to2dArray: {get: function() {
	      return to2dArray;
	    }},
	  extendArray: {get: function() {
	      return extendArray;
	    }},
	  pivot: {get: function() {
	      return pivot;
	    }},
	  arrayReduce: {get: function() {
	      return arrayReduce;
	    }},
	  arrayFilter: {get: function() {
	      return arrayFilter;
	    }},
	  arrayMap: {get: function() {
	      return arrayMap;
	    }},
	  arrayEach: {get: function() {
	      return arrayEach;
	    }},
	  arraySum: {get: function() {
	      return arraySum;
	    }},
	  arrayMax: {get: function() {
	      return arrayMax;
	    }},
	  arrayMin: {get: function() {
	      return arrayMin;
	    }},
	  arrayAvg: {get: function() {
	      return arrayAvg;
	    }},
	  arrayFlatten: {get: function() {
	      return arrayFlatten;
	    }},
	  arrayUnique: {get: function() {
	      return arrayUnique;
	    }},
	  __esModule: {value: true}
	});
	function to2dArray(arr) {
	  var i = 0,
	      ilen = arr.length;
	  while (i < ilen) {
	    arr[i] = [arr[i]];
	    i++;
	  }
	}
	function extendArray(arr, extension) {
	  var i = 0,
	      ilen = extension.length;
	  while (i < ilen) {
	    arr.push(extension[i]);
	    i++;
	  }
	}
	function pivot(arr) {
	  var pivotedArr = [];
	  if (!arr || arr.length === 0 || !arr[0] || arr[0].length === 0) {
	    return pivotedArr;
	  }
	  var rowCount = arr.length;
	  var colCount = arr[0].length;
	  for (var i = 0; i < rowCount; i++) {
	    for (var j = 0; j < colCount; j++) {
	      if (!pivotedArr[j]) {
	        pivotedArr[j] = [];
	      }
	      pivotedArr[j][i] = arr[i][j];
	    }
	  }
	  return pivotedArr;
	}
	function arrayReduce(array, iteratee, accumulator, initFromArray) {
	  var index = -1,
	      length = array.length;
	  if (initFromArray && length) {
	    accumulator = array[++index];
	  }
	  while (++index < length) {
	    accumulator = iteratee(accumulator, array[index], index, array);
	  }
	  return accumulator;
	}
	function arrayFilter(array, predicate) {
	  var index = -1,
	      length = array.length,
	      resIndex = -1,
	      result = [];
	  while (++index < length) {
	    var value = array[index];
	    if (predicate(value, index, array)) {
	      result[++resIndex] = value;
	    }
	  }
	  return result;
	}
	function arrayMap(array, iteratee) {
	  var index = -1,
	      length = array.length,
	      resIndex = -1,
	      result = [];
	  while (++index < length) {
	    var value = array[index];
	    result[++resIndex] = iteratee(value, index, array);
	  }
	  return result;
	}
	function arrayEach(array, iteratee) {
	  var index = -1,
	      length = array.length;
	  while (++index < length) {
	    if (iteratee(array[index], index, array) === false) {
	      break;
	    }
	  }
	  return array;
	}
	function arraySum(array) {
	  return arrayReduce(array, (function(a, b) {
	    return (a + b);
	  }), 0);
	}
	function arrayMax(array) {
	  return arrayReduce(array, (function(a, b) {
	    return (a > b ? a : b);
	  }), Array.isArray(array) ? array[0] : void 0);
	}
	function arrayMin(array) {
	  return arrayReduce(array, (function(a, b) {
	    return (a < b ? a : b);
	  }), Array.isArray(array) ? array[0] : void 0);
	}
	function arrayAvg(array) {
	  if (!array.length) {
	    return 0;
	  }
	  return arraySum(array) / array.length;
	}
	function arrayFlatten(array) {
	  return arrayReduce(array, (function(initial, value) {
	    return initial.concat(Array.isArray(value) ? arrayFlatten(value) : value);
	  }), []);
	}
	function arrayUnique(array) {
	  var unique = [];
	  arrayEach(array, (function(value) {
	    if (unique.indexOf(value) === -1) {
	      unique.push(value);
	    }
	  }));
	  return unique;
	}

	//# 
	},{}],43:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  isIE8: {get: function() {
	      return isIE8;
	    }},
	  isIE9: {get: function() {
	      return isIE9;
	    }},
	  isSafari: {get: function() {
	      return isSafari;
	    }},
	  isChrome: {get: function() {
	      return isChrome;
	    }},
	  isMobileBrowser: {get: function() {
	      return isMobileBrowser;
	    }},
	  isTouchSupported: {get: function() {
	      return isTouchSupported;
	    }},
	  isWebComponentSupportedNatively: {get: function() {
	      return isWebComponentSupportedNatively;
	    }},
	  hasCaptionProblem: {get: function() {
	      return hasCaptionProblem;
	    }},
	  __esModule: {value: true}
	});
	var _isIE8 = !(document.createTextNode('test').textContent);
	function isIE8() {
	  return _isIE8;
	}
	var _isIE9 = !!(document.documentMode);
	function isIE9() {
	  return _isIE9;
	}
	var _isSafari = (/Safari/.test(navigator.userAgent) && /Apple Computer/.test(navigator.vendor));
	function isSafari() {
	  return _isSafari;
	}
	var _isChrome = (/Chrome/.test(navigator.userAgent) && /Google/.test(navigator.vendor));
	function isChrome() {
	  return _isChrome;
	}
	function isMobileBrowser(userAgent) {
	  if (!userAgent) {
	    userAgent = navigator.userAgent;
	  }
	  return (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(userAgent));
	}
	function isTouchSupported() {
	  return ('ontouchstart' in window);
	}
	function isWebComponentSupportedNatively() {
	  var test = document.createElement('div');
	  return test.createShadowRoot && test.createShadowRoot.toString().match(/\[native code\]/) ? true : false;
	}
	var _hasCaptionProblem;
	function detectCaptionProblem() {
	  var TABLE = document.createElement('TABLE');
	  TABLE.style.borderSpacing = 0;
	  TABLE.style.borderWidth = 0;
	  TABLE.style.padding = 0;
	  var TBODY = document.createElement('TBODY');
	  TABLE.appendChild(TBODY);
	  TBODY.appendChild(document.createElement('TR'));
	  TBODY.firstChild.appendChild(document.createElement('TD'));
	  TBODY.firstChild.firstChild.innerHTML = '<tr><td>t<br>t</td></tr>';
	  var CAPTION = document.createElement('CAPTION');
	  CAPTION.innerHTML = 'c<br>c<br>c<br>c';
	  CAPTION.style.padding = 0;
	  CAPTION.style.margin = 0;
	  TABLE.insertBefore(CAPTION, TBODY);
	  document.body.appendChild(TABLE);
	  _hasCaptionProblem = (TABLE.offsetHeight < 2 * TABLE.lastChild.offsetHeight);
	  document.body.removeChild(TABLE);
	}
	function hasCaptionProblem() {
	  if (_hasCaptionProblem === void 0) {
	    detectCaptionProblem();
	  }
	  return _hasCaptionProblem;
	}

	//# 
	},{}],44:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  spreadsheetColumnLabel: {get: function() {
	      return spreadsheetColumnLabel;
	    }},
	  createSpreadsheetData: {get: function() {
	      return createSpreadsheetData;
	    }},
	  createSpreadsheetObjectData: {get: function() {
	      return createSpreadsheetObjectData;
	    }},
	  createEmptySpreadsheetData: {get: function() {
	      return createEmptySpreadsheetData;
	    }},
	  translateRowsToColumns: {get: function() {
	      return translateRowsToColumns;
	    }},
	  cellMethodLookupFactory: {get: function() {
	      return cellMethodLookupFactory;
	    }},
	  __esModule: {value: true}
	});
	var $__object__;
	var getPrototypeOf = ($__object__ = require("object"), $__object__ && $__object__.__esModule && $__object__ || {default: $__object__}).getPrototypeOf;
	function spreadsheetColumnLabel(index) {
	  var dividend = index + 1;
	  var columnLabel = '';
	  var modulo;
	  while (dividend > 0) {
	    modulo = (dividend - 1) % 26;
	    columnLabel = String.fromCharCode(65 + modulo) + columnLabel;
	    dividend = parseInt((dividend - modulo) / 26, 10);
	  }
	  return columnLabel;
	}
	function createSpreadsheetData(rowCount, colCount) {
	  rowCount = typeof rowCount === 'number' ? rowCount : 100;
	  colCount = typeof colCount === 'number' ? colCount : 4;
	  var rows = [],
	      i,
	      j;
	  for (i = 0; i < rowCount; i++) {
	    var row = [];
	    for (j = 0; j < colCount; j++) {
	      row.push(spreadsheetColumnLabel(j) + (i + 1));
	    }
	    rows.push(row);
	  }
	  return rows;
	}
	function createSpreadsheetObjectData(rowCount, colCount) {
	  rowCount = typeof rowCount === 'number' ? rowCount : 100;
	  colCount = typeof colCount === 'number' ? colCount : 4;
	  var rows = [],
	      i,
	      j;
	  for (i = 0; i < rowCount; i++) {
	    var row = {};
	    for (j = 0; j < colCount; j++) {
	      row['prop' + j] = spreadsheetColumnLabel(j) + (i + 1);
	    }
	    rows.push(row);
	  }
	  return rows;
	}
	function createEmptySpreadsheetData(rows, columns) {
	  var data = [];
	  var row;
	  for (var i = 0; i < rows; i++) {
	    row = [];
	    for (var j = 0; j < columns; j++) {
	      row.push('');
	    }
	    data.push(row);
	  }
	  return data;
	}
	function translateRowsToColumns(input) {
	  var i,
	      ilen,
	      j,
	      jlen,
	      output = [],
	      olen = 0;
	  for (i = 0, ilen = input.length; i < ilen; i++) {
	    for (j = 0, jlen = input[i].length; j < jlen; j++) {
	      if (j == olen) {
	        output.push([]);
	        olen++;
	      }
	      output[j].push(input[i][j]);
	    }
	  }
	  return output;
	}
	function cellMethodLookupFactory(methodName, allowUndefined) {
	  allowUndefined = typeof allowUndefined == 'undefined' ? true : allowUndefined;
	  return function cellMethodLookup(row, col) {
	    return (function getMethodFromProperties(properties) {
	      if (!properties) {
	        return;
	      } else if (properties.hasOwnProperty(methodName) && properties[methodName] !== void 0) {
	        return properties[methodName];
	      } else if (properties.hasOwnProperty('type') && properties.type) {
	        var type;
	        if (typeof properties.type != 'string') {
	          throw new Error('Cell type must be a string ');
	        }
	        type = translateTypeNameToObject(properties.type);
	        if (type.hasOwnProperty(methodName)) {
	          return type[methodName];
	        } else if (allowUndefined) {
	          return;
	        }
	      }
	      return getMethodFromProperties(getPrototypeOf(properties));
	    })(typeof row == 'number' ? this.getCellMeta(row, col) : row);
	  };
	  function translateTypeNameToObject(typeName) {
	    var type = Handsontable.cellTypes[typeName];
	    if (typeof type == 'undefined') {
	      throw new Error('You declared cell type "' + typeName + '" as a string that is not mapped to a known object. ' + 'Cell type must be an object or a string mapped to an object in Handsontable.cellTypes');
	    }
	    return type;
	  }
	}

	//# 
	},{"object":50}],45:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  closest: {get: function() {
	      return closest;
	    }},
	  isChildOf: {get: function() {
	      return isChildOf;
	    }},
	  isChildOfWebComponentTable: {get: function() {
	      return isChildOfWebComponentTable;
	    }},
	  polymerWrap: {get: function() {
	      return polymerWrap;
	    }},
	  polymerUnwrap: {get: function() {
	      return polymerUnwrap;
	    }},
	  index: {get: function() {
	      return index;
	    }},
	  overlayContainsElement: {get: function() {
	      return overlayContainsElement;
	    }},
	  hasClass: {get: function() {
	      return hasClass;
	    }},
	  addClass: {get: function() {
	      return addClass;
	    }},
	  removeClass: {get: function() {
	      return removeClass;
	    }},
	  removeTextNodes: {get: function() {
	      return removeTextNodes;
	    }},
	  empty: {get: function() {
	      return empty;
	    }},
	  HTML_CHARACTERS: {get: function() {
	      return HTML_CHARACTERS;
	    }},
	  fastInnerHTML: {get: function() {
	      return fastInnerHTML;
	    }},
	  fastInnerText: {get: function() {
	      return fastInnerText;
	    }},
	  isVisible: {get: function() {
	      return isVisible;
	    }},
	  offset: {get: function() {
	      return offset;
	    }},
	  getWindowScrollTop: {get: function() {
	      return getWindowScrollTop;
	    }},
	  getWindowScrollLeft: {get: function() {
	      return getWindowScrollLeft;
	    }},
	  getScrollTop: {get: function() {
	      return getScrollTop;
	    }},
	  getScrollLeft: {get: function() {
	      return getScrollLeft;
	    }},
	  getScrollableElement: {get: function() {
	      return getScrollableElement;
	    }},
	  getTrimmingContainer: {get: function() {
	      return getTrimmingContainer;
	    }},
	  getStyle: {get: function() {
	      return getStyle;
	    }},
	  getComputedStyle: {get: function() {
	      return getComputedStyle;
	    }},
	  outerWidth: {get: function() {
	      return outerWidth;
	    }},
	  outerHeight: {get: function() {
	      return outerHeight;
	    }},
	  innerHeight: {get: function() {
	      return innerHeight;
	    }},
	  innerWidth: {get: function() {
	      return innerWidth;
	    }},
	  addEvent: {get: function() {
	      return addEvent;
	    }},
	  removeEvent: {get: function() {
	      return removeEvent;
	    }},
	  getCaretPosition: {get: function() {
	      return getCaretPosition;
	    }},
	  getSelectionEndPosition: {get: function() {
	      return getSelectionEndPosition;
	    }},
	  getSelectionText: {get: function() {
	      return getSelectionText;
	    }},
	  setCaretPosition: {get: function() {
	      return setCaretPosition;
	    }},
	  getScrollbarWidth: {get: function() {
	      return getScrollbarWidth;
	    }},
	  setOverlayPosition: {get: function() {
	      return setOverlayPosition;
	    }},
	  getCssTransform: {get: function() {
	      return getCssTransform;
	    }},
	  resetCssTransform: {get: function() {
	      return resetCssTransform;
	    }},
	  isInput: {get: function() {
	      return isInput;
	    }},
	  isOutsideInput: {get: function() {
	      return isOutsideInput;
	    }},
	  requestAnimationFrame: {get: function() {
	      return requestAnimationFrame;
	    }},
	  cancelAnimationFrame: {get: function() {
	      return cancelAnimationFrame;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47_browser__;
	var $__0 = ($___46__46__47_browser__ = require("../browser"), $___46__46__47_browser__ && $___46__46__47_browser__.__esModule && $___46__46__47_browser__ || {default: $___46__46__47_browser__}),
	    isIE8 = $__0.isIE8,
	    isIE9 = $__0.isIE9,
	    isSafari = $__0.isSafari,
	    hasCaptionProblem = $__0.hasCaptionProblem;
	function closest(element, nodes, until) {
	  while (element != null && element !== until) {
	    if (element.nodeType === Node.ELEMENT_NODE && (nodes.indexOf(element.nodeName) > -1 || nodes.indexOf(element) > -1)) {
	      return element;
	    }
	    if (element.host && element.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
	      element = element.host;
	    } else {
	      element = element.parentNode;
	    }
	  }
	  return null;
	}
	function isChildOf(child, parent) {
	  var node = child.parentNode;
	  var queriedParents = [];
	  if (typeof parent === 'string') {
	    queriedParents = Array.prototype.slice.call(document.querySelectorAll(parent), 0);
	  } else {
	    queriedParents.push(parent);
	  }
	  while (node != null) {
	    if (queriedParents.indexOf(node) > -1) {
	      return true;
	    }
	    node = node.parentNode;
	  }
	  return false;
	}
	function isChildOfWebComponentTable(element) {
	  var hotTableName = 'hot-table',
	      result = false,
	      parentNode;
	  parentNode = polymerWrap(element);
	  function isHotTable(element) {
	    return element.nodeType === Node.ELEMENT_NODE && element.nodeName === hotTableName.toUpperCase();
	  }
	  while (parentNode != null) {
	    if (isHotTable(parentNode)) {
	      result = true;
	      break;
	    } else if (parentNode.host && parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
	      result = isHotTable(parentNode.host);
	      if (result) {
	        break;
	      }
	      parentNode = parentNode.host;
	    }
	    parentNode = parentNode.parentNode;
	  }
	  return result;
	}
	function polymerWrap(element) {
	  return typeof Polymer !== 'undefined' && typeof wrap === 'function' ? wrap(element) : element;
	}
	function polymerUnwrap(element) {
	  return typeof Polymer !== 'undefined' && typeof unwrap === 'function' ? unwrap(element) : element;
	}
	function index(element) {
	  var i = 0;
	  if (element.previousSibling) {
	    while (element = element.previousSibling) {
	      ++i;
	    }
	  }
	  return i;
	}
	function overlayContainsElement(overlayType, element) {
	  var overlayElement = document.querySelector('.ht_clone_' + overlayType);
	  return overlayElement ? overlayElement.contains(element) : null;
	}
	var classListSupport = document.documentElement.classList ? true : false;
	var _hasClass,
	    _addClass,
	    _removeClass;
	function filterEmptyClassNames(classNames) {
	  var len = 0,
	      result = [];
	  if (!classNames || !classNames.length) {
	    return result;
	  }
	  while (classNames[len]) {
	    result.push(classNames[len]);
	    len++;
	  }
	  return result;
	}
	if (classListSupport) {
	  var isSupportMultipleClassesArg = (function() {
	    var element = document.createElement('div');
	    element.classList.add('test', 'test2');
	    return element.classList.contains('test2');
	  }());
	  _hasClass = function _hasClass(element, className) {
	    if (className === '') {
	      return false;
	    }
	    return element.classList.contains(className);
	  };
	  _addClass = function _addClass(element, className) {
	    var len = 0;
	    if (typeof className === 'string') {
	      className = className.split(' ');
	    }
	    className = filterEmptyClassNames(className);
	    if (isSupportMultipleClassesArg) {
	      element.classList.add.apply(element.classList, className);
	    } else {
	      while (className && className[len]) {
	        element.classList.add(className[len]);
	        len++;
	      }
	    }
	  };
	  _removeClass = function _removeClass(element, className) {
	    var len = 0;
	    if (typeof className === 'string') {
	      className = className.split(' ');
	    }
	    className = filterEmptyClassNames(className);
	    if (isSupportMultipleClassesArg) {
	      element.classList.remove.apply(element.classList, className);
	    } else {
	      while (className && className[len]) {
	        element.classList.remove(className[len]);
	        len++;
	      }
	    }
	  };
	} else {
	  var createClassNameRegExp = function createClassNameRegExp(className) {
	    return new RegExp('(\\s|^)' + className + '(\\s|$)');
	  };
	  _hasClass = function _hasClass(element, className) {
	    return element.className.match(createClassNameRegExp(className)) ? true : false;
	  };
	  _addClass = function _addClass(element, className) {
	    var len = 0,
	        _className = element.className;
	    if (typeof className === 'string') {
	      className = className.split(' ');
	    }
	    if (_className === '') {
	      _className = className.join(' ');
	    } else {
	      while (className && className[len]) {
	        if (!createClassNameRegExp(className[len]).test(_className)) {
	          _className += ' ' + className[len];
	        }
	        len++;
	      }
	    }
	    element.className = _className;
	  };
	  _removeClass = function _removeClass(element, className) {
	    var len = 0,
	        _className = element.className;
	    if (typeof className === 'string') {
	      className = className.split(' ');
	    }
	    while (className && className[len]) {
	      _className = _className.replace(createClassNameRegExp(className[len]), ' ').trim();
	      len++;
	    }
	    if (element.className !== _className) {
	      element.className = _className;
	    }
	  };
	}
	function hasClass(element, className) {
	  return _hasClass(element, className);
	}
	function addClass(element, className) {
	  return _addClass(element, className);
	}
	function removeClass(element, className) {
	  return _removeClass(element, className);
	}
	function removeTextNodes(element, parent) {
	  if (element.nodeType === 3) {
	    parent.removeChild(element);
	  } else if (['TABLE', 'THEAD', 'TBODY', 'TFOOT', 'TR'].indexOf(element.nodeName) > -1) {
	    var childs = element.childNodes;
	    for (var i = childs.length - 1; i >= 0; i--) {
	      removeTextNodes(childs[i], element);
	    }
	  }
	}
	function empty(element) {
	  var child;
	  while (child = element.lastChild) {
	    element.removeChild(child);
	  }
	}
	var HTML_CHARACTERS = /(<(.*)>|&(.*);)/;
	function fastInnerHTML(element, content) {
	  if (HTML_CHARACTERS.test(content)) {
	    element.innerHTML = content;
	  } else {
	    fastInnerText(element, content);
	  }
	}
	var textContextSupport = document.createTextNode('test').textContent ? true : false;
	function fastInnerText(element, content) {
	  var child = element.firstChild;
	  if (child && child.nodeType === 3 && child.nextSibling === null) {
	    if (textContextSupport) {
	      child.textContent = content;
	    } else {
	      child.data = content;
	    }
	  } else {
	    empty(element);
	    element.appendChild(document.createTextNode(content));
	  }
	}
	function isVisible(elem) {
	  var next = elem;
	  while (polymerUnwrap(next) !== document.documentElement) {
	    if (next === null) {
	      return false;
	    } else if (next.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
	      if (next.host) {
	        if (next.host.impl) {
	          return isVisible(next.host.impl);
	        } else if (next.host) {
	          return isVisible(next.host);
	        } else {
	          throw new Error('Lost in Web Components world');
	        }
	      } else {
	        return false;
	      }
	    } else if (next.style.display === 'none') {
	      return false;
	    }
	    next = next.parentNode;
	  }
	  return true;
	}
	function offset(elem) {
	  var offsetLeft,
	      offsetTop,
	      lastElem,
	      docElem,
	      box;
	  docElem = document.documentElement;
	  if (hasCaptionProblem() && elem.firstChild && elem.firstChild.nodeName === 'CAPTION') {
	    box = elem.getBoundingClientRect();
	    return {
	      top: box.top + (window.pageYOffset || docElem.scrollTop) - (docElem.clientTop || 0),
	      left: box.left + (window.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || 0)
	    };
	  }
	  offsetLeft = elem.offsetLeft;
	  offsetTop = elem.offsetTop;
	  lastElem = elem;
	  while (elem = elem.offsetParent) {
	    if (elem === document.body) {
	      break;
	    }
	    offsetLeft += elem.offsetLeft;
	    offsetTop += elem.offsetTop;
	    lastElem = elem;
	  }
	  if (lastElem && lastElem.style.position === 'fixed') {
	    offsetLeft += window.pageXOffset || docElem.scrollLeft;
	    offsetTop += window.pageYOffset || docElem.scrollTop;
	  }
	  return {
	    left: offsetLeft,
	    top: offsetTop
	  };
	}
	function getWindowScrollTop() {
	  var res = window.scrollY;
	  if (res === void 0) {
	    res = document.documentElement.scrollTop;
	  }
	  return res;
	}
	function getWindowScrollLeft() {
	  var res = window.scrollX;
	  if (res === void 0) {
	    res = document.documentElement.scrollLeft;
	  }
	  return res;
	}
	function getScrollTop(element) {
	  if (element === window) {
	    return getWindowScrollTop();
	  } else {
	    return element.scrollTop;
	  }
	}
	function getScrollLeft(element) {
	  if (element === window) {
	    return getWindowScrollLeft();
	  } else {
	    return element.scrollLeft;
	  }
	}
	function getScrollableElement(element) {
	  var el = element.parentNode,
	      props = ['auto', 'scroll'],
	      overflow,
	      overflowX,
	      overflowY,
	      computedStyle = '',
	      computedOverflow = '',
	      computedOverflowY = '',
	      computedOverflowX = '';
	  while (el && el.style && document.body !== el) {
	    overflow = el.style.overflow;
	    overflowX = el.style.overflowX;
	    overflowY = el.style.overflowY;
	    if (overflow == 'scroll' || overflowX == 'scroll' || overflowY == 'scroll') {
	      return el;
	    } else if (window.getComputedStyle) {
	      computedStyle = window.getComputedStyle(el);
	      computedOverflow = computedStyle.getPropertyValue('overflow');
	      computedOverflowY = computedStyle.getPropertyValue('overflow-y');
	      computedOverflowX = computedStyle.getPropertyValue('overflow-x');
	      if (computedOverflow === 'scroll' || computedOverflowX === 'scroll' || computedOverflowY === 'scroll') {
	        return el;
	      }
	    }
	    if (el.clientHeight <= el.scrollHeight && (props.indexOf(overflowY) !== -1 || props.indexOf(overflow) !== -1 || props.indexOf(computedOverflow) !== -1 || props.indexOf(computedOverflowY) !== -1)) {
	      return el;
	    }
	    if (el.clientWidth <= el.scrollWidth && (props.indexOf(overflowX) !== -1 || props.indexOf(overflow) !== -1 || props.indexOf(computedOverflow) !== -1 || props.indexOf(computedOverflowX) !== -1)) {
	      return el;
	    }
	    el = el.parentNode;
	  }
	  return window;
	}
	function getTrimmingContainer(base) {
	  var el = base.parentNode;
	  while (el && el.style && document.body !== el) {
	    if (el.style.overflow !== 'visible' && el.style.overflow !== '') {
	      return el;
	    } else if (window.getComputedStyle) {
	      var computedStyle = window.getComputedStyle(el);
	      if (computedStyle.getPropertyValue('overflow') !== 'visible' && computedStyle.getPropertyValue('overflow') !== '') {
	        return el;
	      }
	    }
	    el = el.parentNode;
	  }
	  return window;
	}
	function getStyle(element, prop) {
	  if (!element) {
	    return;
	  } else if (element === window) {
	    if (prop === 'width') {
	      return window.innerWidth + 'px';
	    } else if (prop === 'height') {
	      return window.innerHeight + 'px';
	    }
	    return;
	  }
	  var styleProp = element.style[prop],
	      computedStyle;
	  if (styleProp !== '' && styleProp !== void 0) {
	    return styleProp;
	  } else {
	    computedStyle = getComputedStyle(element);
	    if (computedStyle[prop] !== '' && computedStyle[prop] !== void 0) {
	      return computedStyle[prop];
	    }
	    return void 0;
	  }
	}
	function getComputedStyle(element) {
	  return element.currentStyle || document.defaultView.getComputedStyle(element);
	}
	function outerWidth(element) {
	  return element.offsetWidth;
	}
	function outerHeight(elem) {
	  if (hasCaptionProblem() && elem.firstChild && elem.firstChild.nodeName === 'CAPTION') {
	    return elem.offsetHeight + elem.firstChild.offsetHeight;
	  } else {
	    return elem.offsetHeight;
	  }
	}
	function innerHeight(element) {
	  return element.clientHeight || element.innerHeight;
	}
	function innerWidth(element) {
	  return element.clientWidth || element.innerWidth;
	}
	function addEvent(element, event, callback) {
	  if (window.addEventListener) {
	    element.addEventListener(event, callback, false);
	  } else {
	    element.attachEvent('on' + event, callback);
	  }
	}
	function removeEvent(element, event, callback) {
	  if (window.removeEventListener) {
	    element.removeEventListener(event, callback, false);
	  } else {
	    element.detachEvent('on' + event, callback);
	  }
	}
	function getCaretPosition(el) {
	  if (el.selectionStart) {
	    return el.selectionStart;
	  } else if (document.selection) {
	    el.focus();
	    var r = document.selection.createRange();
	    if (r == null) {
	      return 0;
	    }
	    var re = el.createTextRange();
	    var rc = re.duplicate();
	    re.moveToBookmark(r.getBookmark());
	    rc.setEndPoint('EndToStart', re);
	    return rc.text.length;
	  }
	  return 0;
	}
	function getSelectionEndPosition(el) {
	  if (el.selectionEnd) {
	    return el.selectionEnd;
	  } else if (document.selection) {
	    var r = document.selection.createRange();
	    if (r == null) {
	      return 0;
	    }
	    var re = el.createTextRange();
	    return re.text.indexOf(r.text) + r.text.length;
	  }
	}
	function getSelectionText() {
	  var text = '';
	  if (window.getSelection) {
	    text = window.getSelection().toString();
	  } else if (document.selection && document.selection.type !== 'Control') {
	    text = document.selection.createRange().text;
	  }
	  return text;
	}
	function setCaretPosition(element, pos, endPos) {
	  if (endPos === void 0) {
	    endPos = pos;
	  }
	  if (element.setSelectionRange) {
	    element.focus();
	    try {
	      element.setSelectionRange(pos, endPos);
	    } catch (err) {
	      var elementParent = element.parentNode;
	      var parentDisplayValue = elementParent.style.display;
	      elementParent.style.display = 'block';
	      element.setSelectionRange(pos, endPos);
	      elementParent.style.display = parentDisplayValue;
	    }
	  } else if (element.createTextRange) {
	    var range = element.createTextRange();
	    range.collapse(true);
	    range.moveEnd('character', endPos);
	    range.moveStart('character', pos);
	    range.select();
	  }
	}
	var cachedScrollbarWidth;
	function walkontableCalculateScrollbarWidth() {
	  var inner = document.createElement('p');
	  inner.style.width = '100%';
	  inner.style.height = '200px';
	  var outer = document.createElement('div');
	  outer.style.position = 'absolute';
	  outer.style.top = '0px';
	  outer.style.left = '0px';
	  outer.style.visibility = 'hidden';
	  outer.style.width = '200px';
	  outer.style.height = '150px';
	  outer.style.overflow = 'hidden';
	  outer.appendChild(inner);
	  (document.body || document.documentElement).appendChild(outer);
	  var w1 = inner.offsetWidth;
	  outer.style.overflow = 'scroll';
	  var w2 = inner.offsetWidth;
	  if (w1 == w2) {
	    w2 = outer.clientWidth;
	  }
	  (document.body || document.documentElement).removeChild(outer);
	  return (w1 - w2);
	}
	function getScrollbarWidth() {
	  if (cachedScrollbarWidth === void 0) {
	    cachedScrollbarWidth = walkontableCalculateScrollbarWidth();
	  }
	  return cachedScrollbarWidth;
	}
	function setOverlayPosition(overlayElem, left, top) {
	  if (isIE8() || isIE9()) {
	    overlayElem.style.top = top;
	    overlayElem.style.left = left;
	  } else if (isSafari()) {
	    overlayElem.style['-webkit-transform'] = 'translate3d(' + left + ',' + top + ',0)';
	  } else {
	    overlayElem.style.transform = 'translate3d(' + left + ',' + top + ',0)';
	  }
	}
	function getCssTransform(element) {
	  var transform;
	  if (element.style.transform && (transform = element.style.transform) !== '') {
	    return ['transform', transform];
	  } else if (element.style['-webkit-transform'] && (transform = element.style['-webkit-transform']) !== '') {
	    return ['-webkit-transform', transform];
	  }
	  return -1;
	}
	function resetCssTransform(element) {
	  if (element.transform && element.transform !== '') {
	    element.transform = '';
	  } else if (element['-webkit-transform'] && element['-webkit-transform'] !== '') {
	    element['-webkit-transform'] = '';
	  }
	}
	function isInput(element) {
	  var inputs = ['INPUT', 'SELECT', 'TEXTAREA'];
	  return inputs.indexOf(element.nodeName) > -1 || element.contentEditable === 'true';
	}
	function isOutsideInput(element) {
	  return isInput(element) && element.className.indexOf('handsontableInput') == -1 && element.className.indexOf('copyPaste') == -1;
	}
	var lastTime = 0;
	var vendors = ['ms', 'moz', 'webkit', 'o'];
	var _requestAnimationFrame = window.requestAnimationFrame;
	var _cancelAnimationFrame = window.cancelAnimationFrame;
	for (var x = 0; x < vendors.length && !_requestAnimationFrame; ++x) {
	  _requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
	  _cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];
	}
	if (!_requestAnimationFrame) {
	  _requestAnimationFrame = function(callback) {
	    var currTime = new Date().getTime();
	    var timeToCall = Math.max(0, 16 - (currTime - lastTime));
	    var id = window.setTimeout(function() {
	      callback(currTime + timeToCall);
	    }, timeToCall);
	    lastTime = currTime + timeToCall;
	    return id;
	  };
	}
	if (!_cancelAnimationFrame) {
	  _cancelAnimationFrame = function(id) {
	    clearTimeout(id);
	  };
	}
	function requestAnimationFrame(callback) {
	  return _requestAnimationFrame.call(window, callback);
	}
	function cancelAnimationFrame(id) {
	  _cancelAnimationFrame.call(window, id);
	}

	//# 
	},{"../browser":43}],46:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  stopImmediatePropagation: {get: function() {
	      return stopImmediatePropagation;
	    }},
	  isImmediatePropagationStopped: {get: function() {
	      return isImmediatePropagationStopped;
	    }},
	  stopPropagation: {get: function() {
	      return stopPropagation;
	    }},
	  pageX: {get: function() {
	      return pageX;
	    }},
	  pageY: {get: function() {
	      return pageY;
	    }},
	  __esModule: {value: true}
	});
	function stopImmediatePropagation(event) {
	  event.isImmediatePropagationEnabled = false;
	  event.cancelBubble = true;
	}
	function isImmediatePropagationStopped(event) {
	  return event.isImmediatePropagationEnabled === false;
	}
	function stopPropagation(event) {
	  if (typeof event.stopPropagation === 'function') {
	    event.stopPropagation();
	  } else {
	    event.cancelBubble = true;
	  }
	}
	function pageX(event) {
	  if (event.pageX) {
	    return event.pageX;
	  }
	  var scrollLeft = getWindowScrollLeft();
	  var cursorX = event.clientX + scrollLeft;
	  return cursorX;
	}
	function pageY(event) {
	  if (event.pageY) {
	    return event.pageY;
	  }
	  var scrollTop = getWindowScrollTop();
	  var cursorY = event.clientY + scrollTop;
	  return cursorY;
	}

	//# 
	},{}],47:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  proxy: {get: function() {
	      return proxy;
	    }},
	  throttle: {get: function() {
	      return throttle;
	    }},
	  throttleAfterHits: {get: function() {
	      return throttleAfterHits;
	    }},
	  __esModule: {value: true}
	});
	function proxy(fun, context) {
	  return function() {
	    return fun.apply(context, arguments);
	  };
	}
	function throttle(func) {
	  var wait = arguments[1] !== (void 0) ? arguments[1] : 200;
	  var lastCalled = 0;
	  var result = {lastCallThrottled: true};
	  var lastTimer = null;
	  function _throttle() {
	    var $__0 = this;
	    var args = arguments;
	    var stamp = Date.now();
	    var needCall = false;
	    result.lastCallThrottled = true;
	    if (!lastCalled) {
	      lastCalled = stamp;
	      needCall = true;
	    }
	    var remaining = wait - (stamp - lastCalled);
	    if (needCall) {
	      result.lastCallThrottled = false;
	      func.apply(this, args);
	    } else {
	      if (lastTimer) {
	        clearTimeout(lastTimer);
	      }
	      lastTimer = setTimeout((function() {
	        result.lastCallThrottled = false;
	        func.apply($__0, args);
	        lastCalled = 0;
	        lastTimer = void 0;
	      }), remaining);
	    }
	    return result;
	  }
	  return _throttle;
	}
	function throttleAfterHits(func) {
	  var wait = arguments[1] !== (void 0) ? arguments[1] : 200;
	  var hits = arguments[2] !== (void 0) ? arguments[2] : 10;
	  var funcThrottle = throttle(func, wait);
	  var remainHits = hits;
	  function _clearHits() {
	    remainHits = hits;
	  }
	  function _throttleAfterHits() {
	    if (remainHits) {
	      remainHits--;
	      return func.apply(this, arguments);
	    }
	    return funcThrottle.apply(this, arguments);
	  }
	  _throttleAfterHits.clearHits = _clearHits;
	  return _throttleAfterHits;
	}

	//# 
	},{}],48:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  stringify: {get: function() {
	      return stringify;
	    }},
	  __esModule: {value: true}
	});
	function stringify(value) {
	  switch (typeof value) {
	    case 'string':
	    case 'number':
	      return value + '';
	    case 'object':
	      if (value === null) {
	        return '';
	      } else {
	        return value.toString();
	      }
	      break;
	    case 'undefined':
	      return '';
	    default:
	      return value.toString();
	  }
	}

	//# 
	},{}],49:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  isNumeric: {get: function() {
	      return isNumeric;
	    }},
	  rangeEach: {get: function() {
	      return rangeEach;
	    }},
	  rangeEachReverse: {get: function() {
	      return rangeEachReverse;
	    }},
	  valueAccordingPercent: {get: function() {
	      return valueAccordingPercent;
	    }},
	  __esModule: {value: true}
	});
	function isNumeric(n) {
	  var t = typeof n;
	  return t == 'number' ? !isNaN(n) && isFinite(n) : t == 'string' ? !n.length ? false : n.length == 1 ? /\d/.test(n) : /^\s*[+-]?\s*(?:(?:\d+(?:\.\d+)?(?:e[+-]?\d+)?)|(?:0x[a-f\d]+))\s*$/i.test(n) : t == 'object' ? !!n && typeof n.valueOf() == 'number' && !(n instanceof Date) : false;
	}
	function rangeEach(rangeFrom, rangeTo, iteratee) {
	  var index = -1;
	  if (typeof rangeTo === 'function') {
	    iteratee = rangeTo;
	    rangeTo = rangeFrom;
	  } else {
	    index = rangeFrom - 1;
	  }
	  while (++index <= rangeTo) {
	    if (iteratee(index) === false) {
	      break;
	    }
	  }
	}
	function rangeEachReverse(rangeFrom, rangeTo, iteratee) {
	  var index = rangeFrom + 1;
	  if (typeof rangeTo === 'function') {
	    iteratee = rangeTo;
	    rangeTo = 0;
	  }
	  while (--index >= rangeTo) {
	    if (iteratee(index) === false) {
	      break;
	    }
	  }
	}
	function valueAccordingPercent(value, percent) {
	  percent = parseInt(percent.toString().replace('%', ''), 10);
	  percent = parseInt(value * percent / 100);
	  return percent;
	}

	//# 
	},{}],50:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  duckSchema: {get: function() {
	      return duckSchema;
	    }},
	  inherit: {get: function() {
	      return inherit;
	    }},
	  extend: {get: function() {
	      return extend;
	    }},
	  deepExtend: {get: function() {
	      return deepExtend;
	    }},
	  deepClone: {get: function() {
	      return deepClone;
	    }},
	  clone: {get: function() {
	      return clone;
	    }},
	  mixin: {get: function() {
	      return mixin;
	    }},
	  isObjectEquals: {get: function() {
	      return isObjectEquals;
	    }},
	  isObject: {get: function() {
	      return isObject;
	    }},
	  getPrototypeOf: {get: function() {
	      return getPrototypeOf;
	    }},
	  defineGetter: {get: function() {
	      return defineGetter;
	    }},
	  objectEach: {get: function() {
	      return objectEach;
	    }},
	  getProperty: {get: function() {
	      return getProperty;
	    }},
	  __esModule: {value: true}
	});
	var $__array__;
	var arrayEach = ($__array__ = require("array"), $__array__ && $__array__.__esModule && $__array__ || {default: $__array__}).arrayEach;
	function duckSchema(object) {
	  var schema;
	  if (Array.isArray(object)) {
	    schema = [];
	  } else {
	    schema = {};
	    objectEach(object, function(value, key) {
	      if (value && typeof value === 'object' && !Array.isArray(value)) {
	        schema[key] = duckSchema(value);
	      } else if (Array.isArray(value)) {
	        if (value.length && typeof value[0] === 'object' && !Array.isArray(value[0])) {
	          schema[key] = [duckSchema(value[0])];
	        } else {
	          schema[key] = [];
	        }
	      } else {
	        schema[key] = null;
	      }
	    });
	  }
	  return schema;
	}
	function inherit(Child, Parent) {
	  Parent.prototype.constructor = Parent;
	  Child.prototype = new Parent();
	  Child.prototype.constructor = Child;
	  return Child;
	}
	function extend(target, extension) {
	  objectEach(extension, function(value, key) {
	    target[key] = value;
	  });
	  return target;
	}
	function deepExtend(target, extension) {
	  objectEach(extension, function(value, key) {
	    if (extension[key] && typeof extension[key] === 'object') {
	      if (!target[key]) {
	        if (Array.isArray(extension[key])) {
	          target[key] = [];
	        } else {
	          target[key] = {};
	        }
	      }
	      deepExtend(target[key], extension[key]);
	    } else {
	      target[key] = extension[key];
	    }
	  });
	}
	function deepClone(obj) {
	  if (typeof obj === 'object') {
	    return JSON.parse(JSON.stringify(obj));
	  }
	  return obj;
	}
	function clone(object) {
	  var result = {};
	  objectEach(object, (function(value, key) {
	    return result[key] = value;
	  }));
	  return result;
	}
	function mixin(Base) {
	  for (var mixins = [],
	      $__1 = 1; $__1 < arguments.length; $__1++)
	    mixins[$__1 - 1] = arguments[$__1];
	  if (!Base.MIXINS) {
	    Base.MIXINS = [];
	  }
	  arrayEach(mixins, (function(mixin) {
	    Base.MIXINS.push(mixin.MIXIN_NAME);
	    objectEach(mixin, (function(value, key) {
	      if (Base.prototype[key] !== void 0) {
	        throw new Error(("Mixin conflict. Property '" + key + "' already exist and cannot be overwritten."));
	      }
	      if (typeof value === 'function') {
	        Base.prototype[key] = value;
	      } else {
	        var getter = function _getter(propertyName, initialValue) {
	          propertyName = '_' + propertyName;
	          var initValue = (function(value) {
	            if (Array.isArray(value) || isObject(value)) {
	              value = deepClone(value);
	            }
	            return value;
	          });
	          return function() {
	            if (this[propertyName] === void 0) {
	              this[propertyName] = initValue(initialValue);
	            }
	            return this[propertyName];
	          };
	        };
	        var setter = function _setter(propertyName) {
	          propertyName = '_' + propertyName;
	          return function(value) {
	            this[propertyName] = value;
	          };
	        };
	        Object.defineProperty(Base.prototype, key, {
	          get: getter(key, value),
	          set: setter(key),
	          configurable: true
	        });
	      }
	    }));
	  }));
	  return Base;
	}
	function isObjectEquals(object1, object2) {
	  return JSON.stringify(object1) === JSON.stringify(object2);
	}
	function isObject(obj) {
	  return Object.prototype.toString.call(obj) == '[object Object]';
	}
	function getPrototypeOf(obj) {
	  var prototype;
	  if (typeof obj.__proto__ == 'object') {
	    prototype = obj.__proto__;
	  } else {
	    var oldConstructor,
	        constructor = obj.constructor;
	    if (typeof obj.constructor == 'function') {
	      oldConstructor = constructor;
	      if (delete obj.constructor) {
	        constructor = obj.constructor;
	        obj.constructor = oldConstructor;
	      }
	    }
	    prototype = constructor ? constructor.prototype : null;
	  }
	  return prototype;
	}
	function defineGetter(object, property, value, options) {
	  options.value = value;
	  options.writable = options.writable !== false;
	  options.enumerable = options.enumerable !== false;
	  options.configurable = options.configurable !== false;
	  Object.defineProperty(object, property, options);
	}
	function objectEach(object, iteratee) {
	  for (var key in object) {
	    if (!object.hasOwnProperty || (object.hasOwnProperty && object.hasOwnProperty(key))) {
	      if (iteratee(object[key], key, object) === false) {
	        break;
	      }
	    }
	  }
	  return object;
	}
	function getProperty(object, name) {
	  var names = name.split('.');
	  var result = object;
	  objectEach(names, (function(name) {
	    result = result[name];
	    if (result === void 0) {
	      result = void 0;
	      return false;
	    }
	  }));
	  return result;
	}

	//# 
	},{"array":42}],51:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  columnFactory: {get: function() {
	      return columnFactory;
	    }},
	  __esModule: {value: true}
	});
	var $__object__;
	var inherit = ($__object__ = require("object"), $__object__ && $__object__.__esModule && $__object__ || {default: $__object__}).inherit;
	function columnFactory(GridSettings, conflictList) {
	  function ColumnSettings() {}
	  ;
	  inherit(ColumnSettings, GridSettings);
	  for (var i = 0,
	      len = conflictList.length; i < len; i++) {
	    ColumnSettings.prototype[conflictList[i]] = void 0;
	  }
	  return ColumnSettings;
	}

	//# 
	},{"object":50}],52:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  toUpperCaseFirst: {get: function() {
	      return toUpperCaseFirst;
	    }},
	  startsWith: {get: function() {
	      return startsWith;
	    }},
	  endsWith: {get: function() {
	      return endsWith;
	    }},
	  equalsIgnoreCase: {get: function() {
	      return equalsIgnoreCase;
	    }},
	  randomString: {get: function() {
	      return randomString;
	    }},
	  isPercentValue: {get: function() {
	      return isPercentValue;
	    }},
	  __esModule: {value: true}
	});
	var $__mixed__,
	    $__number__;
	var stringify = ($__mixed__ = require("mixed"), $__mixed__ && $__mixed__.__esModule && $__mixed__ || {default: $__mixed__}).stringify;
	var rangeEach = ($__number__ = require("number"), $__number__ && $__number__.__esModule && $__number__ || {default: $__number__}).rangeEach;
	function toUpperCaseFirst(string) {
	  return string[0].toUpperCase() + string.substr(1);
	}
	function startsWith(string, needle) {
	  var result = true;
	  rangeEach(needle.length - 1, (function(index) {
	    if (string.charAt(index) !== needle.charAt(index)) {
	      result = false;
	      return false;
	    }
	  }));
	  return result;
	}
	function endsWith(string, needle) {
	  var result = true;
	  var needleLength = needle.length - 1;
	  var stringLength = string.length - 1;
	  rangeEach(needleLength, (function(index) {
	    var stringIndex = stringLength - index;
	    var needleIndex = needleLength - index;
	    if (string.charAt(stringIndex) !== needle.charAt(needleIndex)) {
	      result = false;
	      return false;
	    }
	  }));
	  return result;
	}
	function equalsIgnoreCase() {
	  for (var strings = [],
	      $__2 = 0; $__2 < arguments.length; $__2++)
	    strings[$__2] = arguments[$__2];
	  var unique = [];
	  var length = strings.length;
	  while (length--) {
	    var string = stringify(strings[length]).toLowerCase();
	    if (unique.indexOf(string) === -1) {
	      unique.push(string);
	    }
	  }
	  return unique.length === 1;
	}
	function randomString() {
	  function s4() {
	    return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
	  }
	  return s4() + s4() + s4() + s4();
	}
	function isPercentValue(value) {
	  return /^([0-9][0-9]?\%$)|(^100\%$)/.test(value);
	}

	//# 
	},{"mixed":48,"number":49}],53:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  KEY_CODES: {get: function() {
	      return KEY_CODES;
	    }},
	  isPrintableChar: {get: function() {
	      return isPrintableChar;
	    }},
	  isMetaKey: {get: function() {
	      return isMetaKey;
	    }},
	  isCtrlKey: {get: function() {
	      return isCtrlKey;
	    }},
	  isKey: {get: function() {
	      return isKey;
	    }},
	  __esModule: {value: true}
	});
	var $__array__;
	var arrayEach = ($__array__ = require("array"), $__array__ && $__array__.__esModule && $__array__ || {default: $__array__}).arrayEach;
	var KEY_CODES = {
	  MOUSE_LEFT: 1,
	  MOUSE_RIGHT: 3,
	  MOUSE_MIDDLE: 2,
	  BACKSPACE: 8,
	  COMMA: 188,
	  INSERT: 45,
	  DELETE: 46,
	  END: 35,
	  ENTER: 13,
	  ESCAPE: 27,
	  CONTROL_LEFT: 91,
	  COMMAND_LEFT: 17,
	  COMMAND_RIGHT: 93,
	  ALT: 18,
	  HOME: 36,
	  PAGE_DOWN: 34,
	  PAGE_UP: 33,
	  PERIOD: 190,
	  SPACE: 32,
	  SHIFT: 16,
	  CAPS_LOCK: 20,
	  TAB: 9,
	  ARROW_RIGHT: 39,
	  ARROW_LEFT: 37,
	  ARROW_UP: 38,
	  ARROW_DOWN: 40,
	  F1: 112,
	  F2: 113,
	  F3: 114,
	  F4: 115,
	  F5: 116,
	  F6: 117,
	  F7: 118,
	  F8: 119,
	  F9: 120,
	  F10: 121,
	  F11: 122,
	  F12: 123,
	  A: 65,
	  X: 88,
	  C: 67,
	  V: 86
	};
	function isPrintableChar(keyCode) {
	  return ((keyCode == 32) || (keyCode >= 48 && keyCode <= 57) || (keyCode >= 96 && keyCode <= 111) || (keyCode >= 186 && keyCode <= 192) || (keyCode >= 219 && keyCode <= 222) || keyCode >= 226 || (keyCode >= 65 && keyCode <= 90));
	}
	function isMetaKey(keyCode) {
	  var metaKeys = [KEY_CODES.ARROW_DOWN, KEY_CODES.ARROW_UP, KEY_CODES.ARROW_LEFT, KEY_CODES.ARROW_RIGHT, KEY_CODES.HOME, KEY_CODES.END, KEY_CODES.DELETE, KEY_CODES.BACKSPACE, KEY_CODES.F1, KEY_CODES.F2, KEY_CODES.F3, KEY_CODES.F4, KEY_CODES.F5, KEY_CODES.F6, KEY_CODES.F7, KEY_CODES.F8, KEY_CODES.F9, KEY_CODES.F10, KEY_CODES.F11, KEY_CODES.F12, KEY_CODES.TAB, KEY_CODES.PAGE_DOWN, KEY_CODES.PAGE_UP, KEY_CODES.ENTER, KEY_CODES.ESCAPE, KEY_CODES.SHIFT, KEY_CODES.CAPS_LOCK, KEY_CODES.ALT];
	  return metaKeys.indexOf(keyCode) !== -1;
	}
	function isCtrlKey(keyCode) {
	  return [KEY_CODES.CONTROL_LEFT, 224, KEY_CODES.COMMAND_LEFT, KEY_CODES.COMMAND_RIGHT].indexOf(keyCode) !== -1;
	}
	function isKey(keyCode, baseCode) {
	  var keys = baseCode.split('|');
	  var result = false;
	  arrayEach(keys, function(key) {
	    if (keyCode === KEY_CODES[key]) {
	      result = true;
	      return false;
	    }
	  });
	  return result;
	}

	//# 
	},{"array":42}],54:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  localHooks: {get: function() {
	      return localHooks;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47_helpers_47_array__,
	    $___46__46__47_helpers_47_object__;
	var arrayEach = ($___46__46__47_helpers_47_array__ = require("helpers/array"), $___46__46__47_helpers_47_array__ && $___46__46__47_helpers_47_array__.__esModule && $___46__46__47_helpers_47_array__ || {default: $___46__46__47_helpers_47_array__}).arrayEach;
	var defineGetter = ($___46__46__47_helpers_47_object__ = require("helpers/object"), $___46__46__47_helpers_47_object__ && $___46__46__47_helpers_47_object__.__esModule && $___46__46__47_helpers_47_object__ || {default: $___46__46__47_helpers_47_object__}).defineGetter;
	var MIXIN_NAME = 'localHooks';
	var localHooks = {
	  _localHooks: Object.create(null),
	  addLocalHook: function(key, callback) {
	    if (!this._localHooks[key]) {
	      this._localHooks[key] = [];
	    }
	    this._localHooks[key].push(callback);
	  },
	  runLocalHooks: function(key) {
	    for (var params = [],
	        $__3 = 1; $__3 < arguments.length; $__3++)
	      params[$__3 - 1] = arguments[$__3];
	    var $__2 = this;
	    if (this._localHooks[key]) {
	      arrayEach(this._localHooks[key], (function(callback) {
	        return callback.apply($__2, params);
	      }));
	    }
	  },
	  clearLocalHooks: function() {
	    this._localHooks = {};
	  }
	};
	defineGetter(localHooks, 'MIXIN_NAME', MIXIN_NAME, {
	  writable: false,
	  enumerable: false
	});
	;
	Handsontable.utils = Handsontable.utils || {};
	Handsontable.utils.localHooks = localHooks;

	//# 
	},{"helpers/array":42,"helpers/object":50}],55:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  MultiMap: {get: function() {
	      return MultiMap;
	    }},
	  __esModule: {value: true}
	});
	;
	window.MultiMap = MultiMap;
	function MultiMap() {
	  var map = {
	    arrayMap: [],
	    weakMap: new WeakMap()
	  };
	  return {
	    get: function(key) {
	      if (canBeAnArrayMapKey(key)) {
	        return map.arrayMap[key];
	      } else if (canBeAWeakMapKey(key)) {
	        return map.weakMap.get(key);
	      }
	    },
	    set: function(key, value) {
	      if (canBeAnArrayMapKey(key)) {
	        map.arrayMap[key] = value;
	      } else if (canBeAWeakMapKey(key)) {
	        map.weakMap.set(key, value);
	      } else {
	        throw new Error('Invalid key type');
	      }
	    },
	    delete: function(key) {
	      if (canBeAnArrayMapKey(key)) {
	        delete map.arrayMap[key];
	      } else if (canBeAWeakMapKey(key)) {
	        map.weakMap.delete(key);
	      }
	    }
	  };
	  function canBeAnArrayMapKey(obj) {
	    return obj !== null && !isNaNSymbol(obj) && (typeof obj == 'string' || typeof obj == 'number');
	  }
	  function canBeAWeakMapKey(obj) {
	    return obj !== null && (typeof obj == 'object' || typeof obj == 'function');
	  }
	  function isNaNSymbol(obj) {
	    return obj !== obj;
	  }
	}

	//# 
	},{}],56:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  Hooks: {get: function() {
	      return Hooks;
	    }},
	  __esModule: {value: true}
	});
	var $__helpers_47_array__,
	    $__helpers_47_object__;
	var REGISTERED_HOOKS = ['afterCellMetaReset', 'afterChange', 'afterChangesObserved', 'afterColumnMove', 'afterColumnResize', 'afterContextMenuDefaultOptions', 'afterContextMenuHide', 'afterContextMenuShow', 'afterCopyLimit', 'afterCreateCol', 'afterCreateRow', 'afterDeselect', 'afterDestroy', 'afterDocumentKeyDown', 'afterGetCellMeta', 'afterGetColHeader', 'afterGetRowHeader', 'afterInit', 'afterIsMultipleSelectionCheck', 'afterLoadData', 'afterMomentumScroll', 'afterOnCellCornerMouseDown', 'afterOnCellMouseDown', 'afterOnCellMouseOver', 'afterRemoveCol', 'afterRemoveRow', 'afterRender', 'afterRenderer', 'afterScrollHorizontally', 'afterScrollVertically', 'afterSelection', 'afterSelectionByProp', 'afterSelectionEnd', 'afterSelectionEndByProp', 'afterSetCellMeta', 'afterUpdateSettings', 'afterValidate', 'beforeAutofill', 'beforeCellAlignment', 'beforeChange', 'beforeChangeRender', 'beforeDrawBorders', 'beforeGetCellMeta', 'beforeInit', 'beforeInitWalkontable', 'beforeKeyDown', 'beforeOnCellMouseDown', 'beforeRemoveCol', 'beforeRemoveRow', 'beforeRender', 'beforeSetRangeEnd', 'beforeTouchScroll', 'beforeValidate', 'construct', 'init', 'modifyCol', 'modifyColumnHeader', 'modifyColWidth', 'modifyRow', 'modifyRowHeader', 'modifyRowHeight', 'persistentStateLoad', 'persistentStateReset', 'persistentStateSave', 'beforeColumnSort', 'afterColumnSort', 'afterAutofillApplyValues', 'modifyCopyableRange', 'beforeColumnMove', 'afterColumnMove', 'beforeRowMove', 'afterRowMove', 'beforeColumnResize', 'afterColumnResize', 'beforeRowResize', 'afterRowResize'];
	var arrayEach = ($__helpers_47_array__ = require("helpers/array"), $__helpers_47_array__ && $__helpers_47_array__.__esModule && $__helpers_47_array__ || {default: $__helpers_47_array__}).arrayEach;
	var objectEach = ($__helpers_47_object__ = require("helpers/object"), $__helpers_47_object__ && $__helpers_47_object__.__esModule && $__helpers_47_object__ || {default: $__helpers_47_object__}).objectEach;
	var Hooks = function Hooks() {
	  this.globalBucket = this.createEmptyBucket();
	};
	($traceurRuntime.createClass)(Hooks, {
	  createEmptyBucket: function() {
	    var bucket = Object.create(null);
	    arrayEach(REGISTERED_HOOKS, (function(hook) {
	      return (bucket[hook] = []);
	    }));
	    return bucket;
	  },
	  getBucket: function() {
	    var context = arguments[0] !== (void 0) ? arguments[0] : null;
	    if (context) {
	      if (!context.pluginHookBucket) {
	        context.pluginHookBucket = this.createEmptyBucket();
	      }
	      return context.pluginHookBucket;
	    }
	    return this.globalBucket;
	  },
	  add: function(key, callback) {
	    var context = arguments[2] !== (void 0) ? arguments[2] : null;
	    var $__2 = this;
	    if (Array.isArray(callback)) {
	      arrayEach(callback, (function(c) {
	        return ($__2.add(key, c, context));
	      }));
	    } else {
	      var bucket = this.getBucket(context);
	      if (typeof bucket[key] === 'undefined') {
	        this.register(key);
	        bucket[key] = [];
	      }
	      callback.skip = false;
	      if (bucket[key].indexOf(callback) === -1) {
	        bucket[key].push(callback);
	      }
	    }
	    return this;
	  },
	  once: function(key, callback) {
	    var context = arguments[2] !== (void 0) ? arguments[2] : null;
	    var $__2 = this;
	    if (Array.isArray(callback)) {
	      arrayEach(callback, (function(c) {
	        return ($__2.once(key, c, context));
	      }));
	    } else {
	      callback.runOnce = true;
	      this.add(key, callback, context);
	    }
	  },
	  remove: function(key, callback) {
	    var context = arguments[2] !== (void 0) ? arguments[2] : null;
	    var bucket = this.getBucket(context);
	    if (typeof bucket[key] !== 'undefined') {
	      if (bucket[key].indexOf(callback) >= 0) {
	        callback.skip = true;
	        return true;
	      }
	    }
	    return false;
	  },
	  has: function(key) {
	    var context = arguments[1] !== (void 0) ? arguments[1] : null;
	    var bucket = this.getBucket(context);
	    return bucket[key] !== void 0 && bucket[key].length ? true : false;
	  },
	  run: function(context, key, p1, p2, p3, p4, p5, p6) {
	    {
	      var globalHandlers = this.globalBucket[key];
	      var index = -1;
	      var length = globalHandlers ? globalHandlers.length : 0;
	      if (length) {
	        while (++index < length) {
	          if (!globalHandlers[index] || globalHandlers[index].skip) {
	            continue;
	          }
	          var res = globalHandlers[index].call(context, p1, p2, p3, p4, p5, p6);
	          if (res !== void 0) {
	            p1 = res;
	          }
	          if (globalHandlers[index] && globalHandlers[index].runOnce) {
	            this.remove(key, globalHandlers[index]);
	          }
	        }
	      }
	    }
	    {
	      var localHandlers = this.getBucket(context)[key];
	      var index$__4 = -1;
	      var length$__5 = localHandlers ? localHandlers.length : 0;
	      if (length$__5) {
	        while (++index$__4 < length$__5) {
	          if (!localHandlers[index$__4] || localHandlers[index$__4].skip) {
	            continue;
	          }
	          var res$__6 = localHandlers[index$__4].call(context, p1, p2, p3, p4, p5, p6);
	          if (res$__6 !== void 0) {
	            p1 = res$__6;
	          }
	          if (localHandlers[index$__4] && localHandlers[index$__4].runOnce) {
	            this.remove(key, localHandlers[index$__4], context);
	          }
	        }
	      }
	    }
	    return p1;
	  },
	  destroy: function() {
	    var context = arguments[0] !== (void 0) ? arguments[0] : null;
	    objectEach(this.getBucket(context), (function(value, key, bucket) {
	      return (bucket[key].length = 0);
	    }));
	  },
	  register: function(key) {
	    if (!this.isRegistered(key)) {
	      REGISTERED_HOOKS.push(key);
	    }
	  },
	  deregister: function(key) {
	    if (this.isRegistered(key)) {
	      REGISTERED_HOOKS.splice(REGISTERED_HOOKS.indexOf(key), 1);
	    }
	  },
	  isRegistered: function(key) {
	    return REGISTERED_HOOKS.indexOf(key) >= 0;
	  },
	  getRegistered: function() {
	    return REGISTERED_HOOKS;
	  }
	}, {});
	;
	Handsontable.utils = Handsontable.utils || {};
	Handsontable.utils.Hooks = Hooks;

	//# 
	},{"helpers/array":42,"helpers/object":50}],57:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  registerPlugin: {get: function() {
	      return registerPlugin;
	    }},
	  getPlugin: {get: function() {
	      return getPlugin;
	    }},
	  getRegistredPluginNames: {get: function() {
	      return getRegistredPluginNames;
	    }},
	  getPluginName: {get: function() {
	      return getPluginName;
	    }},
	  __esModule: {value: true}
	});
	var $__helpers_47_object__,
	    $__helpers_47_string__;
	var objectEach = ($__helpers_47_object__ = require("helpers/object"), $__helpers_47_object__ && $__helpers_47_object__.__esModule && $__helpers_47_object__ || {default: $__helpers_47_object__}).objectEach;
	var toUpperCaseFirst = ($__helpers_47_string__ = require("helpers/string"), $__helpers_47_string__ && $__helpers_47_string__.__esModule && $__helpers_47_string__ || {default: $__helpers_47_string__}).toUpperCaseFirst;
	var registeredPlugins = new WeakMap();
	Handsontable.plugins = Handsontable.plugins || {};
	function registerPlugin(pluginName, PluginClass) {
	  pluginName = toUpperCaseFirst(pluginName);
	  Handsontable.plugins[pluginName] = PluginClass;
	  Handsontable.hooks.add('construct', function() {
	    var holder;
	    if (!registeredPlugins.has(this)) {
	      registeredPlugins.set(this, {});
	    }
	    holder = registeredPlugins.get(this);
	    if (!holder[pluginName]) {
	      holder[pluginName] = new PluginClass(this);
	    }
	  });
	  Handsontable.hooks.add('afterDestroy', function() {
	    if (registeredPlugins.has(this)) {
	      var pluginsHolder = registeredPlugins.get(this);
	      objectEach(pluginsHolder, (function(plugin) {
	        return plugin.destroy();
	      }));
	      registeredPlugins.delete(this);
	    }
	  });
	}
	function getPlugin(instance, pluginName) {
	  if (typeof pluginName != 'string') {
	    throw Error('Only strings can be passed as "plugin" parameter');
	  }
	  var _pluginName = toUpperCaseFirst(pluginName);
	  if (!registeredPlugins.has(instance) || !registeredPlugins.get(instance)[_pluginName]) {
	    return void 0;
	  }
	  return registeredPlugins.get(instance)[_pluginName];
	}
	function getRegistredPluginNames(hotInstance) {
	  return registeredPlugins.has(hotInstance) ? Object.keys(registeredPlugins.get(hotInstance)) : [];
	}
	function getPluginName(hotInstance, plugin) {
	  var pluginName = null;
	  if (registeredPlugins.has(hotInstance)) {
	    objectEach(registeredPlugins.get(hotInstance), (function(pluginInstance, name) {
	      if (pluginInstance === plugin) {
	        pluginName = name;
	      }
	    }));
	  }
	  return pluginName;
	}
	;
	Handsontable.plugins.utils = Handsontable.plugins.utils || {};
	Handsontable.plugins.registerPlugin = registerPlugin;

	//# 
	},{"helpers/object":50,"helpers/string":52}],58:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  default: {get: function() {
	      return $__default;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47_helpers_47_object__,
	    $___46__46__47_helpers_47_array__,
	    $___46__46__47_plugins__;
	var $__0 = ($___46__46__47_helpers_47_object__ = require("helpers/object"), $___46__46__47_helpers_47_object__ && $___46__46__47_helpers_47_object__.__esModule && $___46__46__47_helpers_47_object__ || {default: $___46__46__47_helpers_47_object__}),
	    defineGetter = $__0.defineGetter,
	    objectEach = $__0.objectEach;
	var arrayEach = ($___46__46__47_helpers_47_array__ = require("helpers/array"), $___46__46__47_helpers_47_array__ && $___46__46__47_helpers_47_array__.__esModule && $___46__46__47_helpers_47_array__ || {default: $___46__46__47_helpers_47_array__}).arrayEach;
	var $__2 = ($___46__46__47_plugins__ = require("plugins"), $___46__46__47_plugins__ && $___46__46__47_plugins__.__esModule && $___46__46__47_plugins__ || {default: $___46__46__47_plugins__}),
	    getRegistredPluginNames = $__2.getRegistredPluginNames,
	    getPluginName = $__2.getPluginName;
	var privatePool = new WeakMap();
	var initializedPlugins = null;
	var BasePlugin = function BasePlugin(hotInstance) {
	  var $__3 = this;
	  defineGetter(this, 'hot', hotInstance, {writable: false});
	  privatePool.set(this, {hooks: {}});
	  initializedPlugins = null;
	  this.pluginName = null;
	  this.pluginsInitializedCallbacks = [];
	  this.isPluginsReady = false;
	  this.enabled = false;
	  this.initialized = false;
	  this.hot.addHook('afterPluginsInitialized', (function() {
	    return $__3.onAfterPluginsInitialized();
	  }));
	  this.hot.addHook('afterUpdateSettings', (function() {
	    return $__3.onUpdateSettings();
	  }));
	  this.hot.addHook('beforeInit', (function() {
	    return $__3.init();
	  }));
	};
	($traceurRuntime.createClass)(BasePlugin, {
	  init: function() {
	    this.pluginName = getPluginName(this.hot, this);
	    if (this.isEnabled && this.isEnabled()) {
	      this.enablePlugin();
	    }
	    if (!initializedPlugins) {
	      initializedPlugins = getRegistredPluginNames(this.hot);
	    }
	    if (initializedPlugins.indexOf(this.pluginName) >= 0) {
	      initializedPlugins.splice(initializedPlugins.indexOf(this.pluginName), 1);
	    }
	    if (!initializedPlugins.length) {
	      this.hot.runHooks('afterPluginsInitialized');
	    }
	    this.initialized = true;
	  },
	  enablePlugin: function() {
	    this.enabled = true;
	  },
	  disablePlugin: function() {
	    if (this.eventManager) {
	      this.eventManager.clear();
	    }
	    this.clearHooks();
	    this.enabled = false;
	  },
	  addHook: function(name, callback) {
	    var hooks = privatePool.get(this).hooks[name] = (privatePool.get(this).hooks[name] || []);
	    this.hot.addHook(name, callback);
	    hooks.push(callback);
	    privatePool.get(this).hooks[name] = hooks;
	  },
	  removeHooks: function(name) {
	    var $__3 = this;
	    arrayEach(privatePool.get(this).hooks[name] || [], (function(callback) {
	      $__3.hot.removeHook(name, callback);
	    }));
	  },
	  clearHooks: function() {
	    var $__3 = this;
	    var hooks = privatePool.get(this).hooks;
	    objectEach(hooks, (function(callbacks, name) {
	      return $__3.removeHooks(name);
	    }));
	    hooks.length = 0;
	  },
	  callOnPluginsReady: function(callback) {
	    if (this.isPluginsReady) {
	      callback();
	    } else {
	      this.pluginsInitializedCallbacks.push(callback);
	    }
	  },
	  onAfterPluginsInitialized: function() {
	    arrayEach(this.pluginsInitializedCallbacks, (function(callback) {
	      return callback();
	    }));
	    this.pluginsInitializedCallbacks.length = 0;
	    this.isPluginsReady = true;
	  },
	  onUpdateSettings: function() {
	    if (this.isEnabled) {
	      if (this.enabled && !this.isEnabled()) {
	        this.disablePlugin();
	      }
	      if (!this.enabled && this.isEnabled()) {
	        this.enablePlugin();
	      }
	      if (this.enabled && this.isEnabled()) {
	        this.updatePlugin();
	      }
	    }
	  },
	  updatePlugin: function() {},
	  destroy: function() {
	    var $__3 = this;
	    if (this.eventManager) {
	      this.eventManager.destroy();
	    }
	    this.clearHooks();
	    objectEach(this, (function(value, property) {
	      if (property !== 'hot') {
	        $__3[property] = null;
	      }
	    }));
	    delete this.hot;
	  }
	}, {});
	var $__default = BasePlugin;
	Handsontable.plugins.BasePlugin = BasePlugin;

	//# 
	},{"helpers/array":42,"helpers/object":50,"plugins":57}],59:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  AutoColumnSize: {get: function() {
	      return AutoColumnSize;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__95_base__,
	    $___46__46__47__46__46__47_helpers_47_array__,
	    $___46__46__47__46__46__47_helpers_47_dom_47_element__,
	    $___46__46__47__46__46__47_utils_47_ghostTable__,
	    $___46__46__47__46__46__47_helpers_47_object__,
	    $___46__46__47__46__46__47_helpers_47_number__,
	    $___46__46__47__46__46__47_plugins__,
	    $___46__46__47__46__46__47_utils_47_samplesGenerator__,
	    $___46__46__47__46__46__47_helpers_47_string__,
	    $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_calculator_47_viewportColumns__;
	var BasePlugin = ($___46__46__47__95_base__ = require("_base"), $___46__46__47__95_base__ && $___46__46__47__95_base__.__esModule && $___46__46__47__95_base__ || {default: $___46__46__47__95_base__}).default;
	var $__1 = ($___46__46__47__46__46__47_helpers_47_array__ = require("helpers/array"), $___46__46__47__46__46__47_helpers_47_array__ && $___46__46__47__46__46__47_helpers_47_array__.__esModule && $___46__46__47__46__46__47_helpers_47_array__ || {default: $___46__46__47__46__46__47_helpers_47_array__}),
	    arrayEach = $__1.arrayEach,
	    arrayFilter = $__1.arrayFilter;
	var $__2 = ($___46__46__47__46__46__47_helpers_47_dom_47_element__ = require("helpers/dom/element"), $___46__46__47__46__46__47_helpers_47_dom_47_element__ && $___46__46__47__46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47__46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47__46__46__47_helpers_47_dom_47_element__}),
	    cancelAnimationFrame = $__2.cancelAnimationFrame,
	    requestAnimationFrame = $__2.requestAnimationFrame,
	    isVisible = $__2.isVisible;
	var GhostTable = ($___46__46__47__46__46__47_utils_47_ghostTable__ = require("utils/ghostTable"), $___46__46__47__46__46__47_utils_47_ghostTable__ && $___46__46__47__46__46__47_utils_47_ghostTable__.__esModule && $___46__46__47__46__46__47_utils_47_ghostTable__ || {default: $___46__46__47__46__46__47_utils_47_ghostTable__}).GhostTable;
	var $__4 = ($___46__46__47__46__46__47_helpers_47_object__ = require("helpers/object"), $___46__46__47__46__46__47_helpers_47_object__ && $___46__46__47__46__46__47_helpers_47_object__.__esModule && $___46__46__47__46__46__47_helpers_47_object__ || {default: $___46__46__47__46__46__47_helpers_47_object__}),
	    isObject = $__4.isObject,
	    objectEach = $__4.objectEach;
	var $__5 = ($___46__46__47__46__46__47_helpers_47_number__ = require("helpers/number"), $___46__46__47__46__46__47_helpers_47_number__ && $___46__46__47__46__46__47_helpers_47_number__.__esModule && $___46__46__47__46__46__47_helpers_47_number__ || {default: $___46__46__47__46__46__47_helpers_47_number__}),
	    valueAccordingPercent = $__5.valueAccordingPercent,
	    rangeEach = $__5.rangeEach;
	var registerPlugin = ($___46__46__47__46__46__47_plugins__ = require("plugins"), $___46__46__47__46__46__47_plugins__ && $___46__46__47__46__46__47_plugins__.__esModule && $___46__46__47__46__46__47_plugins__ || {default: $___46__46__47__46__46__47_plugins__}).registerPlugin;
	var SamplesGenerator = ($___46__46__47__46__46__47_utils_47_samplesGenerator__ = require("utils/samplesGenerator"), $___46__46__47__46__46__47_utils_47_samplesGenerator__ && $___46__46__47__46__46__47_utils_47_samplesGenerator__.__esModule && $___46__46__47__46__46__47_utils_47_samplesGenerator__ || {default: $___46__46__47__46__46__47_utils_47_samplesGenerator__}).SamplesGenerator;
	var isPercentValue = ($___46__46__47__46__46__47_helpers_47_string__ = require("helpers/string"), $___46__46__47__46__46__47_helpers_47_string__ && $___46__46__47__46__46__47_helpers_47_string__.__esModule && $___46__46__47__46__46__47_helpers_47_string__ || {default: $___46__46__47__46__46__47_helpers_47_string__}).isPercentValue;
	var WalkontableViewportColumnsCalculator = ($___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_calculator_47_viewportColumns__ = require("3rdparty/walkontable/src/calculator/viewportColumns"), $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_calculator_47_viewportColumns__ && $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_calculator_47_viewportColumns__.__esModule && $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_calculator_47_viewportColumns__ || {default: $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_calculator_47_viewportColumns__}).WalkontableViewportColumnsCalculator;
	var AutoColumnSize = function AutoColumnSize(hotInstance) {
	  var $__10 = this;
	  $traceurRuntime.superConstructor($AutoColumnSize).call(this, hotInstance);
	  this.widths = [];
	  this.ghostTable = new GhostTable(this.hot);
	  this.samplesGenerator = new SamplesGenerator((function(row, col) {
	    return $__10.hot.getDataAtCell(row, col);
	  }));
	  this.firstCalculation = true;
	  this.inProgress = false;
	  this.addHook('beforeColumnResize', (function(col, size, isDblClick) {
	    return $__10.onBeforeColumnResize(col, size, isDblClick);
	  }));
	};
	var $AutoColumnSize = AutoColumnSize;
	($traceurRuntime.createClass)(AutoColumnSize, {
	  isEnabled: function() {
	    return this.hot.getSettings().autoColumnSize !== false && !this.hot.getSettings().colWidths;
	  },
	  enablePlugin: function() {
	    var $__10 = this;
	    if (this.enabled) {
	      return;
	    }
	    this.addHook('afterLoadData', (function() {
	      return $__10.onAfterLoadData();
	    }));
	    this.addHook('beforeChange', (function(changes) {
	      return $__10.onBeforeChange(changes);
	    }));
	    this.addHook('beforeRender', (function(force) {
	      return $__10.onBeforeRender(force);
	    }));
	    this.addHook('modifyColWidth', (function(width, col) {
	      return $__10.getColumnWidth(col, width);
	    }));
	    $traceurRuntime.superGet(this, $AutoColumnSize.prototype, "enablePlugin").call(this);
	  },
	  disablePlugin: function() {
	    $traceurRuntime.superGet(this, $AutoColumnSize.prototype, "disablePlugin").call(this);
	  },
	  calculateColumnsWidth: function() {
	    var colRange = arguments[0] !== (void 0) ? arguments[0] : {
	      from: 0,
	      to: this.hot.countCols() - 1
	    };
	    var rowRange = arguments[1] !== (void 0) ? arguments[1] : {
	      from: 0,
	      to: this.hot.countRows() - 1
	    };
	    var force = arguments[2] !== (void 0) ? arguments[2] : false;
	    var $__10 = this;
	    if (typeof colRange === 'number') {
	      colRange = {
	        from: colRange,
	        to: colRange
	      };
	    }
	    if (typeof rowRange === 'number') {
	      rowRange = {
	        from: rowRange,
	        to: rowRange
	      };
	    }
	    rangeEach(colRange.from, colRange.to, (function(col) {
	      if (force || ($__10.widths[col] === void 0 && !$__10.hot._getColWidthFromSettings(col))) {
	        var samples = $__10.samplesGenerator.generateColumnSamples(col, rowRange);
	        samples.forEach((function(sample, col) {
	          return $__10.ghostTable.addColumn(col, sample);
	        }));
	      }
	    }));
	    if (this.ghostTable.columns.length) {
	      this.ghostTable.getWidths((function(col, width) {
	        return $__10.widths[col] = width;
	      }));
	      this.ghostTable.clean();
	    }
	  },
	  calculateAllColumnsWidth: function() {
	    var rowRange = arguments[0] !== (void 0) ? arguments[0] : {
	      from: 0,
	      to: this.hot.countRows() - 1
	    };
	    var $__10 = this;
	    var current = 0;
	    var length = this.hot.countCols() - 1;
	    var timer = null;
	    this.inProgress = true;
	    var loop = (function() {
	      if (!$__10.hot) {
	        cancelAnimationFrame(timer);
	        $__10.inProgress = false;
	        return;
	      }
	      $__10.calculateColumnsWidth({
	        from: current,
	        to: Math.min(current + $AutoColumnSize.CALCULATION_STEP, length)
	      }, rowRange);
	      current = current + $AutoColumnSize.CALCULATION_STEP + 1;
	      if (current < length) {
	        timer = requestAnimationFrame(loop);
	      } else {
	        cancelAnimationFrame(timer);
	        $__10.inProgress = false;
	        $__10.hot.view.wt.wtOverlays.adjustElementsSize(true);
	        if ($__10.hot.view.wt.wtOverlays.leftOverlay.needFullRender) {
	          $__10.hot.view.wt.wtOverlays.leftOverlay.clone.draw();
	        }
	      }
	    });
	    if (this.firstCalculation && this.getSyncCalculationLimit()) {
	      this.calculateColumnsWidth({
	        from: 0,
	        to: this.getSyncCalculationLimit()
	      }, rowRange);
	      this.firstCalculation = false;
	      current = this.getSyncCalculationLimit() + 1;
	    }
	    if (current < length) {
	      loop();
	    } else {
	      this.inProgress = false;
	    }
	  },
	  recalculateAllColumnsWidth: function() {
	    if (this.hot.view && isVisible(this.hot.view.wt.wtTable.TABLE)) {
	      this.clearCache();
	      this.calculateAllColumnsWidth();
	    }
	  },
	  getSyncCalculationLimit: function() {
	    var limit = $AutoColumnSize.SYNC_CALCULATION_LIMIT;
	    var colsLimit = this.hot.countCols() - 1;
	    if (isObject(this.hot.getSettings().autoColumnSize)) {
	      limit = this.hot.getSettings().autoColumnSize.syncLimit;
	      if (isPercentValue(limit)) {
	        limit = valueAccordingPercent(colsLimit, limit);
	      } else {
	        limit = limit >> 0;
	      }
	    }
	    return Math.min(limit, colsLimit);
	  },
	  getColumnWidth: function(col) {
	    var defaultWidth = arguments[1];
	    var keepMinimum = arguments[2] !== (void 0) ? arguments[2] : true;
	    var width = defaultWidth;
	    if (width === void 0) {
	      width = this.widths[col];
	      if (keepMinimum && typeof width === 'number') {
	        width = Math.max(width, WalkontableViewportColumnsCalculator.DEFAULT_WIDTH);
	      }
	    }
	    return width;
	  },
	  getFirstVisibleColumn: function() {
	    var wot = this.hot.view.wt;
	    if (wot.wtViewport.columnsVisibleCalculator) {
	      return wot.wtTable.getFirstVisibleColumn();
	    }
	    if (wot.wtViewport.columnsRenderCalculator) {
	      return wot.wtTable.getFirstRenderedColumn();
	    }
	    return -1;
	  },
	  getLastVisibleColumn: function() {
	    var wot = this.hot.view.wt;
	    if (wot.wtViewport.columnsVisibleCalculator) {
	      return wot.wtTable.getLastVisibleColumn();
	    }
	    if (wot.wtViewport.columnsRenderCalculator) {
	      return wot.wtTable.getLastRenderedColumn();
	    }
	    return -1;
	  },
	  clearCache: function() {
	    this.widths.length = 0;
	  },
	  isNeedRecalculate: function() {
	    return arrayFilter(this.widths, (function(item) {
	      return (item === void 0);
	    })).length ? true : false;
	  },
	  onBeforeRender: function() {
	    var force = this.hot.renderCall;
	    this.calculateColumnsWidth({
	      from: this.getFirstVisibleColumn(),
	      to: this.getLastVisibleColumn()
	    }, void 0, force);
	    if (this.isNeedRecalculate() && !this.inProgress) {
	      this.calculateAllColumnsWidth();
	    }
	  },
	  onAfterLoadData: function() {
	    var $__10 = this;
	    if (this.hot.view) {
	      this.recalculateAllColumnsWidth();
	    } else {
	      setTimeout((function() {
	        if ($__10.hot) {
	          $__10.recalculateAllColumnsWidth();
	        }
	      }), 0);
	    }
	  },
	  onBeforeChange: function(changes) {
	    var $__10 = this;
	    arrayEach(changes, (function(data) {
	      return $__10.widths[data[1]] = void 0;
	    }));
	  },
	  onBeforeColumnResize: function(col, size, isDblClick) {
	    if (isDblClick) {
	      this.calculateColumnsWidth(col, void 0, true);
	      size = this.getColumnWidth(col, void 0, false);
	    }
	    return size;
	  },
	  destroy: function() {
	    this.ghostTable.clean();
	    $traceurRuntime.superGet(this, $AutoColumnSize.prototype, "destroy").call(this);
	  }
	}, {
	  get CALCULATION_STEP() {
	    return 50;
	  },
	  get SYNC_CALCULATION_LIMIT() {
	    return 50;
	  }
	}, BasePlugin);
	;
	registerPlugin('autoColumnSize', AutoColumnSize);

	//# 
	},{"3rdparty/walkontable/src/calculator/viewportColumns":3,"_base":58,"helpers/array":42,"helpers/dom/element":45,"helpers/number":49,"helpers/object":50,"helpers/string":52,"plugins":57,"utils/ghostTable":98,"utils/samplesGenerator":99}],60:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  AutoRowSize: {get: function() {
	      return AutoRowSize;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__95_base__,
	    $___46__46__47__46__46__47_helpers_47_array__,
	    $___46__46__47__46__46__47_helpers_47_dom_47_element__,
	    $___46__46__47__46__46__47_utils_47_ghostTable__,
	    $___46__46__47__46__46__47_helpers_47_object__,
	    $___46__46__47__46__46__47_helpers_47_number__,
	    $___46__46__47__46__46__47_plugins__,
	    $___46__46__47__46__46__47_utils_47_samplesGenerator__,
	    $___46__46__47__46__46__47_helpers_47_string__;
	var BasePlugin = ($___46__46__47__95_base__ = require("_base"), $___46__46__47__95_base__ && $___46__46__47__95_base__.__esModule && $___46__46__47__95_base__ || {default: $___46__46__47__95_base__}).default;
	var $__1 = ($___46__46__47__46__46__47_helpers_47_array__ = require("helpers/array"), $___46__46__47__46__46__47_helpers_47_array__ && $___46__46__47__46__46__47_helpers_47_array__.__esModule && $___46__46__47__46__46__47_helpers_47_array__ || {default: $___46__46__47__46__46__47_helpers_47_array__}),
	    arrayEach = $__1.arrayEach,
	    arrayFilter = $__1.arrayFilter;
	var $__2 = ($___46__46__47__46__46__47_helpers_47_dom_47_element__ = require("helpers/dom/element"), $___46__46__47__46__46__47_helpers_47_dom_47_element__ && $___46__46__47__46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47__46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47__46__46__47_helpers_47_dom_47_element__}),
	    cancelAnimationFrame = $__2.cancelAnimationFrame,
	    requestAnimationFrame = $__2.requestAnimationFrame,
	    isVisible = $__2.isVisible;
	var GhostTable = ($___46__46__47__46__46__47_utils_47_ghostTable__ = require("utils/ghostTable"), $___46__46__47__46__46__47_utils_47_ghostTable__ && $___46__46__47__46__46__47_utils_47_ghostTable__.__esModule && $___46__46__47__46__46__47_utils_47_ghostTable__ || {default: $___46__46__47__46__46__47_utils_47_ghostTable__}).GhostTable;
	var $__4 = ($___46__46__47__46__46__47_helpers_47_object__ = require("helpers/object"), $___46__46__47__46__46__47_helpers_47_object__ && $___46__46__47__46__46__47_helpers_47_object__.__esModule && $___46__46__47__46__46__47_helpers_47_object__ || {default: $___46__46__47__46__46__47_helpers_47_object__}),
	    isObject = $__4.isObject,
	    objectEach = $__4.objectEach;
	var $__5 = ($___46__46__47__46__46__47_helpers_47_number__ = require("helpers/number"), $___46__46__47__46__46__47_helpers_47_number__ && $___46__46__47__46__46__47_helpers_47_number__.__esModule && $___46__46__47__46__46__47_helpers_47_number__ || {default: $___46__46__47__46__46__47_helpers_47_number__}),
	    valueAccordingPercent = $__5.valueAccordingPercent,
	    rangeEach = $__5.rangeEach;
	var registerPlugin = ($___46__46__47__46__46__47_plugins__ = require("plugins"), $___46__46__47__46__46__47_plugins__ && $___46__46__47__46__46__47_plugins__.__esModule && $___46__46__47__46__46__47_plugins__ || {default: $___46__46__47__46__46__47_plugins__}).registerPlugin;
	var SamplesGenerator = ($___46__46__47__46__46__47_utils_47_samplesGenerator__ = require("utils/samplesGenerator"), $___46__46__47__46__46__47_utils_47_samplesGenerator__ && $___46__46__47__46__46__47_utils_47_samplesGenerator__.__esModule && $___46__46__47__46__46__47_utils_47_samplesGenerator__ || {default: $___46__46__47__46__46__47_utils_47_samplesGenerator__}).SamplesGenerator;
	var isPercentValue = ($___46__46__47__46__46__47_helpers_47_string__ = require("helpers/string"), $___46__46__47__46__46__47_helpers_47_string__ && $___46__46__47__46__46__47_helpers_47_string__.__esModule && $___46__46__47__46__46__47_helpers_47_string__ || {default: $___46__46__47__46__46__47_helpers_47_string__}).isPercentValue;
	var AutoRowSize = function AutoRowSize(hotInstance) {
	  var $__9 = this;
	  $traceurRuntime.superConstructor($AutoRowSize).call(this, hotInstance);
	  this.heights = [];
	  this.ghostTable = new GhostTable(this.hot);
	  this.samplesGenerator = new SamplesGenerator((function(row, col) {
	    return $__9.hot.getDataAtCell(row, col);
	  }));
	  this.firstCalculation = true;
	  this.inProgress = false;
	  this.addHook('beforeRowResize', (function(row, size, isDblClick) {
	    return $__9.onBeforeRowResize(row, size, isDblClick);
	  }));
	};
	var $AutoRowSize = AutoRowSize;
	($traceurRuntime.createClass)(AutoRowSize, {
	  isEnabled: function() {
	    return this.hot.getSettings().autoRowSize === true || isObject(this.hot.getSettings().autoRowSize);
	  },
	  enablePlugin: function() {
	    var $__9 = this;
	    if (this.enabled) {
	      return;
	    }
	    this.addHook('afterLoadData', (function() {
	      return $__9.onAfterLoadData();
	    }));
	    this.addHook('beforeChange', (function(changes) {
	      return $__9.onBeforeChange(changes);
	    }));
	    this.addHook('beforeColumnMove', (function() {
	      return $__9.recalculateAllRowsHeight();
	    }));
	    this.addHook('beforeColumnResize', (function() {
	      return $__9.recalculateAllRowsHeight();
	    }));
	    this.addHook('beforeColumnSort', (function() {
	      return $__9.clearCache();
	    }));
	    this.addHook('beforeRender', (function(force) {
	      return $__9.onBeforeRender(force);
	    }));
	    this.addHook('beforeRowMove', (function(rowStart, rowEnd) {
	      return $__9.onBeforeRowMove(rowStart, rowEnd);
	    }));
	    this.addHook('modifyRowHeight', (function(height, row) {
	      return $__9.getRowHeight(row, height);
	    }));
	    $traceurRuntime.superGet(this, $AutoRowSize.prototype, "enablePlugin").call(this);
	  },
	  disablePlugin: function() {
	    $traceurRuntime.superGet(this, $AutoRowSize.prototype, "disablePlugin").call(this);
	  },
	  calculateRowsHeight: function() {
	    var rowRange = arguments[0] !== (void 0) ? arguments[0] : {
	      from: 0,
	      to: this.hot.countRows() - 1
	    };
	    var colRange = arguments[1] !== (void 0) ? arguments[1] : {
	      from: 0,
	      to: this.hot.countCols() - 1
	    };
	    var force = arguments[2] !== (void 0) ? arguments[2] : false;
	    var $__9 = this;
	    if (typeof rowRange === 'number') {
	      rowRange = {
	        from: rowRange,
	        to: rowRange
	      };
	    }
	    if (typeof colRange === 'number') {
	      colRange = {
	        from: colRange,
	        to: colRange
	      };
	    }
	    rangeEach(rowRange.from, rowRange.to, (function(row) {
	      if (force || $__9.heights[row] === void 0) {
	        var samples = $__9.samplesGenerator.generateRowSamples(row, colRange);
	        samples.forEach((function(sample, row) {
	          return $__9.ghostTable.addRow(row, sample);
	        }));
	      }
	    }));
	    if (this.ghostTable.rows.length) {
	      this.ghostTable.getHeights((function(row, height) {
	        return $__9.heights[row] = height;
	      }));
	      this.ghostTable.clean();
	    }
	  },
	  calculateAllRowsHeight: function() {
	    var colRange = arguments[0] !== (void 0) ? arguments[0] : {
	      from: 0,
	      to: this.hot.countCols() - 1
	    };
	    var $__9 = this;
	    var current = 0;
	    var length = this.hot.countRows() - 1;
	    var timer = null;
	    this.inProgress = true;
	    var loop = (function() {
	      if (!$__9.hot) {
	        cancelAnimationFrame(timer);
	        $__9.inProgress = false;
	        return;
	      }
	      $__9.calculateRowsHeight({
	        from: current,
	        to: Math.min(current + $AutoRowSize.CALCULATION_STEP, length)
	      }, colRange);
	      current = current + $AutoRowSize.CALCULATION_STEP + 1;
	      if (current < length) {
	        timer = requestAnimationFrame(loop);
	      } else {
	        cancelAnimationFrame(timer);
	        $__9.inProgress = false;
	        $__9.hot.view.wt.wtOverlays.adjustElementsSize(true);
	        if ($__9.hot.view.wt.wtOverlays.leftOverlay.needFullRender) {
	          $__9.hot.view.wt.wtOverlays.leftOverlay.clone.draw();
	        }
	      }
	    });
	    if (this.firstCalculation && this.getSyncCalculationLimit()) {
	      this.calculateRowsHeight({
	        from: 0,
	        to: this.getSyncCalculationLimit()
	      }, colRange);
	      this.firstCalculation = false;
	      current = this.getSyncCalculationLimit() + 1;
	    }
	    if (current < length) {
	      loop();
	    } else {
	      this.inProgress = false;
	    }
	  },
	  recalculateAllRowsHeight: function() {
	    if (isVisible(this.hot.view.wt.wtTable.TABLE)) {
	      this.clearCache();
	      this.calculateAllRowsHeight();
	    }
	  },
	  getSyncCalculationLimit: function() {
	    var limit = $AutoRowSize.SYNC_CALCULATION_LIMIT;
	    var rowsLimit = this.hot.countRows() - 1;
	    if (isObject(this.hot.getSettings().autoRowSize)) {
	      limit = this.hot.getSettings().autoRowSize.syncLimit;
	      if (isPercentValue(limit)) {
	        limit = valueAccordingPercent(rowsLimit, limit);
	      } else {
	        limit = limit >> 0;
	      }
	    }
	    return Math.min(limit, rowsLimit);
	  },
	  getRowHeight: function(row) {
	    var defaultHeight = arguments[1];
	    var height = defaultHeight;
	    if (this.heights[row] !== void 0 && this.heights[row] > (defaultHeight || 0)) {
	      height = this.heights[row];
	    }
	    return height;
	  },
	  getFirstVisibleRow: function() {
	    var wot = this.hot.view.wt;
	    if (wot.wtViewport.rowsVisibleCalculator) {
	      return wot.wtTable.getFirstVisibleRow();
	    }
	    if (wot.wtViewport.rowsRenderCalculator) {
	      return wot.wtTable.getFirstRenderedRow();
	    }
	    return -1;
	  },
	  getLastVisibleRow: function() {
	    var wot = this.hot.view.wt;
	    if (wot.wtViewport.rowsVisibleCalculator) {
	      return wot.wtTable.getLastVisibleRow();
	    }
	    if (wot.wtViewport.rowsRenderCalculator) {
	      return wot.wtTable.getLastRenderedRow();
	    }
	    return -1;
	  },
	  clearCache: function() {
	    this.heights.length = 0;
	  },
	  clearCacheByRange: function(range) {
	    var $__9 = this;
	    if (typeof range === 'number') {
	      range = {
	        from: range,
	        to: range
	      };
	    }
	    rangeEach(Math.min(range.from, range.to), Math.max(range.from, range.to), (function(row) {
	      return $__9.heights[row] = void 0;
	    }));
	  },
	  isNeedRecalculate: function() {
	    return arrayFilter(this.heights, (function(item) {
	      return (item === void 0);
	    })).length ? true : false;
	  },
	  onBeforeRender: function() {
	    var force = this.hot.renderCall;
	    this.calculateRowsHeight({
	      from: this.getFirstVisibleRow(),
	      to: this.getLastVisibleRow()
	    }, void 0, force);
	    if (this.isNeedRecalculate() && !this.inProgress) {
	      this.calculateAllRowsHeight();
	    }
	  },
	  onBeforeRowMove: function(from, to) {
	    this.clearCacheByRange({
	      from: from,
	      to: to
	    });
	    this.calculateAllRowsHeight();
	  },
	  onBeforeRowResize: function(row, size, isDblClick) {
	    if (isDblClick) {
	      this.calculateRowsHeight(row, void 0, true);
	      size = this.getRowHeight(row);
	    }
	    return size;
	  },
	  onAfterLoadData: function() {
	    var $__9 = this;
	    if (this.hot.view) {
	      this.recalculateAllRowsHeight();
	    } else {
	      setTimeout((function() {
	        if ($__9.hot) {
	          $__9.recalculateAllRowsHeight();
	        }
	      }), 0);
	    }
	  },
	  onBeforeChange: function(changes) {
	    var range = null;
	    if (changes.length === 1) {
	      range = changes[0][0];
	    } else if (changes.length > 1) {
	      range = {
	        from: changes[0][0],
	        to: changes[changes.length - 1][0]
	      };
	    }
	    if (range !== null) {
	      this.clearCacheByRange(range);
	    }
	  },
	  destroy: function() {
	    this.ghostTable.clean();
	    $traceurRuntime.superGet(this, $AutoRowSize.prototype, "destroy").call(this);
	  }
	}, {
	  get CALCULATION_STEP() {
	    return 50;
	  },
	  get SYNC_CALCULATION_LIMIT() {
	    return 500;
	  }
	}, BasePlugin);
	;
	registerPlugin('autoRowSize', AutoRowSize);

	//# 
	},{"_base":58,"helpers/array":42,"helpers/dom/element":45,"helpers/number":49,"helpers/object":50,"helpers/string":52,"plugins":57,"utils/ghostTable":98,"utils/samplesGenerator":99}],61:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  Autofill: {get: function() {
	      return Autofill;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__46__46__47_helpers_47_dom_47_element__,
	    $___46__46__47__46__46__47_eventManager__,
	    $___46__46__47__46__46__47_plugins__,
	    $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_coords__;
	var $__0 = ($___46__46__47__46__46__47_helpers_47_dom_47_element__ = require("helpers/dom/element"), $___46__46__47__46__46__47_helpers_47_dom_47_element__ && $___46__46__47__46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47__46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47__46__46__47_helpers_47_dom_47_element__}),
	    offset = $__0.offset,
	    outerHeight = $__0.outerHeight,
	    outerWidth = $__0.outerWidth;
	var eventManagerObject = ($___46__46__47__46__46__47_eventManager__ = require("eventManager"), $___46__46__47__46__46__47_eventManager__ && $___46__46__47__46__46__47_eventManager__.__esModule && $___46__46__47__46__46__47_eventManager__ || {default: $___46__46__47__46__46__47_eventManager__}).eventManager;
	var registerPlugin = ($___46__46__47__46__46__47_plugins__ = require("plugins"), $___46__46__47__46__46__47_plugins__ && $___46__46__47__46__46__47_plugins__.__esModule && $___46__46__47__46__46__47_plugins__ || {default: $___46__46__47__46__46__47_plugins__}).registerPlugin;
	var WalkontableCellCoords = ($___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_coords__ = require("3rdparty/walkontable/src/cell/coords"), $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_coords__ && $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_coords__.__esModule && $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_coords__ || {default: $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_coords__}).WalkontableCellCoords;
	;
	function getDeltas(start, end, data, direction) {
	  var rlength = data.length,
	      clength = data ? data[0].length : 0,
	      deltas = [],
	      arr = [],
	      diffRow,
	      diffCol,
	      startValue,
	      endValue,
	      delta;
	  diffRow = end.row - start.row;
	  diffCol = end.col - start.col;
	  if (['down', 'up'].indexOf(direction) !== -1) {
	    for (var col = 0; col <= diffCol; col++) {
	      startValue = parseInt(data[0][col], 10);
	      endValue = parseInt(data[rlength - 1][col], 10);
	      delta = (direction === 'down' ? (endValue - startValue) : (startValue - endValue)) / (rlength - 1) || 0;
	      arr.push(delta);
	    }
	    deltas.push(arr);
	  }
	  if (['right', 'left'].indexOf(direction) !== -1) {
	    for (var row = 0; row <= diffRow; row++) {
	      startValue = parseInt(data[row][0], 10);
	      endValue = parseInt(data[row][clength - 1], 10);
	      delta = (direction === 'right' ? (endValue - startValue) : (startValue - endValue)) / (clength - 1) || 0;
	      arr = [];
	      arr.push(delta);
	      deltas.push(arr);
	    }
	  }
	  return deltas;
	}
	function Autofill(instance) {
	  var _this = this,
	      mouseDownOnCellCorner = false,
	      wtOnCellCornerMouseDown,
	      wtOnCellMouseOver,
	      eventManager;
	  this.instance = instance;
	  this.addingStarted = false;
	  eventManager = eventManagerObject(instance);
	  function mouseUpCallback(event) {
	    if (!instance.autofill) {
	      return true;
	    }
	    if (instance.autofill.handle && instance.autofill.handle.isDragged) {
	      if (instance.autofill.handle.isDragged > 1) {
	        instance.autofill.apply();
	      }
	      instance.autofill.handle.isDragged = 0;
	      mouseDownOnCellCorner = false;
	    }
	  }
	  function mouseMoveCallback(event) {
	    var tableBottom,
	        tableRight;
	    if (!_this.instance.autofill) {
	      return false;
	    }
	    tableBottom = offset(_this.instance.table).top - (window.pageYOffset || document.documentElement.scrollTop) + outerHeight(_this.instance.table);
	    tableRight = offset(_this.instance.table).left - (window.pageXOffset || document.documentElement.scrollLeft) + outerWidth(_this.instance.table);
	    if (_this.addingStarted === false && _this.instance.autofill.handle.isDragged > 0 && event.clientY > tableBottom && event.clientX <= tableRight) {
	      _this.instance.mouseDragOutside = true;
	      _this.addingStarted = true;
	    } else {
	      _this.instance.mouseDragOutside = false;
	    }
	    if (_this.instance.mouseDragOutside) {
	      setTimeout(function() {
	        _this.addingStarted = false;
	        _this.instance.alter('insert_row');
	      }, 200);
	    }
	  }
	  eventManager.addEventListener(document, 'mouseup', mouseUpCallback);
	  eventManager.addEventListener(document, 'mousemove', mouseMoveCallback);
	  wtOnCellCornerMouseDown = this.instance.view.wt.wtSettings.settings.onCellCornerMouseDown;
	  this.instance.view.wt.wtSettings.settings.onCellCornerMouseDown = function(event) {
	    instance.autofill.handle.isDragged = 1;
	    mouseDownOnCellCorner = true;
	    wtOnCellCornerMouseDown(event);
	  };
	  wtOnCellMouseOver = this.instance.view.wt.wtSettings.settings.onCellMouseOver;
	  this.instance.view.wt.wtSettings.settings.onCellMouseOver = function(event, coords, TD, wt) {
	    if (instance.autofill && mouseDownOnCellCorner && !instance.view.isMouseDown() && instance.autofill.handle && instance.autofill.handle.isDragged) {
	      instance.autofill.handle.isDragged++;
	      instance.autofill.showBorder(coords);
	      instance.autofill.checkIfNewRowNeeded();
	    }
	    wtOnCellMouseOver(event, coords, TD, wt);
	  };
	  this.instance.view.wt.wtSettings.settings.onCellCornerDblClick = function() {
	    instance.autofill.selectAdjacent();
	  };
	}
	Autofill.prototype.init = function() {
	  this.handle = {};
	};
	Autofill.prototype.disable = function() {
	  this.handle.disabled = true;
	};
	Autofill.prototype.selectAdjacent = function() {
	  var select,
	      data,
	      r,
	      maxR,
	      c;
	  if (this.instance.selection.isMultiple()) {
	    select = this.instance.view.wt.selections.area.getCorners();
	  } else {
	    select = this.instance.view.wt.selections.current.getCorners();
	  }
	  data = this.instance.getData();
	  rows: for (r = select[2] + 1; r < this.instance.countRows(); r++) {
	    for (c = select[1]; c <= select[3]; c++) {
	      if (data[r][c]) {
	        break rows;
	      }
	    }
	    if (!!data[r][select[1] - 1] || !!data[r][select[3] + 1]) {
	      maxR = r;
	    }
	  }
	  if (maxR) {
	    this.instance.view.wt.selections.fill.clear();
	    this.instance.view.wt.selections.fill.add(new WalkontableCellCoords(select[0], select[1]));
	    this.instance.view.wt.selections.fill.add(new WalkontableCellCoords(maxR, select[3]));
	    this.apply();
	  }
	};
	Autofill.prototype.apply = function() {
	  var drag,
	      select,
	      start,
	      end,
	      _data,
	      direction,
	      deltas,
	      selRange;
	  this.handle.isDragged = 0;
	  if (this.instance.view.wt.selections.fill.isEmpty()) {
	    return;
	  }
	  drag = this.instance.view.wt.selections.fill.getCorners();
	  this.instance.view.wt.selections.fill.clear();
	  if (this.instance.selection.isMultiple()) {
	    select = this.instance.view.wt.selections.area.getCorners();
	  } else {
	    select = this.instance.view.wt.selections.current.getCorners();
	  }
	  Handsontable.hooks.run(this.instance, 'afterAutofillApplyValues', select, drag);
	  if (drag[0] === select[0] && drag[1] < select[1]) {
	    direction = 'left';
	    start = new WalkontableCellCoords(drag[0], drag[1]);
	    end = new WalkontableCellCoords(drag[2], select[1] - 1);
	  } else if (drag[0] === select[0] && drag[3] > select[3]) {
	    direction = 'right';
	    start = new WalkontableCellCoords(drag[0], select[3] + 1);
	    end = new WalkontableCellCoords(drag[2], drag[3]);
	  } else if (drag[0] < select[0] && drag[1] === select[1]) {
	    direction = 'up';
	    start = new WalkontableCellCoords(drag[0], drag[1]);
	    end = new WalkontableCellCoords(select[0] - 1, drag[3]);
	  } else if (drag[2] > select[2] && drag[1] === select[1]) {
	    direction = 'down';
	    start = new WalkontableCellCoords(select[2] + 1, drag[1]);
	    end = new WalkontableCellCoords(drag[2], drag[3]);
	  }
	  if (start && start.row > -1 && start.col > -1) {
	    selRange = {
	      from: this.instance.getSelectedRange().from,
	      to: this.instance.getSelectedRange().to
	    };
	    _data = this.instance.getData(selRange.from.row, selRange.from.col, selRange.to.row, selRange.to.col);
	    deltas = getDeltas(start, end, _data, direction);
	    Handsontable.hooks.run(this.instance, 'beforeAutofill', start, end, _data);
	    this.instance.populateFromArray(start.row, start.col, _data, end.row, end.col, 'autofill', null, direction, deltas);
	    this.instance.selection.setRangeStart(new WalkontableCellCoords(drag[0], drag[1]));
	    this.instance.selection.setRangeEnd(new WalkontableCellCoords(drag[2], drag[3]));
	  } else {
	    this.instance.selection.refreshBorders();
	  }
	};
	Autofill.prototype.showBorder = function(coords) {
	  var topLeft = this.instance.getSelectedRange().getTopLeftCorner(),
	      bottomRight = this.instance.getSelectedRange().getBottomRightCorner();
	  if (this.instance.getSettings().fillHandle !== 'horizontal' && (bottomRight.row < coords.row || topLeft.row > coords.row)) {
	    coords = new WalkontableCellCoords(coords.row, bottomRight.col);
	  } else if (this.instance.getSettings().fillHandle !== 'vertical') {
	    coords = new WalkontableCellCoords(bottomRight.row, coords.col);
	  } else {
	    return;
	  }
	  this.instance.view.wt.selections.fill.clear();
	  this.instance.view.wt.selections.fill.add(this.instance.getSelectedRange().from);
	  this.instance.view.wt.selections.fill.add(this.instance.getSelectedRange().to);
	  this.instance.view.wt.selections.fill.add(coords);
	  this.instance.view.render();
	};
	Autofill.prototype.checkIfNewRowNeeded = function() {
	  var fillCorners,
	      selection,
	      tableRows = this.instance.countRows(),
	      that = this;
	  if (this.instance.view.wt.selections.fill.cellRange && this.addingStarted === false) {
	    selection = this.instance.getSelected();
	    fillCorners = this.instance.view.wt.selections.fill.getCorners();
	    if (selection[2] < tableRows - 1 && fillCorners[2] === tableRows - 1) {
	      this.addingStarted = true;
	      this.instance._registerTimeout(setTimeout(function() {
	        that.instance.alter('insert_row');
	        that.addingStarted = false;
	      }, 200));
	    }
	  }
	};
	Handsontable.hooks.add('afterInit', function() {
	  var autofill = new Autofill(this);
	  if (typeof this.getSettings().fillHandle !== 'undefined') {
	    if (autofill.handle && this.getSettings().fillHandle === false) {
	      autofill.disable();
	    } else if (!autofill.handle && this.getSettings().fillHandle !== false) {
	      this.autofill = autofill;
	      this.autofill.init();
	    }
	  }
	});
	Handsontable.Autofill = Autofill;

	//# 
	},{"3rdparty/walkontable/src/cell/coords":5,"eventManager":41,"helpers/dom/element":45,"plugins":57}],62:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  ColumnSorting: {get: function() {
	      return ColumnSorting;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__46__46__47_helpers_47_dom_47_element__,
	    $___46__46__47__46__46__47_helpers_47_array__,
	    $___46__46__47__46__46__47_eventManager__,
	    $___46__46__47__95_base__,
	    $___46__46__47__46__46__47_plugins__;
	var $__0 = ($___46__46__47__46__46__47_helpers_47_dom_47_element__ = require("helpers/dom/element"), $___46__46__47__46__46__47_helpers_47_dom_47_element__ && $___46__46__47__46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47__46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47__46__46__47_helpers_47_dom_47_element__}),
	    addClass = $__0.addClass,
	    closest = $__0.closest,
	    hasClass = $__0.hasClass,
	    index = $__0.index,
	    removeClass = $__0.removeClass;
	var $__1 = ($___46__46__47__46__46__47_helpers_47_array__ = require("helpers/array"), $___46__46__47__46__46__47_helpers_47_array__ && $___46__46__47__46__46__47_helpers_47_array__.__esModule && $___46__46__47__46__46__47_helpers_47_array__ || {default: $___46__46__47__46__46__47_helpers_47_array__}),
	    arrayEach = $__1.arrayEach,
	    arrayMap = $__1.arrayMap,
	    arrayReduce = $__1.arrayReduce;
	var eventManagerObject = ($___46__46__47__46__46__47_eventManager__ = require("eventManager"), $___46__46__47__46__46__47_eventManager__ && $___46__46__47__46__46__47_eventManager__.__esModule && $___46__46__47__46__46__47_eventManager__ || {default: $___46__46__47__46__46__47_eventManager__}).eventManager;
	var BasePlugin = ($___46__46__47__95_base__ = require("_base"), $___46__46__47__95_base__ && $___46__46__47__95_base__.__esModule && $___46__46__47__95_base__ || {default: $___46__46__47__95_base__}).default;
	var registerPlugin = ($___46__46__47__46__46__47_plugins__ = require("plugins"), $___46__46__47__46__46__47_plugins__ && $___46__46__47__46__46__47_plugins__.__esModule && $___46__46__47__46__46__47_plugins__ || {default: $___46__46__47__46__46__47_plugins__}).registerPlugin;
	Handsontable.hooks.register('beforeColumnSort');
	Handsontable.hooks.register('afterColumnSort');
	var ColumnSorting = function ColumnSorting(hotInstance) {
	  $traceurRuntime.superConstructor($ColumnSorting).call(this, hotInstance);
	  this.sortIndicators = [];
	};
	var $ColumnSorting = ColumnSorting;
	($traceurRuntime.createClass)(ColumnSorting, {
	  isEnabled: function() {
	    return !!(this.hot.getSettings().columnSorting);
	  },
	  enablePlugin: function() {
	    var $__5 = this;
	    if (this.enabled) {
	      return;
	    }
	    var _this = this;
	    this.hot.sortIndex = [];
	    this.hot.sort = function() {
	      var args = Array.prototype.slice.call(arguments);
	      return _this.sortByColumn.apply(_this, args);
	    };
	    if (typeof this.hot.getSettings().observeChanges === 'undefined') {
	      this.enableObserveChangesPlugin();
	    }
	    this.bindColumnSortingAfterClick();
	    this.addHook('afterTrimRow', (function(row) {
	      return $__5.sort();
	    }));
	    this.addHook('afterUntrimRow', (function(row) {
	      return $__5.sort();
	    }));
	    this.addHook('modifyRow', (function(row) {
	      return $__5.translateRow(row);
	    }));
	    this.addHook('afterUpdateSettings', (function() {
	      return $__5.onAfterUpdateSettings();
	    }));
	    this.addHook('afterGetColHeader', (function(col, TH) {
	      return $__5.getColHeader(col, TH);
	    }));
	    this.addHook('afterCreateRow', function() {
	      _this.afterCreateRow.apply(_this, arguments);
	    });
	    this.addHook('afterRemoveRow', function() {
	      _this.afterRemoveRow.apply(_this, arguments);
	    });
	    this.addHook('afterInit', (function() {
	      return $__5.sortBySettings();
	    }));
	    this.addHook('afterLoadData', (function() {
	      $__5.hot.sortIndex = [];
	      if ($__5.hot.view) {
	        $__5.sortBySettings();
	      }
	    }));
	    if (this.hot.view) {
	      this.sortBySettings();
	    }
	    $traceurRuntime.superGet(this, $ColumnSorting.prototype, "enablePlugin").call(this);
	  },
	  disablePlugin: function() {
	    this.hot.sort = void 0;
	    $traceurRuntime.superGet(this, $ColumnSorting.prototype, "disablePlugin").call(this);
	  },
	  onAfterUpdateSettings: function() {
	    this.sortBySettings();
	  },
	  sortBySettings: function() {
	    var sortingSettings = this.hot.getSettings().columnSorting;
	    var loadedSortingState = this.loadSortingState();
	    var sortingColumn;
	    var sortingOrder;
	    if (typeof loadedSortingState === 'undefined') {
	      sortingColumn = sortingSettings.column;
	      sortingOrder = sortingSettings.sortOrder;
	    } else {
	      sortingColumn = loadedSortingState.sortColumn;
	      sortingOrder = loadedSortingState.sortOrder;
	    }
	    this.sortByColumn(sortingColumn, sortingOrder);
	  },
	  setSortingColumn: function(col, order) {
	    if (typeof col == 'undefined') {
	      this.hot.sortColumn = void 0;
	      this.hot.sortOrder = void 0;
	      return;
	    } else if (this.hot.sortColumn === col && typeof order == 'undefined') {
	      if (this.hot.sortOrder === false) {
	        this.hot.sortOrder = void 0;
	      } else {
	        this.hot.sortOrder = !this.hot.sortOrder;
	      }
	    } else {
	      this.hot.sortOrder = typeof order === 'undefined' ? true : order;
	    }
	    this.hot.sortColumn = col;
	  },
	  sortByColumn: function(col, order) {
	    this.setSortingColumn(col, order);
	    if (typeof this.hot.sortColumn == 'undefined') {
	      return;
	    }
	    Handsontable.hooks.run(this.hot, 'beforeColumnSort', this.hot.sortColumn, this.hot.sortOrder);
	    this.sort();
	    this.hot.render();
	    this.saveSortingState();
	    Handsontable.hooks.run(this.hot, 'afterColumnSort', this.hot.sortColumn, this.hot.sortOrder);
	  },
	  saveSortingState: function() {
	    var sortingState = {};
	    if (typeof this.hot.sortColumn != 'undefined') {
	      sortingState.sortColumn = this.hot.sortColumn;
	    }
	    if (typeof this.hot.sortOrder != 'undefined') {
	      sortingState.sortOrder = this.hot.sortOrder;
	    }
	    if (sortingState.hasOwnProperty('sortColumn') || sortingState.hasOwnProperty('sortOrder')) {
	      Handsontable.hooks.run(this.hot, 'persistentStateSave', 'columnSorting', sortingState);
	    }
	  },
	  loadSortingState: function() {
	    var storedState = {};
	    Handsontable.hooks.run(this.hot, 'persistentStateLoad', 'columnSorting', storedState);
	    return storedState.value;
	  },
	  bindColumnSortingAfterClick: function() {
	    if (this.bindedSortEvent) {
	      return;
	    }
	    var eventManager = eventManagerObject(this.hot),
	        _this = this;
	    this.bindedSortEvent = true;
	    eventManager.addEventListener(this.hot.rootElement, 'click', function(e) {
	      if (hasClass(e.target, 'columnSorting')) {
	        var col = getColumn(e.target);
	        if (col === this.lastSortedColumn) {
	          switch (_this.hot.sortOrder) {
	            case void 0:
	              _this.sortOrderClass = 'ascending';
	              break;
	            case true:
	              _this.sortOrderClass = 'descending';
	              break;
	            case false:
	              _this.sortOrderClass = void 0;
	          }
	        } else {
	          _this.sortOrderClass = 'ascending';
	        }
	        this.lastSortedColumn = col;
	        _this.sortByColumn(col);
	      }
	    });
	    function countRowHeaders() {
	      var tr = _this.hot.view.TBODY.querySelector('tr');
	      var length = 1;
	      if (tr) {
	        length = tr.querySelectorAll('th').length;
	      }
	      return length;
	    }
	    function getColumn(target) {
	      var TH = closest(target, 'TH');
	      return _this.hot.view.wt.wtTable.getFirstRenderedColumn() + index(TH) - countRowHeaders();
	    }
	  },
	  enableObserveChangesPlugin: function() {
	    var _this = this;
	    this.hot._registerTimeout(setTimeout(function() {
	      _this.hot.updateSettings({observeChanges: true});
	    }, 0));
	  },
	  defaultSort: function(sortOrder) {
	    return function(a, b) {
	      if (typeof a[1] == 'string') {
	        a[1] = a[1].toLowerCase();
	      }
	      if (typeof b[1] == 'string') {
	        b[1] = b[1].toLowerCase();
	      }
	      if (a[1] === b[1]) {
	        return 0;
	      }
	      if (a[1] === null || a[1] === '') {
	        return 1;
	      }
	      if (b[1] === null || b[1] === '') {
	        return -1;
	      }
	      if (isNaN(a[1]) && !isNaN(b[1])) {
	        return sortOrder ? 1 : -1;
	      } else if (!isNaN(a[1]) && isNaN(b[1])) {
	        return sortOrder ? -1 : 1;
	      }
	      if (a[1] < b[1]) {
	        return sortOrder ? -1 : 1;
	      }
	      if (a[1] > b[1]) {
	        return sortOrder ? 1 : -1;
	      }
	      return 0;
	    };
	  },
	  dateSort: function(sortOrder) {
	    return function(a, b) {
	      if (a[1] === b[1]) {
	        return 0;
	      }
	      if (a[1] === null || a[1] === '') {
	        return 1;
	      }
	      if (b[1] === null || b[1] === '') {
	        return -1;
	      }
	      var aDate = new Date(a[1]);
	      var bDate = new Date(b[1]);
	      if (aDate < bDate) {
	        return sortOrder ? -1 : 1;
	      }
	      if (aDate > bDate) {
	        return sortOrder ? 1 : -1;
	      }
	      return 0;
	    };
	  },
	  sort: function() {
	    if (typeof this.hot.sortOrder == 'undefined') {
	      this.hot.sortIndex.length = 0;
	      return;
	    }
	    var colMeta,
	        sortFunction;
	    this.hot.sortingEnabled = false;
	    this.hot.sortIndex.length = 0;
	    var colOffset = this.hot.colOffset();
	    for (var i = 0,
	        ilen = this.hot.countRows() - this.hot.getSettings().minSpareRows; i < ilen; i++) {
	      this.hot.sortIndex.push([i, this.hot.getDataAtCell(i, this.hot.sortColumn + colOffset)]);
	    }
	    colMeta = this.hot.getCellMeta(0, this.hot.sortColumn);
	    this.sortIndicators[this.hot.sortColumn] = colMeta.sortIndicator;
	    switch (colMeta.type) {
	      case 'date':
	        sortFunction = this.dateSort;
	        break;
	      default:
	        sortFunction = this.defaultSort;
	    }
	    this.hot.sortIndex.sort(sortFunction(this.hot.sortOrder));
	    for (var i = this.hot.sortIndex.length; i < this.hot.countRows(); i++) {
	      this.hot.sortIndex.push([i, this.hot.getDataAtCell(i, this.hot.sortColumn + colOffset)]);
	    }
	    this.hot.sortingEnabled = true;
	  },
	  translateRow: function(row) {
	    if (this.hot.sortingEnabled && (typeof this.hot.sortOrder !== 'undefined') && this.hot.sortIndex && this.hot.sortIndex.length && this.hot.sortIndex[row]) {
	      return this.hot.sortIndex[row][0];
	    }
	    return row;
	  },
	  untranslateRow: function(row) {
	    if (this.hot.sortingEnabled && this.hot.sortIndex && this.hot.sortIndex.length) {
	      for (var i = 0; i < this.hot.sortIndex.length; i++) {
	        if (this.hot.sortIndex[i][0] == row) {
	          return i;
	        }
	      }
	    }
	  },
	  getColHeader: function(col, TH) {
	    var headerLink = TH.querySelector('.colHeader');
	    var colspan = TH.getAttribute('colspan');
	    var TRs = TH.parentNode.parentNode.childNodes;
	    var headerLevel = Array.prototype.indexOf.call(TRs, TH.parentNode);
	    headerLevel = headerLevel - TRs.length;
	    if (!headerLink) {
	      return;
	    }
	    if (this.hot.getSettings().columnSorting && col >= 0 && headerLevel === -1) {
	      addClass(headerLink, 'columnSorting');
	    }
	    removeClass(headerLink, 'descending');
	    removeClass(headerLink, 'ascending');
	    if (this.sortIndicators[col]) {
	      if (col === this.hot.sortColumn) {
	        if (this.sortOrderClass === 'ascending') {
	          addClass(headerLink, 'ascending');
	        } else if (this.sortOrderClass === 'descending') {
	          addClass(headerLink, 'descending');
	        }
	      }
	    }
	  },
	  isSorted: function() {
	    return typeof this.hot.sortColumn != 'undefined';
	  },
	  afterCreateRow: function(index, amount) {
	    if (!this.isSorted()) {
	      return;
	    }
	    for (var i = 0; i < this.hot.sortIndex.length; i++) {
	      if (this.hot.sortIndex[i][0] >= index) {
	        this.hot.sortIndex[i][0] += amount;
	      }
	    }
	    for (var i = 0; i < amount; i++) {
	      this.hot.sortIndex.splice(index + i, 0, [index + i, this.hot.getSourceData()[index + i][this.hot.sortColumn + this.hot.colOffset()]]);
	    }
	    this.saveSortingState();
	  },
	  afterRemoveRow: function(index, amount) {
	    if (!this.isSorted()) {
	      return;
	    }
	    var removedRows = this.hot.sortIndex.splice(index, amount);
	    removedRows = arrayMap(removedRows, (function(row) {
	      return row[0];
	    }));
	    function countRowShift(logicalRow) {
	      return arrayReduce(removedRows, (function(count, removedLogicalRow) {
	        if (logicalRow > removedLogicalRow) {
	          count++;
	        }
	        return count;
	      }), 0);
	    }
	    this.hot.sortIndex = arrayMap(this.hot.sortIndex, (function(logicalRow, physicalRow) {
	      var rowShift = countRowShift(logicalRow[0]);
	      if (rowShift) {
	        logicalRow[0] -= rowShift;
	      }
	      return logicalRow;
	    }));
	    this.saveSortingState();
	  }
	}, {}, BasePlugin);
	;
	registerPlugin('columnSorting', ColumnSorting);

	//# 
	},{"_base":58,"eventManager":41,"helpers/array":42,"helpers/dom/element":45,"plugins":57}],63:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  CommentEditor: {get: function() {
	      return CommentEditor;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__46__46__47_helpers_47_dom_47_element__;
	var addClass = ($___46__46__47__46__46__47_helpers_47_dom_47_element__ = require("helpers/dom/element"), $___46__46__47__46__46__47_helpers_47_dom_47_element__ && $___46__46__47__46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47__46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47__46__46__47_helpers_47_dom_47_element__}).addClass;
	var CommentEditor = function CommentEditor() {
	  this.editor = this.createEditor();
	  this.editorStyle = this.editor.style;
	  this.editorStyle.position = 'absolute';
	  this.editorStyle.zIndex = 100;
	  this.hide();
	};
	var $CommentEditor = CommentEditor;
	($traceurRuntime.createClass)(CommentEditor, {
	  setPosition: function(x, y) {
	    this.editorStyle.left = x + 'px';
	    this.editorStyle.top = y + 'px';
	  },
	  show: function() {
	    this.editorStyle.display = 'block';
	  },
	  hide: function() {
	    this.editorStyle.display = 'none';
	  },
	  isVisible: function() {
	    return this.editorStyle.display === 'block';
	  },
	  setValue: function() {
	    var value = arguments[0] !== (void 0) ? arguments[0] : '';
	    value = value || '';
	    this.getInputElement().value = value;
	  },
	  getValue: function() {
	    return this.getInputElement().value;
	  },
	  isFocused: function() {
	    return document.activeElement === this.getInputElement();
	  },
	  focus: function() {
	    this.getInputElement().focus();
	  },
	  createEditor: function() {
	    var container = document.querySelector('.' + $CommentEditor.CLASS_EDITOR_CONTAINER);
	    var editor;
	    var textArea;
	    if (!container) {
	      container = document.createElement('div');
	      addClass(container, $CommentEditor.CLASS_EDITOR_CONTAINER);
	      document.body.appendChild(container);
	    }
	    editor = document.createElement('div');
	    addClass(editor, $CommentEditor.CLASS_EDITOR);
	    textArea = document.createElement('textarea');
	    addClass(textArea, $CommentEditor.CLASS_INPUT);
	    editor.appendChild(textArea);
	    container.appendChild(editor);
	    return editor;
	  },
	  getInputElement: function() {
	    return this.editor.querySelector('.' + $CommentEditor.CLASS_INPUT);
	  },
	  destroy: function() {
	    this.editor.parentNode.removeChild(this.editor);
	    this.editor = null;
	    this.editorStyle = null;
	  }
	}, {
	  get CLASS_EDITOR_CONTAINER() {
	    return 'htCommentsContainer';
	  },
	  get CLASS_EDITOR() {
	    return 'htComments';
	  },
	  get CLASS_INPUT() {
	    return 'htCommentTextArea';
	  },
	  get CLASS_CELL() {
	    return 'htCommentCell';
	  }
	});
	;

	//# 
	},{"helpers/dom/element":45}],64:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  Comments: {get: function() {
	      return Comments;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__46__46__47_helpers_47_dom_47_element__,
	    $___46__46__47__46__46__47_eventManager__,
	    $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_coords__,
	    $___46__46__47__46__46__47_plugins__,
	    $___46__46__47__95_base__,
	    $__commentEditor__;
	var $__0 = ($___46__46__47__46__46__47_helpers_47_dom_47_element__ = require("helpers/dom/element"), $___46__46__47__46__46__47_helpers_47_dom_47_element__ && $___46__46__47__46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47__46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47__46__46__47_helpers_47_dom_47_element__}),
	    addClass = $__0.addClass,
	    closest = $__0.closest,
	    getWindowScrollLeft = $__0.getWindowScrollLeft,
	    getWindowScrollTop = $__0.getWindowScrollTop,
	    hasClass = $__0.hasClass,
	    offset = $__0.offset;
	var EventManager = ($___46__46__47__46__46__47_eventManager__ = require("eventManager"), $___46__46__47__46__46__47_eventManager__ && $___46__46__47__46__46__47_eventManager__.__esModule && $___46__46__47__46__46__47_eventManager__ || {default: $___46__46__47__46__46__47_eventManager__}).EventManager;
	var WalkontableCellCoords = ($___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_coords__ = require("3rdparty/walkontable/src/cell/coords"), $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_coords__ && $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_coords__.__esModule && $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_coords__ || {default: $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_coords__}).WalkontableCellCoords;
	var $__3 = ($___46__46__47__46__46__47_plugins__ = require("plugins"), $___46__46__47__46__46__47_plugins__ && $___46__46__47__46__46__47_plugins__.__esModule && $___46__46__47__46__46__47_plugins__ || {default: $___46__46__47__46__46__47_plugins__}),
	    registerPlugin = $__3.registerPlugin,
	    getPlugin = $__3.getPlugin;
	var BasePlugin = ($___46__46__47__95_base__ = require("_base"), $___46__46__47__95_base__ && $___46__46__47__95_base__.__esModule && $___46__46__47__95_base__ || {default: $___46__46__47__95_base__}).default;
	var CommentEditor = ($__commentEditor__ = require("commentEditor"), $__commentEditor__ && $__commentEditor__.__esModule && $__commentEditor__ || {default: $__commentEditor__}).CommentEditor;
	var Comments = function Comments(hotInstance) {
	  $traceurRuntime.superConstructor($Comments).call(this, hotInstance);
	  this.editor = null;
	  this.eventManager = null;
	  this.range = {};
	  this.mouseDown = false;
	  this.contextMenuEvent = false;
	  this.timer = null;
	};
	var $Comments = Comments;
	($traceurRuntime.createClass)(Comments, {
	  isEnabled: function() {
	    return this.hot.getSettings().comments;
	  },
	  enablePlugin: function() {
	    var $__6 = this;
	    if (this.enabled) {
	      return;
	    }
	    if (!this.editor) {
	      this.editor = new CommentEditor();
	    }
	    if (!this.eventManager) {
	      this.eventManager = new EventManager(this);
	    }
	    this.addHook('afterContextMenuDefaultOptions', (function(options) {
	      return $__6.addToContextMenu(options);
	    }));
	    this.addHook('afterRenderer', (function(TD, row, col, prop, value, cellProperties) {
	      return $__6.onAfterRenderer(TD, cellProperties);
	    }));
	    this.addHook('afterScrollVertically', (function() {
	      return $__6.refreshEditorPosition();
	    }));
	    this.addHook('afterColumnResize', (function() {
	      return $__6.refreshEditorPosition();
	    }));
	    this.addHook('afterRowResize', (function() {
	      return $__6.refreshEditorPosition();
	    }));
	    this.registerListeners();
	    $traceurRuntime.superGet(this, $Comments.prototype, "enablePlugin").call(this);
	  },
	  disablePlugin: function() {
	    $traceurRuntime.superGet(this, $Comments.prototype, "disablePlugin").call(this);
	  },
	  registerListeners: function() {
	    var $__6 = this;
	    this.eventManager.addEventListener(document, 'mouseover', (function(event) {
	      return $__6.onMouseOver(event);
	    }));
	    this.eventManager.addEventListener(document, 'mousedown', (function(event) {
	      return $__6.onMouseDown(event);
	    }));
	    this.eventManager.addEventListener(document, 'mousemove', (function(event) {
	      return $__6.onMouseMove(event);
	    }));
	    this.eventManager.addEventListener(document, 'mouseup', (function(event) {
	      return $__6.onMouseUp(event);
	    }));
	    this.eventManager.addEventListener(this.editor.getInputElement(), 'blur', (function(event) {
	      return $__6.onEditorBlur(event);
	    }));
	  },
	  setRange: function(range) {
	    this.range = range;
	  },
	  clearRange: function() {
	    this.range = {};
	  },
	  targetIsCellWithComment: function(event) {
	    return hasClass(event.target, 'htCommentCell') && closest(event.target, [this.hot.rootElement]) ? true : false;
	  },
	  targetIsCommentTextArea: function(event) {
	    return this.editor.getInputElement() === event.target;
	  },
	  saveComment: function() {
	    if (!this.range.from) {
	      throw new Error('Before using this method, first set cell range (hot.getPlugin("comment").setRange())');
	    }
	    var comment = this.editor.getValue();
	    var row = this.range.from.row;
	    var col = this.range.from.col;
	    this.hot.setCellMeta(row, col, 'comment', comment);
	    this.hot.render();
	  },
	  saveCommentAtCell: function(row, col) {
	    this.setRange({from: new WalkontableCellCoords(row, col)});
	    this.saveComment();
	  },
	  removeComment: function() {
	    if (!this.range.from) {
	      throw new Error('Before using this method, first set cell range (hot.getPlugin("comment").setRange())');
	    }
	    this.hot.removeCellMeta(this.range.from.row, this.range.from.col, 'comment');
	    this.hot.render();
	    this.hide();
	  },
	  removeCommentAtCell: function(row, col) {
	    this.setRange({from: new WalkontableCellCoords(row, col)});
	    this.removeComment();
	  },
	  show: function() {
	    if (!this.range.from) {
	      throw new Error('Before using this method, first set cell range (hot.getPlugin("comment").setRange())');
	    }
	    var meta = this.hot.getCellMeta(this.range.from.row, this.range.from.col);
	    this.refreshEditorPosition(true);
	    this.editor.setValue(meta.comment || '');
	    this.editor.show();
	    return true;
	  },
	  showAtCell: function(row, col) {
	    this.setRange({from: new WalkontableCellCoords(row, col)});
	    return this.show();
	  },
	  hide: function() {
	    this.editor.hide();
	  },
	  refreshEditorPosition: function() {
	    var force = arguments[0] !== (void 0) ? arguments[0] : false;
	    if (!force && (!this.range.from || !this.editor.isVisible())) {
	      return;
	    }
	    var TD = this.hot.view.wt.wtTable.getCell(this.range.from);
	    var cellOffset = offset(TD);
	    var lastColWidth = this.hot.getColWidth(this.range.from.col);
	    var cellTopOffset = cellOffset.top;
	    var cellLeftOffset = cellOffset.left;
	    var verticalCompensation = 0;
	    var horizontalCompensation = 0;
	    if (this.hot.view.wt.wtViewport.hasVerticalScroll()) {
	      cellTopOffset = cellTopOffset - this.hot.view.wt.wtOverlays.topOverlay.getScrollPosition();
	      verticalCompensation = 20;
	    }
	    if (this.hot.view.wt.wtViewport.hasHorizontalScroll()) {
	      cellLeftOffset = cellLeftOffset - this.hot.view.wt.wtOverlays.leftOverlay.getScrollPosition();
	      horizontalCompensation = 20;
	    }
	    var x = cellLeftOffset + lastColWidth;
	    var y = cellTopOffset;
	    var rect = this.hot.view.wt.wtTable.holder.getBoundingClientRect();
	    var holderPos = {
	      left: rect.left + getWindowScrollLeft() + horizontalCompensation,
	      right: rect.right + getWindowScrollLeft() - 15,
	      top: rect.top + getWindowScrollTop() + verticalCompensation,
	      bottom: rect.bottom + getWindowScrollTop()
	    };
	    if (x <= holderPos.left || x > holderPos.right || y <= holderPos.top || y > holderPos.bottom) {
	      this.hide();
	    } else {
	      this.editor.setPosition(x, y);
	    }
	  },
	  onMouseDown: function(event) {
	    this.mouseDown = true;
	    if (!this.hot.view || !this.hot.view.wt) {
	      return;
	    }
	    if (!this.contextMenuEvent && !this.targetIsCommentTextArea(event) && !this.targetIsCellWithComment(event)) {
	      this.hide();
	    }
	    this.contextMenuEvent = false;
	  },
	  onMouseOver: function(event) {
	    if (this.mouseDown || this.editor.isFocused()) {
	      return;
	    }
	    if (this.targetIsCellWithComment(event)) {
	      var coordinates = this.hot.view.wt.wtTable.getCoords(event.target);
	      var range = {from: new WalkontableCellCoords(coordinates.row, coordinates.col)};
	      this.setRange(range);
	      this.show();
	    } else if (!this.targetIsCommentTextArea(event) && !this.editor.isFocused()) {
	      this.hide();
	    }
	  },
	  onMouseMove: function(event) {
	    var $__6 = this;
	    if (this.targetIsCommentTextArea(event)) {
	      this.mouseDown = true;
	      clearTimeout(this.timer);
	      this.timer = setTimeout((function() {
	        $__6.mouseDown = false;
	      }), 200);
	    }
	  },
	  onMouseUp: function(event) {
	    this.mouseDown = false;
	  },
	  onAfterRenderer: function(TD, cellProperties) {
	    if (cellProperties.comment) {
	      addClass(TD, cellProperties.commentedCellClassName);
	    }
	  },
	  onEditorBlur: function(event) {
	    this.saveComment();
	  },
	  checkSelectionCommentsConsistency: function() {
	    var selected = this.hot.getSelectedRange();
	    if (!selected) {
	      return false;
	    }
	    var hasComment = false;
	    var cell = selected.from;
	    if (this.hot.getCellMeta(cell.row, cell.col).comment) {
	      hasComment = true;
	    }
	    return hasComment;
	  },
	  onContextMenuAddComment: function() {
	    var $__6 = this;
	    var coords = this.hot.getSelectedRange();
	    this.contextMenuEvent = true;
	    this.setRange({from: coords.from});
	    this.show();
	    setTimeout((function() {
	      if ($__6.hot) {
	        $__6.hot.deselectCell();
	        $__6.editor.focus();
	      }
	    }), 10);
	  },
	  onContextMenuRemoveComment: function(key, selection) {
	    this.contextMenuEvent = true;
	    this.removeCommentAtCell(selection.start.row, selection.start.col);
	  },
	  addToContextMenu: function(defaultOptions) {
	    var $__6 = this;
	    defaultOptions.items.push(Handsontable.plugins.ContextMenu.SEPARATOR, {
	      key: 'commentsAddEdit',
	      name: (function() {
	        return $__6.checkSelectionCommentsConsistency() ? 'Edit Comment' : 'Add Comment';
	      }),
	      callback: (function() {
	        return $__6.onContextMenuAddComment();
	      }),
	      disabled: function() {
	        return this.getSelected() ? false : true;
	      }
	    }, {
	      key: 'commentsRemove',
	      name: function() {
	        return 'Delete Comment';
	      },
	      callback: (function(key, selection) {
	        return $__6.onContextMenuRemoveComment(key, selection);
	      }),
	      disabled: (function() {
	        return !$__6.checkSelectionCommentsConsistency();
	      })
	    });
	  },
	  destroy: function() {
	    if (this.editor) {
	      this.editor.destroy();
	    }
	    $traceurRuntime.superGet(this, $Comments.prototype, "destroy").call(this);
	  }
	}, {}, BasePlugin);
	;
	registerPlugin('comments', Comments);

	//# 
	},{"3rdparty/walkontable/src/cell/coords":5,"_base":58,"commentEditor":63,"eventManager":41,"helpers/dom/element":45,"plugins":57}],65:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  CommandExecutor: {get: function() {
	      return CommandExecutor;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__46__46__47_helpers_47_array__;
	var arrayEach = ($___46__46__47__46__46__47_helpers_47_array__ = require("helpers/array"), $___46__46__47__46__46__47_helpers_47_array__ && $___46__46__47__46__46__47_helpers_47_array__.__esModule && $___46__46__47__46__46__47_helpers_47_array__ || {default: $___46__46__47__46__46__47_helpers_47_array__}).arrayEach;
	var CommandExecutor = function CommandExecutor(hotInstance) {
	  this.hot = hotInstance;
	  this.commands = {};
	  this.commonCallback = null;
	};
	($traceurRuntime.createClass)(CommandExecutor, {
	  registerCommand: function(name, commandDescriptor) {
	    this.commands[name] = commandDescriptor;
	  },
	  setCommonCallback: function(callback) {
	    this.commonCallback = callback;
	  },
	  execute: function(commandName) {
	    for (var params = [],
	        $__3 = 1; $__3 < arguments.length; $__3++)
	      params[$__3 - 1] = arguments[$__3];
	    var $__1 = this;
	    var commandSplit = commandName.split(':');
	    commandName = commandSplit[0];
	    var subCommandName = commandSplit.length === 2 ? commandSplit[1] : null;
	    var command = this.commands[commandName];
	    if (!command) {
	      throw new Error(("Menu command '" + commandName + "' not exists."));
	    }
	    if (subCommandName && command.submenu) {
	      command = findSubCommand(subCommandName, command.submenu.items);
	    }
	    if (command.disabled === true) {
	      return;
	    }
	    if (typeof command.disabled == 'function' && command.disabled.call(this.hot) === true) {
	      return;
	    }
	    if (command.hasOwnProperty('submenu')) {
	      return;
	    }
	    var callbacks = [];
	    if (typeof command.callback === 'function') {
	      callbacks.push(command.callback);
	    }
	    if (typeof this.commonCallback === 'function') {
	      callbacks.push(this.commonCallback);
	    }
	    params.unshift(commandSplit.join(':'));
	    arrayEach(callbacks, (function(callback) {
	      return callback.apply($__1.hot, params);
	    }));
	  }
	}, {});
	function findSubCommand(subCommandName, subCommands) {
	  var command;
	  arrayEach(subCommands, (function(cmd) {
	    var cmds = cmd.key ? cmd.key.split(':') : null;
	    if (Array.isArray(cmds) && cmds[1] === subCommandName) {
	      command = cmd;
	      return false;
	    }
	  }));
	  return command;
	}
	;

	//# 
	},{"helpers/array":42}],66:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  ContextMenu: {get: function() {
	      return ContextMenu;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__95_base__,
	    $___46__46__47__46__46__47_helpers_47_array__,
	    $__commandExecutor__,
	    $___46__46__47__46__46__47_eventManager__,
	    $___46__46__47__46__46__47_helpers_47_dom_47_element__,
	    $__itemsFactory__,
	    $__menu__,
	    $___46__46__47__46__46__47_helpers_47_object__,
	    $___46__46__47__46__46__47_plugins__,
	    $___46__46__47__46__46__47_helpers_47_dom_47_event__,
	    $__predefinedItems__;
	var BasePlugin = ($___46__46__47__95_base__ = require("_base"), $___46__46__47__95_base__ && $___46__46__47__95_base__.__esModule && $___46__46__47__95_base__ || {default: $___46__46__47__95_base__}).default;
	var arrayEach = ($___46__46__47__46__46__47_helpers_47_array__ = require("helpers/array"), $___46__46__47__46__46__47_helpers_47_array__ && $___46__46__47__46__46__47_helpers_47_array__.__esModule && $___46__46__47__46__46__47_helpers_47_array__ || {default: $___46__46__47__46__46__47_helpers_47_array__}).arrayEach;
	var CommandExecutor = ($__commandExecutor__ = require("commandExecutor"), $__commandExecutor__ && $__commandExecutor__.__esModule && $__commandExecutor__ || {default: $__commandExecutor__}).CommandExecutor;
	var EventManager = ($___46__46__47__46__46__47_eventManager__ = require("eventManager"), $___46__46__47__46__46__47_eventManager__ && $___46__46__47__46__46__47_eventManager__.__esModule && $___46__46__47__46__46__47_eventManager__ || {default: $___46__46__47__46__46__47_eventManager__}).EventManager;
	var hasClass = ($___46__46__47__46__46__47_helpers_47_dom_47_element__ = require("helpers/dom/element"), $___46__46__47__46__46__47_helpers_47_dom_47_element__ && $___46__46__47__46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47__46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47__46__46__47_helpers_47_dom_47_element__}).hasClass;
	var ItemsFactory = ($__itemsFactory__ = require("itemsFactory"), $__itemsFactory__ && $__itemsFactory__.__esModule && $__itemsFactory__ || {default: $__itemsFactory__}).ItemsFactory;
	var Menu = ($__menu__ = require("menu"), $__menu__ && $__menu__.__esModule && $__menu__ || {default: $__menu__}).Menu;
	var $__7 = ($___46__46__47__46__46__47_helpers_47_object__ = require("helpers/object"), $___46__46__47__46__46__47_helpers_47_object__ && $___46__46__47__46__46__47_helpers_47_object__.__esModule && $___46__46__47__46__46__47_helpers_47_object__ || {default: $___46__46__47__46__46__47_helpers_47_object__}),
	    objectEach = $__7.objectEach,
	    mixin = $__7.mixin;
	var registerPlugin = ($___46__46__47__46__46__47_plugins__ = require("plugins"), $___46__46__47__46__46__47_plugins__ && $___46__46__47__46__46__47_plugins__.__esModule && $___46__46__47__46__46__47_plugins__ || {default: $___46__46__47__46__46__47_plugins__}).registerPlugin;
	var stopPropagation = ($___46__46__47__46__46__47_helpers_47_dom_47_event__ = require("helpers/dom/event"), $___46__46__47__46__46__47_helpers_47_dom_47_event__ && $___46__46__47__46__46__47_helpers_47_dom_47_event__.__esModule && $___46__46__47__46__46__47_helpers_47_dom_47_event__ || {default: $___46__46__47__46__46__47_helpers_47_dom_47_event__}).stopPropagation;
	var $__10 = ($__predefinedItems__ = require("predefinedItems"), $__predefinedItems__ && $__predefinedItems__.__esModule && $__predefinedItems__ || {default: $__predefinedItems__}),
	    ROW_ABOVE = $__10.ROW_ABOVE,
	    ROW_BELOW = $__10.ROW_BELOW,
	    COLUMN_LEFT = $__10.COLUMN_LEFT,
	    COLUMN_RIGHT = $__10.COLUMN_RIGHT,
	    REMOVE_ROW = $__10.REMOVE_ROW,
	    REMOVE_COLUMN = $__10.REMOVE_COLUMN,
	    UNDO = $__10.UNDO,
	    REDO = $__10.REDO,
	    READ_ONLY = $__10.READ_ONLY,
	    ALIGNMENT = $__10.ALIGNMENT,
	    SEPARATOR = $__10.SEPARATOR,
	    predefinedItems = $__10.predefinedItems;
	var ContextMenu = function ContextMenu(hotInstance) {
	  $traceurRuntime.superConstructor($ContextMenu).call(this, hotInstance);
	  this.eventManager = new EventManager(this);
	  this.commandExecutor = new CommandExecutor(this.hot);
	  this.itemsFactory = null;
	  this.menu = null;
	};
	var $ContextMenu = ContextMenu;
	($traceurRuntime.createClass)(ContextMenu, {
	  isEnabled: function() {
	    return this.hot.getSettings().contextMenu;
	  },
	  enablePlugin: function() {
	    var $__11 = this;
	    if (this.enabled) {
	      return;
	    }
	    this.itemsFactory = new ItemsFactory(this.hot, $ContextMenu.DEFAULT_ITEMS);
	    var settings = this.hot.getSettings().contextMenu;
	    var predefinedItems = {items: this.itemsFactory.getVisibleItems(settings)};
	    this.registerEvents();
	    if (typeof settings.callback === 'function') {
	      this.commandExecutor.setCommonCallback(settings.callback);
	    }
	    $traceurRuntime.superGet(this, $ContextMenu.prototype, "enablePlugin").call(this);
	    this.callOnPluginsReady((function() {
	      $__11.hot.runHooks('afterContextMenuDefaultOptions', predefinedItems);
	      $__11.itemsFactory.setPredefinedItems(predefinedItems.items);
	      var menuItems = $__11.itemsFactory.getVisibleItems(settings);
	      $__11.menu = new Menu($__11.hot, {className: 'htContextMenu'});
	      $__11.menu.setMenuItems(menuItems);
	      $__11.menu.addLocalHook('afterOpen', (function() {
	        return $__11.onMenuAfterOpen();
	      }));
	      $__11.menu.addLocalHook('afterClose', (function() {
	        return $__11.onMenuAfterClose();
	      }));
	      $__11.menu.addLocalHook('executeCommand', (function() {
	        for (var params = [],
	            $__13 = 0; $__13 < arguments.length; $__13++)
	          params[$__13] = arguments[$__13];
	        return $__11.executeCommand.apply($__11, params);
	      }));
	      arrayEach(menuItems, (function(command) {
	        return $__11.commandExecutor.registerCommand(command.key, command);
	      }));
	    }));
	  },
	  disablePlugin: function() {
	    this.close();
	    if (this.menu) {
	      this.menu.destroy();
	      this.menu = null;
	    }
	    $traceurRuntime.superGet(this, $ContextMenu.prototype, "disablePlugin").call(this);
	  },
	  registerEvents: function() {
	    var $__11 = this;
	    this.eventManager.addEventListener(this.hot.rootElement, 'contextmenu', (function(event) {
	      return $__11.onContextMenu(event);
	    }));
	  },
	  open: function(event) {
	    if (!this.menu) {
	      return;
	    }
	    this.menu.open();
	    this.menu.setPosition(event);
	    this.menu.hotMenu.isHotTableEnv = this.hot.isHotTableEnv;
	    Handsontable.eventManager.isHotTableEnv = this.hot.isHotTableEnv;
	  },
	  close: function() {
	    if (!this.menu) {
	      return;
	    }
	    this.menu.close();
	  },
	  executeCommand: function() {
	    for (var params = [],
	        $__13 = 0; $__13 < arguments.length; $__13++)
	      params[$__13] = arguments[$__13];
	    this.commandExecutor.execute.apply(this.commandExecutor, params);
	  },
	  onContextMenu: function(event) {
	    var settings = this.hot.getSettings();
	    var showRowHeaders = settings.rowHeaders;
	    var showColHeaders = settings.colHeaders;
	    function isValidElement(element) {
	      return element.nodeName === 'TD' || element.parentNode.nodeName === 'TD';
	    }
	    var element = event.realTarget;
	    this.close();
	    event.preventDefault();
	    stopPropagation(event);
	    if (!(showRowHeaders || showColHeaders)) {
	      if (!isValidElement(element) && !(hasClass(element, 'current') && hasClass(element, 'wtBorder'))) {
	        return;
	      }
	    } else if (showRowHeaders && showColHeaders) {
	      var containsCornerHeader = element.parentNode.querySelectorAll('.cornerHeader').length > 0;
	      if (containsCornerHeader) {
	        return;
	      }
	    }
	    this.open(event);
	  },
	  onMenuAfterOpen: function() {
	    this.hot.runHooks('afterContextMenuShow', this);
	  },
	  onMenuAfterClose: function() {
	    this.hot.listen();
	    this.hot.runHooks('afterContextMenuHide', this);
	  },
	  destroy: function() {
	    this.close();
	    if (this.menu) {
	      this.menu.destroy();
	    }
	    $traceurRuntime.superGet(this, $ContextMenu.prototype, "destroy").call(this);
	  }
	}, {get DEFAULT_ITEMS() {
	    return [ROW_ABOVE, ROW_BELOW, SEPARATOR, COLUMN_LEFT, COLUMN_RIGHT, SEPARATOR, REMOVE_ROW, REMOVE_COLUMN, SEPARATOR, UNDO, REDO, SEPARATOR, READ_ONLY, SEPARATOR, ALIGNMENT];
	  }}, BasePlugin);
	ContextMenu.SEPARATOR = {name: SEPARATOR};
	Handsontable.hooks.register('afterContextMenuDefaultOptions');
	Handsontable.hooks.register('afterContextMenuShow');
	Handsontable.hooks.register('afterContextMenuHide');
	Handsontable.hooks.register('afterContextMenuExecute');
	;
	registerPlugin('contextMenu', ContextMenu);

	//# 
	},{"_base":58,"commandExecutor":65,"eventManager":41,"helpers/array":42,"helpers/dom/element":45,"helpers/dom/event":46,"helpers/object":50,"itemsFactory":68,"menu":69,"plugins":57,"predefinedItems":70}],67:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  Cursor: {get: function() {
	      return Cursor;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__46__46__47_helpers_47_dom_47_element__,
	    $___46__46__47__46__46__47_helpers_47_dom_47_event__;
	var $__0 = ($___46__46__47__46__46__47_helpers_47_dom_47_element__ = require("helpers/dom/element"), $___46__46__47__46__46__47_helpers_47_dom_47_element__ && $___46__46__47__46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47__46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47__46__46__47_helpers_47_dom_47_element__}),
	    getWindowScrollLeft = $__0.getWindowScrollLeft,
	    getWindowScrollTop = $__0.getWindowScrollTop;
	var $__1 = ($___46__46__47__46__46__47_helpers_47_dom_47_event__ = require("helpers/dom/event"), $___46__46__47__46__46__47_helpers_47_dom_47_event__ && $___46__46__47__46__46__47_helpers_47_dom_47_event__.__esModule && $___46__46__47__46__46__47_helpers_47_dom_47_event__ || {default: $___46__46__47__46__46__47_helpers_47_dom_47_event__}),
	    pageX = $__1.pageX,
	    pageY = $__1.pageY;
	var Cursor = function Cursor(object) {
	  var windowScrollTop = getWindowScrollTop();
	  var windowScrollLeft = getWindowScrollLeft();
	  var top,
	      topRelative;
	  var left,
	      leftRelative;
	  var scrollTop,
	      scrollLeft;
	  var cellHeight,
	      cellWidth;
	  this.type = this.getSourceType(object);
	  if (this.type === 'literal') {
	    top = parseInt(object.top, 10);
	    left = parseInt(object.left, 10);
	    cellHeight = object.height;
	    cellWidth = object.width;
	  } else if (this.type === 'event') {
	    top = parseInt(pageY(object), 10);
	    left = parseInt(pageX(object), 10);
	    cellHeight = object.target.clientHeight;
	    cellWidth = object.target.clientWidth;
	  }
	  topRelative = top - windowScrollTop;
	  leftRelative = left - windowScrollLeft;
	  scrollTop = windowScrollTop;
	  scrollLeft = windowScrollLeft;
	  this.top = top;
	  this.topRelative = topRelative;
	  this.left = left;
	  this.leftRelative = leftRelative;
	  this.scrollTop = scrollTop;
	  this.scrollLeft = scrollLeft;
	  this.cellHeight = cellHeight;
	  this.cellWidth = cellWidth;
	};
	($traceurRuntime.createClass)(Cursor, {
	  getSourceType: function(object) {
	    var type = 'literal';
	    if (object instanceof Event) {
	      type = 'event';
	    }
	    return type;
	  },
	  fitsAbove: function(element) {
	    return this.topRelative >= element.offsetHeight;
	  },
	  fitsBelow: function(element) {
	    var viewportHeight = arguments[1] !== (void 0) ? arguments[1] : window.innerHeight;
	    return this.topRelative + element.offsetHeight <= viewportHeight;
	  },
	  fitsOnRight: function(element) {
	    var viewportWidth = arguments[1] !== (void 0) ? arguments[1] : window.innerWidth;
	    return this.leftRelative + this.cellWidth + element.offsetWidth <= viewportWidth;
	  },
	  fitsOnLeft: function(element) {
	    return this.leftRelative >= element.offsetWidth;
	  }
	}, {});
	;
	Handsontable.plugins.utils = Handsontable.plugins.utils || {};
	Handsontable.plugins.utils.Cursor = Cursor;

	//# 
	},{"helpers/dom/element":45,"helpers/dom/event":46}],68:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  ItemsFactory: {get: function() {
	      return ItemsFactory;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__46__46__47_helpers_47_object__,
	    $___46__46__47__46__46__47_helpers_47_array__,
	    $__predefinedItems__;
	var $__0 = ($___46__46__47__46__46__47_helpers_47_object__ = require("helpers/object"), $___46__46__47__46__46__47_helpers_47_object__ && $___46__46__47__46__46__47_helpers_47_object__.__esModule && $___46__46__47__46__46__47_helpers_47_object__ || {default: $___46__46__47__46__46__47_helpers_47_object__}),
	    objectEach = $__0.objectEach,
	    isObject = $__0.isObject,
	    extend = $__0.extend;
	var arrayEach = ($___46__46__47__46__46__47_helpers_47_array__ = require("helpers/array"), $___46__46__47__46__46__47_helpers_47_array__ && $___46__46__47__46__46__47_helpers_47_array__.__esModule && $___46__46__47__46__46__47_helpers_47_array__ || {default: $___46__46__47__46__46__47_helpers_47_array__}).arrayEach;
	var $__2 = ($__predefinedItems__ = require("predefinedItems"), $__predefinedItems__ && $__predefinedItems__.__esModule && $__predefinedItems__ || {default: $__predefinedItems__}),
	    SEPARATOR = $__2.SEPARATOR,
	    ITEMS = $__2.ITEMS,
	    predefinedItems = $__2.predefinedItems;
	var ItemsFactory = function ItemsFactory(hotInstance) {
	  var orderPattern = arguments[1] !== (void 0) ? arguments[1] : null;
	  this.hot = hotInstance;
	  this.predefinedItems = predefinedItems();
	  this.defaultOrderPattern = orderPattern;
	};
	($traceurRuntime.createClass)(ItemsFactory, {
	  setPredefinedItems: function(predefinedItems) {
	    var $__3 = this;
	    var items = {};
	    this.defaultOrderPattern.length = 0;
	    objectEach(predefinedItems, (function(value, key) {
	      var menuItemKey = '';
	      if (value.name === SEPARATOR) {
	        items[SEPARATOR] = value;
	        menuItemKey = SEPARATOR;
	      } else if (isNaN(parseInt(key, 10))) {
	        value.key = value.key === void 0 ? key : value.key;
	        items[key] = value;
	        menuItemKey = value.key;
	      } else {
	        items[value.key] = value;
	        menuItemKey = value.key;
	      }
	      $__3.defaultOrderPattern.push(menuItemKey);
	    }));
	    this.predefinedItems = items;
	  },
	  getVisibleItems: function() {
	    var pattern = arguments[0] !== (void 0) ? arguments[0] : null;
	    var $__3 = this;
	    var visibleItems = {};
	    objectEach(this.predefinedItems, (function(value, key) {
	      if (!value.hidden || value.hidden && !value.hidden.apply($__3.hot)) {
	        visibleItems[key] = value;
	      }
	    }));
	    return getItems(pattern, this.defaultOrderPattern, visibleItems);
	  },
	  getItems: function() {
	    var pattern = arguments[0] !== (void 0) ? arguments[0] : null;
	    return getItems(pattern, this.defaultOrderPattern, this.predefinedItems);
	  }
	}, {});
	function getItems() {
	  var pattern = arguments[0] !== (void 0) ? arguments[0] : null;
	  var defaultPattern = arguments[1] !== (void 0) ? arguments[1] : [];
	  var items = arguments[2] !== (void 0) ? arguments[2] : {};
	  var result = [];
	  if (pattern && pattern.items) {
	    pattern = pattern.items;
	  } else if (!Array.isArray(pattern)) {
	    pattern = defaultPattern;
	  }
	  if (isObject(pattern)) {
	    objectEach(pattern, (function(value, key) {
	      var item = items[typeof value === 'string' ? value : key];
	      if (!item) {
	        item = value;
	      }
	      if (isObject(value)) {
	        extend(item, value);
	      } else if (typeof item === 'string') {
	        item = {name: item};
	      }
	      if (item.key === void 0) {
	        item.key = key;
	      }
	      result.push(item);
	    }));
	  } else {
	    arrayEach(pattern, (function(name, key) {
	      var item = items[name];
	      if (!item && ITEMS.indexOf(name) >= 0) {
	        return;
	      }
	      if (!item) {
	        item = {
	          name: name,
	          key: key + ''
	        };
	      }
	      if (isObject(name)) {
	        extend(item, name);
	      }
	      if (item.key === void 0) {
	        item.key = key;
	      }
	      result.push(item);
	    }));
	  }
	  if (result[0].name === SEPARATOR) {
	    result.shift();
	  }
	  return result;
	}
	;

	//# 
	},{"helpers/array":42,"helpers/object":50,"predefinedItems":70}],69:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  Menu: {get: function() {
	      return Menu;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__46__46__47_helpers_47_dom_47_element__,
	    $___46__46__47__46__46__47_helpers_47_array__,
	    $__cursor__,
	    $___46__46__47__46__46__47_eventManager__,
	    $___46__46__47__46__46__47_helpers_47_object__,
	    $__utils__,
	    $___46__46__47__46__46__47_helpers_47_unicode__,
	    $___46__46__47__46__46__47_mixins_47_localHooks__,
	    $__predefinedItems__,
	    $___46__46__47__46__46__47_helpers_47_dom_47_event__;
	var $__0 = ($___46__46__47__46__46__47_helpers_47_dom_47_element__ = require("helpers/dom/element"), $___46__46__47__46__46__47_helpers_47_dom_47_element__ && $___46__46__47__46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47__46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47__46__46__47_helpers_47_dom_47_element__}),
	    addClass = $__0.addClass,
	    empty = $__0.empty,
	    fastInnerHTML = $__0.fastInnerHTML,
	    getComputedStyle = $__0.getComputedStyle,
	    getScrollbarWidth = $__0.getScrollbarWidth,
	    getWindowScrollLeft = $__0.getWindowScrollLeft,
	    getWindowScrollTop = $__0.getWindowScrollTop,
	    hasClass = $__0.hasClass,
	    isChildOf = $__0.isChildOf,
	    removeClass = $__0.removeClass;
	var arrayEach = ($___46__46__47__46__46__47_helpers_47_array__ = require("helpers/array"), $___46__46__47__46__46__47_helpers_47_array__ && $___46__46__47__46__46__47_helpers_47_array__.__esModule && $___46__46__47__46__46__47_helpers_47_array__ || {default: $___46__46__47__46__46__47_helpers_47_array__}).arrayEach;
	var Cursor = ($__cursor__ = require("cursor"), $__cursor__ && $__cursor__.__esModule && $__cursor__ || {default: $__cursor__}).Cursor;
	var EventManager = ($___46__46__47__46__46__47_eventManager__ = require("eventManager"), $___46__46__47__46__46__47_eventManager__ && $___46__46__47__46__46__47_eventManager__.__esModule && $___46__46__47__46__46__47_eventManager__ || {default: $___46__46__47__46__46__47_eventManager__}).EventManager;
	var $__4 = ($___46__46__47__46__46__47_helpers_47_object__ = require("helpers/object"), $___46__46__47__46__46__47_helpers_47_object__ && $___46__46__47__46__46__47_helpers_47_object__.__esModule && $___46__46__47__46__46__47_helpers_47_object__ || {default: $___46__46__47__46__46__47_helpers_47_object__}),
	    extend = $__4.extend,
	    isObject = $__4.isObject,
	    objectEach = $__4.objectEach,
	    mixin = $__4.mixin;
	var $__5 = ($__utils__ = require("utils"), $__utils__ && $__utils__.__esModule && $__utils__ || {default: $__utils__}),
	    isSeparator = $__5.isSeparator,
	    isDisabled = $__5.isDisabled,
	    isSelectionDisabled = $__5.isSelectionDisabled,
	    hasSubMenu = $__5.hasSubMenu,
	    normalizeSelection = $__5.normalizeSelection;
	var KEY_CODES = ($___46__46__47__46__46__47_helpers_47_unicode__ = require("helpers/unicode"), $___46__46__47__46__46__47_helpers_47_unicode__ && $___46__46__47__46__46__47_helpers_47_unicode__.__esModule && $___46__46__47__46__46__47_helpers_47_unicode__ || {default: $___46__46__47__46__46__47_helpers_47_unicode__}).KEY_CODES;
	var localHooks = ($___46__46__47__46__46__47_mixins_47_localHooks__ = require("mixins/localHooks"), $___46__46__47__46__46__47_mixins_47_localHooks__ && $___46__46__47__46__46__47_mixins_47_localHooks__.__esModule && $___46__46__47__46__46__47_mixins_47_localHooks__ || {default: $___46__46__47__46__46__47_mixins_47_localHooks__}).localHooks;
	var $__8 = ($__predefinedItems__ = require("predefinedItems"), $__predefinedItems__ && $__predefinedItems__.__esModule && $__predefinedItems__ || {default: $__predefinedItems__}),
	    SEPARATOR = $__8.SEPARATOR,
	    predefinedItems = $__8.predefinedItems;
	var $__9 = ($___46__46__47__46__46__47_helpers_47_dom_47_event__ = require("helpers/dom/event"), $___46__46__47__46__46__47_helpers_47_dom_47_event__ && $___46__46__47__46__46__47_helpers_47_dom_47_event__.__esModule && $___46__46__47__46__46__47_helpers_47_dom_47_event__ || {default: $___46__46__47__46__46__47_helpers_47_dom_47_event__}),
	    stopPropagation = $__9.stopPropagation,
	    stopImmediatePropagation = $__9.stopImmediatePropagation,
	    pageX = $__9.pageX,
	    pageY = $__9.pageY;
	var Menu = function Menu(hotInstance) {
	  var options = arguments[1] !== (void 0) ? arguments[1] : {
	    parent: null,
	    name: null,
	    className: '',
	    keepInViewport: true
	  };
	  this.hot = hotInstance;
	  this.options = options;
	  this.eventManager = new EventManager(this);
	  this.container = this.createContainer(this.options.name);
	  this.hotMenu = null;
	  this.hotSubMenus = {};
	  this.parentMenu = this.options.parent || null;
	  this.menuItems = null;
	  this.origOutsideClickDeselects = null;
	  this._afterScrollCallback = null;
	  this.registerEvents();
	};
	var $Menu = Menu;
	($traceurRuntime.createClass)(Menu, {
	  registerEvents: function() {
	    var $__10 = this;
	    this.eventManager.addEventListener(document.documentElement, 'mousedown', (function(event) {
	      return $__10.onDocumentMouseDown(event);
	    }));
	  },
	  setMenuItems: function(menuItems) {
	    this.menuItems = menuItems;
	  },
	  isSubMenu: function() {
	    return this.parentMenu !== null;
	  },
	  open: function() {
	    var $__10 = this;
	    this.container.removeAttribute('style');
	    this.container.style.display = 'block';
	    var settings = {
	      data: this.menuItems,
	      colHeaders: false,
	      colWidths: [200],
	      autoRowSize: false,
	      readOnly: true,
	      copyPaste: false,
	      columns: [{
	        data: 'name',
	        renderer: (function(hot, TD, row, col, prop, value) {
	          return $__10.menuItemRenderer(hot, TD, row, col, prop, value);
	        })
	      }],
	      renderAllRows: true,
	      fragmentSelection: 'cell',
	      beforeKeyDown: (function(event) {
	        return $__10.onBeforeKeyDown(event);
	      }),
	      afterOnCellMouseOver: (function(event, coords, TD) {
	        return $__10.openSubMenu(coords.row);
	      })
	    };
	    this.origOutsideClickDeselects = this.hot.getSettings().outsideClickDeselects;
	    this.hot.getSettings().outsideClickDeselects = false;
	    this.hotMenu = new Handsontable.Core(this.container, settings);
	    this.hotMenu.addHook('afterInit', (function() {
	      return $__10.onAfterInit();
	    }));
	    this.hotMenu.init();
	    this.hotMenu.listen();
	    this.blockMainTableCallbacks();
	    this.runLocalHooks('afterOpen');
	  },
	  close: function() {
	    var closeParent = arguments[0] !== (void 0) ? arguments[0] : false;
	    if (!this.isOpened()) {
	      return;
	    }
	    if (closeParent && this.parentMenu) {
	      this.parentMenu.close();
	    } else {
	      this.closeAllSubMenus();
	      this.container.style.display = 'none';
	      this.releaseMainTableCallbacks();
	      this.hotMenu.destroy();
	      this.hotMenu = null;
	      this.hot.getSettings().outsideClickDeselects = this.origOutsideClickDeselects;
	      this.runLocalHooks('afterClose');
	    }
	  },
	  openSubMenu: function(row) {
	    var cell = this.hotMenu.getCell(row, 0);
	    this.closeAllSubMenus();
	    if (!cell || !hasSubMenu(cell)) {
	      return false;
	    }
	    var dataItem = this.hotMenu.getSourceDataAtRow(row);
	    var subMenu = new $Menu(this.hot, {
	      parent: this,
	      name: dataItem.name,
	      className: this.options.className
	    });
	    subMenu.setMenuItems(dataItem.submenu.items);
	    subMenu.open();
	    subMenu.setPosition(cell.getBoundingClientRect());
	    this.hotSubMenus[dataItem.key] = subMenu;
	    return subMenu;
	  },
	  closeSubMenu: function(row) {
	    var dataItem = this.hotMenu.getSourceDataAtRow(row);
	    var menus = this.hotSubMenus[dataItem.key];
	    if (menus) {
	      menus.destroy();
	      delete this.hotSubMenus[dataItem.key];
	    }
	  },
	  closeAllSubMenus: function() {
	    var $__10 = this;
	    arrayEach(this.hotMenu.getData(), (function(value, row) {
	      return $__10.closeSubMenu(row);
	    }));
	  },
	  isAllSubMenusClosed: function() {
	    return Object.keys(this.hotSubMenus).length === 0;
	  },
	  destroy: function() {
	    this.clearLocalHooks();
	    this.close();
	    this.parentMenu = null;
	    this.eventManager.destroy();
	  },
	  isOpened: function() {
	    return this.hotMenu !== null;
	  },
	  executeCommand: function(event) {
	    if (!this.isOpened() || !this.hotMenu.getSelected()) {
	      return;
	    }
	    var selectedItem = this.hotMenu.getSourceDataAtRow(this.hotMenu.getSelected()[0]);
	    this.runLocalHooks('select', selectedItem, event);
	    if (selectedItem.isCommand === false) {
	      return;
	    }
	    var selRange = this.hot.getSelectedRange();
	    var normalizedSelection = selRange ? normalizeSelection(selRange) : {};
	    this.runLocalHooks('executeCommand', selectedItem.key, normalizedSelection, event);
	    if (this.isSubMenu()) {
	      this.parentMenu.runLocalHooks('executeCommand', selectedItem.key, normalizedSelection, event);
	    }
	    this.close(true);
	  },
	  setPosition: function(coords) {
	    var cursor = new Cursor(coords);
	    if (this.options.keepInViewport) {
	      if (cursor.fitsBelow(this.container)) {
	        this.setPositionBelowCursor(cursor);
	      } else if (cursor.fitsAbove(this.container)) {
	        this.setPositionAboveCursor(cursor);
	      } else {
	        this.setPositionBelowCursor(cursor);
	      }
	      if (cursor.fitsOnRight(this.container)) {
	        this.setPositionOnRightOfCursor(cursor);
	      } else {
	        this.setPositionOnLeftOfCursor(cursor);
	      }
	    } else {
	      this.setPositionBelowCursor(cursor);
	      this.setPositionOnRightOfCursor(cursor);
	    }
	  },
	  setPositionAboveCursor: function(cursor) {
	    var top = cursor.top - this.container.offsetHeight;
	    if (this.isSubMenu()) {
	      top = window.scrollY + cursor.top + cursor.cellHeight - this.container.offsetHeight + 3;
	    }
	    this.container.style.top = top + 'px';
	  },
	  setPositionBelowCursor: function(cursor) {
	    var top = cursor.top - 1;
	    if (this.isSubMenu()) {
	      top = cursor.top + window.scrollY - 1;
	    }
	    this.container.style.top = top + 'px';
	  },
	  setPositionOnRightOfCursor: function(cursor) {
	    var left;
	    if (this.isSubMenu()) {
	      left = window.scrollX + 1 + cursor.left + cursor.cellWidth;
	    } else {
	      left = 1 + cursor.left;
	    }
	    this.container.style.left = left + 'px';
	  },
	  setPositionOnLeftOfCursor: function(cursor) {
	    this.container.style.left = (cursor.left - this.container.offsetWidth + getScrollbarWidth() + 4) + 'px';
	  },
	  selectFirstCell: function() {
	    var cell = this.hotMenu.getCell(0, 0);
	    if (isSeparator(cell) || isDisabled(cell) || isSelectionDisabled(cell)) {
	      this.selectNextCell(0, 0);
	    } else {
	      this.hotMenu.selectCell(0, 0);
	    }
	  },
	  selectLastCell: function() {
	    var lastRow = this.hotMenu.countRows() - 1;
	    var cell = this.hotMenu.getCell(lastRow, 0);
	    if (isSeparator(cell) || isDisabled(cell) || isSelectionDisabled(cell)) {
	      this.selectPrevCell(lastRow, 0);
	    } else {
	      this.hotMenu.selectCell(lastRow, 0);
	    }
	  },
	  selectNextCell: function(row, col) {
	    var nextRow = row + 1;
	    var cell = nextRow < this.hotMenu.countRows() ? this.hotMenu.getCell(nextRow, col) : null;
	    if (!cell) {
	      return;
	    }
	    if (isSeparator(cell) || isDisabled(cell) || isSelectionDisabled(cell)) {
	      this.selectNextCell(nextRow, col);
	    } else {
	      this.hotMenu.selectCell(nextRow, col);
	    }
	  },
	  selectPrevCell: function(row, col) {
	    var prevRow = row - 1;
	    var cell = prevRow >= 0 ? this.hotMenu.getCell(prevRow, col) : null;
	    if (!cell) {
	      return;
	    }
	    if (isSeparator(cell) || isDisabled(cell) || isSelectionDisabled(cell)) {
	      this.selectPrevCell(prevRow, col);
	    } else {
	      this.hotMenu.selectCell(prevRow, col);
	    }
	  },
	  menuItemRenderer: function(hot, TD, row, col, prop, value) {
	    var $__10 = this;
	    var item = hot.getSourceDataAtRow(row);
	    var wrapper = document.createElement('div');
	    var isSubMenu = (function(item) {
	      return item.hasOwnProperty('submenu');
	    });
	    var itemIsSeparator = (function(item) {
	      return new RegExp(SEPARATOR, 'i').test(item.name);
	    });
	    var itemIsDisabled = (function(item) {
	      return item.disabled === true || (typeof item.disabled == 'function' && item.disabled.call($__10.hot) === true);
	    });
	    var itemIsHidden = (function(item) {
	      return typeof item.hidden == 'function' && item.hidden.call($__10.hot) === true;
	    });
	    var itemIsSelectionDisabled = (function(item) {
	      return item.disableSelection;
	    });
	    var isHidden = itemIsHidden(item);
	    if (typeof value === 'function') {
	      value = value.call(this.hot);
	    }
	    empty(TD);
	    addClass(wrapper, 'htItemWrapper');
	    TD.appendChild(wrapper);
	    if (itemIsSeparator(item)) {
	      addClass(TD, 'htSeparator');
	    } else if (!isHidden && typeof item.renderer === 'function') {
	      addClass(TD, 'htCustomMenuRenderer');
	      TD.appendChild(item.renderer(hot, wrapper, row, col, prop, value));
	    } else {
	      fastInnerHTML(wrapper, value);
	    }
	    if (isHidden) {
	      if (TD.parentNode) {
	        addClass(TD.parentNode, 'htHidden');
	      }
	    } else if (itemIsDisabled(item)) {
	      addClass(TD, 'htDisabled');
	      this.eventManager.addEventListener(wrapper, 'mouseenter', (function() {
	        return hot.deselectCell();
	      }));
	    } else if (itemIsSelectionDisabled(item)) {
	      addClass(TD, 'htSelectionDisabled');
	      this.eventManager.addEventListener(wrapper, 'mouseenter', (function() {
	        return hot.deselectCell();
	      }));
	    } else if (isSubMenu(item)) {
	      addClass(TD, 'htSubmenu');
	      if (itemIsSelectionDisabled(item)) {
	        this.eventManager.addEventListener(wrapper, 'mouseenter', (function() {
	          return hot.deselectCell();
	        }));
	      } else {
	        this.eventManager.addEventListener(wrapper, 'mouseenter', (function() {
	          return hot.selectCell(row, col, void 0, void 0, void 0, false);
	        }));
	      }
	    } else {
	      removeClass(TD, 'htSubmenu');
	      removeClass(TD, 'htDisabled');
	      if (itemIsSelectionDisabled(item)) {
	        this.eventManager.addEventListener(wrapper, 'mouseenter', (function() {
	          return hot.deselectCell();
	        }));
	      } else {
	        this.eventManager.addEventListener(wrapper, 'mouseenter', (function() {
	          return hot.selectCell(row, col, void 0, void 0, void 0, false);
	        }));
	      }
	    }
	  },
	  createContainer: function() {
	    var name = arguments[0] !== (void 0) ? arguments[0] : null;
	    if (name) {
	      name = name.replace(/ /g, '_');
	      name = this.options.className + 'Sub_' + name;
	    }
	    var container;
	    if (name) {
	      container = document.querySelector('.' + this.options.className + '.' + name);
	    } else {
	      container = document.querySelector('.' + this.options.className);
	    }
	    if (!container) {
	      container = document.createElement('div');
	      addClass(container, 'htMenu ' + this.options.className);
	      if (name) {
	        addClass(container, name);
	      }
	      document.getElementsByTagName('body')[0].appendChild(container);
	    }
	    return container;
	  },
	  blockMainTableCallbacks: function() {
	    this._afterScrollCallback = function() {};
	    this.hot.addHook('afterScrollVertically', this._afterScrollCallback);
	    this.hot.addHook('afterScrollHorizontally', this._afterScrollCallback);
	  },
	  releaseMainTableCallbacks: function() {
	    if (this._afterScrollCallback) {
	      this.hot.removeHook('afterScrollVertically', this._afterScrollCallback);
	      this.hot.removeHook('afterScrollHorizontally', this._afterScrollCallback);
	      this._afterScrollCallback = null;
	    }
	  },
	  onBeforeKeyDown: function(event) {
	    var selection = this.hotMenu.getSelected();
	    var stopEvent = false;
	    switch (event.keyCode) {
	      case KEY_CODES.ESCAPE:
	        this.close();
	        stopEvent = true;
	        break;
	      case KEY_CODES.ENTER:
	        if (selection) {
	          if (this.hotMenu.getSourceDataAtRow(selection[0]).submenu) {
	            stopEvent = true;
	          } else {
	            this.executeCommand(event);
	            this.close(true);
	          }
	        }
	        break;
	      case KEY_CODES.ARROW_DOWN:
	        if (selection) {
	          this.selectNextCell(selection[0], selection[1]);
	        } else {
	          this.selectFirstCell();
	        }
	        stopEvent = true;
	        break;
	      case KEY_CODES.ARROW_UP:
	        if (selection) {
	          this.selectPrevCell(selection[0], selection[1]);
	        } else {
	          this.selectLastCell();
	        }
	        stopEvent = true;
	        break;
	      case KEY_CODES.ARROW_RIGHT:
	        if (selection) {
	          var menu = this.openSubMenu(selection[0]);
	          if (menu) {
	            menu.selectFirstCell();
	          }
	        }
	        stopEvent = true;
	        break;
	      case KEY_CODES.ARROW_LEFT:
	        if (selection && this.isSubMenu()) {
	          this.close();
	          if (this.parentMenu) {
	            this.parentMenu.hotMenu.listen();
	          }
	          stopEvent = true;
	        }
	        break;
	    }
	    if (stopEvent) {
	      event.preventDefault();
	      stopImmediatePropagation(event);
	    }
	  },
	  onAfterInit: function() {
	    var data = this.hotMenu.getSettings().data;
	    var hiderStyle = this.hotMenu.view.wt.wtTable.hider.style;
	    var holderStyle = this.hotMenu.view.wt.wtTable.holder.style;
	    var currentHiderWidth = parseInt(hiderStyle.width, 10);
	    var realHeight = 0;
	    arrayEach(data, (function(value) {
	      return realHeight += value.name === SEPARATOR ? 1 : 26;
	    }));
	    holderStyle.width = currentHiderWidth + 22 + 'px';
	    holderStyle.height = realHeight + 4 + 'px';
	  },
	  onDocumentMouseDown: function(event) {
	    if (!this.isOpened()) {
	      return;
	    }
	    if (this.container && isChildOf(event.target, this.container)) {
	      this.executeCommand(event);
	    }
	    if ((this.isAllSubMenusClosed() || this.isSubMenu()) && (!isChildOf(event.target, '.htMenu') && isChildOf(event.target, document))) {
	      this.close(true);
	    }
	  }
	}, {});
	mixin(Menu, localHooks);
	;

	//# 
	},{"cursor":67,"eventManager":41,"helpers/array":42,"helpers/dom/element":45,"helpers/dom/event":46,"helpers/object":50,"helpers/unicode":53,"mixins/localHooks":54,"predefinedItems":70,"utils":71}],70:[function(require,module,exports){
	"use strict";
	var $__4;
	Object.defineProperties(exports, {
	  ROW_ABOVE: {get: function() {
	      return ROW_ABOVE;
	    }},
	  ROW_BELOW: {get: function() {
	      return ROW_BELOW;
	    }},
	  COLUMN_LEFT: {get: function() {
	      return COLUMN_LEFT;
	    }},
	  COLUMN_RIGHT: {get: function() {
	      return COLUMN_RIGHT;
	    }},
	  CLEAR_COLUMN: {get: function() {
	      return CLEAR_COLUMN;
	    }},
	  REMOVE_ROW: {get: function() {
	      return REMOVE_ROW;
	    }},
	  REMOVE_COLUMN: {get: function() {
	      return REMOVE_COLUMN;
	    }},
	  UNDO: {get: function() {
	      return UNDO;
	    }},
	  REDO: {get: function() {
	      return REDO;
	    }},
	  READ_ONLY: {get: function() {
	      return READ_ONLY;
	    }},
	  ALIGNMENT: {get: function() {
	      return ALIGNMENT;
	    }},
	  SEPARATOR: {get: function() {
	      return SEPARATOR;
	    }},
	  ITEMS: {get: function() {
	      return ITEMS;
	    }},
	  predefinedItems: {get: function() {
	      return predefinedItems;
	    }},
	  addItem: {get: function() {
	      return addItem;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__46__46__47_helpers_47_object__,
	    $___46__46__47__46__46__47_helpers_47_number__,
	    $__utils__;
	var $__0 = ($___46__46__47__46__46__47_helpers_47_object__ = require("helpers/object"), $___46__46__47__46__46__47_helpers_47_object__ && $___46__46__47__46__46__47_helpers_47_object__.__esModule && $___46__46__47__46__46__47_helpers_47_object__ || {default: $___46__46__47__46__46__47_helpers_47_object__}),
	    objectEach = $__0.objectEach,
	    clone = $__0.clone;
	var rangeEach = ($___46__46__47__46__46__47_helpers_47_number__ = require("helpers/number"), $___46__46__47__46__46__47_helpers_47_number__ && $___46__46__47__46__46__47_helpers_47_number__.__esModule && $___46__46__47__46__46__47_helpers_47_number__ || {default: $___46__46__47__46__46__47_helpers_47_number__}).rangeEach;
	var $__2 = ($__utils__ = require("utils"), $__utils__ && $__utils__.__esModule && $__utils__ || {default: $__utils__}),
	    align = $__2.align,
	    getAlignmentClasses = $__2.getAlignmentClasses,
	    getValidSelection = $__2.getValidSelection,
	    checkSelectionConsistency = $__2.checkSelectionConsistency,
	    markLabelAsSelected = $__2.markLabelAsSelected;
	var ROW_ABOVE = 'row_above';
	var ROW_BELOW = 'row_below';
	var COLUMN_LEFT = 'col_left';
	var COLUMN_RIGHT = 'col_right';
	var CLEAR_COLUMN = 'clear_column';
	var REMOVE_ROW = 'remove_row';
	var REMOVE_COLUMN = 'remove_col';
	var UNDO = 'undo';
	var REDO = 'redo';
	var READ_ONLY = 'make_read_only';
	var ALIGNMENT = 'alignment';
	var SEPARATOR = '---------';
	var ITEMS = [ROW_ABOVE, ROW_BELOW, COLUMN_LEFT, COLUMN_RIGHT, CLEAR_COLUMN, REMOVE_ROW, REMOVE_COLUMN, UNDO, REDO, READ_ONLY, ALIGNMENT, SEPARATOR];
	function predefinedItems() {
	  var items = {};
	  objectEach(_predefinedItems, (function(value, key) {
	    return items[key] = clone(value);
	  }));
	  return items;
	}
	function addItem(key, item) {
	  if (ITEMS.indexOf(key) === -1) {
	    _predefinedItems[key] = item;
	  }
	}
	var _predefinedItems = ($__4 = {}, Object.defineProperty($__4, SEPARATOR, {
	  value: {name: SEPARATOR},
	  configurable: true,
	  enumerable: true,
	  writable: true
	}), Object.defineProperty($__4, ROW_ABOVE, {
	  value: {
	    key: ROW_ABOVE,
	    name: 'Insert row above',
	    callback: function(key, selection) {
	      this.alter('insert_row', selection.start.row);
	    },
	    disabled: function() {
	      var selected = getValidSelection(this);
	      if (!selected) {
	        return true;
	      }
	      var rowCount = this.countRows();
	      var entireColumnSelection = [0, selected[1], rowCount - 1, selected[1]];
	      return (entireColumnSelection.join(',') === selected.join(',')) && rowCount > 1;
	    },
	    hidden: function() {
	      return !this.getSettings().allowInsertRow;
	    }
	  },
	  configurable: true,
	  enumerable: true,
	  writable: true
	}), Object.defineProperty($__4, ROW_BELOW, {
	  value: {
	    key: ROW_BELOW,
	    name: 'Insert row below',
	    callback: function(key, selection) {
	      this.alter('insert_row', selection.end.row + 1);
	    },
	    disabled: function() {
	      var selected = getValidSelection(this);
	      if (!selected) {
	        return true;
	      }
	      var rowCount = this.countRows();
	      var entireColumnSelection = [0, selected[1], rowCount - 1, selected[1]];
	      return (entireColumnSelection.join(',') === selected.join(',')) && rowCount > 1;
	    },
	    hidden: function() {
	      return !this.getSettings().allowInsertRow;
	    }
	  },
	  configurable: true,
	  enumerable: true,
	  writable: true
	}), Object.defineProperty($__4, COLUMN_LEFT, {
	  value: {
	    key: COLUMN_LEFT,
	    name: 'Insert column on the left',
	    callback: function(key, selection) {
	      this.alter('insert_col', selection.start.col);
	    },
	    disabled: function() {
	      var selected = getValidSelection(this);
	      if (!selected) {
	        return true;
	      }
	      if (!this.isColumnModificationAllowed()) {
	        return true;
	      }
	      var entireRowSelection = [selected[0], 0, selected[0], this.countCols() - 1];
	      var rowSelected = entireRowSelection.join(',') == selected.join(',');
	      return selected[1] < 0 || this.countCols() >= this.getSettings().maxCols || rowSelected;
	    },
	    hidden: function() {
	      return !this.getSettings().allowInsertColumn;
	    }
	  },
	  configurable: true,
	  enumerable: true,
	  writable: true
	}), Object.defineProperty($__4, COLUMN_RIGHT, {
	  value: {
	    key: COLUMN_RIGHT,
	    name: 'Insert column on the right',
	    callback: function(key, selection) {
	      this.alter('insert_col', selection.end.col + 1);
	    },
	    disabled: function() {
	      var selected = getValidSelection(this);
	      if (!selected) {
	        return true;
	      }
	      if (!this.isColumnModificationAllowed()) {
	        return true;
	      }
	      var entireRowSelection = [selected[0], 0, selected[0], this.countCols() - 1];
	      var rowSelected = entireRowSelection.join(',') == selected.join(',');
	      return selected[1] < 0 || this.countCols() >= this.getSettings().maxCols || rowSelected;
	    },
	    hidden: function() {
	      return !this.getSettings().allowInsertColumn;
	    }
	  },
	  configurable: true,
	  enumerable: true,
	  writable: true
	}), Object.defineProperty($__4, CLEAR_COLUMN, {
	  value: {
	    key: CLEAR_COLUMN,
	    name: 'Clear column',
	    callback: function(key, selection) {
	      var column = selection.start.col;
	      if (this.countRows()) {
	        this.populateFromArray(0, column, [[null]], Math.max(selection.start.row, selection.end.row), column);
	      }
	    },
	    disabled: function() {
	      var selected = getValidSelection(this);
	      if (!selected) {
	        return true;
	      }
	      var entireRowSelection = [selected[0], 0, selected[0], this.countCols() - 1];
	      var rowSelected = entireRowSelection.join(',') == selected.join(',');
	      return selected[1] < 0 || this.countCols() >= this.getSettings().maxCols || rowSelected;
	    }
	  },
	  configurable: true,
	  enumerable: true,
	  writable: true
	}), Object.defineProperty($__4, REMOVE_ROW, {
	  value: {
	    key: REMOVE_ROW,
	    name: 'Remove row',
	    callback: function(key, selection) {
	      var amount = selection.end.row - selection.start.row + 1;
	      this.alter('remove_row', selection.start.row, amount);
	    },
	    disabled: function() {
	      var selected = getValidSelection(this);
	      if (!selected) {
	        return true;
	      }
	      var entireColumnSelection = [0, selected[1], this.countRows() - 1, selected[1]];
	      return entireColumnSelection.join(',') === selected.join(',');
	    },
	    hidden: function() {
	      return !this.getSettings().allowRemoveRow;
	    }
	  },
	  configurable: true,
	  enumerable: true,
	  writable: true
	}), Object.defineProperty($__4, REMOVE_COLUMN, {
	  value: {
	    key: REMOVE_COLUMN,
	    name: 'Remove column',
	    callback: function(key, selection) {
	      var amount = selection.end.col - selection.start.col + 1;
	      this.alter('remove_col', selection.start.col, amount);
	    },
	    disabled: function() {
	      var selected = getValidSelection(this);
	      if (!selected) {
	        return true;
	      }
	      if (!this.isColumnModificationAllowed()) {
	        return true;
	      }
	      var entireRowSelection = [selected[0], 0, selected[0], this.countCols() - 1];
	      var rowSelected = entireRowSelection.join(',') == selected.join(',');
	      return (selected[1] < 0 || rowSelected);
	    },
	    hidden: function() {
	      return !this.getSettings().allowRemoveColumn;
	    }
	  },
	  configurable: true,
	  enumerable: true,
	  writable: true
	}), Object.defineProperty($__4, UNDO, {
	  value: {
	    key: UNDO,
	    name: 'Undo',
	    callback: function() {
	      this.undo();
	    },
	    disabled: function() {
	      return this.undoRedo && !this.undoRedo.isUndoAvailable();
	    }
	  },
	  configurable: true,
	  enumerable: true,
	  writable: true
	}), Object.defineProperty($__4, REDO, {
	  value: {
	    key: REDO,
	    name: 'Redo',
	    callback: function() {
	      this.redo();
	    },
	    disabled: function() {
	      return this.undoRedo && !this.undoRedo.isRedoAvailable();
	    }
	  },
	  configurable: true,
	  enumerable: true,
	  writable: true
	}), Object.defineProperty($__4, READ_ONLY, {
	  value: {
	    key: READ_ONLY,
	    name: function() {
	      var $__3 = this;
	      var label = 'Read only';
	      var atLeastOneReadOnly = checkSelectionConsistency(this.getSelectedRange(), (function(row, col) {
	        return $__3.getCellMeta(row, col).readOnly;
	      }));
	      if (atLeastOneReadOnly) {
	        label = markLabelAsSelected(label);
	      }
	      return label;
	    },
	    callback: function() {
	      var $__3 = this;
	      var range = this.getSelectedRange();
	      var atLeastOneReadOnly = checkSelectionConsistency(range, (function(row, col) {
	        return $__3.getCellMeta(row, col).readOnly;
	      }));
	      range.forAll((function(row, col) {
	        $__3.getCellMeta(row, col).readOnly = atLeastOneReadOnly ? false : true;
	      }));
	      this.render();
	    },
	    disabled: function() {
	      return this.getSelectedRange() ? false : true;
	    }
	  },
	  configurable: true,
	  enumerable: true,
	  writable: true
	}), Object.defineProperty($__4, ALIGNMENT, {
	  value: {
	    key: ALIGNMENT,
	    name: 'Alignment',
	    disabled: function() {
	      return this.getSelectedRange() ? false : true;
	    },
	    submenu: {items: [{
	        key: (ALIGNMENT + ":left"),
	        name: function() {
	          var $__3 = this;
	          var label = 'Left';
	          var hasClass = checkSelectionConsistency(this.getSelectedRange(), (function(row, col) {
	            var className = $__3.getCellMeta(row, col).className;
	            if (className && className.indexOf('htLeft') !== -1) {
	              return true;
	            }
	          }));
	          if (hasClass) {
	            label = markLabelAsSelected(label);
	          }
	          return label;
	        },
	        callback: function() {
	          var $__3 = this;
	          var range = this.getSelectedRange();
	          var stateBefore = getAlignmentClasses(range, (function(row, col) {
	            return $__3.getCellMeta(row, col).className;
	          }));
	          var type = 'horizontal';
	          var alignment = 'htLeft';
	          this.runHooks('beforeCellAlignment', stateBefore, range, type, alignment);
	          align(range, type, alignment, (function(row, col) {
	            return $__3.getCellMeta(row, col);
	          }));
	          this.render();
	        },
	        disabled: false
	      }, {
	        key: (ALIGNMENT + ":center"),
	        name: function() {
	          var $__3 = this;
	          var label = 'Center';
	          var hasClass = checkSelectionConsistency(this.getSelectedRange(), (function(row, col) {
	            var className = $__3.getCellMeta(row, col).className;
	            if (className && className.indexOf('htCenter') !== -1) {
	              return true;
	            }
	          }));
	          if (hasClass) {
	            label = markLabelAsSelected(label);
	          }
	          return label;
	        },
	        callback: function() {
	          var $__3 = this;
	          var range = this.getSelectedRange();
	          var stateBefore = getAlignmentClasses(range, (function(row, col) {
	            return $__3.getCellMeta(row, col).className;
	          }));
	          var type = 'horizontal';
	          var alignment = 'htCenter';
	          this.runHooks('beforeCellAlignment', stateBefore, range, type, alignment);
	          align(range, type, alignment, (function(row, col) {
	            return $__3.getCellMeta(row, col);
	          }));
	          this.render();
	        },
	        disabled: false
	      }, {
	        key: (ALIGNMENT + ":right"),
	        name: function() {
	          var $__3 = this;
	          var label = 'Right';
	          var hasClass = checkSelectionConsistency(this.getSelectedRange(), (function(row, col) {
	            var className = $__3.getCellMeta(row, col).className;
	            if (className && className.indexOf('htRight') !== -1) {
	              return true;
	            }
	          }));
	          if (hasClass) {
	            label = markLabelAsSelected(label);
	          }
	          return label;
	        },
	        callback: function() {
	          var $__3 = this;
	          var range = this.getSelectedRange();
	          var stateBefore = getAlignmentClasses(range, (function(row, col) {
	            return $__3.getCellMeta(row, col).className;
	          }));
	          var type = 'horizontal';
	          var alignment = 'htRight';
	          this.runHooks('beforeCellAlignment', stateBefore, range, type, alignment);
	          align(range, type, alignment, (function(row, col) {
	            return $__3.getCellMeta(row, col);
	          }));
	          this.render();
	        },
	        disabled: false
	      }, {
	        key: (ALIGNMENT + ":justify"),
	        name: function() {
	          var $__3 = this;
	          var label = 'Justify';
	          var hasClass = checkSelectionConsistency(this.getSelectedRange(), (function(row, col) {
	            var className = $__3.getCellMeta(row, col).className;
	            if (className && className.indexOf('htJustify') !== -1) {
	              return true;
	            }
	          }));
	          if (hasClass) {
	            label = markLabelAsSelected(label);
	          }
	          return label;
	        },
	        callback: function() {
	          var $__3 = this;
	          var range = this.getSelectedRange();
	          var stateBefore = getAlignmentClasses(range, (function(row, col) {
	            return $__3.getCellMeta(row, col).className;
	          }));
	          var type = 'horizontal';
	          var alignment = 'htJustify';
	          this.runHooks('beforeCellAlignment', stateBefore, range, type, alignment);
	          align(range, type, alignment, (function(row, col) {
	            return $__3.getCellMeta(row, col);
	          }));
	          this.render();
	        },
	        disabled: false
	      }, {name: SEPARATOR}, {
	        key: (ALIGNMENT + ":top"),
	        name: function() {
	          var $__3 = this;
	          var label = 'Top';
	          var hasClass = checkSelectionConsistency(this.getSelectedRange(), (function(row, col) {
	            var className = $__3.getCellMeta(row, col).className;
	            if (className && className.indexOf('htTop') !== -1) {
	              return true;
	            }
	          }));
	          if (hasClass) {
	            label = markLabelAsSelected(label);
	          }
	          return label;
	        },
	        callback: function() {
	          var $__3 = this;
	          var range = this.getSelectedRange();
	          var stateBefore = getAlignmentClasses(range, (function(row, col) {
	            return $__3.getCellMeta(row, col).className;
	          }));
	          var type = 'vertical';
	          var alignment = 'htTop';
	          this.runHooks('beforeCellAlignment', stateBefore, range, type, alignment);
	          align(range, type, alignment, (function(row, col) {
	            return $__3.getCellMeta(row, col);
	          }));
	          this.render();
	        },
	        disabled: false
	      }, {
	        key: (ALIGNMENT + ":middle"),
	        name: function() {
	          var $__3 = this;
	          var label = 'Middle';
	          var hasClass = checkSelectionConsistency(this.getSelectedRange(), (function(row, col) {
	            var className = $__3.getCellMeta(row, col).className;
	            if (className && className.indexOf('htMiddle') !== -1) {
	              return true;
	            }
	          }));
	          if (hasClass) {
	            label = markLabelAsSelected(label);
	          }
	          return label;
	        },
	        callback: function() {
	          var $__3 = this;
	          var range = this.getSelectedRange();
	          var stateBefore = getAlignmentClasses(range, (function(row, col) {
	            return $__3.getCellMeta(row, col).className;
	          }));
	          var type = 'vertical';
	          var alignment = 'htMiddle';
	          this.runHooks('beforeCellAlignment', stateBefore, range, type, alignment);
	          align(range, type, alignment, (function(row, col) {
	            return $__3.getCellMeta(row, col);
	          }));
	          this.render();
	        },
	        disabled: false
	      }, {
	        key: (ALIGNMENT + ":bottom"),
	        name: function() {
	          var $__3 = this;
	          var label = 'Bottom';
	          var hasClass = checkSelectionConsistency(this.getSelectedRange(), (function(row, col) {
	            var className = $__3.getCellMeta(row, col).className;
	            if (className && className.indexOf('htBottom') !== -1) {
	              return true;
	            }
	          }));
	          if (hasClass) {
	            label = markLabelAsSelected(label);
	          }
	          return label;
	        },
	        callback: function() {
	          var $__3 = this;
	          var range = this.getSelectedRange();
	          var stateBefore = getAlignmentClasses(range, (function(row, col) {
	            return $__3.getCellMeta(row, col).className;
	          }));
	          var type = 'vertical';
	          var alignment = 'htBottom';
	          this.runHooks('beforeCellAlignment', stateBefore, range, type, alignment);
	          align(range, type, alignment, (function(row, col) {
	            return $__3.getCellMeta(row, col);
	          }));
	          this.render();
	        },
	        disabled: false
	      }]}
	  },
	  configurable: true,
	  enumerable: true,
	  writable: true
	}), $__4);

	//# 
	},{"helpers/number":49,"helpers/object":50,"utils":71}],71:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  normalizeSelection: {get: function() {
	      return normalizeSelection;
	    }},
	  isSeparator: {get: function() {
	      return isSeparator;
	    }},
	  hasSubMenu: {get: function() {
	      return hasSubMenu;
	    }},
	  isDisabled: {get: function() {
	      return isDisabled;
	    }},
	  isSelectionDisabled: {get: function() {
	      return isSelectionDisabled;
	    }},
	  getValidSelection: {get: function() {
	      return getValidSelection;
	    }},
	  prepareVerticalAlignClass: {get: function() {
	      return prepareVerticalAlignClass;
	    }},
	  prepareHorizontalAlignClass: {get: function() {
	      return prepareHorizontalAlignClass;
	    }},
	  getAlignmentClasses: {get: function() {
	      return getAlignmentClasses;
	    }},
	  align: {get: function() {
	      return align;
	    }},
	  checkSelectionConsistency: {get: function() {
	      return checkSelectionConsistency;
	    }},
	  markLabelAsSelected: {get: function() {
	      return markLabelAsSelected;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__46__46__47_helpers_47_dom_47_element__;
	var hasClass = ($___46__46__47__46__46__47_helpers_47_dom_47_element__ = require("helpers/dom/element"), $___46__46__47__46__46__47_helpers_47_dom_47_element__ && $___46__46__47__46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47__46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47__46__46__47_helpers_47_dom_47_element__}).hasClass;
	function normalizeSelection(selRange) {
	  return {
	    start: selRange.getTopLeftCorner(),
	    end: selRange.getBottomRightCorner()
	  };
	}
	function isSeparator(cell) {
	  return hasClass(cell, 'htSeparator');
	}
	function hasSubMenu(cell) {
	  return hasClass(cell, 'htSubmenu');
	}
	function isDisabled(cell) {
	  return hasClass(cell, 'htDisabled');
	}
	function isSelectionDisabled(cell) {
	  return hasClass(cell, 'htSelectionDisabled');
	}
	function getValidSelection(hot) {
	  var selected = hot.getSelected();
	  if (!selected) {
	    return null;
	  }
	  if (selected[0] < 0) {
	    return null;
	  }
	  if (hot.countRows() >= hot.getSettings().maxRows) {
	    return null;
	  }
	  return selected;
	}
	function prepareVerticalAlignClass(className, alignment) {
	  if (className.indexOf(alignment) != -1) {
	    return className;
	  }
	  className = className.replace('htTop', '').replace('htMiddle', '').replace('htBottom', '').replace('  ', '');
	  className += ' ' + alignment;
	  return className;
	}
	function prepareHorizontalAlignClass(className, alignment) {
	  if (className.indexOf(alignment) != -1) {
	    return className;
	  }
	  className = className.replace('htLeft', '').replace('htCenter', '').replace('htRight', '').replace('htJustify', '').replace('  ', '');
	  className += ' ' + alignment;
	  return className;
	}
	function getAlignmentClasses(range, callback) {
	  var classes = {};
	  for (var row = range.from.row; row <= range.to.row; row++) {
	    for (var col = range.from.col; col <= range.to.col; col++) {
	      if (!classes[row]) {
	        classes[row] = [];
	      }
	      classes[row][col] = callback(row, col);
	    }
	  }
	  return classes;
	}
	function align(range, type, alignment, cellDescriptor) {
	  if (range.from.row == range.to.row && range.from.col == range.to.col) {
	    applyAlignClassName(range.from.row, range.from.col, type, alignment, cellDescriptor);
	  } else {
	    for (var row = range.from.row; row <= range.to.row; row++) {
	      for (var col = range.from.col; col <= range.to.col; col++) {
	        applyAlignClassName(row, col, type, alignment, cellDescriptor);
	      }
	    }
	  }
	}
	function applyAlignClassName(row, col, type, alignment, cellDescriptor) {
	  var cellMeta = cellDescriptor(row, col);
	  var className = alignment;
	  if (cellMeta.className) {
	    if (type === 'vertical') {
	      className = prepareVerticalAlignClass(cellMeta.className, alignment);
	    } else {
	      className = prepareHorizontalAlignClass(cellMeta.className, alignment);
	    }
	  }
	  cellMeta.className = className;
	}
	function checkSelectionConsistency(range, comparator) {
	  var result = false;
	  if (range) {
	    range.forAll(function(row, col) {
	      if (comparator(row, col)) {
	        result = true;
	        return false;
	      }
	    });
	  }
	  return result;
	}
	function markLabelAsSelected(label) {
	  return '<span class="selected">' + String.fromCharCode(10003) + '</span>' + label;
	}

	//# 
	},{"helpers/dom/element":45}],72:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  ContextMenuCopyPaste: {get: function() {
	      return ContextMenuCopyPaste;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__46__46__47_helpers_47_dom_47_element__,
	    $___46__46__47__46__46__47_helpers_47_array__,
	    $___46__46__47__46__46__47_eventManager__,
	    $___46__46__47__46__46__47_plugins__,
	    $___46__46__47__95_base__,
	    $__zeroclipboard__;
	var removeClass = ($___46__46__47__46__46__47_helpers_47_dom_47_element__ = require("helpers/dom/element"), $___46__46__47__46__46__47_helpers_47_dom_47_element__ && $___46__46__47__46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47__46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47__46__46__47_helpers_47_dom_47_element__}).removeClass;
	var arrayEach = ($___46__46__47__46__46__47_helpers_47_array__ = require("helpers/array"), $___46__46__47__46__46__47_helpers_47_array__ && $___46__46__47__46__46__47_helpers_47_array__.__esModule && $___46__46__47__46__46__47_helpers_47_array__ || {default: $___46__46__47__46__46__47_helpers_47_array__}).arrayEach;
	var EventManager = ($___46__46__47__46__46__47_eventManager__ = require("eventManager"), $___46__46__47__46__46__47_eventManager__ && $___46__46__47__46__46__47_eventManager__.__esModule && $___46__46__47__46__46__47_eventManager__ || {default: $___46__46__47__46__46__47_eventManager__}).EventManager;
	var registerPlugin = ($___46__46__47__46__46__47_plugins__ = require("plugins"), $___46__46__47__46__46__47_plugins__ && $___46__46__47__46__46__47_plugins__.__esModule && $___46__46__47__46__46__47_plugins__ || {default: $___46__46__47__46__46__47_plugins__}).registerPlugin;
	var BasePlugin = ($___46__46__47__95_base__ = require("_base"), $___46__46__47__95_base__ && $___46__46__47__95_base__.__esModule && $___46__46__47__95_base__ || {default: $___46__46__47__95_base__}).default;
	var ZeroClipboard = ($__zeroclipboard__ = require("zeroclipboard"), $__zeroclipboard__ && $__zeroclipboard__.__esModule && $__zeroclipboard__ || {default: $__zeroclipboard__}).default;
	var ContextMenuCopyPaste = function ContextMenuCopyPaste(hotInstance) {
	  $traceurRuntime.superConstructor($ContextMenuCopyPaste).call(this, hotInstance);
	  this.eventManager = new EventManager(this);
	  this.swfPath = null;
	  this.outsideClickDeselectsCache = null;
	};
	var $ContextMenuCopyPaste = ContextMenuCopyPaste;
	($traceurRuntime.createClass)(ContextMenuCopyPaste, {
	  isEnabled: function() {
	    return this.hot.getSettings().contextMenuCopyPaste;
	  },
	  enablePlugin: function() {
	    var $__6 = this;
	    if (this.enabled) {
	      return;
	    }
	    if (typeof this.hot.getSettings().contextMenuCopyPaste === 'object') {
	      this.swfPath = this.hot.getSettings().contextMenuCopyPaste.swfPath;
	    }
	    if (typeof ZeroClipboard === 'undefined') {
	      console.error('To be able to use the Copy/Paste feature from the context menu, you need to manually include ZeroClipboard.js file to your website.');
	    }
	    try {
	      new ActiveXObject('ShockwaveFlash.ShockwaveFlash');
	    } catch (exception) {
	      if (typeof navigator.mimeTypes['application/x-shockwave-flash'] == 'undefined') {
	        console.error('To be able to use the Copy/Paste feature from the context menu, your browser needs to have Flash Plugin installed.');
	      }
	    }
	    if (this.swfPath) {
	      ZeroClipboard.config({swfPath: this.swfPath});
	    }
	    this.hot.addHook('afterContextMenuShow', (function() {
	      return $__6.onAfterContextMenuShow();
	    }));
	    this.hot.addHook('afterContextMenuDefaultOptions', (function(options) {
	      return $__6.onAfterContextMenuDefaultOptions(options);
	    }));
	    this.registerEvents();
	    $traceurRuntime.superGet(this, $ContextMenuCopyPaste.prototype, "enablePlugin").call(this);
	  },
	  disablePlugin: function() {
	    $traceurRuntime.superGet(this, $ContextMenuCopyPaste.prototype, "disablePlugin").call(this);
	  },
	  registerEvents: function() {
	    var $__6 = this;
	    this.eventManager.addEventListener(document, 'mouseenter', (function() {
	      return $__6.removeCurrentClass();
	    }));
	    this.eventManager.addEventListener(document, 'mouseleave', (function() {
	      return $__6.removeZeroClipboardClass();
	    }));
	  },
	  getCopyValue: function() {
	    this.hot.copyPaste.setCopyableText();
	    return this.hot.copyPaste.copyPasteInstance.elTextarea.value;
	  },
	  onAfterContextMenuDefaultOptions: function(defaultOptions) {
	    defaultOptions.items.unshift({
	      key: 'copy',
	      name: 'Copy'
	    }, {
	      key: 'paste',
	      name: 'Paste',
	      callback: function() {
	        this.copyPaste.triggerPaste();
	      }
	    }, Handsontable.plugins.ContextMenu.SEPARATOR);
	  },
	  onAfterContextMenuShow: function() {
	    var $__6 = this;
	    var contextMenu = this.hot.getPlugin('contextMenu');
	    var data = contextMenu.menu.hotMenu.getSourceData();
	    arrayEach(data, (function(item, index) {
	      if (item.key === 'copy') {
	        var zeroClipboardInstance = new ZeroClipboard(contextMenu.menu.hotMenu.getCell(index, 0));
	        zeroClipboardInstance.off();
	        zeroClipboardInstance.on('copy', (function(event) {
	          var clipboard = event.clipboardData;
	          clipboard.setData('text/plain', $__6.getCopyValue());
	          $__6.hot.getSettings().outsideClickDeselects = $__6.outsideClickDeselectsCache;
	        }));
	        return false;
	      }
	    }));
	  },
	  removeCurrentClass: function() {
	    var contextMenu = this.hot.getPlugin('contextMenu');
	    if (contextMenu.menu.isOpened()) {
	      var element = contextMenu.menu.hotMenu.rootElement.querySelector('td.current');
	      if (element) {
	        removeClass(element, 'current');
	      }
	    }
	    this.outsideClickDeselectsCache = this.hot.getSettings().outsideClickDeselects;
	    this.hot.getSettings().outsideClickDeselects = false;
	  },
	  removeZeroClipboardClass: function() {
	    var contextMenu = this.hot.getPlugin('contextMenu');
	    if (contextMenu.menu.isOpened()) {
	      var element = contextMenu.menu.hotMenu.rootElement.querySelector('td.zeroclipboard-is-hover');
	      if (element) {
	        removeClass(element, 'zeroclipboard-is-hover');
	      }
	    }
	    this.hot.getSettings().outsideClickDeselects = this.outsideClickDeselectsCache;
	  }
	}, {}, BasePlugin);
	;
	registerPlugin('contextMenuCopyPaste', ContextMenuCopyPaste);

	//# 
	},{"_base":58,"eventManager":41,"helpers/array":42,"helpers/dom/element":45,"plugins":57,"zeroclipboard":"zeroclipboard"}],73:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  CopyPastePlugin: {get: function() {
	      return CopyPastePlugin;
	    }},
	  __esModule: {value: true}
	});
	var $__copyPaste__,
	    $__SheetClip__,
	    $___46__46__47__46__46__47_helpers_47_unicode__,
	    $___46__46__47__46__46__47_helpers_47_array__,
	    $___46__46__47__46__46__47_helpers_47_number__,
	    $___46__46__47__46__46__47_helpers_47_dom_47_event__,
	    $___46__46__47__46__46__47_helpers_47_dom_47_element__,
	    $___46__46__47__46__46__47_helpers_47_function__,
	    $___46__46__47__46__46__47_plugins__,
	    $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_coords__,
	    $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_range__;
	var copyPaste = ($__copyPaste__ = require("copyPaste"), $__copyPaste__ && $__copyPaste__.__esModule && $__copyPaste__ || {default: $__copyPaste__}).default;
	var SheetClip = ($__SheetClip__ = require("SheetClip"), $__SheetClip__ && $__SheetClip__.__esModule && $__SheetClip__ || {default: $__SheetClip__}).default;
	var $__2 = ($___46__46__47__46__46__47_helpers_47_unicode__ = require("helpers/unicode"), $___46__46__47__46__46__47_helpers_47_unicode__ && $___46__46__47__46__46__47_helpers_47_unicode__.__esModule && $___46__46__47__46__46__47_helpers_47_unicode__ || {default: $___46__46__47__46__46__47_helpers_47_unicode__}),
	    KEY_CODES = $__2.KEY_CODES,
	    isCtrlKey = $__2.isCtrlKey;
	var arrayEach = ($___46__46__47__46__46__47_helpers_47_array__ = require("helpers/array"), $___46__46__47__46__46__47_helpers_47_array__ && $___46__46__47__46__46__47_helpers_47_array__.__esModule && $___46__46__47__46__46__47_helpers_47_array__ || {default: $___46__46__47__46__46__47_helpers_47_array__}).arrayEach;
	var rangeEach = ($___46__46__47__46__46__47_helpers_47_number__ = require("helpers/number"), $___46__46__47__46__46__47_helpers_47_number__ && $___46__46__47__46__46__47_helpers_47_number__.__esModule && $___46__46__47__46__46__47_helpers_47_number__ || {default: $___46__46__47__46__46__47_helpers_47_number__}).rangeEach;
	var $__5 = ($___46__46__47__46__46__47_helpers_47_dom_47_event__ = require("helpers/dom/event"), $___46__46__47__46__46__47_helpers_47_dom_47_event__ && $___46__46__47__46__46__47_helpers_47_dom_47_event__.__esModule && $___46__46__47__46__46__47_helpers_47_dom_47_event__ || {default: $___46__46__47__46__46__47_helpers_47_dom_47_event__}),
	    stopImmediatePropagation = $__5.stopImmediatePropagation,
	    isImmediatePropagationStopped = $__5.isImmediatePropagationStopped;
	var getSelectionText = ($___46__46__47__46__46__47_helpers_47_dom_47_element__ = require("helpers/dom/element"), $___46__46__47__46__46__47_helpers_47_dom_47_element__ && $___46__46__47__46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47__46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47__46__46__47_helpers_47_dom_47_element__}).getSelectionText;
	var proxy = ($___46__46__47__46__46__47_helpers_47_function__ = require("helpers/function"), $___46__46__47__46__46__47_helpers_47_function__ && $___46__46__47__46__46__47_helpers_47_function__.__esModule && $___46__46__47__46__46__47_helpers_47_function__ || {default: $___46__46__47__46__46__47_helpers_47_function__}).proxy;
	var registerPlugin = ($___46__46__47__46__46__47_plugins__ = require("plugins"), $___46__46__47__46__46__47_plugins__ && $___46__46__47__46__46__47_plugins__.__esModule && $___46__46__47__46__46__47_plugins__ || {default: $___46__46__47__46__46__47_plugins__}).registerPlugin;
	var WalkontableCellCoords = ($___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_coords__ = require("3rdparty/walkontable/src/cell/coords"), $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_coords__ && $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_coords__.__esModule && $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_coords__ || {default: $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_coords__}).WalkontableCellCoords;
	var WalkontableCellRange = ($___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_range__ = require("3rdparty/walkontable/src/cell/range"), $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_range__ && $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_range__.__esModule && $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_range__ || {default: $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_range__}).WalkontableCellRange;
	function CopyPastePlugin(instance) {
	  var _this = this;
	  this.copyPasteInstance = copyPaste();
	  this.copyPasteInstance.onCut(onCut);
	  this.copyPasteInstance.onPaste(onPaste);
	  this.onPaste = onPaste;
	  instance.addHook('beforeKeyDown', onBeforeKeyDown);
	  function onCut() {
	    if (!instance.isListening()) {
	      return;
	    }
	    instance.selection.empty();
	  }
	  function onPaste(str) {
	    var input,
	        inputArray,
	        selected,
	        coordsFrom,
	        coordsTo,
	        cellRange,
	        topLeftCorner,
	        bottomRightCorner,
	        areaStart,
	        areaEnd;
	    if (!instance.isListening() || !instance.selection.isSelected()) {
	      return;
	    }
	    input = str;
	    inputArray = SheetClip.parse(input);
	    selected = instance.getSelected();
	    coordsFrom = new WalkontableCellCoords(selected[0], selected[1]);
	    coordsTo = new WalkontableCellCoords(selected[2], selected[3]);
	    cellRange = new WalkontableCellRange(coordsFrom, coordsFrom, coordsTo);
	    topLeftCorner = cellRange.getTopLeftCorner();
	    bottomRightCorner = cellRange.getBottomRightCorner();
	    areaStart = topLeftCorner;
	    areaEnd = new WalkontableCellCoords(Math.max(bottomRightCorner.row, inputArray.length - 1 + topLeftCorner.row), Math.max(bottomRightCorner.col, inputArray[0].length - 1 + topLeftCorner.col));
	    var isSelRowAreaCoverInputValue = coordsTo.row - coordsFrom.row >= inputArray.length - 1;
	    var isSelColAreaCoverInputValue = coordsTo.col - coordsFrom.col >= inputArray[0].length - 1;
	    instance.addHookOnce('afterChange', (function(changes, source) {
	      var changesLength = changes ? changes.length : 0;
	      if (changesLength) {
	        var offset = {
	          row: 0,
	          col: 0
	        };
	        var highestColumnIndex = -1;
	        arrayEach(changes, (function(change, index) {
	          var nextChange = changesLength > index + 1 ? changes[index + 1] : null;
	          if (nextChange) {
	            if (!isSelRowAreaCoverInputValue) {
	              offset.row = offset.row + Math.max(nextChange[0] - change[0] - 1, 0);
	            }
	            if (!isSelColAreaCoverInputValue && change[1] > highestColumnIndex) {
	              highestColumnIndex = change[1];
	              offset.col = offset.col + Math.max(nextChange[1] - change[1] - 1, 0);
	            }
	          }
	        }));
	        instance.selectCell(areaStart.row, areaStart.col, areaEnd.row + offset.row, areaEnd.col + offset.col);
	      }
	    }));
	    instance.populateFromArray(areaStart.row, areaStart.col, inputArray, areaEnd.row, areaEnd.col, 'paste', instance.getSettings().pasteMode);
	  }
	  function onBeforeKeyDown(event) {
	    if (!instance.getSelected()) {
	      return;
	    }
	    if (instance.getActiveEditor() && instance.getActiveEditor().isOpened()) {
	      return;
	    }
	    if (isImmediatePropagationStopped(event)) {
	      return;
	    }
	    if (isCtrlKey(event.keyCode)) {
	      if (instance.getSettings().fragmentSelection && getSelectionText()) {
	        return;
	      }
	      _this.setCopyableText();
	      stopImmediatePropagation(event);
	      return;
	    }
	    var ctrlDown = (event.ctrlKey || event.metaKey) && !event.altKey;
	    if (event.keyCode == KEY_CODES.A && ctrlDown) {
	      instance._registerTimeout(setTimeout(proxy(_this.setCopyableText, _this), 0));
	    }
	  }
	  this.destroy = function() {
	    if (this.copyPasteInstance) {
	      this.copyPasteInstance.removeCallback(onCut);
	      this.copyPasteInstance.removeCallback(onPaste);
	      this.copyPasteInstance.destroy();
	      this.copyPasteInstance = null;
	    }
	    instance.removeHook('beforeKeyDown', onBeforeKeyDown);
	  };
	  instance.addHook('afterDestroy', proxy(this.destroy, this));
	  this.triggerPaste = proxy(this.copyPasteInstance.triggerPaste, this.copyPasteInstance);
	  this.triggerCut = proxy(this.copyPasteInstance.triggerCut, this.copyPasteInstance);
	  this.setCopyableText = function() {
	    var settings = instance.getSettings();
	    var copyRowsLimit = settings.copyRowsLimit;
	    var copyColsLimit = settings.copyColsLimit;
	    var selRange = instance.getSelectedRange();
	    var topLeft = selRange.getTopLeftCorner();
	    var bottomRight = selRange.getBottomRightCorner();
	    var startRow = topLeft.row;
	    var startCol = topLeft.col;
	    var endRow = bottomRight.row;
	    var endCol = bottomRight.col;
	    var finalEndRow = Math.min(endRow, startRow + copyRowsLimit - 1);
	    var finalEndCol = Math.min(endCol, startCol + copyColsLimit - 1);
	    var copyableRanges = [];
	    copyableRanges.push({
	      startRow: startRow,
	      startCol: startCol,
	      endRow: finalEndRow,
	      endCol: finalEndCol
	    });
	    copyableRanges = Handsontable.hooks.run(instance, 'modifyCopyableRange', copyableRanges);
	    var copyableData = this.getRangedCopyableData(copyableRanges);
	    instance.copyPaste.copyPasteInstance.copyable(copyableData);
	    if (endRow !== finalEndRow || endCol !== finalEndCol) {
	      Handsontable.hooks.run(instance, 'afterCopyLimit', endRow - startRow + 1, endCol - startCol + 1, copyRowsLimit, copyColsLimit);
	    }
	  };
	  this.getRangedCopyableData = function(ranges) {
	    var dataSet = [];
	    var copyableRows = [];
	    var copyableColumns = [];
	    arrayEach(ranges, (function(range) {
	      rangeEach(range.startRow, range.endRow, (function(row) {
	        if (copyableRows.indexOf(row) === -1) {
	          copyableRows.push(row);
	        }
	      }));
	      rangeEach(range.startCol, range.endCol, (function(column) {
	        if (copyableColumns.indexOf(column) === -1) {
	          copyableColumns.push(column);
	        }
	      }));
	    }));
	    arrayEach(copyableRows, (function(row) {
	      var rowSet = [];
	      arrayEach(copyableColumns, (function(column) {
	        rowSet.push(instance.getCopyableData(row, column));
	      }));
	      dataSet.push(rowSet);
	    }));
	    return SheetClip.stringify(dataSet);
	  };
	}
	function init() {
	  var instance = this,
	      pluginEnabled = instance.getSettings().copyPaste !== false;
	  if (pluginEnabled && !instance.copyPaste) {
	    instance.copyPaste = new CopyPastePlugin(instance);
	  } else if (!pluginEnabled && instance.copyPaste) {
	    instance.copyPaste.destroy();
	    instance.copyPaste = null;
	  }
	}
	Handsontable.hooks.add('afterInit', init);
	Handsontable.hooks.add('afterUpdateSettings', init);
	Handsontable.hooks.register('afterCopyLimit');
	Handsontable.hooks.register('modifyCopyableRange');
	;

	//# 
	},{"3rdparty/walkontable/src/cell/coords":5,"3rdparty/walkontable/src/cell/range":6,"SheetClip":"SheetClip","copyPaste":"copyPaste","helpers/array":42,"helpers/dom/element":45,"helpers/dom/event":46,"helpers/function":47,"helpers/number":49,"helpers/unicode":53,"plugins":57}],74:[function(require,module,exports){
	"use strict";
	var $___46__46__47__46__46__47_plugins__,
	    $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_range__,
	    $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_selection__;
	var registerPlugin = ($___46__46__47__46__46__47_plugins__ = require("plugins"), $___46__46__47__46__46__47_plugins__ && $___46__46__47__46__46__47_plugins__.__esModule && $___46__46__47__46__46__47_plugins__ || {default: $___46__46__47__46__46__47_plugins__}).registerPlugin;
	var WalkontableCellRange = ($___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_range__ = require("3rdparty/walkontable/src/cell/range"), $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_range__ && $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_range__.__esModule && $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_range__ || {default: $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_range__}).WalkontableCellRange;
	var WalkontableSelection = ($___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_selection__ = require("3rdparty/walkontable/src/selection"), $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_selection__ && $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_selection__.__esModule && $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_selection__ || {default: $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_selection__}).WalkontableSelection;
	function CustomBorders() {}
	var instance;
	var checkEnable = function(customBorders) {
	  if (typeof customBorders === 'boolean') {
	    if (customBorders === true) {
	      return true;
	    }
	  }
	  if (typeof customBorders === 'object') {
	    if (customBorders.length > 0) {
	      return true;
	    }
	  }
	  return false;
	};
	var init = function() {
	  if (checkEnable(this.getSettings().customBorders)) {
	    if (!this.customBorders) {
	      instance = this;
	      this.customBorders = new CustomBorders();
	    }
	  }
	};
	var getSettingIndex = function(className) {
	  for (var i = 0; i < instance.view.wt.selections.length; i++) {
	    if (instance.view.wt.selections[i].settings.className == className) {
	      return i;
	    }
	  }
	  return -1;
	};
	var insertBorderIntoSettings = function(border) {
	  var coordinates = {
	    row: border.row,
	    col: border.col
	  };
	  var selection = new WalkontableSelection(border, new WalkontableCellRange(coordinates, coordinates, coordinates));
	  var index = getSettingIndex(border.className);
	  if (index >= 0) {
	    instance.view.wt.selections[index] = selection;
	  } else {
	    instance.view.wt.selections.push(selection);
	  }
	};
	var prepareBorderFromCustomAdded = function(row, col, borderObj) {
	  var border = createEmptyBorders(row, col);
	  border = extendDefaultBorder(border, borderObj);
	  this.setCellMeta(row, col, 'borders', border);
	  insertBorderIntoSettings(border);
	};
	var prepareBorderFromCustomAddedRange = function(rowObj) {
	  var range = rowObj.range;
	  for (var row = range.from.row; row <= range.to.row; row++) {
	    for (var col = range.from.col; col <= range.to.col; col++) {
	      var border = createEmptyBorders(row, col);
	      var add = 0;
	      if (row == range.from.row) {
	        add++;
	        if (rowObj.hasOwnProperty('top')) {
	          border.top = rowObj.top;
	        }
	      }
	      if (row == range.to.row) {
	        add++;
	        if (rowObj.hasOwnProperty('bottom')) {
	          border.bottom = rowObj.bottom;
	        }
	      }
	      if (col == range.from.col) {
	        add++;
	        if (rowObj.hasOwnProperty('left')) {
	          border.left = rowObj.left;
	        }
	      }
	      if (col == range.to.col) {
	        add++;
	        if (rowObj.hasOwnProperty('right')) {
	          border.right = rowObj.right;
	        }
	      }
	      if (add > 0) {
	        this.setCellMeta(row, col, 'borders', border);
	        insertBorderIntoSettings(border);
	      }
	    }
	  }
	};
	var createClassName = function(row, col) {
	  return 'border_row' + row + 'col' + col;
	};
	var createDefaultCustomBorder = function() {
	  return {
	    width: 1,
	    color: '#000'
	  };
	};
	var createSingleEmptyBorder = function() {
	  return {hide: true};
	};
	var createDefaultHtBorder = function() {
	  return {
	    width: 1,
	    color: '#000',
	    cornerVisible: false
	  };
	};
	var createEmptyBorders = function(row, col) {
	  return {
	    className: createClassName(row, col),
	    border: createDefaultHtBorder(),
	    row: row,
	    col: col,
	    top: createSingleEmptyBorder(),
	    right: createSingleEmptyBorder(),
	    bottom: createSingleEmptyBorder(),
	    left: createSingleEmptyBorder()
	  };
	};
	var extendDefaultBorder = function(defaultBorder, customBorder) {
	  if (customBorder.hasOwnProperty('border')) {
	    defaultBorder.border = customBorder.border;
	  }
	  if (customBorder.hasOwnProperty('top')) {
	    defaultBorder.top = customBorder.top;
	  }
	  if (customBorder.hasOwnProperty('right')) {
	    defaultBorder.right = customBorder.right;
	  }
	  if (customBorder.hasOwnProperty('bottom')) {
	    defaultBorder.bottom = customBorder.bottom;
	  }
	  if (customBorder.hasOwnProperty('left')) {
	    defaultBorder.left = customBorder.left;
	  }
	  return defaultBorder;
	};
	var removeBordersFromDom = function(borderClassName) {
	  var borders = document.querySelectorAll('.' + borderClassName);
	  for (var i = 0; i < borders.length; i++) {
	    if (borders[i]) {
	      if (borders[i].nodeName != 'TD') {
	        var parent = borders[i].parentNode;
	        if (parent.parentNode) {
	          parent.parentNode.removeChild(parent);
	        }
	      }
	    }
	  }
	};
	var removeAllBorders = function(row, col) {
	  var borderClassName = createClassName(row, col);
	  removeBordersFromDom(borderClassName);
	  this.removeCellMeta(row, col, 'borders');
	};
	var setBorder = function(row, col, place, remove) {
	  var bordersMeta = this.getCellMeta(row, col).borders;
	  if (!bordersMeta || bordersMeta.border == undefined) {
	    bordersMeta = createEmptyBorders(row, col);
	  }
	  if (remove) {
	    bordersMeta[place] = createSingleEmptyBorder();
	  } else {
	    bordersMeta[place] = createDefaultCustomBorder();
	  }
	  this.setCellMeta(row, col, 'borders', bordersMeta);
	  var borderClassName = createClassName(row, col);
	  removeBordersFromDom(borderClassName);
	  insertBorderIntoSettings(bordersMeta);
	  this.render();
	};
	var prepareBorder = function(range, place, remove) {
	  if (range.from.row == range.to.row && range.from.col == range.to.col) {
	    if (place == 'noBorders') {
	      removeAllBorders.call(this, range.from.row, range.from.col);
	    } else {
	      setBorder.call(this, range.from.row, range.from.col, place, remove);
	    }
	  } else {
	    switch (place) {
	      case 'noBorders':
	        for (var column = range.from.col; column <= range.to.col; column++) {
	          for (var row = range.from.row; row <= range.to.row; row++) {
	            removeAllBorders.call(this, row, column);
	          }
	        }
	        break;
	      case 'top':
	        for (var topCol = range.from.col; topCol <= range.to.col; topCol++) {
	          setBorder.call(this, range.from.row, topCol, place, remove);
	        }
	        break;
	      case 'right':
	        for (var rowRight = range.from.row; rowRight <= range.to.row; rowRight++) {
	          setBorder.call(this, rowRight, range.to.col, place);
	        }
	        break;
	      case 'bottom':
	        for (var bottomCol = range.from.col; bottomCol <= range.to.col; bottomCol++) {
	          setBorder.call(this, range.to.row, bottomCol, place);
	        }
	        break;
	      case 'left':
	        for (var rowLeft = range.from.row; rowLeft <= range.to.row; rowLeft++) {
	          setBorder.call(this, rowLeft, range.from.col, place);
	        }
	        break;
	    }
	  }
	};
	var checkSelectionBorders = function(hot, direction) {
	  var atLeastOneHasBorder = false;
	  hot.getSelectedRange().forAll(function(r, c) {
	    var metaBorders = hot.getCellMeta(r, c).borders;
	    if (metaBorders) {
	      if (direction) {
	        if (!metaBorders[direction].hasOwnProperty('hide')) {
	          atLeastOneHasBorder = true;
	          return false;
	        }
	      } else {
	        atLeastOneHasBorder = true;
	        return false;
	      }
	    }
	  });
	  return atLeastOneHasBorder;
	};
	var markSelected = function(label) {
	  return '<span class="selected">' + String.fromCharCode(10003) + '</span>' + label;
	};
	var addBordersOptionsToContextMenu = function(defaultOptions) {
	  if (!this.getSettings().customBorders) {
	    return;
	  }
	  defaultOptions.items.push(Handsontable.plugins.ContextMenu.SEPARATOR);
	  defaultOptions.items.push({
	    key: 'borders',
	    name: 'Borders',
	    submenu: {items: [{
	        key: 'borders:top',
	        name: function() {
	          var label = 'Top';
	          var hasBorder = checkSelectionBorders(this, 'top');
	          if (hasBorder) {
	            label = markSelected(label);
	          }
	          return label;
	        },
	        callback: function() {
	          var hasBorder = checkSelectionBorders(this, 'top');
	          prepareBorder.call(this, this.getSelectedRange(), 'top', hasBorder);
	        },
	        disabled: false
	      }, {
	        key: 'borders:right',
	        name: function() {
	          var label = 'Right';
	          var hasBorder = checkSelectionBorders(this, 'right');
	          if (hasBorder) {
	            label = markSelected(label);
	          }
	          return label;
	        },
	        callback: function() {
	          var hasBorder = checkSelectionBorders(this, 'right');
	          prepareBorder.call(this, this.getSelectedRange(), 'right', hasBorder);
	        },
	        disabled: false
	      }, {
	        key: 'borders:bottom',
	        name: function() {
	          var label = 'Bottom';
	          var hasBorder = checkSelectionBorders(this, 'bottom');
	          if (hasBorder) {
	            label = markSelected(label);
	          }
	          return label;
	        },
	        callback: function() {
	          var hasBorder = checkSelectionBorders(this, 'bottom');
	          prepareBorder.call(this, this.getSelectedRange(), 'bottom', hasBorder);
	        },
	        disabled: false
	      }, {
	        key: 'borders:left',
	        name: function() {
	          var label = 'Left';
	          var hasBorder = checkSelectionBorders(this, 'left');
	          if (hasBorder) {
	            label = markSelected(label);
	          }
	          return label;
	        },
	        callback: function() {
	          var hasBorder = checkSelectionBorders(this, 'left');
	          prepareBorder.call(this, this.getSelectedRange(), 'left', hasBorder);
	        },
	        disabled: false
	      }, {
	        key: 'borders:no_borders',
	        name: 'Remove border(s)',
	        callback: function() {
	          prepareBorder.call(this, this.getSelectedRange(), 'noBorders');
	        },
	        disabled: function() {
	          return !checkSelectionBorders(this);
	        }
	      }]}
	  });
	};
	Handsontable.hooks.add('beforeInit', init);
	Handsontable.hooks.add('afterContextMenuDefaultOptions', addBordersOptionsToContextMenu);
	Handsontable.hooks.add('afterInit', function() {
	  var customBorders = this.getSettings().customBorders;
	  if (customBorders) {
	    for (var i = 0; i < customBorders.length; i++) {
	      if (customBorders[i].range) {
	        prepareBorderFromCustomAddedRange.call(this, customBorders[i]);
	      } else {
	        prepareBorderFromCustomAdded.call(this, customBorders[i].row, customBorders[i].col, customBorders[i]);
	      }
	    }
	    this.render();
	    this.view.wt.draw(true);
	  }
	});
	Handsontable.CustomBorders = CustomBorders;

	//# 
	},{"3rdparty/walkontable/src/cell/range":6,"3rdparty/walkontable/src/selection":18,"plugins":57}],75:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  DragToScroll: {get: function() {
	      return DragToScroll;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__46__46__47_eventManager__,
	    $___46__46__47__46__46__47_plugins__;
	var eventManagerObject = ($___46__46__47__46__46__47_eventManager__ = require("eventManager"), $___46__46__47__46__46__47_eventManager__ && $___46__46__47__46__46__47_eventManager__.__esModule && $___46__46__47__46__46__47_eventManager__ || {default: $___46__46__47__46__46__47_eventManager__}).eventManager;
	var registerPlugin = ($___46__46__47__46__46__47_plugins__ = require("plugins"), $___46__46__47__46__46__47_plugins__ && $___46__46__47__46__46__47_plugins__.__esModule && $___46__46__47__46__46__47_plugins__ || {default: $___46__46__47__46__46__47_plugins__}).registerPlugin;
	;
	Handsontable.plugins.DragToScroll = DragToScroll;
	function DragToScroll() {
	  this.boundaries = null;
	  this.callback = null;
	}
	DragToScroll.prototype.setBoundaries = function(boundaries) {
	  this.boundaries = boundaries;
	};
	DragToScroll.prototype.setCallback = function(callback) {
	  this.callback = callback;
	};
	DragToScroll.prototype.check = function(x, y) {
	  var diffX = 0;
	  var diffY = 0;
	  if (y < this.boundaries.top) {
	    diffY = y - this.boundaries.top;
	  } else if (y > this.boundaries.bottom) {
	    diffY = y - this.boundaries.bottom;
	  }
	  if (x < this.boundaries.left) {
	    diffX = x - this.boundaries.left;
	  } else if (x > this.boundaries.right) {
	    diffX = x - this.boundaries.right;
	  }
	  this.callback(diffX, diffY);
	};
	var dragToScroll;
	var instance;
	var setupListening = function(instance) {
	  instance.dragToScrollListening = false;
	  var scrollHandler = instance.view.wt.wtTable.holder;
	  dragToScroll = new DragToScroll();
	  if (scrollHandler === window) {
	    return;
	  } else {
	    dragToScroll.setBoundaries(scrollHandler.getBoundingClientRect());
	  }
	  dragToScroll.setCallback(function(scrollX, scrollY) {
	    if (scrollX < 0) {
	      scrollHandler.scrollLeft -= 50;
	    } else if (scrollX > 0) {
	      scrollHandler.scrollLeft += 50;
	    }
	    if (scrollY < 0) {
	      scrollHandler.scrollTop -= 20;
	    } else if (scrollY > 0) {
	      scrollHandler.scrollTop += 20;
	    }
	  });
	  instance.dragToScrollListening = true;
	};
	Handsontable.hooks.add('afterInit', function() {
	  var instance = this;
	  var eventManager = eventManagerObject(this);
	  eventManager.addEventListener(document, 'mouseup', function() {
	    instance.dragToScrollListening = false;
	  });
	  eventManager.addEventListener(document, 'mousemove', function(event) {
	    if (instance.dragToScrollListening) {
	      dragToScroll.check(event.clientX, event.clientY);
	    }
	  });
	});
	Handsontable.hooks.add('afterDestroy', function() {
	  eventManagerObject(this).clear();
	});
	Handsontable.hooks.add('afterOnCellMouseDown', function() {
	  setupListening(this);
	});
	Handsontable.hooks.add('afterOnCellCornerMouseDown', function() {
	  setupListening(this);
	});
	Handsontable.plugins.DragToScroll = DragToScroll;

	//# 
	},{"eventManager":41,"plugins":57}],76:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  ManualColumnFreeze: {get: function() {
	      return ManualColumnFreeze;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__95_base__,
	    $___46__46__47__46__46__47_plugins__;
	var BasePlugin = ($___46__46__47__95_base__ = require("_base"), $___46__46__47__95_base__ && $___46__46__47__95_base__.__esModule && $___46__46__47__95_base__ || {default: $___46__46__47__95_base__}).default;
	var registerPlugin = ($___46__46__47__46__46__47_plugins__ = require("plugins"), $___46__46__47__46__46__47_plugins__ && $___46__46__47__46__46__47_plugins__.__esModule && $___46__46__47__46__46__47_plugins__ || {default: $___46__46__47__46__46__47_plugins__}).registerPlugin;
	var ManualColumnFreeze = function ManualColumnFreeze(hotInstance) {
	  $traceurRuntime.superConstructor($ManualColumnFreeze).call(this, hotInstance);
	};
	var $ManualColumnFreeze = ManualColumnFreeze;
	($traceurRuntime.createClass)(ManualColumnFreeze, {
	  isEnabled: function() {
	    return !!this.hot.getSettings().manualColumnFreeze;
	  },
	  enablePlugin: function() {
	    var $__2 = this;
	    if (this.enabled) {
	      return;
	    }
	    this.addHook('modifyCol', (function(col) {
	      return $__2.onModifyCol(col);
	    }));
	    this.addHook('afterContextMenuDefaultOptions', (function(defaultOptions) {
	      return $__2.addContextMenuEntry(defaultOptions);
	    }));
	    $traceurRuntime.superGet(this, $ManualColumnFreeze.prototype, "enablePlugin").call(this);
	  },
	  disablePlugin: function() {
	    $traceurRuntime.superGet(this, $ManualColumnFreeze.prototype, "disablePlugin").call(this);
	  },
	  init: function() {
	    $traceurRuntime.superGet(this, $ManualColumnFreeze.prototype, "init").call(this);
	    if (typeof this.hot.manualColumnPositionsPluginUsages === 'undefined') {
	      this.hot.manualColumnPositionsPluginUsages = ['manualColumnFreeze'];
	    } else {
	      this.hot.manualColumnPositionsPluginUsages.push('manualColumnFreeze');
	    }
	    this.fixedColumnsCount = this.hot.getSettings().fixedColumnsLeft;
	  },
	  onModifyCol: function(column) {
	    if (this.hot.manualColumnPositionsPluginUsages.length > 1) {
	      return column;
	    }
	    return this.getModifiedColumnIndex(column);
	  },
	  getModifiedColumnIndex: function(column) {
	    return this.hot.manualColumnPositions[column];
	  },
	  addContextMenuEntry: function(defaultOptions) {
	    var _this = this;
	    defaultOptions.items.push(Handsontable.plugins.ContextMenu.SEPARATOR, {
	      key: 'freeze_column',
	      name: function() {
	        var selectedColumn = _this.hot.getSelected()[1];
	        if (selectedColumn > _this.fixedColumnsCount - 1) {
	          return 'Freeze this column';
	        } else {
	          return 'Unfreeze this column';
	        }
	      },
	      disabled: function() {
	        var selection = _this.hot.getSelected();
	        return selection[1] !== selection[3];
	      },
	      callback: function() {
	        var selectedColumn = _this.hot.getSelected()[1];
	        if (selectedColumn > _this.fixedColumnsCount - 1) {
	          _this.freezeColumn(selectedColumn);
	        } else {
	          _this.unfreezeColumn(selectedColumn);
	        }
	      }
	    });
	  },
	  freezeColumn: function(column) {
	    if (column <= this.fixedColumnsCount - 1) {
	      return;
	    }
	    var modifiedColumn = this.getModifiedColumnIndex(column) || column;
	    this.checkPositionData(modifiedColumn);
	    this.modifyColumnOrder(modifiedColumn, column, null, 'freeze');
	    this.addFixedColumn();
	    this.hot.view.wt.wtOverlays.leftOverlay.refresh();
	    this.hot.view.wt.wtOverlays.adjustElementsSize();
	  },
	  unfreezeColumn: function(column) {
	    if (column > this.fixedColumnsCount - 1) {
	      return;
	    }
	    var returnCol = this.getBestColumnReturnPosition(column);
	    var modifiedColumn = this.getModifiedColumnIndex(column) || column;
	    this.checkPositionData(modifiedColumn);
	    this.modifyColumnOrder(modifiedColumn, column, returnCol, 'unfreeze');
	    this.removeFixedColumn();
	    this.hot.view.wt.wtOverlays.leftOverlay.refresh();
	    this.hot.view.wt.wtOverlays.adjustElementsSize();
	  },
	  addFixedColumn: function() {
	    this.hot.updateSettings({fixedColumnsLeft: this.fixedColumnsCount + 1});
	    this.fixedColumnsCount++;
	  },
	  removeFixedColumn: function() {
	    this.hot.updateSettings({fixedColumnsLeft: this.fixedColumnsCount - 1});
	    this.fixedColumnsCount--;
	  },
	  checkPositionData: function(column) {
	    if (!this.hot.manualColumnPositions || this.hot.manualColumnPositions.length === 0) {
	      if (!this.hot.manualColumnPositions) {
	        this.hot.manualColumnPositions = [];
	      }
	    }
	    if (column) {
	      if (!this.hot.manualColumnPositions[column]) {
	        this.createPositionData(column + 1);
	      }
	    } else {
	      this.createPositionData(this.hot.countCols());
	    }
	  },
	  createPositionData: function(length) {
	    if (this.hot.manualColumnPositions.length < length) {
	      for (var i = this.hot.manualColumnPositions.length; i < length; i++) {
	        this.hot.manualColumnPositions[i] = i;
	      }
	    }
	  },
	  modifyColumnOrder: function(column, actualColumn, returnColumn, action) {
	    if (returnColumn == null) {
	      returnColumn = column;
	    }
	    if (action === 'freeze') {
	      this.hot.manualColumnPositions.splice(this.fixedColumnsCount, 0, this.hot.manualColumnPositions.splice(actualColumn, 1)[0]);
	    } else if (action === 'unfreeze') {
	      this.hot.manualColumnPositions.splice(returnColumn, 0, this.hot.manualColumnPositions.splice(actualColumn, 1)[0]);
	    }
	  },
	  getBestColumnReturnPosition: function(column) {
	    var i = this.fixedColumnsCount;
	    var j = this.getModifiedColumnIndex(i);
	    var initialCol = this.getModifiedColumnIndex(column);
	    while (j < initialCol) {
	      i++;
	      j = this.getModifiedColumnIndex(i);
	    }
	    return i - 1;
	  }
	}, {}, BasePlugin);
	;
	registerPlugin('manualColumnFreeze', ManualColumnFreeze);

	//# 
	},{"_base":58,"plugins":57}],77:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  ManualColumnMove: {get: function() {
	      return ManualColumnMove;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__46__46__47_helpers_47_dom_47_element__,
	    $___46__46__47__46__46__47_eventManager__,
	    $___46__46__47__46__46__47_helpers_47_dom_47_event__,
	    $___46__46__47__46__46__47_plugins__;
	var $__0 = ($___46__46__47__46__46__47_helpers_47_dom_47_element__ = require("helpers/dom/element"), $___46__46__47__46__46__47_helpers_47_dom_47_element__ && $___46__46__47__46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47__46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47__46__46__47_helpers_47_dom_47_element__}),
	    addClass = $__0.addClass,
	    hasClass = $__0.hasClass,
	    removeClass = $__0.removeClass;
	var eventManagerObject = ($___46__46__47__46__46__47_eventManager__ = require("eventManager"), $___46__46__47__46__46__47_eventManager__ && $___46__46__47__46__46__47_eventManager__.__esModule && $___46__46__47__46__46__47_eventManager__ || {default: $___46__46__47__46__46__47_eventManager__}).eventManager;
	var $__2 = ($___46__46__47__46__46__47_helpers_47_dom_47_event__ = require("helpers/dom/event"), $___46__46__47__46__46__47_helpers_47_dom_47_event__ && $___46__46__47__46__46__47_helpers_47_dom_47_event__.__esModule && $___46__46__47__46__46__47_helpers_47_dom_47_event__ || {default: $___46__46__47__46__46__47_helpers_47_dom_47_event__}),
	    pageX = $__2.pageX,
	    pageY = $__2.pageY;
	var registerPlugin = ($___46__46__47__46__46__47_plugins__ = require("plugins"), $___46__46__47__46__46__47_plugins__ && $___46__46__47__46__46__47_plugins__.__esModule && $___46__46__47__46__46__47_plugins__ || {default: $___46__46__47__46__46__47_plugins__}).registerPlugin;
	;
	function ManualColumnMove() {
	  var startCol,
	      endCol,
	      startX,
	      startOffset,
	      currentCol,
	      instance,
	      currentTH,
	      handle = document.createElement('DIV'),
	      guide = document.createElement('DIV'),
	      eventManager = eventManagerObject(this);
	  handle.className = 'manualColumnMover';
	  guide.className = 'manualColumnMoverGuide';
	  var saveManualColumnPositions = function() {
	    var instance = this;
	    Handsontable.hooks.run(instance, 'persistentStateSave', 'manualColumnPositions', instance.manualColumnPositions);
	  };
	  var loadManualColumnPositions = function() {
	    var instance = this;
	    var storedState = {};
	    Handsontable.hooks.run(instance, 'persistentStateLoad', 'manualColumnPositions', storedState);
	    return storedState.value;
	  };
	  function setupHandlePosition(TH) {
	    instance = this;
	    currentTH = TH;
	    var col = this.view.wt.wtTable.getCoords(TH).col;
	    if (col >= 0) {
	      currentCol = col;
	      var box = currentTH.getBoundingClientRect();
	      startOffset = box.left;
	      handle.style.top = box.top + 'px';
	      handle.style.left = startOffset + 'px';
	      instance.rootElement.appendChild(handle);
	    }
	  }
	  function refreshHandlePosition(TH, delta) {
	    var box = TH.getBoundingClientRect();
	    var handleWidth = 6;
	    if (delta > 0) {
	      handle.style.left = (box.left + box.width - handleWidth) + 'px';
	    } else {
	      handle.style.left = box.left + 'px';
	    }
	  }
	  function setupGuidePosition() {
	    var instance = this;
	    addClass(handle, 'active');
	    addClass(guide, 'active');
	    var box = currentTH.getBoundingClientRect();
	    guide.style.width = box.width + 'px';
	    guide.style.height = instance.view.maximumVisibleElementHeight(0) + 'px';
	    guide.style.top = handle.style.top;
	    guide.style.left = startOffset + 'px';
	    instance.rootElement.appendChild(guide);
	  }
	  function refreshGuidePosition(diff) {
	    guide.style.left = startOffset + diff + 'px';
	  }
	  function hideHandleAndGuide() {
	    removeClass(handle, 'active');
	    removeClass(guide, 'active');
	  }
	  var checkColumnHeader = function(element) {
	    if (element.tagName != 'BODY') {
	      if (element.parentNode.tagName == 'THEAD') {
	        return true;
	      } else {
	        element = element.parentNode;
	        return checkColumnHeader(element);
	      }
	    }
	    return false;
	  };
	  var getTHFromTargetElement = function(element) {
	    if (element.tagName != 'TABLE') {
	      if (element.tagName == 'TH') {
	        return element;
	      } else {
	        return getTHFromTargetElement(element.parentNode);
	      }
	    }
	    return null;
	  };
	  var bindEvents = function() {
	    var instance = this;
	    var pressed;
	    eventManager.addEventListener(instance.rootElement, 'mouseover', function(e) {
	      if (checkColumnHeader(e.target)) {
	        var th = getTHFromTargetElement(e.target);
	        if (th) {
	          if (pressed) {
	            var col = instance.view.wt.wtTable.getCoords(th).col;
	            if (col >= 0) {
	              endCol = col;
	              refreshHandlePosition(e.target, endCol - startCol);
	            }
	          } else {
	            setupHandlePosition.call(instance, th);
	          }
	        }
	      }
	    });
	    eventManager.addEventListener(instance.rootElement, 'mousedown', function(e) {
	      if (hasClass(e.target, 'manualColumnMover')) {
	        startX = pageX(e);
	        setupGuidePosition.call(instance);
	        pressed = instance;
	        startCol = currentCol;
	        endCol = currentCol;
	      }
	    });
	    eventManager.addEventListener(window, 'mousemove', function(e) {
	      if (pressed) {
	        refreshGuidePosition(pageX(e) - startX);
	      }
	    });
	    eventManager.addEventListener(window, 'mouseup', function(e) {
	      if (pressed) {
	        hideHandleAndGuide();
	        pressed = false;
	        createPositionData(instance.manualColumnPositions, instance.countCols());
	        instance.manualColumnPositions.splice(endCol, 0, instance.manualColumnPositions.splice(startCol, 1)[0]);
	        Handsontable.hooks.run(instance, 'beforeColumnMove', startCol, endCol);
	        instance.forceFullRender = true;
	        instance.view.render();
	        saveManualColumnPositions.call(instance);
	        Handsontable.hooks.run(instance, 'afterColumnMove', startCol, endCol);
	        setupHandlePosition.call(instance, currentTH);
	      }
	    });
	    instance.addHook('afterDestroy', unbindEvents);
	  };
	  var unbindEvents = function() {
	    eventManager.clear();
	  };
	  var createPositionData = function(positionArr, len) {
	    if (positionArr.length < len) {
	      for (var i = positionArr.length; i < len; i++) {
	        positionArr[i] = i;
	      }
	    }
	  };
	  this.beforeInit = function() {
	    this.manualColumnPositions = [];
	  };
	  this.init = function(source) {
	    var instance = this;
	    var manualColMoveEnabled = !!(this.getSettings().manualColumnMove);
	    if (manualColMoveEnabled) {
	      var initialManualColumnPositions = this.getSettings().manualColumnMove;
	      var loadedManualColumnPositions = loadManualColumnPositions.call(instance);
	      if (typeof loadedManualColumnPositions != 'undefined') {
	        this.manualColumnPositions = loadedManualColumnPositions;
	      } else if (Array.isArray(initialManualColumnPositions)) {
	        this.manualColumnPositions = initialManualColumnPositions;
	      } else {
	        this.manualColumnPositions = [];
	      }
	      if (source === 'afterInit' || source === 'afterUpdateSettings' && eventManager.context.eventListeners.length === 0) {
	        if (typeof instance.manualColumnPositionsPluginUsages === 'undefined') {
	          instance.manualColumnPositionsPluginUsages = ['manualColumnMove'];
	        } else {
	          instance.manualColumnPositionsPluginUsages.push('manualColumnMove');
	        }
	        bindEvents.call(this);
	        if (this.manualColumnPositions.length > 0) {
	          this.forceFullRender = true;
	          this.render();
	        }
	      }
	    } else {
	      var pluginUsagesIndex = instance.manualColumnPositionsPluginUsages ? instance.manualColumnPositionsPluginUsages.indexOf('manualColumnMove') : -1;
	      if (pluginUsagesIndex > -1) {
	        unbindEvents.call(this);
	        this.manualColumnPositions = [];
	        instance.manualColumnPositionsPluginUsages[pluginUsagesIndex] = void 0;
	      }
	    }
	  };
	  this.modifyCol = function(col) {
	    if (this.getSettings().manualColumnMove) {
	      if (typeof this.manualColumnPositions[col] === 'undefined') {
	        createPositionData(this.manualColumnPositions, col + 1);
	      }
	      return this.manualColumnPositions[col];
	    }
	    return col;
	  };
	  this.afterRemoveCol = function(index, amount) {
	    if (!this.getSettings().manualColumnMove) {
	      return;
	    }
	    var rmindx,
	        colpos = this.manualColumnPositions;
	    rmindx = colpos.splice(index, amount);
	    colpos = colpos.map(function(colpos) {
	      var i,
	          newpos = colpos;
	      for (i = 0; i < rmindx.length; i++) {
	        if (colpos > rmindx[i]) {
	          newpos--;
	        }
	      }
	      return newpos;
	    });
	    this.manualColumnPositions = colpos;
	  };
	  this.afterCreateCol = function(index, amount) {
	    if (!this.getSettings().manualColumnMove) {
	      return;
	    }
	    var colpos = this.manualColumnPositions;
	    if (!colpos.length) {
	      return;
	    }
	    var addindx = [];
	    for (var i = 0; i < amount; i++) {
	      addindx.push(index + i);
	    }
	    if (index >= colpos.length) {
	      colpos.concat(addindx);
	    } else {
	      colpos = colpos.map(function(colpos) {
	        return (colpos >= index) ? (colpos + amount) : colpos;
	      });
	      colpos.splice.apply(colpos, [index, 0].concat(addindx));
	    }
	    this.manualColumnPositions = colpos;
	  };
	}
	var htManualColumnMove = new ManualColumnMove();
	Handsontable.hooks.add('beforeInit', htManualColumnMove.beforeInit);
	Handsontable.hooks.add('afterInit', function() {
	  htManualColumnMove.init.call(this, 'afterInit');
	});
	Handsontable.hooks.add('afterUpdateSettings', function() {
	  htManualColumnMove.init.call(this, 'afterUpdateSettings');
	});
	Handsontable.hooks.add('modifyCol', htManualColumnMove.modifyCol);
	Handsontable.hooks.add('afterRemoveCol', htManualColumnMove.afterRemoveCol);
	Handsontable.hooks.add('afterCreateCol', htManualColumnMove.afterCreateCol);
	Handsontable.hooks.register('beforeColumnMove');
	Handsontable.hooks.register('afterColumnMove');

	//# 
	},{"eventManager":41,"helpers/dom/element":45,"helpers/dom/event":46,"plugins":57}],78:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  ManualColumnResize: {get: function() {
	      return ManualColumnResize;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__95_base_46_js__,
	    $___46__46__47__46__46__47_helpers_47_dom_47_element__,
	    $___46__46__47__46__46__47_eventManager__,
	    $___46__46__47__46__46__47_helpers_47_dom_47_event__,
	    $___46__46__47__46__46__47_plugins__;
	var BasePlugin = ($___46__46__47__95_base_46_js__ = require("_base.js"), $___46__46__47__95_base_46_js__ && $___46__46__47__95_base_46_js__.__esModule && $___46__46__47__95_base_46_js__ || {default: $___46__46__47__95_base_46_js__}).default;
	var $__1 = ($___46__46__47__46__46__47_helpers_47_dom_47_element__ = require("helpers/dom/element"), $___46__46__47__46__46__47_helpers_47_dom_47_element__ && $___46__46__47__46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47__46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47__46__46__47_helpers_47_dom_47_element__}),
	    addClass = $__1.addClass,
	    hasClass = $__1.hasClass,
	    removeClass = $__1.removeClass;
	var eventManagerObject = ($___46__46__47__46__46__47_eventManager__ = require("eventManager"), $___46__46__47__46__46__47_eventManager__ && $___46__46__47__46__46__47_eventManager__.__esModule && $___46__46__47__46__46__47_eventManager__ || {default: $___46__46__47__46__46__47_eventManager__}).eventManager;
	var $__3 = ($___46__46__47__46__46__47_helpers_47_dom_47_event__ = require("helpers/dom/event"), $___46__46__47__46__46__47_helpers_47_dom_47_event__ && $___46__46__47__46__46__47_helpers_47_dom_47_event__.__esModule && $___46__46__47__46__46__47_helpers_47_dom_47_event__ || {default: $___46__46__47__46__46__47_helpers_47_dom_47_event__}),
	    pageX = $__3.pageX,
	    pageY = $__3.pageY;
	var registerPlugin = ($___46__46__47__46__46__47_plugins__ = require("plugins"), $___46__46__47__46__46__47_plugins__ && $___46__46__47__46__46__47_plugins__.__esModule && $___46__46__47__46__46__47_plugins__ || {default: $___46__46__47__46__46__47_plugins__}).registerPlugin;
	var ManualColumnResize = function ManualColumnResize(hotInstance) {
	  $traceurRuntime.superConstructor($ManualColumnResize).call(this, hotInstance);
	  this.currentTH = null;
	  this.currentCol = null;
	  this.currentWidth = null;
	  this.newSize = null;
	  this.startY = null;
	  this.startWidth = null;
	  this.startOffset = null;
	  this.handle = document.createElement('DIV');
	  this.guide = document.createElement('DIV');
	  this.eventManager = eventManagerObject(this);
	  this.pressed = null;
	  this.dblclick = 0;
	  this.autoresizeTimeout = null;
	  this.manualColumnWidths = [];
	  addClass(this.handle, 'manualColumnResizer');
	  addClass(this.guide, 'manualColumnResizerGuide');
	};
	var $ManualColumnResize = ManualColumnResize;
	($traceurRuntime.createClass)(ManualColumnResize, {
	  isEnabled: function() {
	    return this.hot.getSettings().manualColumnResize;
	  },
	  enablePlugin: function() {
	    var $__5 = this;
	    if (this.enabled) {
	      return;
	    }
	    this.manualColumnWidths = [];
	    var initialColumnWidth = this.hot.getSettings().manualColumnResize;
	    var loadedManualColumnWidths = this.loadManualColumnWidths();
	    this.addHook('modifyColWidth', (function(width, col) {
	      return $__5.onModifyColWidth(width, col);
	    }));
	    if (typeof loadedManualColumnWidths != 'undefined') {
	      this.manualColumnWidths = loadedManualColumnWidths;
	    } else if (Array.isArray(initialColumnWidth)) {
	      this.manualColumnWidths = initialColumnWidth;
	    } else {
	      this.manualColumnWidths = [];
	    }
	    Handsontable.hooks.register('beforeColumnResize');
	    Handsontable.hooks.register('afterColumnResize');
	    this.bindEvents();
	    $traceurRuntime.superGet(this, $ManualColumnResize.prototype, "enablePlugin").call(this);
	  },
	  updatePlugin: function() {
	    var initialColumnWidth = this.hot.getSettings().manualColumnResize;
	    if (Array.isArray(initialColumnWidth)) {
	      this.manualColumnWidths = initialColumnWidth;
	    } else {
	      this.manualColumnWidths = [];
	    }
	  },
	  disablePlugin: function() {
	    $traceurRuntime.superGet(this, $ManualColumnResize.prototype, "disablePlugin").call(this);
	  },
	  saveManualColumnWidths: function() {
	    this.hot.runHooks('persistentStateSave', 'manualColumnWidths', this.manualColumnWidths);
	  },
	  loadManualColumnWidths: function() {
	    var storedState = {};
	    this.hot.runHooks('persistentStateLoad', 'manualColumnWidths', storedState);
	    return storedState.value;
	  },
	  setupHandlePosition: function(TH) {
	    this.currentTH = TH;
	    var col = this.hot.view.wt.wtTable.getCoords(TH).col;
	    if (col >= 0) {
	      var box = this.currentTH.getBoundingClientRect();
	      this.currentCol = col;
	      this.startOffset = box.left - 6;
	      this.startWidth = parseInt(box.width, 10);
	      this.handle.style.top = box.top + 'px';
	      this.handle.style.left = this.startOffset + this.startWidth + 'px';
	      this.hot.rootElement.appendChild(this.handle);
	    }
	  },
	  refreshHandlePosition: function() {
	    this.handle.style.left = this.startOffset + this.currentWidth + 'px';
	  },
	  setupGuidePosition: function() {
	    addClass(this.handle, 'active');
	    addClass(this.guide, 'active');
	    this.guide.style.top = this.handle.style.top;
	    this.guide.style.left = this.handle.style.left;
	    this.guide.style.height = this.hot.view.maximumVisibleElementHeight(0) + 'px';
	    this.hot.rootElement.appendChild(this.guide);
	  },
	  refreshGuidePosition: function() {
	    this.guide.style.left = this.handle.style.left;
	  },
	  hideHandleAndGuide: function() {
	    removeClass(this.handle, 'active');
	    removeClass(this.guide, 'active');
	  },
	  checkIfColumnHeader: function(element) {
	    if (element.tagName != 'BODY') {
	      if (element.parentNode.tagName == 'THEAD') {
	        return true;
	      } else {
	        element = element.parentNode;
	        return this.checkIfColumnHeader(element);
	      }
	    }
	    return false;
	  },
	  getTHFromTargetElement: function(element) {
	    if (element.tagName != 'TABLE') {
	      if (element.tagName == 'TH') {
	        return element;
	      } else {
	        return this.getTHFromTargetElement(element.parentNode);
	      }
	    }
	    return null;
	  },
	  onMouseOver: function(event) {
	    if (this.checkIfColumnHeader(event.target)) {
	      var th = this.getTHFromTargetElement(event.target);
	      if (!th) {
	        return;
	      }
	      var colspan = th.getAttribute('colspan');
	      if (th && (colspan === null || colspan === 1)) {
	        if (!this.pressed) {
	          this.setupHandlePosition(th);
	        }
	      }
	    }
	  },
	  afterMouseDownTimeout: function() {
	    if (this.dblclick >= 2) {
	      var hookNewSize = this.hot.runHooks('beforeColumnResize', this.currentCol, this.newSize, true);
	      if (hookNewSize !== void 0) {
	        this.newSize = hookNewSize;
	      }
	      this.setManualSize(this.currentCol, this.newSize);
	      this.hot.forceFullRender = true;
	      this.hot.view.render();
	      this.hot.view.wt.wtOverlays.adjustElementsSize(true);
	      this.hot.runHooks('afterColumnResize', this.currentCol, this.newSize, true);
	    }
	    this.dblclick = 0;
	    this.autoresizeTimeout = null;
	  },
	  onMouseDown: function(event) {
	    var $__5 = this;
	    if (hasClass(event.target, 'manualColumnResizer')) {
	      this.setupGuidePosition();
	      this.pressed = this.hot;
	      if (this.autoresizeTimeout === null) {
	        this.autoresizeTimeout = setTimeout((function() {
	          return $__5.afterMouseDownTimeout();
	        }), 500);
	        this.hot._registerTimeout(this.autoresizeTimeout);
	      }
	      this.dblclick++;
	      this.startX = pageX(event);
	      this.newSize = this.startWidth;
	    }
	  },
	  onMouseMove: function(event) {
	    if (this.pressed) {
	      this.currentWidth = this.startWidth + (pageX(event) - this.startX);
	      this.newSize = this.setManualSize(this.currentCol, this.currentWidth);
	      this.refreshHandlePosition();
	      this.refreshGuidePosition();
	    }
	  },
	  onMouseUp: function(event) {
	    if (this.pressed) {
	      this.hideHandleAndGuide();
	      this.pressed = false;
	      if (this.newSize != this.startWidth) {
	        this.hot.runHooks('beforeColumnResize', this.currentCol, this.newSize);
	        this.hot.forceFullRender = true;
	        this.hot.view.render();
	        this.hot.view.wt.wtOverlays.adjustElementsSize(true);
	        this.saveManualColumnWidths();
	        this.hot.runHooks('afterColumnResize', this.currentCol, this.newSize);
	      }
	      this.setupHandlePosition(this.currentTH);
	    }
	  },
	  bindEvents: function() {
	    var $__5 = this;
	    this.eventManager.addEventListener(this.hot.rootElement, 'mouseover', (function(e) {
	      return $__5.onMouseOver(e);
	    }));
	    this.eventManager.addEventListener(this.hot.rootElement, 'mousedown', (function(e) {
	      return $__5.onMouseDown(e);
	    }));
	    this.eventManager.addEventListener(window, 'mousemove', (function(e) {
	      return $__5.onMouseMove(e);
	    }));
	    this.eventManager.addEventListener(window, 'mouseup', (function(e) {
	      return $__5.onMouseUp(e);
	    }));
	  },
	  setManualSize: function(column, width) {
	    width = Math.max(width, 20);
	    column = this.hot.runHooks('modifyCol', column);
	    this.manualColumnWidths[column] = width;
	    return width;
	  },
	  onModifyColWidth: function(width, column) {
	    if (this.enabled) {
	      column = this.hot.runHooks('modifyCol', column);
	      if (this.hot.getSettings().manualColumnResize && this.manualColumnWidths[column]) {
	        return this.manualColumnWidths[column];
	      }
	    }
	    return width;
	  }
	}, {}, BasePlugin);
	;
	registerPlugin('manualColumnResize', ManualColumnResize);

	//# 
	},{"_base.js":58,"eventManager":41,"helpers/dom/element":45,"helpers/dom/event":46,"plugins":57}],79:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  ManualRowMove: {get: function() {
	      return ManualRowMove;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__46__46__47_helpers_47_dom_47_element__,
	    $___46__46__47__46__46__47_eventManager__,
	    $___46__46__47__46__46__47_helpers_47_dom_47_event__,
	    $___46__46__47__46__46__47_plugins__;
	var $__0 = ($___46__46__47__46__46__47_helpers_47_dom_47_element__ = require("helpers/dom/element"), $___46__46__47__46__46__47_helpers_47_dom_47_element__ && $___46__46__47__46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47__46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47__46__46__47_helpers_47_dom_47_element__}),
	    addClass = $__0.addClass,
	    hasClass = $__0.hasClass,
	    removeClass = $__0.removeClass;
	var eventManagerObject = ($___46__46__47__46__46__47_eventManager__ = require("eventManager"), $___46__46__47__46__46__47_eventManager__ && $___46__46__47__46__46__47_eventManager__.__esModule && $___46__46__47__46__46__47_eventManager__ || {default: $___46__46__47__46__46__47_eventManager__}).eventManager;
	var $__2 = ($___46__46__47__46__46__47_helpers_47_dom_47_event__ = require("helpers/dom/event"), $___46__46__47__46__46__47_helpers_47_dom_47_event__ && $___46__46__47__46__46__47_helpers_47_dom_47_event__.__esModule && $___46__46__47__46__46__47_helpers_47_dom_47_event__ || {default: $___46__46__47__46__46__47_helpers_47_dom_47_event__}),
	    pageX = $__2.pageX,
	    pageY = $__2.pageY;
	var registerPlugin = ($___46__46__47__46__46__47_plugins__ = require("plugins"), $___46__46__47__46__46__47_plugins__ && $___46__46__47__46__46__47_plugins__.__esModule && $___46__46__47__46__46__47_plugins__ || {default: $___46__46__47__46__46__47_plugins__}).registerPlugin;
	;
	function ManualRowMove() {
	  var startRow,
	      endRow,
	      startY,
	      startOffset,
	      currentRow,
	      currentTH,
	      handle = document.createElement('DIV'),
	      guide = document.createElement('DIV'),
	      eventManager = eventManagerObject(this);
	  handle.className = 'manualRowMover';
	  guide.className = 'manualRowMoverGuide';
	  var saveManualRowPositions = function() {
	    var instance = this;
	    Handsontable.hooks.run(instance, 'persistentStateSave', 'manualRowPositions', instance.manualRowPositions);
	  };
	  var loadManualRowPositions = function() {
	    var instance = this,
	        storedState = {};
	    Handsontable.hooks.run(instance, 'persistentStateLoad', 'manualRowPositions', storedState);
	    return storedState.value;
	  };
	  function setupHandlePosition(TH) {
	    var instance = this;
	    currentTH = TH;
	    var row = this.view.wt.wtTable.getCoords(TH).row;
	    if (row >= 0) {
	      currentRow = row;
	      var box = currentTH.getBoundingClientRect();
	      startOffset = box.top;
	      handle.style.top = startOffset + 'px';
	      handle.style.left = box.left + 'px';
	      instance.rootElement.appendChild(handle);
	    }
	  }
	  function refreshHandlePosition(TH, delta) {
	    var box = TH.getBoundingClientRect();
	    var handleHeight = 6;
	    if (delta > 0) {
	      handle.style.top = (box.top + box.height - handleHeight) + 'px';
	    } else {
	      handle.style.top = box.top + 'px';
	    }
	  }
	  function setupGuidePosition() {
	    var instance = this;
	    addClass(handle, 'active');
	    addClass(guide, 'active');
	    var box = currentTH.getBoundingClientRect();
	    guide.style.width = instance.view.maximumVisibleElementWidth(0) + 'px';
	    guide.style.height = box.height + 'px';
	    guide.style.top = startOffset + 'px';
	    guide.style.left = handle.style.left;
	    instance.rootElement.appendChild(guide);
	  }
	  function refreshGuidePosition(diff) {
	    guide.style.top = startOffset + diff + 'px';
	  }
	  function hideHandleAndGuide() {
	    removeClass(handle, 'active');
	    removeClass(guide, 'active');
	  }
	  var checkRowHeader = function(element) {
	    if (element.tagName != 'BODY') {
	      if (element.parentNode.tagName == 'TBODY') {
	        return true;
	      } else {
	        element = element.parentNode;
	        return checkRowHeader(element);
	      }
	    }
	    return false;
	  };
	  var getTHFromTargetElement = function(element) {
	    if (element.tagName != 'TABLE') {
	      if (element.tagName == 'TH') {
	        return element;
	      } else {
	        return getTHFromTargetElement(element.parentNode);
	      }
	    }
	    return null;
	  };
	  var bindEvents = function() {
	    var instance = this;
	    var pressed;
	    eventManager.addEventListener(instance.rootElement, 'mouseover', function(e) {
	      if (checkRowHeader(e.target)) {
	        var th = getTHFromTargetElement(e.target);
	        if (th) {
	          if (pressed) {
	            endRow = instance.view.wt.wtTable.getCoords(th).row;
	            refreshHandlePosition(th, endRow - startRow);
	          } else {
	            setupHandlePosition.call(instance, th);
	          }
	        }
	      }
	    });
	    eventManager.addEventListener(instance.rootElement, 'mousedown', function(e) {
	      if (hasClass(e.target, 'manualRowMover')) {
	        startY = pageY(e);
	        setupGuidePosition.call(instance);
	        pressed = instance;
	        startRow = currentRow;
	        endRow = currentRow;
	      }
	    });
	    eventManager.addEventListener(window, 'mousemove', function(e) {
	      if (pressed) {
	        refreshGuidePosition(pageY(e) - startY);
	      }
	    });
	    eventManager.addEventListener(window, 'mouseup', function(e) {
	      if (pressed) {
	        hideHandleAndGuide();
	        pressed = false;
	        createPositionData(instance.manualRowPositions, instance.countRows());
	        instance.manualRowPositions.splice(endRow, 0, instance.manualRowPositions.splice(startRow, 1)[0]);
	        Handsontable.hooks.run(instance, 'beforeRowMove', startRow, endRow);
	        instance.forceFullRender = true;
	        instance.view.render();
	        saveManualRowPositions.call(instance);
	        Handsontable.hooks.run(instance, 'afterRowMove', startRow, endRow);
	        setupHandlePosition.call(instance, currentTH);
	      }
	    });
	    instance.addHook('afterDestroy', unbindEvents);
	  };
	  var unbindEvents = function() {
	    eventManager.clear();
	  };
	  var createPositionData = function(positionArr, len) {
	    if (positionArr.length < len) {
	      for (var i = positionArr.length; i < len; i++) {
	        positionArr[i] = i;
	      }
	    }
	  };
	  this.beforeInit = function() {
	    this.manualRowPositions = [];
	  };
	  this.init = function(source) {
	    var instance = this;
	    var manualRowMoveEnabled = !!(instance.getSettings().manualRowMove);
	    if (manualRowMoveEnabled) {
	      var initialManualRowPositions = instance.getSettings().manualRowMove;
	      var loadedManualRowPostions = loadManualRowPositions.call(instance);
	      if (typeof instance.manualRowPositionsPluginUsages === 'undefined') {
	        instance.manualRowPositionsPluginUsages = ['manualColumnMove'];
	      } else {
	        instance.manualRowPositionsPluginUsages.push('manualColumnMove');
	      }
	      if (typeof loadedManualRowPostions != 'undefined') {
	        this.manualRowPositions = loadedManualRowPostions;
	      } else if (Array.isArray(initialManualRowPositions)) {
	        this.manualRowPositions = initialManualRowPositions;
	      } else {
	        this.manualRowPositions = [];
	      }
	      if (source === 'afterInit' || source === 'afterUpdateSettings' && eventManager.context.eventListeners.length === 0) {
	        bindEvents.call(this);
	        if (this.manualRowPositions.length > 0) {
	          instance.forceFullRender = true;
	          instance.render();
	        }
	      }
	    } else {
	      var pluginUsagesIndex = instance.manualRowPositionsPluginUsages ? instance.manualRowPositionsPluginUsages.indexOf('manualColumnMove') : -1;
	      if (pluginUsagesIndex > -1) {
	        unbindEvents.call(this);
	        instance.manualRowPositions = [];
	        instance.manualRowPositionsPluginUsages[pluginUsagesIndex] = void 0;
	      }
	    }
	  };
	  this.modifyRow = function(row) {
	    var instance = this;
	    if (instance.getSettings().manualRowMove) {
	      if (typeof instance.manualRowPositions[row] === 'undefined') {
	        createPositionData(this.manualRowPositions, row + 1);
	      }
	      return instance.manualRowPositions[row];
	    }
	    return row;
	  };
	}
	var htManualRowMove = new ManualRowMove();
	Handsontable.hooks.add('beforeInit', htManualRowMove.beforeInit);
	Handsontable.hooks.add('afterInit', function() {
	  htManualRowMove.init.call(this, 'afterInit');
	});
	Handsontable.hooks.add('afterUpdateSettings', function() {
	  htManualRowMove.init.call(this, 'afterUpdateSettings');
	});
	Handsontable.hooks.add('modifyRow', htManualRowMove.modifyRow);
	Handsontable.hooks.register('beforeRowMove');
	Handsontable.hooks.register('afterRowMove');

	//# 
	},{"eventManager":41,"helpers/dom/element":45,"helpers/dom/event":46,"plugins":57}],80:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  ManualRowResize: {get: function() {
	      return ManualRowResize;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__95_base_46_js__,
	    $___46__46__47__46__46__47_helpers_47_dom_47_element__,
	    $___46__46__47__46__46__47_eventManager__,
	    $___46__46__47__46__46__47_helpers_47_dom_47_event__,
	    $___46__46__47__46__46__47_plugins__;
	var BasePlugin = ($___46__46__47__95_base_46_js__ = require("_base.js"), $___46__46__47__95_base_46_js__ && $___46__46__47__95_base_46_js__.__esModule && $___46__46__47__95_base_46_js__ || {default: $___46__46__47__95_base_46_js__}).default;
	var $__1 = ($___46__46__47__46__46__47_helpers_47_dom_47_element__ = require("helpers/dom/element"), $___46__46__47__46__46__47_helpers_47_dom_47_element__ && $___46__46__47__46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47__46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47__46__46__47_helpers_47_dom_47_element__}),
	    addClass = $__1.addClass,
	    hasClass = $__1.hasClass,
	    removeClass = $__1.removeClass;
	var eventManagerObject = ($___46__46__47__46__46__47_eventManager__ = require("eventManager"), $___46__46__47__46__46__47_eventManager__ && $___46__46__47__46__46__47_eventManager__.__esModule && $___46__46__47__46__46__47_eventManager__ || {default: $___46__46__47__46__46__47_eventManager__}).eventManager;
	var $__3 = ($___46__46__47__46__46__47_helpers_47_dom_47_event__ = require("helpers/dom/event"), $___46__46__47__46__46__47_helpers_47_dom_47_event__ && $___46__46__47__46__46__47_helpers_47_dom_47_event__.__esModule && $___46__46__47__46__46__47_helpers_47_dom_47_event__ || {default: $___46__46__47__46__46__47_helpers_47_dom_47_event__}),
	    pageX = $__3.pageX,
	    pageY = $__3.pageY;
	var registerPlugin = ($___46__46__47__46__46__47_plugins__ = require("plugins"), $___46__46__47__46__46__47_plugins__ && $___46__46__47__46__46__47_plugins__.__esModule && $___46__46__47__46__46__47_plugins__ || {default: $___46__46__47__46__46__47_plugins__}).registerPlugin;
	var ManualRowResize = function ManualRowResize(hotInstance) {
	  $traceurRuntime.superConstructor($ManualRowResize).call(this, hotInstance);
	  this.currentTH = null;
	  this.currentRow = null;
	  this.currentHeight = null;
	  this.newSize = null;
	  this.startY = null;
	  this.startHeight = null;
	  this.startOffset = null;
	  this.handle = document.createElement('DIV');
	  this.guide = document.createElement('DIV');
	  this.eventManager = eventManagerObject(this);
	  this.pressed = null;
	  this.dblclick = 0;
	  this.autoresizeTimeout = null;
	  this.manualRowHeights = [];
	  addClass(this.handle, 'manualRowResizer');
	  addClass(this.guide, 'manualRowResizerGuide');
	};
	var $ManualRowResize = ManualRowResize;
	($traceurRuntime.createClass)(ManualRowResize, {
	  isEnabled: function() {
	    return this.hot.getSettings().manualRowResize;
	  },
	  enablePlugin: function() {
	    var $__5 = this;
	    if (this.enabled) {
	      return;
	    }
	    this.manualRowHeights = [];
	    var initialRowHeights = this.hot.getSettings().manualRowResize;
	    var loadedManualRowHeights = this.loadManualRowHeights();
	    if (typeof loadedManualRowHeights != 'undefined') {
	      this.manualRowHeights = loadedManualRowHeights;
	    } else if (Array.isArray(initialRowHeights)) {
	      this.manualRowHeights = initialRowHeights;
	    } else {
	      this.manualRowHeights = [];
	    }
	    this.addHook('modifyRowHeight', (function(height, row) {
	      return $__5.onModifyRowHeight(height, row);
	    }));
	    Handsontable.hooks.register('beforeRowResize');
	    Handsontable.hooks.register('afterRowResize');
	    this.bindEvents();
	    $traceurRuntime.superGet(this, $ManualRowResize.prototype, "enablePlugin").call(this);
	  },
	  updatePlugin: function() {
	    var initialRowHeights = this.hot.getSettings().manualRowResize;
	    if (Array.isArray(initialRowHeights)) {
	      this.manualRowHeights = initialRowHeights;
	    } else {
	      this.manualRowHeights = [];
	    }
	  },
	  disablePlugin: function() {
	    $traceurRuntime.superGet(this, $ManualRowResize.prototype, "disablePlugin").call(this);
	  },
	  saveManualRowHeights: function() {
	    this.hot.runHooks('persistentStateSave', 'manualRowHeights', this.manualRowHeights);
	  },
	  loadManualRowHeights: function() {
	    var storedState = {};
	    this.hot.runHooks('persistentStateLoad', 'manualRowHeights', storedState);
	    return storedState.value;
	  },
	  setupHandlePosition: function(TH) {
	    this.currentTH = TH;
	    var row = this.hot.view.wt.wtTable.getCoords(TH).row;
	    if (row >= 0) {
	      var box = this.currentTH.getBoundingClientRect();
	      this.currentRow = row;
	      this.startOffset = box.top - 6;
	      this.startHeight = parseInt(box.height, 10);
	      this.handle.style.left = box.left + 'px';
	      this.handle.style.top = this.startOffset + this.startHeight + 'px';
	      this.hot.rootElement.appendChild(this.handle);
	    }
	  },
	  refreshHandlePosition: function() {
	    this.handle.style.top = this.startOffset + this.currentHeight + 'px';
	  },
	  setupGuidePosition: function() {
	    addClass(this.handle, 'active');
	    addClass(this.guide, 'active');
	    this.guide.style.top = this.handle.style.top;
	    this.guide.style.left = this.handle.style.left;
	    this.guide.style.width = this.hot.view.maximumVisibleElementWidth(0) + 'px';
	    this.hot.rootElement.appendChild(this.guide);
	  },
	  refreshGuidePosition: function() {
	    this.guide.style.top = this.handle.style.top;
	  },
	  hideHandleAndGuide: function() {
	    removeClass(this.handle, 'active');
	    removeClass(this.guide, 'active');
	  },
	  checkIfRowHeader: function(element) {
	    if (element.tagName != 'BODY') {
	      if (element.parentNode.tagName == 'TBODY') {
	        return true;
	      } else {
	        element = element.parentNode;
	        return this.checkIfRowHeader(element);
	      }
	    }
	    return false;
	  },
	  getTHFromTargetElement: function(element) {
	    if (element.tagName != 'TABLE') {
	      if (element.tagName == 'TH') {
	        return element;
	      } else {
	        return this.getTHFromTargetElement(element.parentNode);
	      }
	    }
	    return null;
	  },
	  onMouseOver: function(event) {
	    if (this.checkIfRowHeader(event.target)) {
	      var th = this.getTHFromTargetElement(event.target);
	      if (th) {
	        if (!this.pressed) {
	          this.setupHandlePosition(th);
	        }
	      }
	    }
	  },
	  afterMouseDownTimeout: function() {
	    if (this.dblclick >= 2) {
	      var hookNewSize = this.hot.runHooks('beforeRowResize', this.currentRow, this.newSize, true);
	      if (hookNewSize !== void 0) {
	        this.newSize = hookNewSize;
	      }
	      this.setManualSize(this.currentRow, this.newSize);
	      this.hot.forceFullRender = true;
	      this.hot.view.render();
	      this.hot.view.wt.wtOverlays.adjustElementsSize(true);
	      this.hot.runHooks('afterRowResize', this.currentRow, this.newSize, true);
	    }
	    this.dblclick = 0;
	    this.autoresizeTimeout = null;
	  },
	  onMouseDown: function(event) {
	    var $__5 = this;
	    if (hasClass(event.target, 'manualRowResizer')) {
	      this.setupGuidePosition();
	      this.pressed = this.hot;
	      if (this.autoresizeTimeout == null) {
	        this.autoresizeTimeout = setTimeout((function() {
	          return $__5.afterMouseDownTimeout();
	        }), 500);
	        this.hot._registerTimeout(this.autoresizeTimeout);
	      }
	      this.dblclick++;
	      this.startY = pageY(event);
	      this.newSize = this.startHeight;
	    }
	  },
	  onMouseMove: function(event) {
	    if (this.pressed) {
	      this.currentHeight = this.startHeight + (pageY(event) - this.startY);
	      this.newSize = this.setManualSize(this.currentRow, this.currentHeight);
	      this.refreshHandlePosition();
	      this.refreshGuidePosition();
	    }
	  },
	  onMouseUp: function(event) {
	    if (this.pressed) {
	      this.hideHandleAndGuide();
	      this.pressed = false;
	      if (this.newSize != this.startHeight) {
	        this.hot.runHooks('beforeRowResize', this.currentRow, this.newSize);
	        this.hot.forceFullRender = true;
	        this.hot.view.render();
	        this.hot.view.wt.wtOverlays.adjustElementsSize(true);
	        this.saveManualRowHeights();
	        this.hot.runHooks('afterRowResize', this.currentRow, this.newSize);
	      }
	      this.setupHandlePosition(this.currentTH);
	    }
	  },
	  bindEvents: function() {
	    var $__5 = this;
	    this.eventManager.addEventListener(this.hot.rootElement, 'mouseover', (function(e) {
	      return $__5.onMouseOver(e);
	    }));
	    this.eventManager.addEventListener(this.hot.rootElement, 'mousedown', (function(e) {
	      return $__5.onMouseDown(e);
	    }));
	    this.eventManager.addEventListener(window, 'mousemove', (function(e) {
	      return $__5.onMouseMove(e);
	    }));
	    this.eventManager.addEventListener(window, 'mouseup', (function(e) {
	      return $__5.onMouseUp(e);
	    }));
	  },
	  setManualSize: function(row, height) {
	    row = this.hot.runHooks('modifyRow', row);
	    this.manualRowHeights[row] = height;
	    return height;
	  },
	  onModifyRowHeight: function(height, row) {
	    if (this.enabled) {
	      var autoRowSizePlugin = this.hot.getPlugin('autoRowSize');
	      var autoRowHeightResult = autoRowSizePlugin ? autoRowSizePlugin.heights[row] : null;
	      row = this.hot.runHooks('modifyRow', row);
	      var manualRowHeight = this.manualRowHeights[row];
	      if (manualRowHeight !== void 0 && (manualRowHeight === autoRowHeightResult || manualRowHeight > (height || 0))) {
	        return manualRowHeight;
	      }
	    }
	    return height;
	  }
	}, {}, BasePlugin);
	;
	registerPlugin('manualRowResize', ManualRowResize);

	//# 
	},{"_base.js":58,"eventManager":41,"helpers/dom/element":45,"helpers/dom/event":46,"plugins":57}],81:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  MergeCells: {get: function() {
	      return MergeCells;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__46__46__47_plugins__,
	    $___46__46__47__46__46__47_helpers_47_dom_47_event__,
	    $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_coords__,
	    $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_range__,
	    $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_table__;
	var registerPlugin = ($___46__46__47__46__46__47_plugins__ = require("plugins"), $___46__46__47__46__46__47_plugins__ && $___46__46__47__46__46__47_plugins__.__esModule && $___46__46__47__46__46__47_plugins__ || {default: $___46__46__47__46__46__47_plugins__}).registerPlugin;
	var stopImmediatePropagation = ($___46__46__47__46__46__47_helpers_47_dom_47_event__ = require("helpers/dom/event"), $___46__46__47__46__46__47_helpers_47_dom_47_event__ && $___46__46__47__46__46__47_helpers_47_dom_47_event__.__esModule && $___46__46__47__46__46__47_helpers_47_dom_47_event__ || {default: $___46__46__47__46__46__47_helpers_47_dom_47_event__}).stopImmediatePropagation;
	var WalkontableCellCoords = ($___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_coords__ = require("3rdparty/walkontable/src/cell/coords"), $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_coords__ && $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_coords__.__esModule && $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_coords__ || {default: $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_coords__}).WalkontableCellCoords;
	var WalkontableCellRange = ($___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_range__ = require("3rdparty/walkontable/src/cell/range"), $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_range__ && $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_range__.__esModule && $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_range__ || {default: $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_range__}).WalkontableCellRange;
	var WalkontableTable = ($___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_table__ = require("3rdparty/walkontable/src/table"), $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_table__ && $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_table__.__esModule && $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_table__ || {default: $___46__46__47__46__46__47_3rdparty_47_walkontable_47_src_47_table__}).WalkontableTable;
	;
	function CellInfoCollection() {
	  var collection = [];
	  collection.getInfo = function(row, col) {
	    for (var i = 0,
	        ilen = this.length; i < ilen; i++) {
	      if (this[i].row <= row && this[i].row + this[i].rowspan - 1 >= row && this[i].col <= col && this[i].col + this[i].colspan - 1 >= col) {
	        return this[i];
	      }
	    }
	  };
	  collection.setInfo = function(info) {
	    for (var i = 0,
	        ilen = this.length; i < ilen; i++) {
	      if (this[i].row === info.row && this[i].col === info.col) {
	        this[i] = info;
	        return;
	      }
	    }
	    this.push(info);
	  };
	  collection.removeInfo = function(row, col) {
	    for (var i = 0,
	        ilen = this.length; i < ilen; i++) {
	      if (this[i].row === row && this[i].col === col) {
	        this.splice(i, 1);
	        break;
	      }
	    }
	  };
	  return collection;
	}
	function MergeCells(mergeCellsSetting) {
	  this.mergedCellInfoCollection = new CellInfoCollection();
	  if (Array.isArray(mergeCellsSetting)) {
	    for (var i = 0,
	        ilen = mergeCellsSetting.length; i < ilen; i++) {
	      this.mergedCellInfoCollection.setInfo(mergeCellsSetting[i]);
	    }
	  }
	}
	MergeCells.prototype.canMergeRange = function(cellRange) {
	  return !cellRange.isSingle();
	};
	MergeCells.prototype.mergeRange = function(cellRange) {
	  if (!this.canMergeRange(cellRange)) {
	    return;
	  }
	  var topLeft = cellRange.getTopLeftCorner();
	  var bottomRight = cellRange.getBottomRightCorner();
	  var mergeParent = {};
	  mergeParent.row = topLeft.row;
	  mergeParent.col = topLeft.col;
	  mergeParent.rowspan = bottomRight.row - topLeft.row + 1;
	  mergeParent.colspan = bottomRight.col - topLeft.col + 1;
	  this.mergedCellInfoCollection.setInfo(mergeParent);
	};
	MergeCells.prototype.mergeOrUnmergeSelection = function(cellRange) {
	  var info = this.mergedCellInfoCollection.getInfo(cellRange.from.row, cellRange.from.col);
	  if (info) {
	    this.unmergeSelection(cellRange.from);
	  } else {
	    this.mergeSelection(cellRange);
	  }
	};
	MergeCells.prototype.mergeSelection = function(cellRange) {
	  this.mergeRange(cellRange);
	};
	MergeCells.prototype.unmergeSelection = function(cellRange) {
	  var info = this.mergedCellInfoCollection.getInfo(cellRange.row, cellRange.col);
	  this.mergedCellInfoCollection.removeInfo(info.row, info.col);
	};
	MergeCells.prototype.applySpanProperties = function(TD, row, col) {
	  var info = this.mergedCellInfoCollection.getInfo(row, col);
	  if (info) {
	    if (info.row === row && info.col === col) {
	      TD.setAttribute('rowspan', info.rowspan);
	      TD.setAttribute('colspan', info.colspan);
	    } else {
	      TD.removeAttribute('rowspan');
	      TD.removeAttribute('colspan');
	      TD.style.display = 'none';
	    }
	  } else {
	    TD.removeAttribute('rowspan');
	    TD.removeAttribute('colspan');
	  }
	};
	MergeCells.prototype.modifyTransform = function(hook, currentSelectedRange, delta) {
	  var sameRowspan = function(merged, coords) {
	    if (coords.row >= merged.row && coords.row <= (merged.row + merged.rowspan - 1)) {
	      return true;
	    }
	    return false;
	  },
	      sameColspan = function(merged, coords) {
	        if (coords.col >= merged.col && coords.col <= (merged.col + merged.colspan - 1)) {
	          return true;
	        }
	        return false;
	      },
	      getNextPosition = function(newDelta) {
	        return new WalkontableCellCoords(currentSelectedRange.to.row + newDelta.row, currentSelectedRange.to.col + newDelta.col);
	      };
	  var newDelta = {
	    row: delta.row,
	    col: delta.col
	  };
	  if (hook == 'modifyTransformStart') {
	    if (!this.lastDesiredCoords) {
	      this.lastDesiredCoords = new WalkontableCellCoords(null, null);
	    }
	    var currentPosition = new WalkontableCellCoords(currentSelectedRange.highlight.row, currentSelectedRange.highlight.col),
	        mergedParent = this.mergedCellInfoCollection.getInfo(currentPosition.row, currentPosition.col),
	        currentRangeContainsMerge;
	    for (var i = 0,
	        mergesLength = this.mergedCellInfoCollection.length; i < mergesLength; i++) {
	      var range = this.mergedCellInfoCollection[i];
	      range = new WalkontableCellCoords(range.row + range.rowspan - 1, range.col + range.colspan - 1);
	      if (currentSelectedRange.includes(range)) {
	        currentRangeContainsMerge = true;
	        break;
	      }
	    }
	    if (mergedParent) {
	      var mergeTopLeft = new WalkontableCellCoords(mergedParent.row, mergedParent.col),
	          mergeBottomRight = new WalkontableCellCoords(mergedParent.row + mergedParent.rowspan - 1, mergedParent.col + mergedParent.colspan - 1),
	          mergeRange = new WalkontableCellRange(mergeTopLeft, mergeTopLeft, mergeBottomRight);
	      if (!mergeRange.includes(this.lastDesiredCoords)) {
	        this.lastDesiredCoords = new WalkontableCellCoords(null, null);
	      }
	      newDelta.row = this.lastDesiredCoords.row ? this.lastDesiredCoords.row - currentPosition.row : newDelta.row;
	      newDelta.col = this.lastDesiredCoords.col ? this.lastDesiredCoords.col - currentPosition.col : newDelta.col;
	      if (delta.row > 0) {
	        newDelta.row = mergedParent.row + mergedParent.rowspan - 1 - currentPosition.row + delta.row;
	      } else if (delta.row < 0) {
	        newDelta.row = currentPosition.row - mergedParent.row + delta.row;
	      }
	      if (delta.col > 0) {
	        newDelta.col = mergedParent.col + mergedParent.colspan - 1 - currentPosition.col + delta.col;
	      } else if (delta.col < 0) {
	        newDelta.col = currentPosition.col - mergedParent.col + delta.col;
	      }
	    }
	    var nextPosition = new WalkontableCellCoords(currentSelectedRange.highlight.row + newDelta.row, currentSelectedRange.highlight.col + newDelta.col),
	        nextParentIsMerged = this.mergedCellInfoCollection.getInfo(nextPosition.row, nextPosition.col);
	    if (nextParentIsMerged) {
	      this.lastDesiredCoords = nextPosition;
	      newDelta = {
	        row: nextParentIsMerged.row - currentPosition.row,
	        col: nextParentIsMerged.col - currentPosition.col
	      };
	    }
	  } else if (hook == 'modifyTransformEnd') {
	    for (var i = 0,
	        mergesLength = this.mergedCellInfoCollection.length; i < mergesLength; i++) {
	      var currentMerge = this.mergedCellInfoCollection[i],
	          mergeTopLeft = new WalkontableCellCoords(currentMerge.row, currentMerge.col),
	          mergeBottomRight = new WalkontableCellCoords(currentMerge.row + currentMerge.rowspan - 1, currentMerge.col + currentMerge.colspan - 1),
	          mergedRange = new WalkontableCellRange(mergeTopLeft, mergeTopLeft, mergeBottomRight),
	          sharedBorders = currentSelectedRange.getBordersSharedWith(mergedRange);
	      if (mergedRange.isEqual(currentSelectedRange)) {
	        currentSelectedRange.setDirection('NW-SE');
	      } else if (sharedBorders.length > 0) {
	        var mergeHighlighted = (currentSelectedRange.highlight.isEqual(mergedRange.from));
	        if (sharedBorders.indexOf('top') > -1) {
	          if (currentSelectedRange.to.isSouthEastOf(mergedRange.from) && mergeHighlighted) {
	            currentSelectedRange.setDirection('NW-SE');
	          } else if (currentSelectedRange.to.isSouthWestOf(mergedRange.from) && mergeHighlighted) {
	            currentSelectedRange.setDirection('NE-SW');
	          }
	        } else if (sharedBorders.indexOf('bottom') > -1) {
	          if (currentSelectedRange.to.isNorthEastOf(mergedRange.from) && mergeHighlighted) {
	            currentSelectedRange.setDirection('SW-NE');
	          } else if (currentSelectedRange.to.isNorthWestOf(mergedRange.from) && mergeHighlighted) {
	            currentSelectedRange.setDirection('SE-NW');
	          }
	        }
	      }
	      var nextPosition = getNextPosition(newDelta),
	          withinRowspan = sameRowspan(currentMerge, nextPosition),
	          withinColspan = sameColspan(currentMerge, nextPosition);
	      if (currentSelectedRange.includesRange(mergedRange) && (mergedRange.includes(nextPosition) || withinRowspan || withinColspan)) {
	        if (withinRowspan) {
	          if (newDelta.row < 0) {
	            newDelta.row -= currentMerge.rowspan - 1;
	          } else if (newDelta.row > 0) {
	            newDelta.row += currentMerge.rowspan - 1;
	          }
	        }
	        if (withinColspan) {
	          if (newDelta.col < 0) {
	            newDelta.col -= currentMerge.colspan - 1;
	          } else if (newDelta.col > 0) {
	            newDelta.col += currentMerge.colspan - 1;
	          }
	        }
	      }
	    }
	  }
	  if (newDelta.row !== 0) {
	    delta.row = newDelta.row;
	  }
	  if (newDelta.col !== 0) {
	    delta.col = newDelta.col;
	  }
	};
	MergeCells.prototype.shiftCollection = function(direction, index, count) {
	  var shiftVector = [0, 0];
	  switch (direction) {
	    case 'right':
	      shiftVector[0] += 1;
	      break;
	    case 'left':
	      shiftVector[0] -= 1;
	      break;
	    case 'down':
	      shiftVector[1] += 1;
	      break;
	    case 'up':
	      shiftVector[1] -= 1;
	      break;
	  }
	  for (var i = 0; i < this.mergedCellInfoCollection.length; i++) {
	    var currentMerge = this.mergedCellInfoCollection[i];
	    if (direction === 'right' || direction === 'left') {
	      if (index <= currentMerge.col) {
	        currentMerge.col += shiftVector[0];
	      }
	    } else {
	      if (index <= currentMerge.row) {
	        currentMerge.row += shiftVector[1];
	      }
	    }
	  }
	};
	var beforeInit = function() {
	  var instance = this;
	  var mergeCellsSetting = instance.getSettings().mergeCells;
	  if (mergeCellsSetting) {
	    if (!instance.mergeCells) {
	      instance.mergeCells = new MergeCells(mergeCellsSetting);
	    }
	  }
	};
	var afterInit = function() {
	  var instance = this;
	  if (instance.mergeCells) {
	    instance.view.wt.wtTable.getCell = function(coords) {
	      if (instance.getSettings().mergeCells) {
	        var mergeParent = instance.mergeCells.mergedCellInfoCollection.getInfo(coords.row, coords.col);
	        if (mergeParent) {
	          coords = mergeParent;
	        }
	      }
	      return WalkontableTable.prototype.getCell.call(this, coords);
	    };
	  }
	};
	var afterUpdateSettings = function() {
	  var instance = this;
	  var mergeCellsSetting = instance.getSettings().mergeCells;
	  if (mergeCellsSetting) {
	    if (instance.mergeCells) {
	      instance.mergeCells.mergedCellInfoCollection = new CellInfoCollection();
	      if (Array.isArray(mergeCellsSetting)) {
	        for (var i = 0,
	            ilen = mergeCellsSetting.length; i < ilen; i++) {
	          instance.mergeCells.mergedCellInfoCollection.setInfo(mergeCellsSetting[i]);
	        }
	      }
	    } else {
	      instance.mergeCells = new MergeCells(mergeCellsSetting);
	    }
	  } else {
	    if (instance.mergeCells) {
	      instance.mergeCells.mergedCellInfoCollection = new CellInfoCollection();
	    }
	  }
	};
	var onBeforeKeyDown = function(event) {
	  if (!this.mergeCells) {
	    return;
	  }
	  var ctrlDown = (event.ctrlKey || event.metaKey) && !event.altKey;
	  if (ctrlDown) {
	    if (event.keyCode === 77) {
	      this.mergeCells.mergeOrUnmergeSelection(this.getSelectedRange());
	      this.render();
	      stopImmediatePropagation(event);
	    }
	  }
	};
	var addMergeActionsToContextMenu = function(defaultOptions) {
	  if (!this.getSettings().mergeCells) {
	    return;
	  }
	  defaultOptions.items.push(Handsontable.plugins.ContextMenu.SEPARATOR);
	  defaultOptions.items.push({
	    key: 'mergeCells',
	    name: function() {
	      var sel = this.getSelected();
	      var info = this.mergeCells.mergedCellInfoCollection.getInfo(sel[0], sel[1]);
	      if (info) {
	        return 'Unmerge cells';
	      } else {
	        return 'Merge cells';
	      }
	    },
	    callback: function() {
	      this.mergeCells.mergeOrUnmergeSelection(this.getSelectedRange());
	      this.render();
	    },
	    disabled: function() {
	      return false;
	    }
	  });
	};
	var afterRenderer = function(TD, row, col, prop, value, cellProperties) {
	  if (this.mergeCells) {
	    this.mergeCells.applySpanProperties(TD, row, col);
	  }
	};
	var modifyTransformFactory = function(hook) {
	  return function(delta) {
	    var mergeCellsSetting = this.getSettings().mergeCells;
	    if (mergeCellsSetting) {
	      var currentSelectedRange = this.getSelectedRange();
	      this.mergeCells.modifyTransform(hook, currentSelectedRange, delta);
	      if (hook === 'modifyTransformEnd') {
	        var totalRows = this.countRows();
	        var totalCols = this.countCols();
	        if (currentSelectedRange.from.row < 0) {
	          currentSelectedRange.from.row = 0;
	        } else if (currentSelectedRange.from.row > 0 && currentSelectedRange.from.row >= totalRows) {
	          currentSelectedRange.from.row = currentSelectedRange.from - 1;
	        }
	        if (currentSelectedRange.from.col < 0) {
	          currentSelectedRange.from.col = 0;
	        } else if (currentSelectedRange.from.col > 0 && currentSelectedRange.from.col >= totalCols) {
	          currentSelectedRange.from.col = totalCols - 1;
	        }
	      }
	    }
	  };
	};
	var beforeSetRangeEnd = function(coords) {
	  this.lastDesiredCoords = null;
	  var mergeCellsSetting = this.getSettings().mergeCells;
	  if (mergeCellsSetting) {
	    var selRange = this.getSelectedRange();
	    selRange.highlight = new WalkontableCellCoords(selRange.highlight.row, selRange.highlight.col);
	    selRange.to = coords;
	    var rangeExpanded = false;
	    do {
	      rangeExpanded = false;
	      for (var i = 0,
	          ilen = this.mergeCells.mergedCellInfoCollection.length; i < ilen; i++) {
	        var cellInfo = this.mergeCells.mergedCellInfoCollection[i];
	        var mergedCellTopLeft = new WalkontableCellCoords(cellInfo.row, cellInfo.col);
	        var mergedCellBottomRight = new WalkontableCellCoords(cellInfo.row + cellInfo.rowspan - 1, cellInfo.col + cellInfo.colspan - 1);
	        var mergedCellRange = new WalkontableCellRange(mergedCellTopLeft, mergedCellTopLeft, mergedCellBottomRight);
	        if (selRange.expandByRange(mergedCellRange)) {
	          coords.row = selRange.to.row;
	          coords.col = selRange.to.col;
	          rangeExpanded = true;
	        }
	      }
	    } while (rangeExpanded);
	  }
	};
	var beforeDrawAreaBorders = function(corners, className) {
	  if (className && className == 'area') {
	    var mergeCellsSetting = this.getSettings().mergeCells;
	    if (mergeCellsSetting) {
	      var selRange = this.getSelectedRange();
	      var startRange = new WalkontableCellRange(selRange.from, selRange.from, selRange.from);
	      var stopRange = new WalkontableCellRange(selRange.to, selRange.to, selRange.to);
	      for (var i = 0,
	          ilen = this.mergeCells.mergedCellInfoCollection.length; i < ilen; i++) {
	        var cellInfo = this.mergeCells.mergedCellInfoCollection[i];
	        var mergedCellTopLeft = new WalkontableCellCoords(cellInfo.row, cellInfo.col);
	        var mergedCellBottomRight = new WalkontableCellCoords(cellInfo.row + cellInfo.rowspan - 1, cellInfo.col + cellInfo.colspan - 1);
	        var mergedCellRange = new WalkontableCellRange(mergedCellTopLeft, mergedCellTopLeft, mergedCellBottomRight);
	        if (startRange.expandByRange(mergedCellRange)) {
	          corners[0] = startRange.from.row;
	          corners[1] = startRange.from.col;
	        }
	        if (stopRange.expandByRange(mergedCellRange)) {
	          corners[2] = stopRange.from.row;
	          corners[3] = stopRange.from.col;
	        }
	      }
	    }
	  }
	};
	var afterGetCellMeta = function(row, col, cellProperties) {
	  var mergeCellsSetting = this.getSettings().mergeCells;
	  if (mergeCellsSetting) {
	    var mergeParent = this.mergeCells.mergedCellInfoCollection.getInfo(row, col);
	    if (mergeParent && (mergeParent.row != row || mergeParent.col != col)) {
	      cellProperties.copyable = false;
	    }
	  }
	};
	var afterViewportRowCalculatorOverride = function(calc) {
	  var mergeCellsSetting = this.getSettings().mergeCells;
	  if (mergeCellsSetting) {
	    var colCount = this.countCols();
	    var mergeParent;
	    for (var c = 0; c < colCount; c++) {
	      mergeParent = this.mergeCells.mergedCellInfoCollection.getInfo(calc.startRow, c);
	      if (mergeParent) {
	        if (mergeParent.row < calc.startRow) {
	          calc.startRow = mergeParent.row;
	          return afterViewportRowCalculatorOverride.call(this, calc);
	        }
	      }
	      mergeParent = this.mergeCells.mergedCellInfoCollection.getInfo(calc.endRow, c);
	      if (mergeParent) {
	        var mergeEnd = mergeParent.row + mergeParent.rowspan - 1;
	        if (mergeEnd > calc.endRow) {
	          calc.endRow = mergeEnd;
	          return afterViewportRowCalculatorOverride.call(this, calc);
	        }
	      }
	    }
	  }
	};
	var afterViewportColumnCalculatorOverride = function(calc) {
	  var mergeCellsSetting = this.getSettings().mergeCells;
	  if (mergeCellsSetting) {
	    var rowCount = this.countRows();
	    var mergeParent;
	    for (var r = 0; r < rowCount; r++) {
	      mergeParent = this.mergeCells.mergedCellInfoCollection.getInfo(r, calc.startColumn);
	      if (mergeParent) {
	        if (mergeParent.col < calc.startColumn) {
	          calc.startColumn = mergeParent.col;
	          return afterViewportColumnCalculatorOverride.call(this, calc);
	        }
	      }
	      mergeParent = this.mergeCells.mergedCellInfoCollection.getInfo(r, calc.endColumn);
	      if (mergeParent) {
	        var mergeEnd = mergeParent.col + mergeParent.colspan - 1;
	        if (mergeEnd > calc.endColumn) {
	          calc.endColumn = mergeEnd;
	          return afterViewportColumnCalculatorOverride.call(this, calc);
	        }
	      }
	    }
	  }
	};
	var isMultipleSelection = function(isMultiple) {
	  if (isMultiple && this.mergeCells) {
	    var mergedCells = this.mergeCells.mergedCellInfoCollection,
	        selectionRange = this.getSelectedRange();
	    for (var group in mergedCells) {
	      if (selectionRange.highlight.row == mergedCells[group].row && selectionRange.highlight.col == mergedCells[group].col && selectionRange.to.row == mergedCells[group].row + mergedCells[group].rowspan - 1 && selectionRange.to.col == mergedCells[group].col + mergedCells[group].colspan - 1) {
	        return false;
	      }
	    }
	  }
	  return isMultiple;
	};
	function afterAutofillApplyValues(select, drag) {
	  var mergeCellsSetting = this.getSettings().mergeCells;
	  if (!mergeCellsSetting || this.selection.isMultiple()) {
	    return;
	  }
	  var info = this.mergeCells.mergedCellInfoCollection.getInfo(select[0], select[1]);
	  if (info) {
	    select[0] = info.row;
	    select[1] = info.col;
	    select[2] = info.row + info.rowspan - 1;
	    select[3] = info.col + info.colspan - 1;
	  }
	}
	function onAfterCreateCol(col, count) {
	  if (this.mergeCells) {
	    this.mergeCells.shiftCollection('right', col, count);
	  }
	}
	function onAfterRemoveCol(col, count) {
	  if (this.mergeCells) {
	    this.mergeCells.shiftCollection('left', col, count);
	  }
	}
	function onAfterCreateRow(row, count) {
	  if (this.mergeCells) {
	    this.mergeCells.shiftCollection('down', row, count);
	  }
	}
	function onAfterRemoveRow(row, count) {
	  if (this.mergeCells) {
	    this.mergeCells.shiftCollection('up', row, count);
	  }
	}
	Handsontable.hooks.add('beforeInit', beforeInit);
	Handsontable.hooks.add('afterInit', afterInit);
	Handsontable.hooks.add('afterUpdateSettings', afterUpdateSettings);
	Handsontable.hooks.add('beforeKeyDown', onBeforeKeyDown);
	Handsontable.hooks.add('modifyTransformStart', modifyTransformFactory('modifyTransformStart'));
	Handsontable.hooks.add('modifyTransformEnd', modifyTransformFactory('modifyTransformEnd'));
	Handsontable.hooks.add('beforeSetRangeEnd', beforeSetRangeEnd);
	Handsontable.hooks.add('beforeDrawBorders', beforeDrawAreaBorders);
	Handsontable.hooks.add('afterIsMultipleSelection', isMultipleSelection);
	Handsontable.hooks.add('afterRenderer', afterRenderer);
	Handsontable.hooks.add('afterContextMenuDefaultOptions', addMergeActionsToContextMenu);
	Handsontable.hooks.add('afterGetCellMeta', afterGetCellMeta);
	Handsontable.hooks.add('afterViewportRowCalculatorOverride', afterViewportRowCalculatorOverride);
	Handsontable.hooks.add('afterViewportColumnCalculatorOverride', afterViewportColumnCalculatorOverride);
	Handsontable.hooks.add('afterAutofillApplyValues', afterAutofillApplyValues);
	Handsontable.hooks.add('afterCreateCol', onAfterCreateCol);
	Handsontable.hooks.add('afterRemoveCol', onAfterRemoveCol);
	Handsontable.hooks.add('afterCreateRow', onAfterCreateRow);
	Handsontable.hooks.add('afterRemoveRow', onAfterRemoveRow);
	Handsontable.MergeCells = MergeCells;

	//# 
	},{"3rdparty/walkontable/src/cell/coords":5,"3rdparty/walkontable/src/cell/range":6,"3rdparty/walkontable/src/table":20,"helpers/dom/event":46,"plugins":57}],82:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  MultipleSelectionHandles: {get: function() {
	      return MultipleSelectionHandles;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__46__46__47_helpers_47_dom_47_element__,
	    $___46__46__47__95_base__,
	    $___46__46__47__46__46__47_eventManager__,
	    $___46__46__47__46__46__47_plugins__;
	var $__0 = ($___46__46__47__46__46__47_helpers_47_dom_47_element__ = require("helpers/dom/element"), $___46__46__47__46__46__47_helpers_47_dom_47_element__ && $___46__46__47__46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47__46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47__46__46__47_helpers_47_dom_47_element__}),
	    getWindowScrollTop = $__0.getWindowScrollTop,
	    hasClass = $__0.hasClass,
	    getWindowScrollLeft = $__0.getWindowScrollLeft;
	var BasePlugin = ($___46__46__47__95_base__ = require("_base"), $___46__46__47__95_base__ && $___46__46__47__95_base__.__esModule && $___46__46__47__95_base__ || {default: $___46__46__47__95_base__}).default;
	var EventManager = ($___46__46__47__46__46__47_eventManager__ = require("eventManager"), $___46__46__47__46__46__47_eventManager__ && $___46__46__47__46__46__47_eventManager__.__esModule && $___46__46__47__46__46__47_eventManager__ || {default: $___46__46__47__46__46__47_eventManager__}).EventManager;
	var registerPlugin = ($___46__46__47__46__46__47_plugins__ = require("plugins"), $___46__46__47__46__46__47_plugins__ && $___46__46__47__46__46__47_plugins__.__esModule && $___46__46__47__46__46__47_plugins__ || {default: $___46__46__47__46__46__47_plugins__}).registerPlugin;
	var MultipleSelectionHandles = function MultipleSelectionHandles(hotInstance) {
	  $traceurRuntime.superConstructor($MultipleSelectionHandles).call(this, hotInstance);
	  this.dragged = [];
	  this.eventManager = null;
	  this.lastSetCell = null;
	};
	var $MultipleSelectionHandles = MultipleSelectionHandles;
	($traceurRuntime.createClass)(MultipleSelectionHandles, {
	  isEnabled: function() {
	    return Handsontable.mobileBrowser;
	  },
	  enablePlugin: function() {
	    if (this.enabled) {
	      return;
	    }
	    if (!this.eventManager) {
	      this.eventManager = new EventManager(this);
	    }
	    this.registerListeners();
	    $traceurRuntime.superGet(this, $MultipleSelectionHandles.prototype, "enablePlugin").call(this);
	  },
	  registerListeners: function() {
	    var _this = this;
	    function removeFromDragged(query) {
	      if (_this.dragged.length === 1) {
	        _this.dragged.splice(0, _this.dragged.length);
	        return true;
	      }
	      var entryPosition = _this.dragged.indexOf(query);
	      if (entryPosition == -1) {
	        return false;
	      } else if (entryPosition === 0) {
	        _this.dragged = _this.dragged.slice(0, 1);
	      } else if (entryPosition == 1) {
	        _this.dragged = _this.dragged.slice(-1);
	      }
	    }
	    this.eventManager.addEventListener(this.hot.rootElement, 'touchstart', function(event) {
	      var selectedRange;
	      if (hasClass(event.target, 'topLeftSelectionHandle-HitArea')) {
	        selectedRange = _this.hot.getSelectedRange();
	        _this.dragged.push('topLeft');
	        _this.touchStartRange = {
	          width: selectedRange.getWidth(),
	          height: selectedRange.getHeight(),
	          direction: selectedRange.getDirection()
	        };
	        event.preventDefault();
	        return false;
	      } else if (hasClass(event.target, 'bottomRightSelectionHandle-HitArea')) {
	        selectedRange = _this.hot.getSelectedRange();
	        _this.dragged.push('bottomRight');
	        _this.touchStartRange = {
	          width: selectedRange.getWidth(),
	          height: selectedRange.getHeight(),
	          direction: selectedRange.getDirection()
	        };
	        event.preventDefault();
	        return false;
	      }
	    });
	    this.eventManager.addEventListener(this.hot.rootElement, 'touchend', function(event) {
	      if (hasClass(event.target, 'topLeftSelectionHandle-HitArea')) {
	        removeFromDragged.call(_this, 'topLeft');
	        _this.touchStartRange = void 0;
	        event.preventDefault();
	        return false;
	      } else if (hasClass(event.target, 'bottomRightSelectionHandle-HitArea')) {
	        removeFromDragged.call(_this, 'bottomRight');
	        _this.touchStartRange = void 0;
	        event.preventDefault();
	        return false;
	      }
	    });
	    this.eventManager.addEventListener(this.hot.rootElement, 'touchmove', function(event) {
	      var scrollTop = getWindowScrollTop(),
	          scrollLeft = getWindowScrollLeft(),
	          endTarget,
	          targetCoords,
	          selectedRange,
	          rangeWidth,
	          rangeHeight,
	          rangeDirection,
	          newRangeCoords;
	      if (_this.dragged.length === 0) {
	        return;
	      }
	      endTarget = document.elementFromPoint(event.touches[0].screenX - scrollLeft, event.touches[0].screenY - scrollTop);
	      if (!endTarget || endTarget === _this.lastSetCell) {
	        return;
	      }
	      if (endTarget.nodeName == 'TD' || endTarget.nodeName == 'TH') {
	        targetCoords = _this.hot.getCoords(endTarget);
	        if (targetCoords.col == -1) {
	          targetCoords.col = 0;
	        }
	        selectedRange = _this.hot.getSelectedRange();
	        rangeWidth = selectedRange.getWidth();
	        rangeHeight = selectedRange.getHeight();
	        rangeDirection = selectedRange.getDirection();
	        if (rangeWidth == 1 && rangeHeight == 1) {
	          _this.hot.selection.setRangeEnd(targetCoords);
	        }
	        newRangeCoords = _this.getCurrentRangeCoords(selectedRange, targetCoords, _this.touchStartRange.direction, rangeDirection, _this.dragged[0]);
	        if (newRangeCoords.start !== null) {
	          _this.hot.selection.setRangeStart(newRangeCoords.start);
	        }
	        _this.hot.selection.setRangeEnd(newRangeCoords.end);
	        _this.lastSetCell = endTarget;
	      }
	      event.preventDefault();
	    });
	  },
	  getCurrentRangeCoords: function(selectedRange, currentTouch, touchStartDirection, currentDirection, draggedHandle) {
	    var topLeftCorner = selectedRange.getTopLeftCorner(),
	        bottomRightCorner = selectedRange.getBottomRightCorner(),
	        bottomLeftCorner = selectedRange.getBottomLeftCorner(),
	        topRightCorner = selectedRange.getTopRightCorner();
	    var newCoords = {
	      start: null,
	      end: null
	    };
	    switch (touchStartDirection) {
	      case 'NE-SW':
	        switch (currentDirection) {
	          case 'NE-SW':
	          case 'NW-SE':
	            if (draggedHandle == 'topLeft') {
	              newCoords = {
	                start: new WalkontableCellCoords(currentTouch.row, selectedRange.highlight.col),
	                end: new WalkontableCellCoords(bottomLeftCorner.row, currentTouch.col)
	              };
	            } else {
	              newCoords = {
	                start: new WalkontableCellCoords(selectedRange.highlight.row, currentTouch.col),
	                end: new WalkontableCellCoords(currentTouch.row, topLeftCorner.col)
	              };
	            }
	            break;
	          case 'SE-NW':
	            if (draggedHandle == 'bottomRight') {
	              newCoords = {
	                start: new WalkontableCellCoords(bottomRightCorner.row, currentTouch.col),
	                end: new WalkontableCellCoords(currentTouch.row, topLeftCorner.col)
	              };
	            }
	            break;
	        }
	        break;
	      case 'NW-SE':
	        switch (currentDirection) {
	          case 'NE-SW':
	            if (draggedHandle == 'topLeft') {
	              newCoords = {
	                start: currentTouch,
	                end: bottomLeftCorner
	              };
	            } else {
	              newCoords.end = currentTouch;
	            }
	            break;
	          case 'NW-SE':
	            if (draggedHandle == 'topLeft') {
	              newCoords = {
	                start: currentTouch,
	                end: bottomRightCorner
	              };
	            } else {
	              newCoords.end = currentTouch;
	            }
	            break;
	          case 'SE-NW':
	            if (draggedHandle == 'topLeft') {
	              newCoords = {
	                start: currentTouch,
	                end: topLeftCorner
	              };
	            } else {
	              newCoords.end = currentTouch;
	            }
	            break;
	          case 'SW-NE':
	            if (draggedHandle == 'topLeft') {
	              newCoords = {
	                start: currentTouch,
	                end: topRightCorner
	              };
	            } else {
	              newCoords.end = currentTouch;
	            }
	            break;
	        }
	        break;
	      case 'SW-NE':
	        switch (currentDirection) {
	          case 'NW-SE':
	            if (draggedHandle == 'bottomRight') {
	              newCoords = {
	                start: new WalkontableCellCoords(currentTouch.row, topLeftCorner.col),
	                end: new WalkontableCellCoords(bottomLeftCorner.row, currentTouch.col)
	              };
	            } else {
	              newCoords = {
	                start: new WalkontableCellCoords(topLeftCorner.row, currentTouch.col),
	                end: new WalkontableCellCoords(currentTouch.row, bottomRightCorner.col)
	              };
	            }
	            break;
	          case 'SW-NE':
	            if (draggedHandle == 'topLeft') {
	              newCoords = {
	                start: new WalkontableCellCoords(selectedRange.highlight.row, currentTouch.col),
	                end: new WalkontableCellCoords(currentTouch.row, bottomRightCorner.col)
	              };
	            } else {
	              newCoords = {
	                start: new WalkontableCellCoords(currentTouch.row, topLeftCorner.col),
	                end: new WalkontableCellCoords(topLeftCorner.row, currentTouch.col)
	              };
	            }
	            break;
	          case 'SE-NW':
	            if (draggedHandle == 'bottomRight') {
	              newCoords = {
	                start: new WalkontableCellCoords(currentTouch.row, topRightCorner.col),
	                end: new WalkontableCellCoords(topLeftCorner.row, currentTouch.col)
	              };
	            } else if (draggedHandle == 'topLeft') {
	              newCoords = {
	                start: bottomLeftCorner,
	                end: currentTouch
	              };
	            }
	            break;
	        }
	        break;
	      case 'SE-NW':
	        switch (currentDirection) {
	          case 'NW-SE':
	          case 'NE-SW':
	          case 'SW-NE':
	            if (draggedHandle == 'topLeft') {
	              newCoords.end = currentTouch;
	            }
	            break;
	          case 'SE-NW':
	            if (draggedHandle == 'topLeft') {
	              newCoords.end = currentTouch;
	            } else {
	              newCoords = {
	                start: currentTouch,
	                end: topLeftCorner
	              };
	            }
	            break;
	        }
	        break;
	    }
	    return newCoords;
	  },
	  isDragged: function() {
	    return this.dragged.length > 0;
	  }
	}, {}, BasePlugin);
	;
	registerPlugin('multipleSelectionHandles', MultipleSelectionHandles);

	//# 
	},{"_base":58,"eventManager":41,"helpers/dom/element":45,"plugins":57}],83:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  ObserveChanges: {get: function() {
	      return ObserveChanges;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__46__46__47_plugins__,
	    $__jsonpatch__;
	var registerPlugin = ($___46__46__47__46__46__47_plugins__ = require("plugins"), $___46__46__47__46__46__47_plugins__ && $___46__46__47__46__46__47_plugins__.__esModule && $___46__46__47__46__46__47_plugins__ || {default: $___46__46__47__46__46__47_plugins__}).registerPlugin;
	var jsonpatch = ($__jsonpatch__ = require("jsonpatch"), $__jsonpatch__ && $__jsonpatch__.__esModule && $__jsonpatch__ || {default: $__jsonpatch__}).default;
	;
	function ObserveChanges() {}
	Handsontable.hooks.add('afterLoadData', init);
	Handsontable.hooks.add('afterUpdateSettings', init);
	Handsontable.hooks.register('afterChangesObserved');
	function init() {
	  var instance = this;
	  var pluginEnabled = instance.getSettings().observeChanges;
	  if (pluginEnabled) {
	    if (instance.observer) {
	      destroy.call(instance);
	    }
	    createObserver.call(instance);
	    bindEvents.call(instance);
	  } else if (!pluginEnabled) {
	    destroy.call(instance);
	  }
	}
	function createObserver() {
	  var instance = this;
	  instance.observeChangesActive = true;
	  instance.pauseObservingChanges = function() {
	    instance.observeChangesActive = false;
	  };
	  instance.resumeObservingChanges = function() {
	    instance.observeChangesActive = true;
	  };
	  instance.observedData = instance.getSourceData();
	  instance.observer = jsonpatch.observe(instance.observedData, function(patches) {
	    if (instance.observeChangesActive) {
	      runHookForOperation.call(instance, patches);
	      instance.render();
	    }
	    instance.runHooks('afterChangesObserved');
	  });
	}
	function runHookForOperation(rawPatches) {
	  var instance = this;
	  var patches = cleanPatches(rawPatches);
	  for (var i = 0,
	      len = patches.length; i < len; i++) {
	    var patch = patches[i];
	    var parsedPath = parsePath(patch.path);
	    switch (patch.op) {
	      case 'add':
	        if (isNaN(parsedPath.col)) {
	          instance.runHooks('afterCreateRow', parsedPath.row);
	        } else {
	          instance.runHooks('afterCreateCol', parsedPath.col);
	        }
	        break;
	      case 'remove':
	        if (isNaN(parsedPath.col)) {
	          instance.runHooks('afterRemoveRow', parsedPath.row, 1);
	        } else {
	          instance.runHooks('afterRemoveCol', parsedPath.col, 1);
	        }
	        break;
	      case 'replace':
	        instance.runHooks('afterChange', [parsedPath.row, parsedPath.col, null, patch.value], 'external');
	        break;
	    }
	  }
	  function cleanPatches(rawPatches) {
	    var patches;
	    patches = removeLengthRelatedPatches(rawPatches);
	    patches = removeMultipleAddOrRemoveColPatches(patches);
	    return patches;
	  }
	  function removeMultipleAddOrRemoveColPatches(rawPatches) {
	    var newOrRemovedColumns = [];
	    return rawPatches.filter(function(patch) {
	      var parsedPath = parsePath(patch.path);
	      if (['add', 'remove'].indexOf(patch.op) != -1 && !isNaN(parsedPath.col)) {
	        if (newOrRemovedColumns.indexOf(parsedPath.col) != -1) {
	          return false;
	        } else {
	          newOrRemovedColumns.push(parsedPath.col);
	        }
	      }
	      return true;
	    });
	  }
	  function removeLengthRelatedPatches(rawPatches) {
	    return rawPatches.filter(function(patch) {
	      return !/[/]length/ig.test(patch.path);
	    });
	  }
	  function parsePath(path) {
	    var match = path.match(/^\/(\d+)\/?(.*)?$/);
	    return {
	      row: parseInt(match[1], 10),
	      col: /^\d*$/.test(match[2]) ? parseInt(match[2], 10) : match[2]
	    };
	  }
	}
	function destroy() {
	  var instance = this;
	  if (instance.observer) {
	    destroyObserver.call(instance);
	    unbindEvents.call(instance);
	  }
	}
	function destroyObserver() {
	  var instance = this;
	  jsonpatch.unobserve(instance.observedData, instance.observer);
	  delete instance.observedData;
	  delete instance.observeChangesActive;
	  delete instance.pauseObservingChanges;
	  delete instance.resumeObservingChanges;
	}
	function bindEvents() {
	  var instance = this;
	  instance.addHook('afterDestroy', destroy);
	  instance.addHook('afterCreateRow', afterTableAlter);
	  instance.addHook('afterRemoveRow', afterTableAlter);
	  instance.addHook('afterCreateCol', afterTableAlter);
	  instance.addHook('afterRemoveCol', afterTableAlter);
	  instance.addHook('afterChange', function(changes, source) {
	    if (source != 'loadData') {
	      afterTableAlter.call(this);
	    }
	  });
	}
	function unbindEvents() {
	  var instance = this;
	  instance.removeHook('afterDestroy', destroy);
	  instance.removeHook('afterCreateRow', afterTableAlter);
	  instance.removeHook('afterRemoveRow', afterTableAlter);
	  instance.removeHook('afterCreateCol', afterTableAlter);
	  instance.removeHook('afterRemoveCol', afterTableAlter);
	  instance.removeHook('afterChange', afterTableAlter);
	}
	function afterTableAlter() {
	  var instance = this;
	  instance.pauseObservingChanges();
	  instance.addHookOnce('afterChangesObserved', function() {
	    instance.resumeObservingChanges();
	  });
	}

	//# 
	},{"jsonpatch":"jsonpatch","plugins":57}],84:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  HandsontablePersistentState: {get: function() {
	      return HandsontablePersistentState;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__46__46__47_plugins__;
	var registerPlugin = ($___46__46__47__46__46__47_plugins__ = require("plugins"), $___46__46__47__46__46__47_plugins__ && $___46__46__47__46__46__47_plugins__.__esModule && $___46__46__47__46__46__47_plugins__ || {default: $___46__46__47__46__46__47_plugins__}).registerPlugin;
	;
	function Storage(prefix) {
	  var savedKeys;
	  var saveSavedKeys = function() {
	    window.localStorage[prefix + '__' + 'persistentStateKeys'] = JSON.stringify(savedKeys);
	  };
	  var loadSavedKeys = function() {
	    var keysJSON = window.localStorage[prefix + '__' + 'persistentStateKeys'];
	    var keys = typeof keysJSON == 'string' ? JSON.parse(keysJSON) : void 0;
	    savedKeys = keys ? keys : [];
	  };
	  var clearSavedKeys = function() {
	    savedKeys = [];
	    saveSavedKeys();
	  };
	  loadSavedKeys();
	  this.saveValue = function(key, value) {
	    window.localStorage[prefix + '_' + key] = JSON.stringify(value);
	    if (savedKeys.indexOf(key) == -1) {
	      savedKeys.push(key);
	      saveSavedKeys();
	    }
	  };
	  this.loadValue = function(key, defaultValue) {
	    key = typeof key === 'undefined' ? defaultValue : key;
	    var value = window.localStorage[prefix + '_' + key];
	    return typeof value == 'undefined' ? void 0 : JSON.parse(value);
	  };
	  this.reset = function(key) {
	    window.localStorage.removeItem(prefix + '_' + key);
	  };
	  this.resetAll = function() {
	    for (var index = 0; index < savedKeys.length; index++) {
	      window.localStorage.removeItem(prefix + '_' + savedKeys[index]);
	    }
	    clearSavedKeys();
	  };
	}
	function HandsontablePersistentState() {
	  var plugin = this;
	  this.init = function() {
	    var instance = this,
	        pluginSettings = instance.getSettings().persistentState;
	    plugin.enabled = !!(pluginSettings);
	    if (!plugin.enabled) {
	      removeHooks.call(instance);
	      return;
	    }
	    if (!instance.storage) {
	      instance.storage = new Storage(instance.rootElement.id);
	    }
	    instance.resetState = plugin.resetValue;
	    addHooks.call(instance);
	  };
	  this.saveValue = function(key, value) {
	    var instance = this;
	    instance.storage.saveValue(key, value);
	  };
	  this.loadValue = function(key, saveTo) {
	    var instance = this;
	    saveTo.value = instance.storage.loadValue(key);
	  };
	  this.resetValue = function(key) {
	    var instance = this;
	    if (typeof key === 'undefined') {
	      instance.storage.resetAll();
	    } else {
	      instance.storage.reset(key);
	    }
	  };
	  var hooks = {
	    persistentStateSave: plugin.saveValue,
	    persistentStateLoad: plugin.loadValue,
	    persistentStateReset: plugin.resetValue
	  };
	  for (var hookName in hooks) {
	    if (hooks.hasOwnProperty(hookName)) {
	      Handsontable.hooks.register(hookName);
	    }
	  }
	  function addHooks() {
	    var instance = this;
	    for (var hookName in hooks) {
	      if (hooks.hasOwnProperty(hookName)) {
	        instance.addHook(hookName, hooks[hookName]);
	      }
	    }
	  }
	  function removeHooks() {
	    var instance = this;
	    for (var hookName in hooks) {
	      if (hooks.hasOwnProperty(hookName)) {
	        instance.removeHook(hookName, hooks[hookName]);
	      }
	    }
	  }
	}
	var htPersistentState = new HandsontablePersistentState();
	Handsontable.hooks.add('beforeInit', htPersistentState.init);
	Handsontable.hooks.add('afterUpdateSettings', htPersistentState.init);

	//# 
	},{"plugins":57}],85:[function(require,module,exports){
	"use strict";
	var $___46__46__47__46__46__47_helpers_47_dom_47_element__,
	    $___46__46__47__46__46__47_renderers__;
	var $__0 = ($___46__46__47__46__46__47_helpers_47_dom_47_element__ = require("helpers/dom/element"), $___46__46__47__46__46__47_helpers_47_dom_47_element__ && $___46__46__47__46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47__46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47__46__46__47_helpers_47_dom_47_element__}),
	    addClass = $__0.addClass,
	    removeClass = $__0.removeClass;
	var $__1 = ($___46__46__47__46__46__47_renderers__ = require("renderers"), $___46__46__47__46__46__47_renderers__ && $___46__46__47__46__46__47_renderers__.__esModule && $___46__46__47__46__46__47_renderers__ || {default: $___46__46__47__46__46__47_renderers__}),
	    registerRenderer = $__1.registerRenderer,
	    getRenderer = $__1.getRenderer;
	Handsontable.Search = function Search(instance) {
	  this.query = function(queryStr, callback, queryMethod) {
	    var rowCount = instance.countRows();
	    var colCount = instance.countCols();
	    var queryResult = [];
	    if (!callback) {
	      callback = Handsontable.Search.global.getDefaultCallback();
	    }
	    if (!queryMethod) {
	      queryMethod = Handsontable.Search.global.getDefaultQueryMethod();
	    }
	    for (var rowIndex = 0; rowIndex < rowCount; rowIndex++) {
	      for (var colIndex = 0; colIndex < colCount; colIndex++) {
	        var cellData = instance.getDataAtCell(rowIndex, colIndex);
	        var cellProperties = instance.getCellMeta(rowIndex, colIndex);
	        var cellCallback = cellProperties.search.callback || callback;
	        var cellQueryMethod = cellProperties.search.queryMethod || queryMethod;
	        var testResult = cellQueryMethod(queryStr, cellData);
	        if (testResult) {
	          var singleResult = {
	            row: rowIndex,
	            col: colIndex,
	            data: cellData
	          };
	          queryResult.push(singleResult);
	        }
	        if (cellCallback) {
	          cellCallback(instance, rowIndex, colIndex, cellData, testResult);
	        }
	      }
	    }
	    return queryResult;
	  };
	};
	Handsontable.Search.DEFAULT_CALLBACK = function(instance, row, col, data, testResult) {
	  instance.getCellMeta(row, col).isSearchResult = testResult;
	};
	Handsontable.Search.DEFAULT_QUERY_METHOD = function(query, value) {
	  if (typeof query == 'undefined' || query == null || !query.toLowerCase || query.length === 0) {
	    return false;
	  }
	  if (typeof value == 'undefined' || value == null) {
	    return false;
	  }
	  return value.toString().toLowerCase().indexOf(query.toLowerCase()) != -1;
	};
	Handsontable.Search.DEFAULT_SEARCH_RESULT_CLASS = 'htSearchResult';
	Handsontable.Search.global = (function() {
	  var defaultCallback = Handsontable.Search.DEFAULT_CALLBACK;
	  var defaultQueryMethod = Handsontable.Search.DEFAULT_QUERY_METHOD;
	  var defaultSearchResultClass = Handsontable.Search.DEFAULT_SEARCH_RESULT_CLASS;
	  return {
	    getDefaultCallback: function() {
	      return defaultCallback;
	    },
	    setDefaultCallback: function(newDefaultCallback) {
	      defaultCallback = newDefaultCallback;
	    },
	    getDefaultQueryMethod: function() {
	      return defaultQueryMethod;
	    },
	    setDefaultQueryMethod: function(newDefaultQueryMethod) {
	      defaultQueryMethod = newDefaultQueryMethod;
	    },
	    getDefaultSearchResultClass: function() {
	      return defaultSearchResultClass;
	    },
	    setDefaultSearchResultClass: function(newSearchResultClass) {
	      defaultSearchResultClass = newSearchResultClass;
	    }
	  };
	})();
	Handsontable.SearchCellDecorator = function(instance, TD, row, col, prop, value, cellProperties) {
	  var searchResultClass = (cellProperties.search !== null && typeof cellProperties.search == 'object' && cellProperties.search.searchResultClass) || Handsontable.Search.global.getDefaultSearchResultClass();
	  if (cellProperties.isSearchResult) {
	    addClass(TD, searchResultClass);
	  } else {
	    removeClass(TD, searchResultClass);
	  }
	};
	var originalBaseRenderer = getRenderer('base');
	registerRenderer('base', function(instance, TD, row, col, prop, value, cellProperties) {
	  originalBaseRenderer.apply(this, arguments);
	  Handsontable.SearchCellDecorator.apply(this, arguments);
	});
	function init() {
	  var instance = this;
	  var pluginEnabled = !!instance.getSettings().search;
	  if (pluginEnabled) {
	    instance.search = new Handsontable.Search(instance);
	  } else {
	    delete instance.search;
	  }
	}
	Handsontable.hooks.add('afterInit', init);
	Handsontable.hooks.add('afterUpdateSettings', init);

	//# 
	},{"helpers/dom/element":45,"renderers":88}],86:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  TouchScroll: {get: function() {
	      return TouchScroll;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47__46__46__47_helpers_47_dom_47_element__,
	    $___46__46__47__95_base__,
	    $___46__46__47__46__46__47_plugins__;
	var $__0 = ($___46__46__47__46__46__47_helpers_47_dom_47_element__ = require("helpers/dom/element"), $___46__46__47__46__46__47_helpers_47_dom_47_element__ && $___46__46__47__46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47__46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47__46__46__47_helpers_47_dom_47_element__}),
	    addClass = $__0.addClass,
	    removeClass = $__0.removeClass;
	var BasePlugin = ($___46__46__47__95_base__ = require("_base"), $___46__46__47__95_base__ && $___46__46__47__95_base__.__esModule && $___46__46__47__95_base__ || {default: $___46__46__47__95_base__}).default;
	var registerPlugin = ($___46__46__47__46__46__47_plugins__ = require("plugins"), $___46__46__47__46__46__47_plugins__ && $___46__46__47__46__46__47_plugins__.__esModule && $___46__46__47__46__46__47_plugins__ || {default: $___46__46__47__46__46__47_plugins__}).registerPlugin;
	var TouchScroll = function TouchScroll(hotInstance) {
	  var $__3 = this;
	  $traceurRuntime.superConstructor($TouchScroll).call(this, hotInstance);
	  this.hot.addHook('afterInit', (function() {
	    return $__3.afterInit();
	  }));
	  this.hot.addHook('afterUpdateSettings', (function() {
	    return $__3.onAfterUpdateSettings();
	  }));
	  this.scrollbars = [];
	  this.clones = [];
	};
	var $TouchScroll = TouchScroll;
	($traceurRuntime.createClass)(TouchScroll, {
	  afterInit: function() {
	    this.registerEvents();
	    this.onAfterUpdateSettings();
	  },
	  onAfterUpdateSettings: function() {
	    var _this = this;
	    this.hot.addHookOnce('afterRender', function() {
	      var wtOverlays = _this.hot.view.wt.wtOverlays;
	      _this.scrollbars = [];
	      _this.scrollbars.push(wtOverlays.topOverlay);
	      if (wtOverlays.bottomOverlay.clone) {
	        _this.scrollbars.push(wtOverlays.bottomOverlay);
	      }
	      _this.scrollbars.push(wtOverlays.leftOverlay);
	      if (wtOverlays.topLeftCornerOverlay) {
	        _this.scrollbars.push(wtOverlays.topLeftCornerOverlay);
	      }
	      if (wtOverlays.bottomLeftCornerOverlay && wtOverlays.bottomLeftCornerOverlay.clone) {
	        _this.scrollbars.push(wtOverlays.bottomLeftCornerOverlay);
	      }
	      _this.clones = [];
	      if (wtOverlays.topOverlay.needFullRender) {
	        _this.clones.push(wtOverlays.topOverlay.clone.wtTable.holder.parentNode);
	      }
	      if (wtOverlays.bottomOverlay.needFullRender) {
	        _this.clones.push(wtOverlays.bottomOverlay.clone.wtTable.holder.parentNode);
	      }
	      if (wtOverlays.leftOverlay.needFullRender) {
	        _this.clones.push(wtOverlays.leftOverlay.clone.wtTable.holder.parentNode);
	      }
	      if (wtOverlays.topLeftCornerOverlay) {
	        _this.clones.push(wtOverlays.topLeftCornerOverlay.clone.wtTable.holder.parentNode);
	      }
	      if (wtOverlays.bottomLeftCornerOverlay && wtOverlays.bottomLeftCornerOverlay.clone) {
	        _this.clones.push(wtOverlays.bottomLeftCornerOverlay.clone.wtTable.holder.parentNode);
	      }
	    });
	  },
	  registerEvents: function() {
	    var $__3 = this;
	    this.hot.addHook('beforeTouchScroll', (function() {
	      return $__3.onBeforeTouchScroll();
	    }));
	    this.hot.addHook('afterMomentumScroll', (function() {
	      return $__3.onAfterMomentumScroll();
	    }));
	  },
	  onBeforeTouchScroll: function() {
	    Handsontable.freezeOverlays = true;
	    for (var i = 0,
	        cloneCount = this.clones.length; i < cloneCount; i++) {
	      addClass(this.clones[i], 'hide-tween');
	    }
	  },
	  onAfterMomentumScroll: function() {
	    Handsontable.freezeOverlays = false;
	    var _that = this;
	    for (var i = 0,
	        cloneCount = this.clones.length; i < cloneCount; i++) {
	      removeClass(this.clones[i], 'hide-tween');
	    }
	    for (var i$__5 = 0,
	        cloneCount$__6 = this.clones.length; i$__5 < cloneCount$__6; i$__5++) {
	      addClass(this.clones[i$__5], 'show-tween');
	    }
	    setTimeout(function() {
	      for (var i = 0,
	          cloneCount = _that.clones.length; i < cloneCount; i++) {
	        removeClass(_that.clones[i], 'show-tween');
	      }
	    }, 400);
	    for (var i$__7 = 0,
	        cloneCount$__8 = this.scrollbars.length; i$__7 < cloneCount$__8; i$__7++) {
	      this.scrollbars[i$__7].refresh();
	      this.scrollbars[i$__7].resetFixedPosition();
	    }
	    this.hot.view.wt.wtOverlays.syncScrollWithMaster();
	  }
	}, {}, BasePlugin);
	;
	registerPlugin('touchScroll', TouchScroll);

	//# 
	},{"_base":58,"helpers/dom/element":45,"plugins":57}],87:[function(require,module,exports){
	"use strict";
	var $___46__46__47__46__46__47_helpers_47_object__,
	    $___46__46__47__46__46__47_helpers_47_dom_47_event__;
	var $__0 = ($___46__46__47__46__46__47_helpers_47_object__ = require("helpers/object"), $___46__46__47__46__46__47_helpers_47_object__ && $___46__46__47__46__46__47_helpers_47_object__.__esModule && $___46__46__47__46__46__47_helpers_47_object__ || {default: $___46__46__47__46__46__47_helpers_47_object__}),
	    inherit = $__0.inherit,
	    deepClone = $__0.deepClone;
	var stopImmediatePropagation = ($___46__46__47__46__46__47_helpers_47_dom_47_event__ = require("helpers/dom/event"), $___46__46__47__46__46__47_helpers_47_dom_47_event__ && $___46__46__47__46__46__47_helpers_47_dom_47_event__.__esModule && $___46__46__47__46__46__47_helpers_47_dom_47_event__ || {default: $___46__46__47__46__46__47_helpers_47_dom_47_event__}).stopImmediatePropagation;
	Handsontable.UndoRedo = function(instance) {
	  var plugin = this;
	  this.instance = instance;
	  this.doneActions = [];
	  this.undoneActions = [];
	  this.ignoreNewActions = false;
	  instance.addHook('afterChange', function(changes, origin) {
	    if (changes) {
	      var action = new Handsontable.UndoRedo.ChangeAction(changes);
	      plugin.done(action);
	    }
	  });
	  instance.addHook('afterCreateRow', function(index, amount, createdAutomatically) {
	    if (createdAutomatically) {
	      return;
	    }
	    var action = new Handsontable.UndoRedo.CreateRowAction(index, amount);
	    plugin.done(action);
	  });
	  instance.addHook('beforeRemoveRow', function(index, amount) {
	    var originalData = plugin.instance.getSourceData();
	    index = (originalData.length + index) % originalData.length;
	    var removedData = originalData.slice(index, index + amount);
	    var action = new Handsontable.UndoRedo.RemoveRowAction(index, removedData);
	    plugin.done(action);
	  });
	  instance.addHook('afterCreateCol', function(index, amount, createdAutomatically) {
	    if (createdAutomatically) {
	      return;
	    }
	    var action = new Handsontable.UndoRedo.CreateColumnAction(index, amount);
	    plugin.done(action);
	  });
	  instance.addHook('beforeRemoveCol', function(index, amount) {
	    var originalData = plugin.instance.getSourceData();
	    index = (plugin.instance.countCols() + index) % plugin.instance.countCols();
	    var removedData = [];
	    for (var i = 0,
	        len = originalData.length; i < len; i++) {
	      removedData[i] = originalData[i].slice(index, index + amount);
	    }
	    var headers;
	    if (Array.isArray(instance.getSettings().colHeaders)) {
	      headers = instance.getSettings().colHeaders.slice(index, index + removedData.length);
	    }
	    var action = new Handsontable.UndoRedo.RemoveColumnAction(index, removedData, headers);
	    plugin.done(action);
	  });
	  instance.addHook('beforeCellAlignment', function(stateBefore, range, type, alignment) {
	    var action = new Handsontable.UndoRedo.CellAlignmentAction(stateBefore, range, type, alignment);
	    plugin.done(action);
	  });
	};
	Handsontable.UndoRedo.prototype.done = function(action) {
	  if (!this.ignoreNewActions) {
	    this.doneActions.push(action);
	    this.undoneActions.length = 0;
	  }
	};
	Handsontable.UndoRedo.prototype.undo = function() {
	  if (this.isUndoAvailable()) {
	    var action = this.doneActions.pop();
	    this.ignoreNewActions = true;
	    var that = this;
	    action.undo(this.instance, function() {
	      that.ignoreNewActions = false;
	      that.undoneActions.push(action);
	    });
	  }
	};
	Handsontable.UndoRedo.prototype.redo = function() {
	  if (this.isRedoAvailable()) {
	    var action = this.undoneActions.pop();
	    this.ignoreNewActions = true;
	    var that = this;
	    action.redo(this.instance, function() {
	      that.ignoreNewActions = false;
	      that.doneActions.push(action);
	    });
	  }
	};
	Handsontable.UndoRedo.prototype.isUndoAvailable = function() {
	  return this.doneActions.length > 0;
	};
	Handsontable.UndoRedo.prototype.isRedoAvailable = function() {
	  return this.undoneActions.length > 0;
	};
	Handsontable.UndoRedo.prototype.clear = function() {
	  this.doneActions.length = 0;
	  this.undoneActions.length = 0;
	};
	Handsontable.UndoRedo.Action = function() {};
	Handsontable.UndoRedo.Action.prototype.undo = function() {};
	Handsontable.UndoRedo.Action.prototype.redo = function() {};
	Handsontable.UndoRedo.ChangeAction = function(changes) {
	  this.changes = changes;
	};
	inherit(Handsontable.UndoRedo.ChangeAction, Handsontable.UndoRedo.Action);
	Handsontable.UndoRedo.ChangeAction.prototype.undo = function(instance, undoneCallback) {
	  var data = deepClone(this.changes),
	      emptyRowsAtTheEnd = instance.countEmptyRows(true),
	      emptyColsAtTheEnd = instance.countEmptyCols(true);
	  for (var i = 0,
	      len = data.length; i < len; i++) {
	    data[i].splice(3, 1);
	  }
	  instance.addHookOnce('afterChange', undoneCallback);
	  instance.setDataAtRowProp(data, null, null, 'undo');
	  for (var i = 0,
	      len = data.length; i < len; i++) {
	    if (instance.getSettings().minSpareRows && data[i][0] + 1 + instance.getSettings().minSpareRows === instance.countRows() && emptyRowsAtTheEnd == instance.getSettings().minSpareRows) {
	      instance.alter('remove_row', parseInt(data[i][0] + 1, 10), instance.getSettings().minSpareRows);
	      instance.undoRedo.doneActions.pop();
	    }
	    if (instance.getSettings().minSpareCols && data[i][1] + 1 + instance.getSettings().minSpareCols === instance.countCols() && emptyColsAtTheEnd == instance.getSettings().minSpareCols) {
	      instance.alter('remove_col', parseInt(data[i][1] + 1, 10), instance.getSettings().minSpareCols);
	      instance.undoRedo.doneActions.pop();
	    }
	  }
	};
	Handsontable.UndoRedo.ChangeAction.prototype.redo = function(instance, onFinishCallback) {
	  var data = deepClone(this.changes);
	  for (var i = 0,
	      len = data.length; i < len; i++) {
	    data[i].splice(2, 1);
	  }
	  instance.addHookOnce('afterChange', onFinishCallback);
	  instance.setDataAtRowProp(data, null, null, 'redo');
	};
	Handsontable.UndoRedo.CreateRowAction = function(index, amount) {
	  this.index = index;
	  this.amount = amount;
	};
	inherit(Handsontable.UndoRedo.CreateRowAction, Handsontable.UndoRedo.Action);
	Handsontable.UndoRedo.CreateRowAction.prototype.undo = function(instance, undoneCallback) {
	  var rowCount = instance.countRows(),
	      minSpareRows = instance.getSettings().minSpareRows;
	  if (this.index >= rowCount && this.index - minSpareRows < rowCount) {
	    this.index -= minSpareRows;
	  }
	  instance.addHookOnce('afterRemoveRow', undoneCallback);
	  instance.alter('remove_row', this.index, this.amount);
	};
	Handsontable.UndoRedo.CreateRowAction.prototype.redo = function(instance, redoneCallback) {
	  instance.addHookOnce('afterCreateRow', redoneCallback);
	  instance.alter('insert_row', this.index + 1, this.amount);
	};
	Handsontable.UndoRedo.RemoveRowAction = function(index, data) {
	  this.index = index;
	  this.data = data;
	};
	inherit(Handsontable.UndoRedo.RemoveRowAction, Handsontable.UndoRedo.Action);
	Handsontable.UndoRedo.RemoveRowAction.prototype.undo = function(instance, undoneCallback) {
	  var spliceArgs = [this.index, 0];
	  Array.prototype.push.apply(spliceArgs, this.data);
	  Array.prototype.splice.apply(instance.getSourceData(), spliceArgs);
	  instance.addHookOnce('afterRender', undoneCallback);
	  instance.render();
	};
	Handsontable.UndoRedo.RemoveRowAction.prototype.redo = function(instance, redoneCallback) {
	  instance.addHookOnce('afterRemoveRow', redoneCallback);
	  instance.alter('remove_row', this.index, this.data.length);
	};
	Handsontable.UndoRedo.CreateColumnAction = function(index, amount) {
	  this.index = index;
	  this.amount = amount;
	};
	inherit(Handsontable.UndoRedo.CreateColumnAction, Handsontable.UndoRedo.Action);
	Handsontable.UndoRedo.CreateColumnAction.prototype.undo = function(instance, undoneCallback) {
	  instance.addHookOnce('afterRemoveCol', undoneCallback);
	  instance.alter('remove_col', this.index, this.amount);
	};
	Handsontable.UndoRedo.CreateColumnAction.prototype.redo = function(instance, redoneCallback) {
	  instance.addHookOnce('afterCreateCol', redoneCallback);
	  instance.alter('insert_col', this.index + 1, this.amount);
	};
	Handsontable.UndoRedo.CellAlignmentAction = function(stateBefore, range, type, alignment) {
	  this.stateBefore = stateBefore;
	  this.range = range;
	  this.type = type;
	  this.alignment = alignment;
	};
	Handsontable.UndoRedo.CellAlignmentAction.prototype.undo = function(instance, undoneCallback) {
	  if (!instance.getPlugin('contextMenu').isEnabled()) {
	    return;
	  }
	  for (var row = this.range.from.row; row <= this.range.to.row; row++) {
	    for (var col = this.range.from.col; col <= this.range.to.col; col++) {
	      instance.setCellMeta(row, col, 'className', this.stateBefore[row][col] || ' htLeft');
	    }
	  }
	  instance.addHookOnce('afterRender', undoneCallback);
	  instance.render();
	};
	Handsontable.UndoRedo.CellAlignmentAction.prototype.redo = function(instance, undoneCallback) {
	  if (!instance.getPlugin('contextMenu').isEnabled()) {
	    return;
	  }
	  instance.selectCell(this.range.from.row, this.range.from.col, this.range.to.row, this.range.to.col);
	  instance.getPlugin('contextMenu').executeCommand('alignment:' + this.alignment.replace('ht', '').toLowerCase());
	  instance.addHookOnce('afterRender', undoneCallback);
	  instance.render();
	};
	Handsontable.UndoRedo.RemoveColumnAction = function(index, data, headers) {
	  this.index = index;
	  this.data = data;
	  this.amount = this.data[0].length;
	  this.headers = headers;
	};
	inherit(Handsontable.UndoRedo.RemoveColumnAction, Handsontable.UndoRedo.Action);
	Handsontable.UndoRedo.RemoveColumnAction.prototype.undo = function(instance, undoneCallback) {
	  var row,
	      spliceArgs;
	  for (var i = 0,
	      len = instance.getSourceData().length; i < len; i++) {
	    row = instance.getSourceDataAtRow(i);
	    spliceArgs = [this.index, 0];
	    Array.prototype.push.apply(spliceArgs, this.data[i]);
	    Array.prototype.splice.apply(row, spliceArgs);
	  }
	  if (typeof this.headers != 'undefined') {
	    spliceArgs = [this.index, 0];
	    Array.prototype.push.apply(spliceArgs, this.headers);
	    Array.prototype.splice.apply(instance.getSettings().colHeaders, spliceArgs);
	  }
	  instance.addHookOnce('afterRender', undoneCallback);
	  instance.render();
	};
	Handsontable.UndoRedo.RemoveColumnAction.prototype.redo = function(instance, redoneCallback) {
	  instance.addHookOnce('afterRemoveCol', redoneCallback);
	  instance.alter('remove_col', this.index, this.amount);
	};
	function init() {
	  var instance = this;
	  var pluginEnabled = typeof instance.getSettings().undo == 'undefined' || instance.getSettings().undo;
	  if (pluginEnabled) {
	    if (!instance.undoRedo) {
	      instance.undoRedo = new Handsontable.UndoRedo(instance);
	      exposeUndoRedoMethods(instance);
	      instance.addHook('beforeKeyDown', onBeforeKeyDown);
	      instance.addHook('afterChange', onAfterChange);
	    }
	  } else {
	    if (instance.undoRedo) {
	      delete instance.undoRedo;
	      removeExposedUndoRedoMethods(instance);
	      instance.removeHook('beforeKeyDown', onBeforeKeyDown);
	      instance.removeHook('afterChange', onAfterChange);
	    }
	  }
	}
	function onBeforeKeyDown(event) {
	  var instance = this;
	  var ctrlDown = (event.ctrlKey || event.metaKey) && !event.altKey;
	  if (ctrlDown) {
	    if (event.keyCode === 89 || (event.shiftKey && event.keyCode === 90)) {
	      instance.undoRedo.redo();
	      stopImmediatePropagation(event);
	    } else if (event.keyCode === 90) {
	      instance.undoRedo.undo();
	      stopImmediatePropagation(event);
	    }
	  }
	}
	function onAfterChange(changes, source) {
	  var instance = this;
	  if (source == 'loadData') {
	    return instance.undoRedo.clear();
	  }
	}
	function exposeUndoRedoMethods(instance) {
	  instance.undo = function() {
	    return instance.undoRedo.undo();
	  };
	  instance.redo = function() {
	    return instance.undoRedo.redo();
	  };
	  instance.isUndoAvailable = function() {
	    return instance.undoRedo.isUndoAvailable();
	  };
	  instance.isRedoAvailable = function() {
	    return instance.undoRedo.isRedoAvailable();
	  };
	  instance.clearUndo = function() {
	    return instance.undoRedo.clear();
	  };
	}
	function removeExposedUndoRedoMethods(instance) {
	  delete instance.undo;
	  delete instance.redo;
	  delete instance.isUndoAvailable;
	  delete instance.isRedoAvailable;
	  delete instance.clearUndo;
	}
	Handsontable.hooks.add('afterInit', init);
	Handsontable.hooks.add('afterUpdateSettings', init);

	//# 
	},{"helpers/dom/event":46,"helpers/object":50}],88:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  registerRenderer: {get: function() {
	      return registerRenderer;
	    }},
	  getRenderer: {get: function() {
	      return getRenderer;
	    }},
	  hasRenderer: {get: function() {
	      return hasRenderer;
	    }},
	  __esModule: {value: true}
	});
	var $__helpers_47_string__;
	var toUpperCaseFirst = ($__helpers_47_string__ = require("helpers/string"), $__helpers_47_string__ && $__helpers_47_string__.__esModule && $__helpers_47_string__ || {default: $__helpers_47_string__}).toUpperCaseFirst;
	var registeredRenderers = {};
	Handsontable.renderers = Handsontable.renderers || {};
	Handsontable.renderers.registerRenderer = registerRenderer;
	Handsontable.renderers.getRenderer = getRenderer;
	function registerRenderer(rendererName, rendererFunction) {
	  var registerName;
	  registeredRenderers[rendererName] = rendererFunction;
	  registerName = toUpperCaseFirst(rendererName) + 'Renderer';
	  Handsontable.renderers[registerName] = rendererFunction;
	  Handsontable[registerName] = rendererFunction;
	}
	function getRenderer(rendererName) {
	  if (typeof rendererName == 'function') {
	    return rendererName;
	  }
	  if (typeof rendererName != 'string') {
	    throw Error('Only strings and functions can be passed as "renderer" parameter');
	  }
	  if (!(rendererName in registeredRenderers)) {
	    throw Error('No editor registered under name "' + rendererName + '"');
	  }
	  return registeredRenderers[rendererName];
	}
	function hasRenderer(rendererName) {
	  return rendererName in registeredRenderers;
	}
	;

	//# 
	},{"helpers/string":52}],89:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  cellDecorator: {get: function() {
	      return cellDecorator;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47_helpers_47_dom_47_element__,
	    $___46__46__47_renderers__;
	var $__0 = ($___46__46__47_helpers_47_dom_47_element__ = require("helpers/dom/element"), $___46__46__47_helpers_47_dom_47_element__ && $___46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47_helpers_47_dom_47_element__}),
	    addClass = $__0.addClass,
	    removeClass = $__0.removeClass;
	var registerRenderer = ($___46__46__47_renderers__ = require("renderers"), $___46__46__47_renderers__ && $___46__46__47_renderers__.__esModule && $___46__46__47_renderers__ || {default: $___46__46__47_renderers__}).registerRenderer;
	;
	registerRenderer('base', cellDecorator);
	Handsontable.renderers.cellDecorator = cellDecorator;
	function cellDecorator(instance, TD, row, col, prop, value, cellProperties) {
	  if (cellProperties.className) {
	    if (TD.className) {
	      TD.className = TD.className + ' ' + cellProperties.className;
	    } else {
	      TD.className = cellProperties.className;
	    }
	  }
	  if (cellProperties.readOnly) {
	    addClass(TD, cellProperties.readOnlyCellClassName);
	  }
	  if (cellProperties.valid === false && cellProperties.invalidCellClassName) {
	    addClass(TD, cellProperties.invalidCellClassName);
	  } else {
	    removeClass(TD, cellProperties.invalidCellClassName);
	  }
	  if (cellProperties.wordWrap === false && cellProperties.noWordWrapClassName) {
	    addClass(TD, cellProperties.noWordWrapClassName);
	  }
	  if (!value && cellProperties.placeholder) {
	    addClass(TD, cellProperties.placeholderCellClassName);
	  }
	}

	//# 
	},{"helpers/dom/element":45,"renderers":88}],90:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  autocompleteRenderer: {get: function() {
	      return autocompleteRenderer;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47_helpers_47_dom_47_element__,
	    $___46__46__47_eventManager__,
	    $___46__46__47_renderers__,
	    $___46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_coords__;
	var $__0 = ($___46__46__47_helpers_47_dom_47_element__ = require("helpers/dom/element"), $___46__46__47_helpers_47_dom_47_element__ && $___46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47_helpers_47_dom_47_element__}),
	    addClass = $__0.addClass,
	    hasClass = $__0.hasClass,
	    empty = $__0.empty;
	var eventManagerObject = ($___46__46__47_eventManager__ = require("eventManager"), $___46__46__47_eventManager__ && $___46__46__47_eventManager__.__esModule && $___46__46__47_eventManager__ || {default: $___46__46__47_eventManager__}).eventManager;
	var $__2 = ($___46__46__47_renderers__ = require("renderers"), $___46__46__47_renderers__ && $___46__46__47_renderers__.__esModule && $___46__46__47_renderers__ || {default: $___46__46__47_renderers__}),
	    getRenderer = $__2.getRenderer,
	    registerRenderer = $__2.registerRenderer;
	var WalkontableCellCoords = ($___46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_coords__ = require("3rdparty/walkontable/src/cell/coords"), $___46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_coords__ && $___46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_coords__.__esModule && $___46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_coords__ || {default: $___46__46__47_3rdparty_47_walkontable_47_src_47_cell_47_coords__}).WalkontableCellCoords;
	var clonableWRAPPER = document.createElement('DIV');
	clonableWRAPPER.className = 'htAutocompleteWrapper';
	var clonableARROW = document.createElement('DIV');
	clonableARROW.className = 'htAutocompleteArrow';
	clonableARROW.appendChild(document.createTextNode(String.fromCharCode(9660)));
	var wrapTdContentWithWrapper = function(TD, WRAPPER) {
	  WRAPPER.innerHTML = TD.innerHTML;
	  empty(TD);
	  TD.appendChild(WRAPPER);
	};
	function autocompleteRenderer(instance, TD, row, col, prop, value, cellProperties) {
	  var WRAPPER = clonableWRAPPER.cloneNode(true);
	  var ARROW = clonableARROW.cloneNode(true);
	  getRenderer('text')(instance, TD, row, col, prop, value, cellProperties);
	  TD.appendChild(ARROW);
	  addClass(TD, 'htAutocomplete');
	  if (!TD.firstChild) {
	    TD.appendChild(document.createTextNode(String.fromCharCode(160)));
	  }
	  if (!instance.acArrowListener) {
	    var eventManager = eventManagerObject(instance);
	    instance.acArrowListener = function(event) {
	      if (hasClass(event.target, 'htAutocompleteArrow')) {
	        instance.view.wt.getSetting('onCellDblClick', null, new WalkontableCellCoords(row, col), TD);
	      }
	    };
	    eventManager.addEventListener(instance.rootElement, 'mousedown', instance.acArrowListener);
	    instance.addHookOnce('afterDestroy', function() {
	      eventManager.destroy();
	    });
	  }
	}
	;
	registerRenderer('autocomplete', autocompleteRenderer);

	//# 
	},{"3rdparty/walkontable/src/cell/coords":5,"eventManager":41,"helpers/dom/element":45,"renderers":88}],91:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  checkboxRenderer: {get: function() {
	      return checkboxRenderer;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47_helpers_47_dom_47_element__,
	    $___46__46__47_helpers_47_string__,
	    $___46__46__47_eventManager__,
	    $___46__46__47_renderers__,
	    $___46__46__47_helpers_47_unicode__,
	    $___46__46__47_helpers_47_dom_47_event__;
	var $__0 = ($___46__46__47_helpers_47_dom_47_element__ = require("helpers/dom/element"), $___46__46__47_helpers_47_dom_47_element__ && $___46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47_helpers_47_dom_47_element__}),
	    empty = $__0.empty,
	    addClass = $__0.addClass,
	    hasClass = $__0.hasClass;
	var equalsIgnoreCase = ($___46__46__47_helpers_47_string__ = require("helpers/string"), $___46__46__47_helpers_47_string__ && $___46__46__47_helpers_47_string__.__esModule && $___46__46__47_helpers_47_string__ || {default: $___46__46__47_helpers_47_string__}).equalsIgnoreCase;
	var EventManager = ($___46__46__47_eventManager__ = require("eventManager"), $___46__46__47_eventManager__ && $___46__46__47_eventManager__.__esModule && $___46__46__47_eventManager__ || {default: $___46__46__47_eventManager__}).EventManager;
	var $__3 = ($___46__46__47_renderers__ = require("renderers"), $___46__46__47_renderers__ && $___46__46__47_renderers__.__esModule && $___46__46__47_renderers__ || {default: $___46__46__47_renderers__}),
	    getRenderer = $__3.getRenderer,
	    registerRenderer = $__3.registerRenderer;
	var KEY_CODES = ($___46__46__47_helpers_47_unicode__ = require("helpers/unicode"), $___46__46__47_helpers_47_unicode__ && $___46__46__47_helpers_47_unicode__.__esModule && $___46__46__47_helpers_47_unicode__ || {default: $___46__46__47_helpers_47_unicode__}).KEY_CODES;
	var $__5 = ($___46__46__47_helpers_47_dom_47_event__ = require("helpers/dom/event"), $___46__46__47_helpers_47_dom_47_event__ && $___46__46__47_helpers_47_dom_47_event__.__esModule && $___46__46__47_helpers_47_dom_47_event__ || {default: $___46__46__47_helpers_47_dom_47_event__}),
	    stopPropagation = $__5.stopPropagation,
	    stopImmediatePropagation = $__5.stopImmediatePropagation,
	    isImmediatePropagationStopped = $__5.isImmediatePropagationStopped;
	var isListeningKeyDownEvent = new WeakMap();
	var BAD_VALUE_CLASS = 'htBadValue';
	function checkboxRenderer(instance, TD, row, col, prop, value, cellProperties) {
	  var eventManager = new EventManager(instance);
	  var input = createInput();
	  var labelOptions = cellProperties.label;
	  var badValue = false;
	  if (typeof cellProperties.checkedTemplate === 'undefined') {
	    cellProperties.checkedTemplate = true;
	  }
	  if (typeof cellProperties.uncheckedTemplate === 'undefined') {
	    cellProperties.uncheckedTemplate = false;
	  }
	  empty(TD);
	  if (value === cellProperties.checkedTemplate || equalsIgnoreCase(value, cellProperties.checkedTemplate)) {
	    input.checked = true;
	  } else if (value === cellProperties.uncheckedTemplate || equalsIgnoreCase(value, cellProperties.uncheckedTemplate)) {
	    input.checked = false;
	  } else if (value === null) {
	    addClass(input, 'noValue');
	  } else {
	    input.style.display = 'none';
	    addClass(input, BAD_VALUE_CLASS);
	    badValue = true;
	  }
	  if (!badValue && labelOptions) {
	    var labelText = '';
	    if (labelOptions.value) {
	      labelText = typeof labelOptions.value === 'function' ? labelOptions.value.call(this, row, col, prop, value) : labelOptions.value;
	    } else if (labelOptions.property) {
	      labelText = instance.getDataAtRowProp(row, labelOptions.property);
	    }
	    var label = createLabel(labelText);
	    if (labelOptions.position === 'before') {
	      label.appendChild(input);
	    } else {
	      label.insertBefore(input, label.firstChild);
	    }
	    input = label;
	  }
	  TD.appendChild(input);
	  if (badValue) {
	    TD.appendChild(document.createTextNode('#bad-value#'));
	  }
	  if (cellProperties.readOnly) {
	    eventManager.addEventListener(input, 'click', preventDefault);
	  } else {
	    eventManager.addEventListener(input, 'mousedown', stopPropagation);
	    eventManager.addEventListener(input, 'mouseup', stopPropagation);
	    eventManager.addEventListener(input, 'change', (function(event) {
	      instance.setDataAtRowProp(row, prop, event.target.checked ? cellProperties.checkedTemplate : cellProperties.uncheckedTemplate);
	    }));
	  }
	  if (!isListeningKeyDownEvent.has(instance)) {
	    isListeningKeyDownEvent.set(instance, true);
	    instance.addHook('beforeKeyDown', onBeforeKeyDown);
	  }
	  function onBeforeKeyDown(event) {
	    var allowedKeys = [KEY_CODES.SPACE, KEY_CODES.ENTER, KEY_CODES.DELETE, KEY_CODES.BACKSPACE];
	    if (allowedKeys.indexOf(event.keyCode) !== -1 && !isImmediatePropagationStopped(event)) {
	      eachSelectedCheckboxCell(function() {
	        stopImmediatePropagation(event);
	        event.preventDefault();
	      });
	    }
	    if (event.keyCode == KEY_CODES.SPACE || event.keyCode == KEY_CODES.ENTER) {
	      toggleSelected();
	    }
	    if (event.keyCode == KEY_CODES.DELETE || event.keyCode == KEY_CODES.BACKSPACE) {
	      toggleSelected(false);
	    }
	  }
	  function toggleSelected() {
	    var checked = arguments[0] !== (void 0) ? arguments[0] : null;
	    eachSelectedCheckboxCell(function(checkboxes) {
	      for (var i = 0,
	          len = checkboxes.length; i < len; i++) {
	        if (hasClass(checkboxes[i], BAD_VALUE_CLASS) && checked === null) {
	          return;
	        }
	        toggleCheckbox(checkboxes[i], checked);
	      }
	    });
	  }
	  function toggleCheckbox(checkbox) {
	    var checked = arguments[1] !== (void 0) ? arguments[1] : null;
	    if (checked === null) {
	      checkbox.checked = !checkbox.checked;
	    } else {
	      checkbox.checked = checked;
	    }
	    eventManager.fireEvent(checkbox, 'change');
	  }
	  function eachSelectedCheckboxCell(callback) {
	    var selRange = instance.getSelectedRange();
	    var topLeft = selRange.getTopLeftCorner();
	    var bottomRight = selRange.getBottomRightCorner();
	    for (var row = topLeft.row; row <= bottomRight.row; row++) {
	      for (var col = topLeft.col; col <= bottomRight.col; col++) {
	        var cell = instance.getCell(row, col);
	        var cellProperties$__6 = instance.getCellMeta(row, col);
	        var checkboxes = cell.querySelectorAll('input[type=checkbox]');
	        if (checkboxes.length > 0 && !cellProperties$__6.readOnly) {
	          callback(checkboxes);
	        }
	      }
	    }
	  }
	}
	;
	registerRenderer('checkbox', checkboxRenderer);
	function createInput() {
	  var input = document.createElement('input');
	  input.className = 'htCheckboxRendererInput';
	  input.type = 'checkbox';
	  input.setAttribute('autocomplete', 'off');
	  return input.cloneNode(false);
	}
	function createLabel(text) {
	  var label = document.createElement('label');
	  label.className = 'htCheckboxRendererLabel';
	  label.appendChild(document.createTextNode(text));
	  return label.cloneNode(true);
	}
	function preventDefault(event) {
	  event.preventDefault();
	}

	//# 
	},{"eventManager":41,"helpers/dom/element":45,"helpers/dom/event":46,"helpers/string":52,"helpers/unicode":53,"renderers":88}],92:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  htmlRenderer: {get: function() {
	      return htmlRenderer;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47_helpers_47_dom_47_element__,
	    $___46__46__47_renderers__;
	var fastInnerHTML = ($___46__46__47_helpers_47_dom_47_element__ = require("helpers/dom/element"), $___46__46__47_helpers_47_dom_47_element__ && $___46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47_helpers_47_dom_47_element__}).fastInnerHTML;
	var $__1 = ($___46__46__47_renderers__ = require("renderers"), $___46__46__47_renderers__ && $___46__46__47_renderers__.__esModule && $___46__46__47_renderers__ || {default: $___46__46__47_renderers__}),
	    getRenderer = $__1.getRenderer,
	    registerRenderer = $__1.registerRenderer;
	function htmlRenderer(instance, TD, row, col, prop, value, cellProperties) {
	  getRenderer('base').apply(this, arguments);
	  fastInnerHTML(TD, value);
	}
	;
	registerRenderer('html', htmlRenderer);

	//# 
	},{"helpers/dom/element":45,"renderers":88}],93:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  numericRenderer: {get: function() {
	      return numericRenderer;
	    }},
	  __esModule: {value: true}
	});
	var $__numeral__,
	    $___46__46__47_helpers_47_dom_47_element__,
	    $___46__46__47_renderers__,
	    $___46__46__47_helpers_47_number__;
	var numeral = ($__numeral__ = require("numeral"), $__numeral__ && $__numeral__.__esModule && $__numeral__ || {default: $__numeral__}).default;
	var addClass = ($___46__46__47_helpers_47_dom_47_element__ = require("helpers/dom/element"), $___46__46__47_helpers_47_dom_47_element__ && $___46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47_helpers_47_dom_47_element__}).addClass;
	var $__2 = ($___46__46__47_renderers__ = require("renderers"), $___46__46__47_renderers__ && $___46__46__47_renderers__.__esModule && $___46__46__47_renderers__ || {default: $___46__46__47_renderers__}),
	    getRenderer = $__2.getRenderer,
	    registerRenderer = $__2.registerRenderer;
	var isNumeric = ($___46__46__47_helpers_47_number__ = require("helpers/number"), $___46__46__47_helpers_47_number__ && $___46__46__47_helpers_47_number__.__esModule && $___46__46__47_helpers_47_number__ || {default: $___46__46__47_helpers_47_number__}).isNumeric;
	function numericRenderer(instance, TD, row, col, prop, value, cellProperties) {
	  if (isNumeric(value)) {
	    if (typeof cellProperties.language !== 'undefined') {
	      numeral.language(cellProperties.language);
	    }
	    value = numeral(value).format(cellProperties.format || '0');
	    addClass(TD, 'htNumeric');
	  }
	  getRenderer('text')(instance, TD, row, col, prop, value, cellProperties);
	}
	;
	registerRenderer('numeric', numericRenderer);

	//# 
	},{"helpers/dom/element":45,"helpers/number":49,"numeral":"numeral","renderers":88}],94:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  passwordRenderer: {get: function() {
	      return passwordRenderer;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47_helpers_47_dom_47_element__,
	    $___46__46__47_renderers__;
	var fastInnerHTML = ($___46__46__47_helpers_47_dom_47_element__ = require("helpers/dom/element"), $___46__46__47_helpers_47_dom_47_element__ && $___46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47_helpers_47_dom_47_element__}).fastInnerHTML;
	var $__1 = ($___46__46__47_renderers__ = require("renderers"), $___46__46__47_renderers__ && $___46__46__47_renderers__.__esModule && $___46__46__47_renderers__ || {default: $___46__46__47_renderers__}),
	    getRenderer = $__1.getRenderer,
	    registerRenderer = $__1.registerRenderer;
	function passwordRenderer(instance, TD, row, col, prop, value, cellProperties) {
	  getRenderer('text').apply(this, arguments);
	  value = TD.innerHTML;
	  var hash;
	  var hashLength = cellProperties.hashLength || value.length;
	  var hashSymbol = cellProperties.hashSymbol || '*';
	  for (hash = ''; hash.split(hashSymbol).length - 1 < hashLength; hash += hashSymbol) {}
	  fastInnerHTML(TD, hash);
	}
	;
	registerRenderer('password', passwordRenderer);

	//# 
	},{"helpers/dom/element":45,"renderers":88}],95:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  textRenderer: {get: function() {
	      return textRenderer;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47_helpers_47_dom_47_element__,
	    $___46__46__47_helpers_47_mixed__,
	    $___46__46__47_renderers__;
	var $__0 = ($___46__46__47_helpers_47_dom_47_element__ = require("helpers/dom/element"), $___46__46__47_helpers_47_dom_47_element__ && $___46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47_helpers_47_dom_47_element__}),
	    empty = $__0.empty,
	    fastInnerText = $__0.fastInnerText;
	var stringify = ($___46__46__47_helpers_47_mixed__ = require("helpers/mixed"), $___46__46__47_helpers_47_mixed__ && $___46__46__47_helpers_47_mixed__.__esModule && $___46__46__47_helpers_47_mixed__ || {default: $___46__46__47_helpers_47_mixed__}).stringify;
	var $__2 = ($___46__46__47_renderers__ = require("renderers"), $___46__46__47_renderers__ && $___46__46__47_renderers__.__esModule && $___46__46__47_renderers__ || {default: $___46__46__47_renderers__}),
	    getRenderer = $__2.getRenderer,
	    registerRenderer = $__2.registerRenderer;
	function textRenderer(instance, TD, row, col, prop, value, cellProperties) {
	  getRenderer('base').apply(this, arguments);
	  if (!value && cellProperties.placeholder) {
	    value = cellProperties.placeholder;
	  }
	  var escaped = stringify(value);
	  if (!instance.getSettings().trimWhitespace) {
	    escaped = escaped.replace(/ /g, String.fromCharCode(160));
	  }
	  if (cellProperties.rendererTemplate) {
	    empty(TD);
	    var TEMPLATE = document.createElement('TEMPLATE');
	    TEMPLATE.setAttribute('bind', '{{}}');
	    TEMPLATE.innerHTML = cellProperties.rendererTemplate;
	    HTMLTemplateElement.decorate(TEMPLATE);
	    TEMPLATE.model = instance.getSourceDataAtRow(row);
	    TD.appendChild(TEMPLATE);
	  } else {
	    fastInnerText(TD, escaped);
	  }
	}
	;
	registerRenderer('text', textRenderer);

	//# 
	},{"helpers/dom/element":45,"helpers/mixed":48,"renderers":88}],96:[function(require,module,exports){
	"use strict";
	(function(global) {
	  'use strict';
	  if (global.$traceurRuntime) {
	    return;
	  }
	  var $Object = Object;
	  var $TypeError = TypeError;
	  var $create = $Object.create;
	  var $defineProperties = $Object.defineProperties;
	  var $defineProperty = $Object.defineProperty;
	  var $freeze = $Object.freeze;
	  var $getOwnPropertyDescriptor = $Object.getOwnPropertyDescriptor;
	  var $getOwnPropertyNames = $Object.getOwnPropertyNames;
	  var $keys = $Object.keys;
	  var $hasOwnProperty = $Object.prototype.hasOwnProperty;
	  var $preventExtensions = Object.preventExtensions;
	  var $seal = Object.seal;
	  var $isExtensible = Object.isExtensible;
	  function nonEnum(value) {
	    return {
	      configurable: true,
	      enumerable: false,
	      value: value,
	      writable: true
	    };
	  }
	  var method = nonEnum;
	  var counter = 0;
	  function newUniqueString() {
	    return '__$' + Math.floor(Math.random() * 1e9) + '$' + ++counter + '$__';
	  }
	  var symbolInternalProperty = newUniqueString();
	  var symbolDescriptionProperty = newUniqueString();
	  var symbolDataProperty = newUniqueString();
	  var symbolValues = $create(null);
	  var privateNames = $create(null);
	  function isPrivateName(s) {
	    return privateNames[s];
	  }
	  function createPrivateName() {
	    var s = newUniqueString();
	    privateNames[s] = true;
	    return s;
	  }
	  function isShimSymbol(symbol) {
	    return typeof symbol === 'object' && symbol instanceof SymbolValue;
	  }
	  function typeOf(v) {
	    if (isShimSymbol(v))
	      return 'symbol';
	    return typeof v;
	  }
	  function Symbol(description) {
	    var value = new SymbolValue(description);
	    if (!(this instanceof Symbol))
	      return value;
	    throw new TypeError('Symbol cannot be new\'ed');
	  }
	  $defineProperty(Symbol.prototype, 'constructor', nonEnum(Symbol));
	  $defineProperty(Symbol.prototype, 'toString', method(function() {
	    var symbolValue = this[symbolDataProperty];
	    if (!getOption('symbols'))
	      return symbolValue[symbolInternalProperty];
	    if (!symbolValue)
	      throw TypeError('Conversion from symbol to string');
	    var desc = symbolValue[symbolDescriptionProperty];
	    if (desc === undefined)
	      desc = '';
	    return 'Symbol(' + desc + ')';
	  }));
	  $defineProperty(Symbol.prototype, 'valueOf', method(function() {
	    var symbolValue = this[symbolDataProperty];
	    if (!symbolValue)
	      throw TypeError('Conversion from symbol to string');
	    if (!getOption('symbols'))
	      return symbolValue[symbolInternalProperty];
	    return symbolValue;
	  }));
	  function SymbolValue(description) {
	    var key = newUniqueString();
	    $defineProperty(this, symbolDataProperty, {value: this});
	    $defineProperty(this, symbolInternalProperty, {value: key});
	    $defineProperty(this, symbolDescriptionProperty, {value: description});
	    freeze(this);
	    symbolValues[key] = this;
	  }
	  $defineProperty(SymbolValue.prototype, 'constructor', nonEnum(Symbol));
	  $defineProperty(SymbolValue.prototype, 'toString', {
	    value: Symbol.prototype.toString,
	    enumerable: false
	  });
	  $defineProperty(SymbolValue.prototype, 'valueOf', {
	    value: Symbol.prototype.valueOf,
	    enumerable: false
	  });
	  var hashProperty = createPrivateName();
	  var hashPropertyDescriptor = {value: undefined};
	  var hashObjectProperties = {
	    hash: {value: undefined},
	    self: {value: undefined}
	  };
	  var hashCounter = 0;
	  function getOwnHashObject(object) {
	    var hashObject = object[hashProperty];
	    if (hashObject && hashObject.self === object)
	      return hashObject;
	    if ($isExtensible(object)) {
	      hashObjectProperties.hash.value = hashCounter++;
	      hashObjectProperties.self.value = object;
	      hashPropertyDescriptor.value = $create(null, hashObjectProperties);
	      $defineProperty(object, hashProperty, hashPropertyDescriptor);
	      return hashPropertyDescriptor.value;
	    }
	    return undefined;
	  }
	  function freeze(object) {
	    getOwnHashObject(object);
	    return $freeze.apply(this, arguments);
	  }
	  function preventExtensions(object) {
	    getOwnHashObject(object);
	    return $preventExtensions.apply(this, arguments);
	  }
	  function seal(object) {
	    getOwnHashObject(object);
	    return $seal.apply(this, arguments);
	  }
	  freeze(SymbolValue.prototype);
	  function isSymbolString(s) {
	    return symbolValues[s] || privateNames[s];
	  }
	  function toProperty(name) {
	    if (isShimSymbol(name))
	      return name[symbolInternalProperty];
	    return name;
	  }
	  function removeSymbolKeys(array) {
	    var rv = [];
	    for (var i = 0; i < array.length; i++) {
	      if (!isSymbolString(array[i])) {
	        rv.push(array[i]);
	      }
	    }
	    return rv;
	  }
	  function getOwnPropertyNames(object) {
	    return removeSymbolKeys($getOwnPropertyNames(object));
	  }
	  function keys(object) {
	    return removeSymbolKeys($keys(object));
	  }
	  function getOwnPropertySymbols(object) {
	    var rv = [];
	    var names = $getOwnPropertyNames(object);
	    for (var i = 0; i < names.length; i++) {
	      var symbol = symbolValues[names[i]];
	      if (symbol) {
	        rv.push(symbol);
	      }
	    }
	    return rv;
	  }
	  function getOwnPropertyDescriptor(object, name) {
	    return $getOwnPropertyDescriptor(object, toProperty(name));
	  }
	  function hasOwnProperty(name) {
	    return $hasOwnProperty.call(this, toProperty(name));
	  }
	  function getOption(name) {
	    return global.traceur && global.traceur.options[name];
	  }
	  function defineProperty(object, name, descriptor) {
	    if (isShimSymbol(name)) {
	      name = name[symbolInternalProperty];
	    }
	    $defineProperty(object, name, descriptor);
	    return object;
	  }
	  function polyfillObject(Object) {
	    $defineProperty(Object, 'defineProperty', {value: defineProperty});
	    $defineProperty(Object, 'getOwnPropertyNames', {value: getOwnPropertyNames});
	    $defineProperty(Object, 'getOwnPropertyDescriptor', {value: getOwnPropertyDescriptor});
	    $defineProperty(Object.prototype, 'hasOwnProperty', {value: hasOwnProperty});
	    $defineProperty(Object, 'freeze', {value: freeze});
	    $defineProperty(Object, 'preventExtensions', {value: preventExtensions});
	    $defineProperty(Object, 'seal', {value: seal});
	    $defineProperty(Object, 'keys', {value: keys});
	  }
	  function exportStar(object) {
	    for (var i = 1; i < arguments.length; i++) {
	      var names = $getOwnPropertyNames(arguments[i]);
	      for (var j = 0; j < names.length; j++) {
	        var name = names[j];
	        if (isSymbolString(name))
	          continue;
	        (function(mod, name) {
	          $defineProperty(object, name, {
	            get: function() {
	              return mod[name];
	            },
	            enumerable: true
	          });
	        })(arguments[i], names[j]);
	      }
	    }
	    return object;
	  }
	  function isObject(x) {
	    return x != null && (typeof x === 'object' || typeof x === 'function');
	  }
	  function toObject(x) {
	    if (x == null)
	      throw $TypeError();
	    return $Object(x);
	  }
	  function checkObjectCoercible(argument) {
	    if (argument == null) {
	      throw new TypeError('Value cannot be converted to an Object');
	    }
	    return argument;
	  }
	  function polyfillSymbol(global, Symbol) {
	    if (!global.Symbol) {
	      global.Symbol = Symbol;
	      Object.getOwnPropertySymbols = getOwnPropertySymbols;
	    }
	    if (!global.Symbol.iterator) {
	      global.Symbol.iterator = Symbol('Symbol.iterator');
	    }
	  }
	  function setupGlobals(global) {
	    polyfillSymbol(global, Symbol);
	    global.Reflect = global.Reflect || {};
	    global.Reflect.global = global.Reflect.global || global;
	    polyfillObject(global.Object);
	  }
	  setupGlobals(global);
	  global.$traceurRuntime = {
	    checkObjectCoercible: checkObjectCoercible,
	    createPrivateName: createPrivateName,
	    defineProperties: $defineProperties,
	    defineProperty: $defineProperty,
	    exportStar: exportStar,
	    getOwnHashObject: getOwnHashObject,
	    getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
	    getOwnPropertyNames: $getOwnPropertyNames,
	    isObject: isObject,
	    isPrivateName: isPrivateName,
	    isSymbolString: isSymbolString,
	    keys: $keys,
	    setupGlobals: setupGlobals,
	    toObject: toObject,
	    toProperty: toProperty,
	    typeof: typeOf
	  };
	})(window);
	(function() {
	  'use strict';
	  var $toProperty = $traceurRuntime.toProperty;
	  function spread() {
	    var rv = [],
	        j = 0,
	        iterResult;
	    for (var i = 0; i < arguments.length; i++) {
	      var valueToSpread = $traceurRuntime.checkObjectCoercible(arguments[i]);
	      if (typeof valueToSpread[$toProperty(Symbol.iterator)] !== 'function') {
	        throw new TypeError('Cannot spread non-iterable object.');
	      }
	      var iter = valueToSpread[$toProperty(Symbol.iterator)]();
	      while (!(iterResult = iter.next()).done) {
	        rv[j++] = iterResult.value;
	      }
	    }
	    return rv;
	  }
	  $traceurRuntime.spread = spread;
	})();
	(function() {
	  'use strict';
	  var $Object = Object;
	  var $TypeError = TypeError;
	  var $create = $Object.create;
	  var $defineProperties = $traceurRuntime.defineProperties;
	  var $defineProperty = $traceurRuntime.defineProperty;
	  var $getOwnPropertyDescriptor = $traceurRuntime.getOwnPropertyDescriptor;
	  var $getPrototypeOf = Object.getPrototypeOf;
	  var $toProperty = $traceurRuntime.toProperty;
	  var $__0 = Object,
	      getOwnPropertyNames = $__0.getOwnPropertyNames,
	      getOwnPropertySymbols = $__0.getOwnPropertySymbols;
	  function superDescriptor(homeObject, name) {
	    var proto = $getPrototypeOf(homeObject);
	    do {
	      var result = $getOwnPropertyDescriptor(proto, name);
	      if (result)
	        return result;
	      proto = $getPrototypeOf(proto);
	    } while (proto);
	    return undefined;
	  }
	  function superConstructor(ctor) {
	    return ctor.__proto__;
	  }
	  function superCall(self, homeObject, name, args) {
	    return superGet(self, homeObject, name).apply(self, args);
	  }
	  function superGet(self, homeObject, name) {
	    var descriptor = superDescriptor(homeObject, name);
	    if (descriptor) {
	      if (!descriptor.get)
	        return descriptor.value;
	      return descriptor.get.call(self);
	    }
	    return undefined;
	  }
	  function superSet(self, homeObject, name, value) {
	    var descriptor = superDescriptor(homeObject, name);
	    if (descriptor && descriptor.set) {
	      descriptor.set.call(self, value);
	      return value;
	    }
	    throw $TypeError(("super has no setter '" + name + "'."));
	  }
	  function getDescriptors(object) {
	    var descriptors = {};
	    var names = getOwnPropertyNames(object);
	    for (var i = 0; i < names.length; i++) {
	      var name = names[i];
	      descriptors[name] = $getOwnPropertyDescriptor(object, name);
	    }
	    var symbols = getOwnPropertySymbols(object);
	    for (var i = 0; i < symbols.length; i++) {
	      var symbol = symbols[i];
	      descriptors[$toProperty(symbol)] = $getOwnPropertyDescriptor(object, $toProperty(symbol));
	    }
	    return descriptors;
	  }
	  function createClass(ctor, object, staticObject, superClass) {
	    $defineProperty(object, 'constructor', {
	      value: ctor,
	      configurable: true,
	      enumerable: false,
	      writable: true
	    });
	    if (arguments.length > 3) {
	      if (typeof superClass === 'function')
	        ctor.__proto__ = superClass;
	      ctor.prototype = $create(getProtoParent(superClass), getDescriptors(object));
	    } else {
	      ctor.prototype = object;
	    }
	    $defineProperty(ctor, 'prototype', {
	      configurable: false,
	      writable: false
	    });
	    return $defineProperties(ctor, getDescriptors(staticObject));
	  }
	  function getProtoParent(superClass) {
	    if (typeof superClass === 'function') {
	      var prototype = superClass.prototype;
	      if ($Object(prototype) === prototype || prototype === null)
	        return superClass.prototype;
	      throw new $TypeError('super prototype must be an Object or null');
	    }
	    if (superClass === null)
	      return null;
	    throw new $TypeError(("Super expression must either be null or a function, not " + typeof superClass + "."));
	  }
	  function defaultSuperCall(self, homeObject, args) {
	    if ($getPrototypeOf(homeObject) !== null)
	      superCall(self, homeObject, 'constructor', args);
	  }
	  $traceurRuntime.createClass = createClass;
	  $traceurRuntime.defaultSuperCall = defaultSuperCall;
	  $traceurRuntime.superCall = superCall;
	  $traceurRuntime.superConstructor = superConstructor;
	  $traceurRuntime.superGet = superGet;
	  $traceurRuntime.superSet = superSet;
	})();

	//# 
	},{}],97:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  TableView: {get: function() {
	      return TableView;
	    }},
	  __esModule: {value: true}
	});
	var $__helpers_47_dom_47_element__,
	    $__eventManager__,
	    $__helpers_47_dom_47_event__,
	    $__3rdparty_47_walkontable_47_src_47_cell_47_coords__,
	    $__3rdparty_47_walkontable_47_src_47_selection__,
	    $__3rdparty_47_walkontable_47_src_47_core__;
	var $__0 = ($__helpers_47_dom_47_element__ = require("helpers/dom/element"), $__helpers_47_dom_47_element__ && $__helpers_47_dom_47_element__.__esModule && $__helpers_47_dom_47_element__ || {default: $__helpers_47_dom_47_element__}),
	    addClass = $__0.addClass,
	    empty = $__0.empty,
	    fastInnerHTML = $__0.fastInnerHTML,
	    fastInnerText = $__0.fastInnerText,
	    getScrollbarWidth = $__0.getScrollbarWidth,
	    hasClass = $__0.hasClass,
	    isChildOf = $__0.isChildOf,
	    isInput = $__0.isInput,
	    isOutsideInput = $__0.isOutsideInput;
	var eventManagerObject = ($__eventManager__ = require("eventManager"), $__eventManager__ && $__eventManager__.__esModule && $__eventManager__ || {default: $__eventManager__}).eventManager;
	var $__2 = ($__helpers_47_dom_47_event__ = require("helpers/dom/event"), $__helpers_47_dom_47_event__ && $__helpers_47_dom_47_event__.__esModule && $__helpers_47_dom_47_event__ || {default: $__helpers_47_dom_47_event__}),
	    stopPropagation = $__2.stopPropagation,
	    isImmediatePropagationStopped = $__2.isImmediatePropagationStopped;
	var WalkontableCellCoords = ($__3rdparty_47_walkontable_47_src_47_cell_47_coords__ = require("3rdparty/walkontable/src/cell/coords"), $__3rdparty_47_walkontable_47_src_47_cell_47_coords__ && $__3rdparty_47_walkontable_47_src_47_cell_47_coords__.__esModule && $__3rdparty_47_walkontable_47_src_47_cell_47_coords__ || {default: $__3rdparty_47_walkontable_47_src_47_cell_47_coords__}).WalkontableCellCoords;
	var WalkontableSelection = ($__3rdparty_47_walkontable_47_src_47_selection__ = require("3rdparty/walkontable/src/selection"), $__3rdparty_47_walkontable_47_src_47_selection__ && $__3rdparty_47_walkontable_47_src_47_selection__.__esModule && $__3rdparty_47_walkontable_47_src_47_selection__ || {default: $__3rdparty_47_walkontable_47_src_47_selection__}).WalkontableSelection;
	var Walkontable = ($__3rdparty_47_walkontable_47_src_47_core__ = require("3rdparty/walkontable/src/core"), $__3rdparty_47_walkontable_47_src_47_core__ && $__3rdparty_47_walkontable_47_src_47_core__.__esModule && $__3rdparty_47_walkontable_47_src_47_core__ || {default: $__3rdparty_47_walkontable_47_src_47_core__}).Walkontable;
	Handsontable.TableView = TableView;
	function TableView(instance) {
	  var that = this;
	  this.eventManager = eventManagerObject(instance);
	  this.instance = instance;
	  this.settings = instance.getSettings();
	  this.selectionMouseDown = false;
	  var originalStyle = instance.rootElement.getAttribute('style');
	  if (originalStyle) {
	    instance.rootElement.setAttribute('data-originalstyle', originalStyle);
	  }
	  addClass(instance.rootElement, 'handsontable');
	  var table = document.createElement('TABLE');
	  addClass(table, 'htCore');
	  if (instance.getSettings().tableClassName) {
	    addClass(table, instance.getSettings().tableClassName);
	  }
	  this.THEAD = document.createElement('THEAD');
	  table.appendChild(this.THEAD);
	  this.TBODY = document.createElement('TBODY');
	  table.appendChild(this.TBODY);
	  instance.table = table;
	  instance.container.insertBefore(table, instance.container.firstChild);
	  this.eventManager.addEventListener(instance.rootElement, 'mousedown', function(event) {
	    this.selectionMouseDown = true;
	    if (!that.isTextSelectionAllowed(event.target)) {
	      clearTextSelection();
	      event.preventDefault();
	      window.focus();
	    }
	  });
	  this.eventManager.addEventListener(instance.rootElement, 'mouseup', function(event) {
	    this.selectionMouseDown = false;
	  });
	  this.eventManager.addEventListener(instance.rootElement, 'mousemove', function(event) {
	    if (this.selectionMouseDown && !that.isTextSelectionAllowed(event.target)) {
	      clearTextSelection();
	      event.preventDefault();
	    }
	  });
	  this.eventManager.addEventListener(document.documentElement, 'keyup', function(event) {
	    if (instance.selection.isInProgress() && !event.shiftKey) {
	      instance.selection.finish();
	    }
	  });
	  var isMouseDown;
	  this.isMouseDown = function() {
	    return isMouseDown;
	  };
	  this.eventManager.addEventListener(document.documentElement, 'mouseup', function(event) {
	    if (instance.selection.isInProgress() && event.which === 1) {
	      instance.selection.finish();
	    }
	    isMouseDown = false;
	    if (isOutsideInput(document.activeElement)) {
	      instance.unlisten();
	    }
	  });
	  this.eventManager.addEventListener(document.documentElement, 'mousedown', function(event) {
	    var next = event.target;
	    var eventX = event.x || event.clientX;
	    var eventY = event.y || event.clientY;
	    if (isMouseDown || !instance.rootElement) {
	      return;
	    }
	    if (next === instance.view.wt.wtTable.holder) {
	      var scrollbarWidth = getScrollbarWidth();
	      if (document.elementFromPoint(eventX + scrollbarWidth, eventY) !== instance.view.wt.wtTable.holder || document.elementFromPoint(eventX, eventY + scrollbarWidth) !== instance.view.wt.wtTable.holder) {
	        return;
	      }
	    } else {
	      while (next !== document.documentElement) {
	        if (next === null) {
	          if (event.isTargetWebComponent) {
	            break;
	          }
	          return;
	        }
	        if (next === instance.rootElement) {
	          return;
	        }
	        next = next.parentNode;
	      }
	    }
	    if (that.settings.outsideClickDeselects) {
	      instance.deselectCell();
	    } else {
	      instance.destroyEditor();
	    }
	  });
	  this.eventManager.addEventListener(table, 'selectstart', function(event) {
	    if (that.settings.fragmentSelection || isInput(event.target)) {
	      return;
	    }
	    event.preventDefault();
	  });
	  var clearTextSelection = function() {
	    if (window.getSelection) {
	      if (window.getSelection().empty) {
	        window.getSelection().empty();
	      } else if (window.getSelection().removeAllRanges) {
	        window.getSelection().removeAllRanges();
	      }
	    } else if (document.selection) {
	      document.selection.empty();
	    }
	  };
	  var selections = [new WalkontableSelection({
	    className: 'current',
	    border: {
	      width: 2,
	      color: '#5292F7',
	      cornerVisible: function() {
	        return that.settings.fillHandle && !that.isCellEdited() && !instance.selection.isMultiple();
	      },
	      multipleSelectionHandlesVisible: function() {
	        return !that.isCellEdited() && !instance.selection.isMultiple();
	      }
	    }
	  }), new WalkontableSelection({
	    className: 'area',
	    border: {
	      width: 1,
	      color: '#89AFF9',
	      cornerVisible: function() {
	        return that.settings.fillHandle && !that.isCellEdited() && instance.selection.isMultiple();
	      },
	      multipleSelectionHandlesVisible: function() {
	        return !that.isCellEdited() && instance.selection.isMultiple();
	      }
	    }
	  }), new WalkontableSelection({
	    className: 'highlight',
	    highlightRowClassName: that.settings.currentRowClassName,
	    highlightColumnClassName: that.settings.currentColClassName
	  }), new WalkontableSelection({
	    className: 'fill',
	    border: {
	      width: 1,
	      color: 'red'
	    }
	  })];
	  selections.current = selections[0];
	  selections.area = selections[1];
	  selections.highlight = selections[2];
	  selections.fill = selections[3];
	  var walkontableConfig = {
	    debug: function() {
	      return that.settings.debug;
	    },
	    externalRowCalculator: this.instance.getPlugin('autoRowSize') && this.instance.getPlugin('autoRowSize').isEnabled(),
	    table: table,
	    stretchH: this.settings.stretchH,
	    data: instance.getDataAtCell,
	    totalRows: (function() {
	      return instance.countRows();
	    }),
	    totalColumns: (function() {
	      return instance.countCols();
	    }),
	    fixedColumnsLeft: function() {
	      return that.settings.fixedColumnsLeft;
	    },
	    fixedRowsTop: function() {
	      return that.settings.fixedRowsTop;
	    },
	    fixedRowsBottom: function() {
	      return that.settings.fixedRowsBottom;
	    },
	    minSpareRows: function() {
	      return that.settings.minSpareRows;
	    },
	    renderAllRows: that.settings.renderAllRows,
	    rowHeaders: function() {
	      var headerRenderers = [];
	      if (instance.hasRowHeaders()) {
	        headerRenderers.push(function(row, TH) {
	          that.appendRowHeader(row, TH);
	        });
	      }
	      Handsontable.hooks.run(instance, 'afterGetRowHeaderRenderers', headerRenderers);
	      return headerRenderers;
	    },
	    columnHeaders: function() {
	      var headerRenderers = [];
	      if (instance.hasColHeaders()) {
	        headerRenderers.push(function(column, TH) {
	          that.appendColHeader(column, TH);
	        });
	      }
	      Handsontable.hooks.run(instance, 'afterGetColumnHeaderRenderers', headerRenderers);
	      return headerRenderers;
	    },
	    columnWidth: instance.getColWidth,
	    rowHeight: instance.getRowHeight,
	    cellRenderer: function(row, col, TD) {
	      var prop = that.instance.colToProp(col),
	          cellProperties = that.instance.getCellMeta(row, col),
	          renderer = that.instance.getCellRenderer(cellProperties);
	      var value = that.instance.getDataAtRowProp(row, prop);
	      renderer(that.instance, TD, row, col, prop, value, cellProperties);
	      Handsontable.hooks.run(that.instance, 'afterRenderer', TD, row, col, prop, value, cellProperties);
	    },
	    selections: selections,
	    hideBorderOnMouseDownOver: function() {
	      return that.settings.fragmentSelection;
	    },
	    onCellMouseDown: function(event, coords, TD, wt) {
	      var colspanOffset;
	      var TR = TD.parentNode;
	      var THEAD = TR.parentNode;
	      var headerLevel;
	      var headerColspan;
	      instance.listen();
	      that.activeWt = wt;
	      isMouseDown = true;
	      Handsontable.hooks.run(instance, 'beforeOnCellMouseDown', event, coords, TD);
	      instance.selection.setSelectedHeaders(false, false);
	      if (!isImmediatePropagationStopped(event)) {
	        if (event.button === 2 && instance.selection.inInSelection(coords)) {
	          var nothing = 1;
	        } else if (event.shiftKey) {
	          if (coords.row >= 0 && coords.col >= 0) {
	            instance.selection.setRangeEnd(coords);
	          }
	        } else {
	          if ((coords.row < 0 || coords.col < 0) && (coords.row >= 0 || coords.col >= 0)) {
	            if (coords.row < 0) {
	              headerLevel = THEAD.childNodes.length - Array.prototype.indexOf.call(THEAD.childNodes, TR) - 1;
	              headerColspan = instance.getHeaderColspan(coords.col, headerLevel);
	              instance.selection.setSelectedHeaders(false, true);
	              instance.selectCell(0, coords.col, instance.countRows() - 1, coords.col + Math.max(0, headerColspan - 1));
	            }
	            if (coords.col < 0) {
	              instance.selection.setSelectedHeaders(true, false);
	              instance.selectCell(coords.row, 0, coords.row, instance.countCols() - 1);
	            }
	          } else {
	            coords.row = coords.row < 0 ? 0 : coords.row;
	            coords.col = coords.col < 0 ? 0 : coords.col;
	            instance.selection.setRangeStart(coords);
	          }
	        }
	        Handsontable.hooks.run(instance, 'afterOnCellMouseDown', event, coords, TD);
	        that.activeWt = that.wt;
	      }
	    },
	    onCellMouseOver: function(event, coords, TD, wt) {
	      that.activeWt = wt;
	      if (coords.row >= 0 && coords.col >= 0) {
	        if (isMouseDown) {
	          instance.selection.setRangeEnd(coords);
	        }
	      } else {
	        if (isMouseDown) {
	          if (coords.row < 0) {
	            if (instance.selection.selectedHeader.cols) {
	              instance.selection.setRangeEnd(new WalkontableCellCoords(instance.countRows() - 1, coords.col));
	              instance.selection.setSelectedHeaders(false, true);
	            } else {
	              instance.selection.setRangeEnd(new WalkontableCellCoords(coords.row, coords.col));
	            }
	          }
	          if (coords.col < 0) {
	            if (instance.selection.selectedHeader.rows) {
	              instance.selection.setRangeEnd(new WalkontableCellCoords(coords.row, instance.countCols() - 1));
	              instance.selection.setSelectedHeaders(true, false);
	            } else {
	              instance.selection.setRangeEnd(new WalkontableCellCoords(coords.row, coords.col));
	            }
	          }
	        }
	      }
	      Handsontable.hooks.run(instance, 'afterOnCellMouseOver', event, coords, TD);
	      that.activeWt = that.wt;
	    },
	    onCellCornerMouseDown: function(event) {
	      event.preventDefault();
	      Handsontable.hooks.run(instance, 'afterOnCellCornerMouseDown', event);
	    },
	    beforeDraw: function(force) {
	      that.beforeRender(force);
	    },
	    onDraw: function(force) {
	      that.onDraw(force);
	    },
	    onScrollVertically: function() {
	      instance.runHooks('afterScrollVertically');
	    },
	    onScrollHorizontally: function() {
	      instance.runHooks('afterScrollHorizontally');
	    },
	    onBeforeDrawBorders: function(corners, borderClassName) {
	      instance.runHooks('beforeDrawBorders', corners, borderClassName);
	    },
	    onBeforeTouchScroll: function() {
	      instance.runHooks('beforeTouchScroll');
	    },
	    onAfterMomentumScroll: function() {
	      instance.runHooks('afterMomentumScroll');
	    },
	    viewportRowCalculatorOverride: function(calc) {
	      var rows = instance.countRows();
	      var viewportOffset = that.settings.viewportRowRenderingOffset;
	      if (viewportOffset === 'auto' && that.settings.fixedRowsTop) {
	        viewportOffset = 10;
	      }
	      if (typeof viewportOffset === 'number') {
	        calc.startRow = Math.max(calc.startRow - viewportOffset, 0);
	        calc.endRow = Math.min(calc.endRow + viewportOffset, rows - 1);
	      }
	      if (viewportOffset === 'auto') {
	        var center = calc.startRow + calc.endRow - calc.startRow;
	        var offset = Math.ceil(center / rows * 12);
	        calc.startRow = Math.max(calc.startRow - offset, 0);
	        calc.endRow = Math.min(calc.endRow + offset, rows - 1);
	      }
	      instance.runHooks('afterViewportRowCalculatorOverride', calc);
	    },
	    viewportColumnCalculatorOverride: function(calc) {
	      var cols = instance.countCols();
	      var viewportOffset = that.settings.viewportColumnRenderingOffset;
	      if (viewportOffset === 'auto' && that.settings.fixedColumnsLeft) {
	        viewportOffset = 10;
	      }
	      if (typeof viewportOffset === 'number') {
	        calc.startColumn = Math.max(calc.startColumn - viewportOffset, 0);
	        calc.endColumn = Math.min(calc.endColumn + viewportOffset, cols - 1);
	      }
	      if (viewportOffset === 'auto') {
	        var center = calc.startColumn + calc.endColumn - calc.startColumn;
	        var offset = Math.ceil(center / cols * 12);
	        calc.startRow = Math.max(calc.startColumn - offset, 0);
	        calc.endColumn = Math.min(calc.endColumn + offset, cols - 1);
	      }
	      instance.runHooks('afterViewportColumnCalculatorOverride', calc);
	    }
	  };
	  Handsontable.hooks.run(instance, 'beforeInitWalkontable', walkontableConfig);
	  this.wt = new Walkontable(walkontableConfig);
	  this.activeWt = this.wt;
	  this.eventManager.addEventListener(that.wt.wtTable.spreader, 'mousedown', function(event) {
	    if (event.target === that.wt.wtTable.spreader && event.which === 3) {
	      stopPropagation(event);
	    }
	  });
	  this.eventManager.addEventListener(that.wt.wtTable.spreader, 'contextmenu', function(event) {
	    if (event.target === that.wt.wtTable.spreader && event.which === 3) {
	      stopPropagation(event);
	    }
	  });
	  this.eventManager.addEventListener(document.documentElement, 'click', function() {
	    if (that.settings.observeDOMVisibility) {
	      if (that.wt.drawInterrupted) {
	        that.instance.forceFullRender = true;
	        that.render();
	      }
	    }
	  });
	}
	TableView.prototype.isTextSelectionAllowed = function(el) {
	  if (isInput(el)) {
	    return true;
	  }
	  var isChildOfTableBody = isChildOf(el, this.instance.view.wt.wtTable.spreader);
	  if (this.settings.fragmentSelection === true && isChildOfTableBody) {
	    return true;
	  }
	  if (this.settings.fragmentSelection === 'cell' && this.isSelectedOnlyCell() && isChildOfTableBody) {
	    return true;
	  }
	  return false;
	};
	TableView.prototype.isSelectedOnlyCell = function() {
	  var $__6 = this.instance.getSelected() || [],
	      row = $__6[0],
	      col = $__6[1],
	      rowEnd = $__6[2],
	      colEnd = $__6[3];
	  return row !== void 0 && row === rowEnd && col === colEnd;
	};
	TableView.prototype.isCellEdited = function() {
	  var activeEditor = this.instance.getActiveEditor();
	  return activeEditor && activeEditor.isOpened();
	};
	TableView.prototype.beforeRender = function(force) {
	  if (force) {
	    Handsontable.hooks.run(this.instance, 'beforeRender', this.instance.forceFullRender);
	  }
	};
	TableView.prototype.onDraw = function(force) {
	  if (force) {
	    Handsontable.hooks.run(this.instance, 'afterRender', this.instance.forceFullRender);
	  }
	};
	TableView.prototype.render = function() {
	  this.wt.draw(!this.instance.forceFullRender);
	  this.instance.forceFullRender = false;
	  this.instance.renderCall = false;
	};
	TableView.prototype.getCellAtCoords = function(coords, topmost) {
	  var td = this.wt.getCell(coords, topmost);
	  if (td < 0) {
	    return null;
	  } else {
	    return td;
	  }
	};
	TableView.prototype.scrollViewport = function(coords) {
	  this.wt.scrollViewport(coords);
	};
	TableView.prototype.appendRowHeader = function(row, TH) {
	  if (TH.firstChild) {
	    var container = TH.firstChild;
	    if (!hasClass(container, 'relative')) {
	      empty(TH);
	      this.appendRowHeader(row, TH);
	      return;
	    }
	    this.updateCellHeader(container.querySelector('.rowHeader'), row, this.instance.getRowHeader);
	  } else {
	    var div = document.createElement('div');
	    var span = document.createElement('span');
	    div.className = 'relative';
	    span.className = 'rowHeader';
	    this.updateCellHeader(span, row, this.instance.getRowHeader);
	    div.appendChild(span);
	    TH.appendChild(div);
	  }
	  Handsontable.hooks.run(this.instance, 'afterGetRowHeader', row, TH);
	};
	TableView.prototype.appendColHeader = function(col, TH) {
	  if (TH.firstChild) {
	    var container = TH.firstChild;
	    if (hasClass(container, 'relative')) {
	      this.updateCellHeader(container.querySelector('.colHeader'), col, this.instance.getColHeader);
	    } else {
	      empty(TH);
	      this.appendColHeader(col, TH);
	    }
	  } else {
	    var div = document.createElement('div');
	    var span = document.createElement('span');
	    div.className = 'relative';
	    span.className = 'colHeader';
	    this.updateCellHeader(span, col, this.instance.getColHeader);
	    div.appendChild(span);
	    TH.appendChild(div);
	  }
	  Handsontable.hooks.run(this.instance, 'afterGetColHeader', col, TH);
	};
	TableView.prototype.updateCellHeader = function(element, index, content) {
	  if (index > -1) {
	    fastInnerHTML(element, content(index));
	  } else {
	    fastInnerText(element, String.fromCharCode(160));
	    addClass(element, 'cornerHeader');
	  }
	};
	TableView.prototype.maximumVisibleElementWidth = function(leftOffset) {
	  var workspaceWidth = this.wt.wtViewport.getWorkspaceWidth();
	  var maxWidth = workspaceWidth - leftOffset;
	  return maxWidth > 0 ? maxWidth : 0;
	};
	TableView.prototype.maximumVisibleElementHeight = function(topOffset) {
	  var workspaceHeight = this.wt.wtViewport.getWorkspaceHeight();
	  var maxHeight = workspaceHeight - topOffset;
	  return maxHeight > 0 ? maxHeight : 0;
	};
	TableView.prototype.mainViewIsActive = function() {
	  return this.wt === this.activeWt;
	};
	TableView.prototype.destroy = function() {
	  this.wt.destroy();
	  this.eventManager.destroy();
	};
	;

	//# 
	},{"3rdparty/walkontable/src/cell/coords":5,"3rdparty/walkontable/src/core":7,"3rdparty/walkontable/src/selection":18,"eventManager":41,"helpers/dom/element":45,"helpers/dom/event":46}],98:[function(require,module,exports){
	"use strict";
	Object.defineProperties(exports, {
	  GhostTable: {get: function() {
	      return GhostTable;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47_helpers_47_dom_47_element__,
	    $___46__46__47_helpers_47_array__,
	    $___46__46__47_helpers_47_object__,
	    $___46__46__47_helpers_47_number__,
	    $___46__46__47_helpers_47_mixed__;
	var $__0 = ($___46__46__47_helpers_47_dom_47_element__ = require("helpers/dom/element"), $___46__46__47_helpers_47_dom_47_element__ && $___46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47_helpers_47_dom_47_element__}),
	    addClass = $__0.addClass,
	    outerHeight = $__0.outerHeight,
	    outerWidth = $__0.outerWidth;
	var arrayEach = ($___46__46__47_helpers_47_array__ = require("helpers/array"), $___46__46__47_helpers_47_array__ && $___46__46__47_helpers_47_array__.__esModule && $___46__46__47_helpers_47_array__ || {default: $___46__46__47_helpers_47_array__}).arrayEach;
	var objectEach = ($___46__46__47_helpers_47_object__ = require("helpers/object"), $___46__46__47_helpers_47_object__ && $___46__46__47_helpers_47_object__.__esModule && $___46__46__47_helpers_47_object__ || {default: $___46__46__47_helpers_47_object__}).objectEach;
	var rangeEach = ($___46__46__47_helpers_47_number__ = require("helpers/number"), $___46__46__47_helpers_47_number__ && $___46__46__47_helpers_47_number__.__esModule && $___46__46__47_helpers_47_number__ || {default: $___46__46__47_helpers_47_number__}).rangeEach;
	var stringify = ($___46__46__47_helpers_47_mixed__ = require("helpers/mixed"), $___46__46__47_helpers_47_mixed__ && $___46__46__47_helpers_47_mixed__.__esModule && $___46__46__47_helpers_47_mixed__ || {default: $___46__46__47_helpers_47_mixed__}).stringify;
	var GhostTable = function GhostTable(hotInstance) {
	  this.hot = hotInstance;
	  this.container = null;
	  this.injected = false;
	  this.rows = [];
	  this.columns = [];
	  this.samples = null;
	};
	($traceurRuntime.createClass)(GhostTable, {
	  addRow: function(row, samples) {
	    if (this.columns.length) {
	      throw new Error('Doesn\'t support multi-dimensional table');
	    }
	    if (!this.rows.length) {
	      this.container = this.createContainer(this.hot.rootElement.className);
	    }
	    var rowObject = {row: row};
	    this.rows.push(rowObject);
	    this.samples = samples;
	    this.table = this.createTable(this.hot.table.className);
	    this.table.colGroup.appendChild(this.createColGroupsCol());
	    this.table.tr.appendChild(this.createRow(row));
	    this.container.container.appendChild(this.table.fragment);
	    rowObject.table = this.table.table;
	  },
	  addColumn: function(column, samples) {
	    if (this.rows.length) {
	      throw new Error('Doesn\'t support multi-dimensional table');
	    }
	    if (!this.columns.length) {
	      this.container = this.createContainer(this.hot.rootElement.className);
	    }
	    var columnObject = {col: column};
	    this.columns.push(columnObject);
	    this.samples = samples;
	    this.table = this.createTable(this.hot.table.className);
	    if (this.hot.getColHeader(column) !== null) {
	      this.hot.view.appendColHeader(column, this.table.th);
	    }
	    this.table.tBody.appendChild(this.createCol(column));
	    this.container.container.appendChild(this.table.fragment);
	    columnObject.table = this.table.table;
	  },
	  getHeights: function(callback) {
	    if (!this.injected) {
	      this.injectTable();
	    }
	    arrayEach(this.rows, (function(row) {
	      callback(row.row, outerHeight(row.table) - 1);
	    }));
	  },
	  getWidths: function(callback) {
	    if (!this.injected) {
	      this.injectTable();
	    }
	    arrayEach(this.columns, (function(column) {
	      callback(column.col, outerWidth(column.table));
	    }));
	  },
	  createColGroupsCol: function() {
	    var $__5 = this;
	    var d = document;
	    var fragment = d.createDocumentFragment();
	    fragment.appendChild(this.createColElement(-1));
	    this.samples.forEach((function(sample) {
	      arrayEach(sample.strings, (function(string) {
	        fragment.appendChild($__5.createColElement(string.col));
	      }));
	    }));
	    return fragment;
	  },
	  createRow: function(row) {
	    var $__5 = this;
	    var d = document;
	    var fragment = d.createDocumentFragment();
	    var th = d.createElement('th');
	    if (this.hot.getRowHeader(row) !== null) {
	      this.hot.view.appendRowHeader(row, th);
	    }
	    fragment.appendChild(th);
	    this.samples.forEach((function(sample) {
	      arrayEach(sample.strings, (function(string) {
	        var column = string.col;
	        var cellProperties = $__5.hot.getCellMeta(row, column);
	        cellProperties.col = column;
	        cellProperties.row = row;
	        var renderer = $__5.hot.getCellRenderer(cellProperties);
	        var td = d.createElement('td');
	        renderer($__5.hot, td, row, column, $__5.hot.colToProp(column), string.value, cellProperties);
	        fragment.appendChild(td);
	      }));
	    }));
	    return fragment;
	  },
	  createCol: function(column) {
	    var $__5 = this;
	    var d = document;
	    var fragment = d.createDocumentFragment();
	    this.samples.forEach((function(sample) {
	      arrayEach(sample.strings, (function(string) {
	        var row = string.row;
	        var cellProperties = $__5.hot.getCellMeta(row, column);
	        cellProperties.col = column;
	        cellProperties.row = row;
	        var renderer = $__5.hot.getCellRenderer(cellProperties);
	        var td = d.createElement('td');
	        var tr = d.createElement('tr');
	        renderer($__5.hot, td, row, column, $__5.hot.colToProp(row), string.value, cellProperties);
	        tr.appendChild(td);
	        fragment.appendChild(tr);
	      }));
	    }));
	    return fragment;
	  },
	  clean: function() {
	    this.rows.length = 0;
	    this.columns.length = 0;
	    if (this.samples) {
	      this.samples.clear();
	    }
	    this.samples = null;
	    this.removeTable();
	  },
	  injectTable: function() {
	    var parent = arguments[0] !== (void 0) ? arguments[0] : null;
	    if (!this.injected) {
	      (parent || this.hot.rootElement).appendChild(this.container.fragment);
	      this.injected = true;
	    }
	  },
	  removeTable: function() {
	    if (this.injected && this.container.container.parentNode) {
	      this.container.container.parentNode.removeChild(this.container.container);
	      this.container = null;
	      this.injected = false;
	    }
	  },
	  createColElement: function(column) {
	    var d = document;
	    var col = d.createElement('col');
	    col.style.width = this.hot.view.wt.wtTable.getStretchedColumnWidth(column) + 'px';
	    return col;
	  },
	  createTable: function() {
	    var className = arguments[0] !== (void 0) ? arguments[0] : '';
	    var d = document;
	    var fragment = d.createDocumentFragment();
	    var table = d.createElement('table');
	    var tHead = d.createElement('thead');
	    var tBody = d.createElement('tbody');
	    var colGroup = d.createElement('colgroup');
	    var tr = d.createElement('tr');
	    var th = d.createElement('th');
	    if (this.isVertical()) {
	      table.appendChild(colGroup);
	    }
	    if (this.isHorizontal()) {
	      tr.appendChild(th);
	      tHead.appendChild(tr);
	      table.style.tableLayout = 'auto';
	      table.style.width = 'auto';
	    }
	    table.appendChild(tHead);
	    if (this.isVertical()) {
	      tBody.appendChild(tr);
	    }
	    table.appendChild(tBody);
	    addClass(table, className);
	    fragment.appendChild(table);
	    return {
	      fragment: fragment,
	      table: table,
	      tHead: tHead,
	      tBody: tBody,
	      colGroup: colGroup,
	      tr: tr,
	      th: th
	    };
	  },
	  createContainer: function() {
	    var className = arguments[0] !== (void 0) ? arguments[0] : '';
	    var d = document;
	    var fragment = d.createDocumentFragment();
	    var container = d.createElement('div');
	    className = 'htGhostTable htAutoSize ' + className.trim();
	    addClass(container, className);
	    fragment.appendChild(container);
	    return {
	      fragment: fragment,
	      container: container
	    };
	  },
	  isVertical: function() {
	    return this.rows.length && !this.columns.length ? true : false;
	  },
	  isHorizontal: function() {
	    return this.columns.length && !this.rows.length ? true : false;
	  }
	}, {});
	;
	Handsontable.utils = Handsontable.utils || {};
	Handsontable.utils.GhostTable = GhostTable;

	//# 
	},{"helpers/array":42,"helpers/dom/element":45,"helpers/mixed":48,"helpers/number":49,"helpers/object":50}],99:[function(require,module,exports){
	"use strict";
	var $__7;
	Object.defineProperties(exports, {
	  SamplesGenerator: {get: function() {
	      return SamplesGenerator;
	    }},
	  __esModule: {value: true}
	});
	var $___46__46__47_helpers_47_dom_47_element__,
	    $___46__46__47_helpers_47_array__,
	    $___46__46__47_helpers_47_object__,
	    $___46__46__47_helpers_47_number__,
	    $___46__46__47_helpers_47_mixed__;
	var $__0 = ($___46__46__47_helpers_47_dom_47_element__ = require("helpers/dom/element"), $___46__46__47_helpers_47_dom_47_element__ && $___46__46__47_helpers_47_dom_47_element__.__esModule && $___46__46__47_helpers_47_dom_47_element__ || {default: $___46__46__47_helpers_47_dom_47_element__}),
	    addClass = $__0.addClass,
	    outerHeight = $__0.outerHeight,
	    outerWidth = $__0.outerWidth;
	var arrayEach = ($___46__46__47_helpers_47_array__ = require("helpers/array"), $___46__46__47_helpers_47_array__ && $___46__46__47_helpers_47_array__.__esModule && $___46__46__47_helpers_47_array__ || {default: $___46__46__47_helpers_47_array__}).arrayEach;
	var objectEach = ($___46__46__47_helpers_47_object__ = require("helpers/object"), $___46__46__47_helpers_47_object__ && $___46__46__47_helpers_47_object__.__esModule && $___46__46__47_helpers_47_object__ || {default: $___46__46__47_helpers_47_object__}).objectEach;
	var rangeEach = ($___46__46__47_helpers_47_number__ = require("helpers/number"), $___46__46__47_helpers_47_number__ && $___46__46__47_helpers_47_number__.__esModule && $___46__46__47_helpers_47_number__ || {default: $___46__46__47_helpers_47_number__}).rangeEach;
	var stringify = ($___46__46__47_helpers_47_mixed__ = require("helpers/mixed"), $___46__46__47_helpers_47_mixed__ && $___46__46__47_helpers_47_mixed__.__esModule && $___46__46__47_helpers_47_mixed__ || {default: $___46__46__47_helpers_47_mixed__}).stringify;
	var SamplesGenerator = function SamplesGenerator(dataFactory) {
	  this.samples = null;
	  this.dataFactory = dataFactory;
	};
	var $SamplesGenerator = SamplesGenerator;
	($traceurRuntime.createClass)(SamplesGenerator, ($__7 = {}, Object.defineProperty($__7, "generateRowSamples", {
	  value: function(rowRange, colRange) {
	    return this.generateSamples('row', colRange, rowRange);
	  },
	  configurable: true,
	  enumerable: true,
	  writable: true
	}), Object.defineProperty($__7, "generateColumnSamples", {
	  value: function(colRange, rowRange) {
	    return this.generateSamples('col', rowRange, colRange);
	  },
	  configurable: true,
	  enumerable: true,
	  writable: true
	}), Object.defineProperty($__7, "generateSamples", {
	  value: function(type, range, specifierRange) {
	    var $__5 = this;
	    var samples = new Map();
	    if (typeof specifierRange === 'number') {
	      specifierRange = {
	        from: specifierRange,
	        to: specifierRange
	      };
	    }
	    rangeEach(specifierRange.from, specifierRange.to, (function(index) {
	      var sample = $__5.generateSample(type, range, index);
	      samples.set(index, sample);
	    }));
	    return samples;
	  },
	  configurable: true,
	  enumerable: true,
	  writable: true
	}), Object.defineProperty($__7, "generateSample", {
	  value: function(type, range, specifierValue) {
	    var $__5 = this;
	    var samples = new Map();
	    rangeEach(range.from, range.to, (function(index) {
	      var $__7;
	      var value;
	      if (type === 'row') {
	        value = $__5.dataFactory(specifierValue, index);
	      } else if (type === 'col') {
	        value = $__5.dataFactory(index, specifierValue);
	      } else {
	        throw new Error('Unsupported sample type');
	      }
	      if (!Array.isArray(value)) {
	        value = stringify(value);
	      }
	      var len = value.length;
	      if (!samples.has(len)) {
	        samples.set(len, {
	          needed: $SamplesGenerator.SAMPLE_COUNT,
	          strings: []
	        });
	      }
	      var sample = samples.get(len);
	      if (sample.needed) {
	        var computedKey = type === 'row' ? 'col' : 'row';
	        sample.strings.push(($__7 = {}, Object.defineProperty($__7, "value", {
	          value: value,
	          configurable: true,
	          enumerable: true,
	          writable: true
	        }), Object.defineProperty($__7, computedKey, {
	          value: index,
	          configurable: true,
	          enumerable: true,
	          writable: true
	        }), $__7));
	        sample.needed--;
	      }
	    }));
	    return samples;
	  },
	  configurable: true,
	  enumerable: true,
	  writable: true
	}), $__7), {get SAMPLE_COUNT() {
	    return 3;
	  }});
	;
	Handsontable.utils = Handsontable.utils || {};
	Handsontable.utils.SamplesGenerator = SamplesGenerator;

	//# 
	},{"helpers/array":42,"helpers/dom/element":45,"helpers/mixed":48,"helpers/number":49,"helpers/object":50}],100:[function(require,module,exports){
	"use strict";
	var $___46__46__47_helpers_47_mixed__;
	var stringify = ($___46__46__47_helpers_47_mixed__ = require("helpers/mixed"), $___46__46__47_helpers_47_mixed__ && $___46__46__47_helpers_47_mixed__.__esModule && $___46__46__47_helpers_47_mixed__ || {default: $___46__46__47_helpers_47_mixed__}).stringify;
	Handsontable.AutocompleteValidator = function(value, callback) {
	  if (this.strict && this.source) {
	    if (typeof this.source === 'function') {
	      this.source(value, process(value, callback));
	    } else {
	      process(value, callback)(this.source);
	    }
	  } else {
	    callback(true);
	  }
	};
	function process(value, callback) {
	  var originalVal = value;
	  var lowercaseVal = typeof originalVal === 'string' ? originalVal.toLowerCase() : null;
	  return function(source) {
	    var found = false;
	    for (var s = 0,
	        slen = source.length; s < slen; s++) {
	      if (originalVal === source[s]) {
	        found = true;
	        break;
	      } else if (lowercaseVal === stringify(source[s]).toLowerCase()) {
	        found = true;
	        break;
	      }
	    }
	    callback(found);
	  };
	}

	//# 
	},{"helpers/mixed":48}],101:[function(require,module,exports){
	"use strict";
	var $__moment__,
	    $___46__46__47_editors__;
	var moment = ($__moment__ = require("moment"), $__moment__ && $__moment__.__esModule && $__moment__ || {default: $__moment__}).default;
	var getEditor = ($___46__46__47_editors__ = require("editors"), $___46__46__47_editors__ && $___46__46__47_editors__.__esModule && $___46__46__47_editors__ || {default: $___46__46__47_editors__}).getEditor;
	Handsontable.DateValidator = function(value, callback) {
	  var valid = true;
	  var dateEditor = getEditor('date', this.instance);
	  if (value === null) {
	    value = '';
	  }
	  var isValidDate = moment(new Date(value)).isValid();
	  var isValidFormat = moment(value, this.dateFormat || dateEditor.defaultDateFormat, true).isValid();
	  if (!isValidDate) {
	    valid = false;
	  }
	  if (!isValidDate && isValidFormat) {
	    valid = true;
	  }
	  if (isValidDate && !isValidFormat) {
	    if (this.correctFormat === true) {
	      var correctedValue = correctFormat(value, this.dateFormat);
	      this.instance.setDataAtCell(this.row, this.col, correctedValue, 'dateValidator');
	      valid = true;
	    } else {
	      valid = false;
	    }
	  }
	  callback(valid);
	};
	var correctFormat = function correctFormat(value, dateFormat) {
	  var date = moment(new Date(value));
	  var year = date.format('YYYY');
	  var yearNow = moment().format('YYYY');
	  if (year.substr(0, 2) !== yearNow.substr(0, 2)) {
	    if (!value.match(new RegExp(year))) {
	      date.year(year.replace(year.substr(0, 2), yearNow.substr(0, 2)));
	    }
	  } else if (year.length > 4) {
	    date.year((date.year() + '').substr(0, 4));
	  }
	  return date.format(dateFormat);
	};

	//# 
	},{"editors":29,"moment":"moment"}],102:[function(require,module,exports){
	"use strict";
	Handsontable.NumericValidator = function(value, callback) {
	  if (value === null) {
	    value = '';
	  }
	  callback(/^-?\d*(\.|\,)?\d*$/.test(value));
	};

	//# 
	},{}],"SheetClip":[function(require,module,exports){
	"use strict";
	(function(global) {
	  "use strict";
	  function countQuotes(str) {
	    return str.split('"').length - 1;
	  }
	  var SheetClip = {
	    parse: function(str) {
	      var r,
	          rLen,
	          rows,
	          arr = [],
	          a = 0,
	          c,
	          cLen,
	          multiline,
	          last;
	      rows = str.split('\n');
	      if (rows.length > 1 && rows[rows.length - 1] === '') {
	        rows.pop();
	      }
	      for (r = 0, rLen = rows.length; r < rLen; r += 1) {
	        rows[r] = rows[r].split('\t');
	        for (c = 0, cLen = rows[r].length; c < cLen; c += 1) {
	          if (!arr[a]) {
	            arr[a] = [];
	          }
	          if (multiline && c === 0) {
	            last = arr[a].length - 1;
	            arr[a][last] = arr[a][last] + '\n' + rows[r][0];
	            if (multiline && (countQuotes(rows[r][0]) & 1)) {
	              multiline = false;
	              arr[a][last] = arr[a][last].substring(0, arr[a][last].length - 1).replace(/""/g, '"');
	            }
	          } else {
	            if (c === cLen - 1 && rows[r][c].indexOf('"') === 0 && (countQuotes(rows[r][c]) & 1)) {
	              arr[a].push(rows[r][c].substring(1).replace(/""/g, '"'));
	              multiline = true;
	            } else {
	              arr[a].push(rows[r][c].replace(/""/g, '"'));
	              multiline = false;
	            }
	          }
	        }
	        if (!multiline) {
	          a += 1;
	        }
	      }
	      return arr;
	    },
	    stringify: function(arr) {
	      var r,
	          rLen,
	          c,
	          cLen,
	          str = '',
	          val;
	      for (r = 0, rLen = arr.length; r < rLen; r += 1) {
	        cLen = arr[r].length;
	        for (c = 0; c < cLen; c += 1) {
	          if (c > 0) {
	            str += '\t';
	          }
	          val = arr[r][c];
	          if (typeof val === 'string') {
	            if (val.indexOf('\n') > -1) {
	              str += '"' + val.replace(/"/g, '""') + '"';
	            } else {
	              str += val;
	            }
	          } else if (val === null || val === void 0) {
	            str += '';
	          } else {
	            str += val;
	          }
	        }
	        str += '\n';
	      }
	      return str;
	    }
	  };
	  if (typeof exports !== 'undefined') {
	    exports.parse = SheetClip.parse;
	    exports.stringify = SheetClip.stringify;
	  } else {
	    global.SheetClip = SheetClip;
	  }
	}(window));

	//# 
	},{}],"autoResize":[function(require,module,exports){
	"use strict";
	function autoResize() {
	  var defaults = {
	    minHeight: 200,
	    maxHeight: 300,
	    minWidth: 100,
	    maxWidth: 300
	  },
	      el,
	      body = document.body,
	      text = document.createTextNode(''),
	      span = document.createElement('SPAN'),
	      observe = function(element, event, handler) {
	        if (window.attachEvent) {
	          element.attachEvent('on' + event, handler);
	        } else {
	          element.addEventListener(event, handler, false);
	        }
	      },
	      unObserve = function(element, event, handler) {
	        if (window.removeEventListener) {
	          element.removeEventListener(event, handler, false);
	        } else {
	          element.detachEvent('on' + event, handler);
	        }
	      },
	      resize = function(newChar) {
	        var width,
	            scrollHeight;
	        if (!newChar) {
	          newChar = "";
	        } else if (!/^[a-zA-Z \.,\\\/\|0-9]$/.test(newChar)) {
	          newChar = ".";
	        }
	        if (text.textContent !== void 0) {
	          text.textContent = el.value + newChar;
	        } else {
	          text.data = el.value + newChar;
	        }
	        span.style.fontSize = Handsontable.Dom.getComputedStyle(el).fontSize;
	        span.style.fontFamily = Handsontable.Dom.getComputedStyle(el).fontFamily;
	        span.style.whiteSpace = "pre";
	        body.appendChild(span);
	        width = span.clientWidth + 2;
	        body.removeChild(span);
	        el.style.height = defaults.minHeight + 'px';
	        if (defaults.minWidth > width) {
	          el.style.width = defaults.minWidth + 'px';
	        } else if (width > defaults.maxWidth) {
	          el.style.width = defaults.maxWidth + 'px';
	        } else {
	          el.style.width = width + 'px';
	        }
	        scrollHeight = el.scrollHeight ? el.scrollHeight - 1 : 0;
	        if (defaults.minHeight > scrollHeight) {
	          el.style.height = defaults.minHeight + 'px';
	        } else if (defaults.maxHeight < scrollHeight) {
	          el.style.height = defaults.maxHeight + 'px';
	          el.style.overflowY = 'visible';
	        } else {
	          el.style.height = scrollHeight + 'px';
	        }
	      },
	      delayedResize = function() {
	        window.setTimeout(resize, 0);
	      },
	      extendDefaults = function(config) {
	        if (config && config.minHeight) {
	          if (config.minHeight == 'inherit') {
	            defaults.minHeight = el.clientHeight;
	          } else {
	            var minHeight = parseInt(config.minHeight);
	            if (!isNaN(minHeight)) {
	              defaults.minHeight = minHeight;
	            }
	          }
	        }
	        if (config && config.maxHeight) {
	          if (config.maxHeight == 'inherit') {
	            defaults.maxHeight = el.clientHeight;
	          } else {
	            var maxHeight = parseInt(config.maxHeight);
	            if (!isNaN(maxHeight)) {
	              defaults.maxHeight = maxHeight;
	            }
	          }
	        }
	        if (config && config.minWidth) {
	          if (config.minWidth == 'inherit') {
	            defaults.minWidth = el.clientWidth;
	          } else {
	            var minWidth = parseInt(config.minWidth);
	            if (!isNaN(minWidth)) {
	              defaults.minWidth = minWidth;
	            }
	          }
	        }
	        if (config && config.maxWidth) {
	          if (config.maxWidth == 'inherit') {
	            defaults.maxWidth = el.clientWidth;
	          } else {
	            var maxWidth = parseInt(config.maxWidth);
	            if (!isNaN(maxWidth)) {
	              defaults.maxWidth = maxWidth;
	            }
	          }
	        }
	        if (!span.firstChild) {
	          span.className = "autoResize";
	          span.style.display = 'inline-block';
	          span.appendChild(text);
	        }
	      },
	      init = function(el_, config, doObserve) {
	        el = el_;
	        extendDefaults(config);
	        if (el.nodeName == 'TEXTAREA') {
	          el.style.resize = 'none';
	          el.style.overflowY = '';
	          el.style.height = defaults.minHeight + 'px';
	          el.style.minWidth = defaults.minWidth + 'px';
	          el.style.maxWidth = defaults.maxWidth + 'px';
	          el.style.overflowY = 'hidden';
	        }
	        if (doObserve) {
	          observe(el, 'change', resize);
	          observe(el, 'cut', delayedResize);
	          observe(el, 'paste', delayedResize);
	          observe(el, 'drop', delayedResize);
	          observe(el, 'keydown', delayedResize);
	        }
	        resize();
	      };
	  return {
	    init: function(el_, config, doObserve) {
	      init(el_, config, doObserve);
	    },
	    unObserve: function() {
	      unObserve(el, 'change', resize);
	      unObserve(el, 'cut', delayedResize);
	      unObserve(el, 'paste', delayedResize);
	      unObserve(el, 'drop', delayedResize);
	      unObserve(el, 'keydown', delayedResize);
	    },
	    resize: resize
	  };
	}
	if (typeof exports !== 'undefined') {
	  module.exports = autoResize;
	}

	//# 
	},{}],"copyPaste":[function(require,module,exports){
	"use strict";
	var instance;
	function copyPaste() {
	  if (!instance) {
	    instance = new CopyPasteClass();
	  } else if (instance.hasBeenDestroyed()) {
	    instance.init();
	  }
	  instance.refCounter++;
	  return instance;
	}
	if (typeof exports !== 'undefined') {
	  module.exports = copyPaste;
	}
	function CopyPasteClass() {
	  this.refCounter = 0;
	  this.init();
	}
	CopyPasteClass.prototype.init = function() {
	  var style,
	      parent;
	  this.copyCallbacks = [];
	  this.cutCallbacks = [];
	  this.pasteCallbacks = [];
	  parent = document.body;
	  if (document.getElementById('CopyPasteDiv')) {
	    this.elDiv = document.getElementById('CopyPasteDiv');
	    this.elTextarea = this.elDiv.firstChild;
	  } else {
	    this.elDiv = document.createElement('div');
	    this.elDiv.id = 'CopyPasteDiv';
	    style = this.elDiv.style;
	    style.position = 'fixed';
	    style.top = '-10000px';
	    style.left = '-10000px';
	    parent.appendChild(this.elDiv);
	    this.elTextarea = document.createElement('textarea');
	    this.elTextarea.className = 'copyPaste';
	    this.elTextarea.onpaste = function(event) {
	      var clipboardContents,
	          temp;
	      if ('WebkitAppearance' in document.documentElement.style) {
	        clipboardContents = event.clipboardData.getData("Text");
	        if (navigator.userAgent.indexOf('Safari') !== -1 && navigator.userAgent.indexOf('Chrome') === -1) {
	          temp = clipboardContents.split('\n');
	          if (temp[temp.length - 1] === '') {
	            temp.pop();
	          }
	          clipboardContents = temp.join('\n');
	        }
	        this.value = clipboardContents;
	        return false;
	      }
	    };
	    style = this.elTextarea.style;
	    style.width = '10000px';
	    style.height = '10000px';
	    style.overflow = 'hidden';
	    this.elDiv.appendChild(this.elTextarea);
	    if (typeof style.opacity !== 'undefined') {
	      style.opacity = 0;
	    }
	  }
	  this.onKeyDownRef = this.onKeyDown.bind(this);
	  document.documentElement.addEventListener('keydown', this.onKeyDownRef, false);
	};
	CopyPasteClass.prototype.onKeyDown = function(event) {
	  var _this = this,
	      isCtrlDown = false;
	  function isActiveElementEditable() {
	    var element = document.activeElement;
	    if (element.shadowRoot && element.shadowRoot.activeElement) {
	      element = element.shadowRoot.activeElement;
	    }
	    return ['INPUT', 'SELECT', 'TEXTAREA'].indexOf(element.nodeName) > -1 || element.contentEditable === 'true';
	  }
	  if (event.metaKey) {
	    isCtrlDown = true;
	  } else if (event.ctrlKey && navigator.userAgent.indexOf('Mac') === -1) {
	    isCtrlDown = true;
	  }
	  if (isCtrlDown) {
	    if (document.activeElement !== this.elTextarea && (this.getSelectionText() !== '' || isActiveElementEditable())) {
	      return;
	    }
	    this.selectNodeText(this.elTextarea);
	    setTimeout(function() {
	      if (document.activeElement !== _this.elTextarea) {
	        _this.selectNodeText(_this.elTextarea);
	      }
	    }, 0);
	  }
	  if (isCtrlDown && (event.keyCode === 67 || event.keyCode === 86 || event.keyCode === 88)) {
	    if (event.keyCode === 88) {
	      setTimeout(function() {
	        _this.triggerCut(event);
	      }, 0);
	    } else if (event.keyCode === 86) {
	      setTimeout(function() {
	        _this.triggerPaste(event);
	      }, 0);
	    }
	  }
	};
	CopyPasteClass.prototype.selectNodeText = function(element) {
	  if (element) {
	    element.select();
	  }
	};
	CopyPasteClass.prototype.getSelectionText = function() {
	  var text = '';
	  if (window.getSelection) {
	    text = window.getSelection().toString();
	  } else if (document.selection && document.selection.type !== 'Control') {
	    text = document.selection.createRange().text;
	  }
	  return text;
	};
	CopyPasteClass.prototype.copyable = function(string) {
	  if (typeof string !== 'string' && string.toString === void 0) {
	    throw new Error('copyable requires string parameter');
	  }
	  this.elTextarea.value = string;
	  this.selectNodeText(this.elTextarea);
	};
	CopyPasteClass.prototype.onCut = function(callback) {
	  this.cutCallbacks.push(callback);
	};
	CopyPasteClass.prototype.onPaste = function(callback) {
	  this.pasteCallbacks.push(callback);
	};
	CopyPasteClass.prototype.removeCallback = function(callback) {
	  var i,
	      len;
	  for (i = 0, len = this.copyCallbacks.length; i < len; i++) {
	    if (this.copyCallbacks[i] === callback) {
	      this.copyCallbacks.splice(i, 1);
	      return true;
	    }
	  }
	  for (i = 0, len = this.cutCallbacks.length; i < len; i++) {
	    if (this.cutCallbacks[i] === callback) {
	      this.cutCallbacks.splice(i, 1);
	      return true;
	    }
	  }
	  for (i = 0, len = this.pasteCallbacks.length; i < len; i++) {
	    if (this.pasteCallbacks[i] === callback) {
	      this.pasteCallbacks.splice(i, 1);
	      return true;
	    }
	  }
	  return false;
	};
	CopyPasteClass.prototype.triggerCut = function(event) {
	  var _this = this;
	  if (_this.cutCallbacks) {
	    setTimeout(function() {
	      for (var i = 0,
	          len = _this.cutCallbacks.length; i < len; i++) {
	        _this.cutCallbacks[i](event);
	      }
	    }, 50);
	  }
	};
	CopyPasteClass.prototype.triggerPaste = function(event, string) {
	  var _this = this;
	  if (_this.pasteCallbacks) {
	    setTimeout(function() {
	      var val = string || _this.elTextarea.value;
	      for (var i = 0,
	          len = _this.pasteCallbacks.length; i < len; i++) {
	        _this.pasteCallbacks[i](val, event);
	      }
	    }, 50);
	  }
	};
	CopyPasteClass.prototype.destroy = function() {
	  if (!this.hasBeenDestroyed() && --this.refCounter === 0) {
	    if (this.elDiv && this.elDiv.parentNode) {
	      this.elDiv.parentNode.removeChild(this.elDiv);
	      this.elDiv = null;
	      this.elTextarea = null;
	    }
	    document.documentElement.removeEventListener('keydown', this.onKeyDownRef);
	    this.onKeyDownRef = null;
	  }
	};
	CopyPasteClass.prototype.hasBeenDestroyed = function() {
	  return !this.refCounter;
	};

	//# 
	},{}],"es6collections":[function(require,module,exports){
	"use strict";
	(function(exports) {
	  'use strict';
	  var i;
	  var defineProperty = Object.defineProperty,
	      is = function(a, b) {
	        return isNaN(a) ? isNaN(b) : a === b;
	      };
	  if (typeof WeakMap == 'undefined') {
	    exports.WeakMap = createCollection({
	      'delete': sharedDelete,
	      clear: sharedClear,
	      get: sharedGet,
	      has: mapHas,
	      set: sharedSet
	    }, true);
	  }
	  if (typeof Map == 'undefined') {
	    exports.Map = createCollection({
	      'delete': sharedDelete,
	      has: mapHas,
	      get: sharedGet,
	      set: sharedSet,
	      keys: sharedKeys,
	      values: sharedValues,
	      entries: mapEntries,
	      forEach: sharedForEach,
	      clear: sharedClear
	    });
	  }
	  if (typeof Set == 'undefined') {
	    exports.Set = createCollection({
	      has: setHas,
	      add: sharedAdd,
	      'delete': sharedDelete,
	      clear: sharedClear,
	      keys: sharedValues,
	      values: sharedValues,
	      entries: setEntries,
	      forEach: sharedForEach
	    });
	  }
	  if (typeof WeakSet == 'undefined') {
	    exports.WeakSet = createCollection({
	      'delete': sharedDelete,
	      add: sharedAdd,
	      clear: sharedClear,
	      has: setHas
	    }, true);
	  }
	  function createCollection(proto, objectOnly) {
	    function Collection(a) {
	      if (!this || this.constructor !== Collection)
	        return new Collection(a);
	      this._keys = [];
	      this._values = [];
	      this._itp = [];
	      this.objectOnly = objectOnly;
	      if (a)
	        init.call(this, a);
	    }
	    if (!objectOnly) {
	      defineProperty(proto, 'size', {get: sharedSize});
	    }
	    proto.constructor = Collection;
	    Collection.prototype = proto;
	    return Collection;
	  }
	  function init(a) {
	    var i;
	    if (this.add)
	      a.forEach(this.add, this);
	    else
	      a.forEach(function(a) {
	        this.set(a[0], a[1]);
	      }, this);
	  }
	  function sharedDelete(key) {
	    if (this.has(key)) {
	      this._keys.splice(i, 1);
	      this._values.splice(i, 1);
	      this._itp.forEach(function(p) {
	        if (i < p[0])
	          p[0]--;
	      });
	    }
	    return -1 < i;
	  }
	  ;
	  function sharedGet(key) {
	    return this.has(key) ? this._values[i] : undefined;
	  }
	  function has(list, key) {
	    if (this.objectOnly && key !== Object(key))
	      throw new TypeError("Invalid value used as weak collection key");
	    if (key != key || key === 0)
	      for (i = list.length; i-- && !is(list[i], key); ) {}
	    else
	      i = list.indexOf(key);
	    return -1 < i;
	  }
	  function setHas(value) {
	    return has.call(this, this._values, value);
	  }
	  function mapHas(value) {
	    return has.call(this, this._keys, value);
	  }
	  function sharedSet(key, value) {
	    this.has(key) ? this._values[i] = value : this._values[this._keys.push(key) - 1] = value;
	    return this;
	  }
	  function sharedAdd(value) {
	    if (!this.has(value))
	      this._values.push(value);
	    return this;
	  }
	  function sharedClear() {
	    this._values.length = 0;
	  }
	  function sharedKeys() {
	    return sharedIterator(this._itp, this._keys);
	  }
	  function sharedValues() {
	    return sharedIterator(this._itp, this._values);
	  }
	  function mapEntries() {
	    return sharedIterator(this._itp, this._keys, this._values);
	  }
	  function setEntries() {
	    return sharedIterator(this._itp, this._values, this._values);
	  }
	  function sharedIterator(itp, array, array2) {
	    var p = [0],
	        done = false;
	    itp.push(p);
	    return {next: function() {
	        var v,
	            k = p[0];
	        if (!done && k < array.length) {
	          v = array2 ? [array[k], array2[k]] : array[k];
	          p[0]++;
	        } else {
	          done = true;
	          itp.splice(itp.indexOf(p), 1);
	        }
	        return {
	          done: done,
	          value: v
	        };
	      }};
	  }
	  function sharedSize() {
	    return this._values.length;
	  }
	  function sharedForEach(callback, context) {
	    var it = this.entries();
	    for (; ; ) {
	      var r = it.next();
	      if (r.done)
	        break;
	      callback.call(context, r.value[1], r.value[0], this);
	    }
	  }
	})(typeof exports != 'undefined' && typeof global != 'undefined' ? global : window);

	//# 
	},{}],"jsonpatch":[function(require,module,exports){
	"use strict";
	var jsonpatch;
	(function(jsonpatch) {
	  var objOps = {
	    add: function(obj, key) {
	      obj[key] = this.value;
	      return true;
	    },
	    remove: function(obj, key) {
	      delete obj[key];
	      return true;
	    },
	    replace: function(obj, key) {
	      obj[key] = this.value;
	      return true;
	    },
	    move: function(obj, key, tree) {
	      var temp = {
	        op: "_get",
	        path: this.from
	      };
	      apply(tree, [temp]);
	      apply(tree, [{
	        op: "remove",
	        path: this.from
	      }]);
	      apply(tree, [{
	        op: "add",
	        path: this.path,
	        value: temp.value
	      }]);
	      return true;
	    },
	    copy: function(obj, key, tree) {
	      var temp = {
	        op: "_get",
	        path: this.from
	      };
	      apply(tree, [temp]);
	      apply(tree, [{
	        op: "add",
	        path: this.path,
	        value: temp.value
	      }]);
	      return true;
	    },
	    test: function(obj, key) {
	      return (JSON.stringify(obj[key]) === JSON.stringify(this.value));
	    },
	    _get: function(obj, key) {
	      this.value = obj[key];
	    }
	  };
	  var arrOps = {
	    add: function(arr, i) {
	      arr.splice(i, 0, this.value);
	      return true;
	    },
	    remove: function(arr, i) {
	      arr.splice(i, 1);
	      return true;
	    },
	    replace: function(arr, i) {
	      arr[i] = this.value;
	      return true;
	    },
	    move: objOps.move,
	    copy: objOps.copy,
	    test: objOps.test,
	    _get: objOps._get
	  };
	  var observeOps = {
	    add: function(patches, path) {
	      var patch = {
	        op: "add",
	        path: path + escapePathComponent(this.name),
	        value: this.object[this.name]
	      };
	      patches.push(patch);
	    },
	    'delete': function(patches, path) {
	      var patch = {
	        op: "remove",
	        path: path + escapePathComponent(this.name)
	      };
	      patches.push(patch);
	    },
	    update: function(patches, path) {
	      var patch = {
	        op: "replace",
	        path: path + escapePathComponent(this.name),
	        value: this.object[this.name]
	      };
	      patches.push(patch);
	    }
	  };
	  function escapePathComponent(str) {
	    if (str.indexOf('/') === -1 && str.indexOf('~') === -1) {
	      return str;
	    }
	    return str.replace(/~/g, '~0').replace(/\//g, '~1');
	  }
	  function _getPathRecursive(root, obj) {
	    var found;
	    for (var key in root) {
	      if (root.hasOwnProperty(key)) {
	        if (root[key] === obj) {
	          return escapePathComponent(key) + '/';
	        } else if (typeof root[key] === 'object') {
	          found = _getPathRecursive(root[key], obj);
	          if (found != '') {
	            return escapePathComponent(key) + '/' + found;
	          }
	        }
	      }
	    }
	    return '';
	  }
	  function getPath(root, obj) {
	    if (root === obj) {
	      return '/';
	    }
	    var path = _getPathRecursive(root, obj);
	    if (path === '') {
	      throw new Error("Object not found in root");
	    }
	    return '/' + path;
	  }
	  var beforeDict = [];
	  jsonpatch.intervals;
	  var Mirror = (function() {
	    function Mirror(obj) {
	      this.observers = [];
	      this.obj = obj;
	    }
	    return Mirror;
	  })();
	  var ObserverInfo = (function() {
	    function ObserverInfo(callback, observer) {
	      this.callback = callback;
	      this.observer = observer;
	    }
	    return ObserverInfo;
	  })();
	  function getMirror(obj) {
	    for (var i = 0,
	        ilen = beforeDict.length; i < ilen; i++) {
	      if (beforeDict[i].obj === obj) {
	        return beforeDict[i];
	      }
	    }
	  }
	  function removeMirror(obj) {
	    for (var i = 0,
	        ilen = beforeDict.length; i < ilen; i++) {
	      if (beforeDict[i] === obj) {
	        beforeDict.splice(i, 1);
	      }
	    }
	  }
	  function getObserverFromMirror(mirror, callback) {
	    for (var j = 0,
	        jlen = mirror.observers.length; j < jlen; j++) {
	      if (mirror.observers[j].callback === callback) {
	        return mirror.observers[j].observer;
	      }
	    }
	  }
	  function removeObserverFromMirror(mirror, observer) {
	    for (var j = 0,
	        jlen = mirror.observers.length; j < jlen; j++) {
	      if (mirror.observers[j].observer === observer) {
	        mirror.observers.splice(j, 1);
	        if (!mirror.observers.length) {
	          removeMirror(mirror);
	        }
	        return;
	      }
	    }
	  }
	  function unobserve(root, observer) {
	    generate(observer);
	    if (Object.observe) {
	      _unobserve(observer, root);
	    } else {
	      clearTimeout(observer.next);
	    }
	    var mirror = getMirror(root);
	    removeObserverFromMirror(mirror, observer);
	  }
	  jsonpatch.unobserve = unobserve;
	  function observe(obj, callback) {
	    var patches = [];
	    var root = obj;
	    var observer;
	    var mirror = getMirror(obj);
	    if (!mirror) {
	      mirror = new Mirror(obj);
	      beforeDict.push(mirror);
	    } else {
	      observer = getObserverFromMirror(mirror, callback);
	    }
	    if (observer) {
	      return observer;
	    }
	    if (Object.observe) {
	      observer = function(arr) {
	        _unobserve(observer, obj);
	        _observe(observer, obj);
	        var a = 0,
	            alen = arr.length;
	        while (a < alen) {
	          if (!(arr[a].name === 'length' && _isArray(arr[a].object)) && !(arr[a].name === '__Jasmine_been_here_before__')) {
	            var type = arr[a].type;
	            switch (type) {
	              case 'new':
	                type = 'add';
	                break;
	              case 'deleted':
	                type = 'delete';
	                break;
	              case 'updated':
	                type = 'update';
	                break;
	            }
	            observeOps[type].call(arr[a], patches, getPath(root, arr[a].object));
	          }
	          a++;
	        }
	        if (patches) {
	          if (callback) {
	            callback(patches);
	          }
	        }
	        observer.patches = patches;
	        patches = [];
	      };
	    } else {
	      observer = {};
	      mirror.value = JSON.parse(JSON.stringify(obj));
	      if (callback) {
	        observer.callback = callback;
	        observer.next = null;
	        var intervals = this.intervals || [100, 1000, 10000, 60000];
	        var currentInterval = 0;
	        var dirtyCheck = function() {
	          generate(observer);
	        };
	        var fastCheck = function() {
	          clearTimeout(observer.next);
	          observer.next = setTimeout(function() {
	            dirtyCheck();
	            currentInterval = 0;
	            observer.next = setTimeout(slowCheck, intervals[currentInterval++]);
	          }, 0);
	        };
	        var slowCheck = function() {
	          dirtyCheck();
	          if (currentInterval == intervals.length) {
	            currentInterval = intervals.length - 1;
	          }
	          observer.next = setTimeout(slowCheck, intervals[currentInterval++]);
	        };
	        if (typeof window !== 'undefined') {
	          if (window.addEventListener) {
	            window.addEventListener('mousedown', fastCheck);
	            window.addEventListener('mouseup', fastCheck);
	            window.addEventListener('keydown', fastCheck);
	          } else {
	            window.attachEvent('onmousedown', fastCheck);
	            window.attachEvent('onmouseup', fastCheck);
	            window.attachEvent('onkeydown', fastCheck);
	          }
	        }
	        observer.next = setTimeout(slowCheck, intervals[currentInterval++]);
	      }
	    }
	    observer.patches = patches;
	    observer.object = obj;
	    mirror.observers.push(new ObserverInfo(callback, observer));
	    return _observe(observer, obj);
	  }
	  jsonpatch.observe = observe;
	  function _observe(observer, obj) {
	    if (Object.observe) {
	      Object.observe(obj, observer);
	      for (var key in obj) {
	        if (obj.hasOwnProperty(key)) {
	          var v = obj[key];
	          if (v && typeof(v) === "object") {
	            _observe(observer, v);
	          }
	        }
	      }
	    }
	    return observer;
	  }
	  function _unobserve(observer, obj) {
	    if (Object.observe) {
	      Object.unobserve(obj, observer);
	      for (var key in obj) {
	        if (obj.hasOwnProperty(key)) {
	          var v = obj[key];
	          if (v && typeof(v) === "object") {
	            _unobserve(observer, v);
	          }
	        }
	      }
	    }
	    return observer;
	  }
	  function generate(observer) {
	    if (Object.observe) {
	      Object.deliverChangeRecords(observer);
	    } else {
	      var mirror;
	      for (var i = 0,
	          ilen = beforeDict.length; i < ilen; i++) {
	        if (beforeDict[i].obj === observer.object) {
	          mirror = beforeDict[i];
	          break;
	        }
	      }
	      if (mirror) {
	        _generate(mirror.value, observer.object, observer.patches, "");
	      }
	    }
	    var temp = observer.patches;
	    if (temp.length > 0) {
	      observer.patches = [];
	      if (observer.callback) {
	        observer.callback(temp);
	      }
	    }
	    return temp;
	  }
	  jsonpatch.generate = generate;
	  var _objectKeys;
	  if (Object.keys) {
	    _objectKeys = Object.keys;
	  } else {
	    _objectKeys = function(obj) {
	      var keys = [];
	      for (var o in obj) {
	        if (obj.hasOwnProperty(o)) {
	          keys.push(o);
	        }
	      }
	      return keys;
	    };
	  }
	  function _generate(mirror, obj, patches, path) {
	    var newKeys = _objectKeys(obj);
	    var oldKeys = _objectKeys(mirror);
	    var changed = false;
	    var deleted = false;
	    for (var t = oldKeys.length - 1; t >= 0; t--) {
	      var key = oldKeys[t];
	      var oldVal = mirror[key];
	      if (obj.hasOwnProperty(key)) {
	        var newVal = obj[key];
	        if (oldVal instanceof Object) {
	          _generate(oldVal, newVal, patches, path + "/" + escapePathComponent(key));
	        } else {
	          if (oldVal != newVal) {
	            changed = true;
	            patches.push({
	              op: "replace",
	              path: path + "/" + escapePathComponent(key),
	              value: newVal
	            });
	            mirror[key] = newVal;
	          }
	        }
	      } else {
	        patches.push({
	          op: "remove",
	          path: path + "/" + escapePathComponent(key)
	        });
	        delete mirror[key];
	        deleted = true;
	      }
	    }
	    if (!deleted && newKeys.length == oldKeys.length) {
	      return;
	    }
	    for (var t = 0; t < newKeys.length; t++) {
	      var key = newKeys[t];
	      if (!mirror.hasOwnProperty(key)) {
	        patches.push({
	          op: "add",
	          path: path + "/" + escapePathComponent(key),
	          value: obj[key]
	        });
	        mirror[key] = JSON.parse(JSON.stringify(obj[key]));
	      }
	    }
	  }
	  var _isArray;
	  if (Array.isArray) {
	    _isArray = Array.isArray;
	  } else {
	    _isArray = function(obj) {
	      return obj.push && typeof obj.length === 'number';
	    };
	  }
	  function apply(tree, patches) {
	    var result = false,
	        p = 0,
	        plen = patches.length,
	        patch;
	    while (p < plen) {
	      patch = patches[p];
	      var keys = patch.path.split('/');
	      var obj = tree;
	      var t = 1;
	      var len = keys.length;
	      while (true) {
	        if (_isArray(obj)) {
	          var index = parseInt(keys[t], 10);
	          t++;
	          if (t >= len) {
	            result = arrOps[patch.op].call(patch, obj, index, tree);
	            break;
	          }
	          obj = obj[index];
	        } else {
	          var key = keys[t];
	          if (key.indexOf('~') != -1) {
	            key = key.replace(/~1/g, '/').replace(/~0/g, '~');
	          }
	          t++;
	          if (t >= len) {
	            result = objOps[patch.op].call(patch, obj, key, tree);
	            break;
	          }
	          obj = obj[key];
	        }
	      }
	      p++;
	    }
	    return result;
	  }
	  jsonpatch.apply = apply;
	})(jsonpatch || (jsonpatch = {}));
	if (typeof exports !== "undefined") {
	  exports.apply = jsonpatch.apply;
	  exports.observe = jsonpatch.observe;
	  exports.unobserve = jsonpatch.unobserve;
	  exports.generate = jsonpatch.generate;
	}

	//# 
	},{}],"moment":[function(require,module,exports){
	//! moment.js
	//! version : 2.10.6
	//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
	//! license : MIT
	//! momentjs.com

	(function (global, factory) {
	    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	    typeof define === 'function' && define.amd ? define(factory) :
	    global.moment = factory()
	}(this, function () { 'use strict';

	    var hookCallback;

	    function utils_hooks__hooks () {
	        return hookCallback.apply(null, arguments);
	    }

	    // This is done to register the method called with moment()
	    // without creating circular dependencies.
	    function setHookCallback (callback) {
	        hookCallback = callback;
	    }

	    function isArray(input) {
	        return Object.prototype.toString.call(input) === '[object Array]';
	    }

	    function isDate(input) {
	        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
	    }

	    function map(arr, fn) {
	        var res = [], i;
	        for (i = 0; i < arr.length; ++i) {
	            res.push(fn(arr[i], i));
	        }
	        return res;
	    }

	    function hasOwnProp(a, b) {
	        return Object.prototype.hasOwnProperty.call(a, b);
	    }

	    function extend(a, b) {
	        for (var i in b) {
	            if (hasOwnProp(b, i)) {
	                a[i] = b[i];
	            }
	        }

	        if (hasOwnProp(b, 'toString')) {
	            a.toString = b.toString;
	        }

	        if (hasOwnProp(b, 'valueOf')) {
	            a.valueOf = b.valueOf;
	        }

	        return a;
	    }

	    function create_utc__createUTC (input, format, locale, strict) {
	        return createLocalOrUTC(input, format, locale, strict, true).utc();
	    }

	    function defaultParsingFlags() {
	        // We need to deep clone this object.
	        return {
	            empty           : false,
	            unusedTokens    : [],
	            unusedInput     : [],
	            overflow        : -2,
	            charsLeftOver   : 0,
	            nullInput       : false,
	            invalidMonth    : null,
	            invalidFormat   : false,
	            userInvalidated : false,
	            iso             : false
	        };
	    }

	    function getParsingFlags(m) {
	        if (m._pf == null) {
	            m._pf = defaultParsingFlags();
	        }
	        return m._pf;
	    }

	    function valid__isValid(m) {
	        if (m._isValid == null) {
	            var flags = getParsingFlags(m);
	            m._isValid = !isNaN(m._d.getTime()) &&
	                flags.overflow < 0 &&
	                !flags.empty &&
	                !flags.invalidMonth &&
	                !flags.invalidWeekday &&
	                !flags.nullInput &&
	                !flags.invalidFormat &&
	                !flags.userInvalidated;

	            if (m._strict) {
	                m._isValid = m._isValid &&
	                    flags.charsLeftOver === 0 &&
	                    flags.unusedTokens.length === 0 &&
	                    flags.bigHour === undefined;
	            }
	        }
	        return m._isValid;
	    }

	    function valid__createInvalid (flags) {
	        var m = create_utc__createUTC(NaN);
	        if (flags != null) {
	            extend(getParsingFlags(m), flags);
	        }
	        else {
	            getParsingFlags(m).userInvalidated = true;
	        }

	        return m;
	    }

	    var momentProperties = utils_hooks__hooks.momentProperties = [];

	    function copyConfig(to, from) {
	        var i, prop, val;

	        if (typeof from._isAMomentObject !== 'undefined') {
	            to._isAMomentObject = from._isAMomentObject;
	        }
	        if (typeof from._i !== 'undefined') {
	            to._i = from._i;
	        }
	        if (typeof from._f !== 'undefined') {
	            to._f = from._f;
	        }
	        if (typeof from._l !== 'undefined') {
	            to._l = from._l;
	        }
	        if (typeof from._strict !== 'undefined') {
	            to._strict = from._strict;
	        }
	        if (typeof from._tzm !== 'undefined') {
	            to._tzm = from._tzm;
	        }
	        if (typeof from._isUTC !== 'undefined') {
	            to._isUTC = from._isUTC;
	        }
	        if (typeof from._offset !== 'undefined') {
	            to._offset = from._offset;
	        }
	        if (typeof from._pf !== 'undefined') {
	            to._pf = getParsingFlags(from);
	        }
	        if (typeof from._locale !== 'undefined') {
	            to._locale = from._locale;
	        }

	        if (momentProperties.length > 0) {
	            for (i in momentProperties) {
	                prop = momentProperties[i];
	                val = from[prop];
	                if (typeof val !== 'undefined') {
	                    to[prop] = val;
	                }
	            }
	        }

	        return to;
	    }

	    var updateInProgress = false;

	    // Moment prototype object
	    function Moment(config) {
	        copyConfig(this, config);
	        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
	        // Prevent infinite loop in case updateOffset creates new moment
	        // objects.
	        if (updateInProgress === false) {
	            updateInProgress = true;
	            utils_hooks__hooks.updateOffset(this);
	            updateInProgress = false;
	        }
	    }

	    function isMoment (obj) {
	        return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
	    }

	    function absFloor (number) {
	        if (number < 0) {
	            return Math.ceil(number);
	        } else {
	            return Math.floor(number);
	        }
	    }

	    function toInt(argumentForCoercion) {
	        var coercedNumber = +argumentForCoercion,
	            value = 0;

	        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
	            value = absFloor(coercedNumber);
	        }

	        return value;
	    }

	    function compareArrays(array1, array2, dontConvert) {
	        var len = Math.min(array1.length, array2.length),
	            lengthDiff = Math.abs(array1.length - array2.length),
	            diffs = 0,
	            i;
	        for (i = 0; i < len; i++) {
	            if ((dontConvert && array1[i] !== array2[i]) ||
	                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
	                diffs++;
	            }
	        }
	        return diffs + lengthDiff;
	    }

	    function Locale() {
	    }

	    var locales = {};
	    var globalLocale;

	    function normalizeLocale(key) {
	        return key ? key.toLowerCase().replace('_', '-') : key;
	    }

	    // pick the locale from the array
	    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
	    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
	    function chooseLocale(names) {
	        var i = 0, j, next, locale, split;

	        while (i < names.length) {
	            split = normalizeLocale(names[i]).split('-');
	            j = split.length;
	            next = normalizeLocale(names[i + 1]);
	            next = next ? next.split('-') : null;
	            while (j > 0) {
	                locale = loadLocale(split.slice(0, j).join('-'));
	                if (locale) {
	                    return locale;
	                }
	                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
	                    //the next array item is better than a shallower substring of this one
	                    break;
	                }
	                j--;
	            }
	            i++;
	        }
	        return null;
	    }

	    function loadLocale(name) {
	        var oldLocale = null;
	        // TODO: Find a better way to register and load all the locales in Node
	        if (!locales[name] && typeof module !== 'undefined' &&
	                module && module.exports) {
	            try {
	                oldLocale = globalLocale._abbr;
	                require('./locale/' + name);
	                // because defineLocale currently also sets the global locale, we
	                // want to undo that for lazy loaded locales
	                locale_locales__getSetGlobalLocale(oldLocale);
	            } catch (e) { }
	        }
	        return locales[name];
	    }

	    // This function will load locale and then set the global locale.  If
	    // no arguments are passed in, it will simply return the current global
	    // locale key.
	    function locale_locales__getSetGlobalLocale (key, values) {
	        var data;
	        if (key) {
	            if (typeof values === 'undefined') {
	                data = locale_locales__getLocale(key);
	            }
	            else {
	                data = defineLocale(key, values);
	            }

	            if (data) {
	                // moment.duration._locale = moment._locale = data;
	                globalLocale = data;
	            }
	        }

	        return globalLocale._abbr;
	    }

	    function defineLocale (name, values) {
	        if (values !== null) {
	            values.abbr = name;
	            locales[name] = locales[name] || new Locale();
	            locales[name].set(values);

	            // backwards compat for now: also set the locale
	            locale_locales__getSetGlobalLocale(name);

	            return locales[name];
	        } else {
	            // useful for testing
	            delete locales[name];
	            return null;
	        }
	    }

	    // returns locale data
	    function locale_locales__getLocale (key) {
	        var locale;

	        if (key && key._locale && key._locale._abbr) {
	            key = key._locale._abbr;
	        }

	        if (!key) {
	            return globalLocale;
	        }

	        if (!isArray(key)) {
	            //short-circuit everything else
	            locale = loadLocale(key);
	            if (locale) {
	                return locale;
	            }
	            key = [key];
	        }

	        return chooseLocale(key);
	    }

	    var aliases = {};

	    function addUnitAlias (unit, shorthand) {
	        var lowerCase = unit.toLowerCase();
	        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
	    }

	    function normalizeUnits(units) {
	        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
	    }

	    function normalizeObjectUnits(inputObject) {
	        var normalizedInput = {},
	            normalizedProp,
	            prop;

	        for (prop in inputObject) {
	            if (hasOwnProp(inputObject, prop)) {
	                normalizedProp = normalizeUnits(prop);
	                if (normalizedProp) {
	                    normalizedInput[normalizedProp] = inputObject[prop];
	                }
	            }
	        }

	        return normalizedInput;
	    }

	    function makeGetSet (unit, keepTime) {
	        return function (value) {
	            if (value != null) {
	                get_set__set(this, unit, value);
	                utils_hooks__hooks.updateOffset(this, keepTime);
	                return this;
	            } else {
	                return get_set__get(this, unit);
	            }
	        };
	    }

	    function get_set__get (mom, unit) {
	        return mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]();
	    }

	    function get_set__set (mom, unit, value) {
	        return mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
	    }

	    // MOMENTS

	    function getSet (units, value) {
	        var unit;
	        if (typeof units === 'object') {
	            for (unit in units) {
	                this.set(unit, units[unit]);
	            }
	        } else {
	            units = normalizeUnits(units);
	            if (typeof this[units] === 'function') {
	                return this[units](value);
	            }
	        }
	        return this;
	    }

	    function zeroFill(number, targetLength, forceSign) {
	        var absNumber = '' + Math.abs(number),
	            zerosToFill = targetLength - absNumber.length,
	            sign = number >= 0;
	        return (sign ? (forceSign ? '+' : '') : '-') +
	            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
	    }

	    var formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Q|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

	    var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

	    var formatFunctions = {};

	    var formatTokenFunctions = {};

	    // token:    'M'
	    // padded:   ['MM', 2]
	    // ordinal:  'Mo'
	    // callback: function () { this.month() + 1 }
	    function addFormatToken (token, padded, ordinal, callback) {
	        var func = callback;
	        if (typeof callback === 'string') {
	            func = function () {
	                return this[callback]();
	            };
	        }
	        if (token) {
	            formatTokenFunctions[token] = func;
	        }
	        if (padded) {
	            formatTokenFunctions[padded[0]] = function () {
	                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
	            };
	        }
	        if (ordinal) {
	            formatTokenFunctions[ordinal] = function () {
	                return this.localeData().ordinal(func.apply(this, arguments), token);
	            };
	        }
	    }

	    function removeFormattingTokens(input) {
	        if (input.match(/\[[\s\S]/)) {
	            return input.replace(/^\[|\]$/g, '');
	        }
	        return input.replace(/\\/g, '');
	    }

	    function makeFormatFunction(format) {
	        var array = format.match(formattingTokens), i, length;

	        for (i = 0, length = array.length; i < length; i++) {
	            if (formatTokenFunctions[array[i]]) {
	                array[i] = formatTokenFunctions[array[i]];
	            } else {
	                array[i] = removeFormattingTokens(array[i]);
	            }
	        }

	        return function (mom) {
	            var output = '';
	            for (i = 0; i < length; i++) {
	                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
	            }
	            return output;
	        };
	    }

	    // format date using native date object
	    function formatMoment(m, format) {
	        if (!m.isValid()) {
	            return m.localeData().invalidDate();
	        }

	        format = expandFormat(format, m.localeData());
	        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

	        return formatFunctions[format](m);
	    }

	    function expandFormat(format, locale) {
	        var i = 5;

	        function replaceLongDateFormatTokens(input) {
	            return locale.longDateFormat(input) || input;
	        }

	        localFormattingTokens.lastIndex = 0;
	        while (i >= 0 && localFormattingTokens.test(format)) {
	            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
	            localFormattingTokens.lastIndex = 0;
	            i -= 1;
	        }

	        return format;
	    }

	    var match1         = /\d/;            //       0 - 9
	    var match2         = /\d\d/;          //      00 - 99
	    var match3         = /\d{3}/;         //     000 - 999
	    var match4         = /\d{4}/;         //    0000 - 9999
	    var match6         = /[+-]?\d{6}/;    // -999999 - 999999
	    var match1to2      = /\d\d?/;         //       0 - 99
	    var match1to3      = /\d{1,3}/;       //       0 - 999
	    var match1to4      = /\d{1,4}/;       //       0 - 9999
	    var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

	    var matchUnsigned  = /\d+/;           //       0 - inf
	    var matchSigned    = /[+-]?\d+/;      //    -inf - inf

	    var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z

	    var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

	    // any word (or two) characters or numbers including two/three word month in arabic.
	    var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;

	    var regexes = {};

	    function isFunction (sth) {
	        // https://github.com/moment/moment/issues/2325
	        return typeof sth === 'function' &&
	            Object.prototype.toString.call(sth) === '[object Function]';
	    }


	    function addRegexToken (token, regex, strictRegex) {
	        regexes[token] = isFunction(regex) ? regex : function (isStrict) {
	            return (isStrict && strictRegex) ? strictRegex : regex;
	        };
	    }

	    function getParseRegexForToken (token, config) {
	        if (!hasOwnProp(regexes, token)) {
	            return new RegExp(unescapeFormat(token));
	        }

	        return regexes[token](config._strict, config._locale);
	    }

	    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
	    function unescapeFormat(s) {
	        return s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
	            return p1 || p2 || p3 || p4;
	        }).replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
	    }

	    var tokens = {};

	    function addParseToken (token, callback) {
	        var i, func = callback;
	        if (typeof token === 'string') {
	            token = [token];
	        }
	        if (typeof callback === 'number') {
	            func = function (input, array) {
	                array[callback] = toInt(input);
	            };
	        }
	        for (i = 0; i < token.length; i++) {
	            tokens[token[i]] = func;
	        }
	    }

	    function addWeekParseToken (token, callback) {
	        addParseToken(token, function (input, array, config, token) {
	            config._w = config._w || {};
	            callback(input, config._w, config, token);
	        });
	    }

	    function addTimeToArrayFromToken(token, input, config) {
	        if (input != null && hasOwnProp(tokens, token)) {
	            tokens[token](input, config._a, config, token);
	        }
	    }

	    var YEAR = 0;
	    var MONTH = 1;
	    var DATE = 2;
	    var HOUR = 3;
	    var MINUTE = 4;
	    var SECOND = 5;
	    var MILLISECOND = 6;

	    function daysInMonth(year, month) {
	        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
	    }

	    // FORMATTING

	    addFormatToken('M', ['MM', 2], 'Mo', function () {
	        return this.month() + 1;
	    });

	    addFormatToken('MMM', 0, 0, function (format) {
	        return this.localeData().monthsShort(this, format);
	    });

	    addFormatToken('MMMM', 0, 0, function (format) {
	        return this.localeData().months(this, format);
	    });

	    // ALIASES

	    addUnitAlias('month', 'M');

	    // PARSING

	    addRegexToken('M',    match1to2);
	    addRegexToken('MM',   match1to2, match2);
	    addRegexToken('MMM',  matchWord);
	    addRegexToken('MMMM', matchWord);

	    addParseToken(['M', 'MM'], function (input, array) {
	        array[MONTH] = toInt(input) - 1;
	    });

	    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
	        var month = config._locale.monthsParse(input, token, config._strict);
	        // if we didn't find a month name, mark the date as invalid.
	        if (month != null) {
	            array[MONTH] = month;
	        } else {
	            getParsingFlags(config).invalidMonth = input;
	        }
	    });

	    // LOCALES

	    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
	    function localeMonths (m) {
	        return this._months[m.month()];
	    }

	    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
	    function localeMonthsShort (m) {
	        return this._monthsShort[m.month()];
	    }

	    function localeMonthsParse (monthName, format, strict) {
	        var i, mom, regex;

	        if (!this._monthsParse) {
	            this._monthsParse = [];
	            this._longMonthsParse = [];
	            this._shortMonthsParse = [];
	        }

	        for (i = 0; i < 12; i++) {
	            // make the regex if we don't have it already
	            mom = create_utc__createUTC([2000, i]);
	            if (strict && !this._longMonthsParse[i]) {
	                this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
	                this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
	            }
	            if (!strict && !this._monthsParse[i]) {
	                regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
	                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
	            }
	            // test the regex
	            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
	                return i;
	            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
	                return i;
	            } else if (!strict && this._monthsParse[i].test(monthName)) {
	                return i;
	            }
	        }
	    }

	    // MOMENTS

	    function setMonth (mom, value) {
	        var dayOfMonth;

	        // TODO: Move this out of here!
	        if (typeof value === 'string') {
	            value = mom.localeData().monthsParse(value);
	            // TODO: Another silent failure?
	            if (typeof value !== 'number') {
	                return mom;
	            }
	        }

	        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
	        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
	        return mom;
	    }

	    function getSetMonth (value) {
	        if (value != null) {
	            setMonth(this, value);
	            utils_hooks__hooks.updateOffset(this, true);
	            return this;
	        } else {
	            return get_set__get(this, 'Month');
	        }
	    }

	    function getDaysInMonth () {
	        return daysInMonth(this.year(), this.month());
	    }

	    function checkOverflow (m) {
	        var overflow;
	        var a = m._a;

	        if (a && getParsingFlags(m).overflow === -2) {
	            overflow =
	                a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
	                a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
	                a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
	                a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
	                a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
	                a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
	                -1;

	            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
	                overflow = DATE;
	            }

	            getParsingFlags(m).overflow = overflow;
	        }

	        return m;
	    }

	    function warn(msg) {
	        if (utils_hooks__hooks.suppressDeprecationWarnings === false && typeof console !== 'undefined' && console.warn) {
	            console.warn('Deprecation warning: ' + msg);
	        }
	    }

	    function deprecate(msg, fn) {
	        var firstTime = true;

	        return extend(function () {
	            if (firstTime) {
	                warn(msg + '\n' + (new Error()).stack);
	                firstTime = false;
	            }
	            return fn.apply(this, arguments);
	        }, fn);
	    }

	    var deprecations = {};

	    function deprecateSimple(name, msg) {
	        if (!deprecations[name]) {
	            warn(msg);
	            deprecations[name] = true;
	        }
	    }

	    utils_hooks__hooks.suppressDeprecationWarnings = false;

	    var from_string__isoRegex = /^\s*(?:[+-]\d{6}|\d{4})-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

	    var isoDates = [
	        ['YYYYYY-MM-DD', /[+-]\d{6}-\d{2}-\d{2}/],
	        ['YYYY-MM-DD', /\d{4}-\d{2}-\d{2}/],
	        ['GGGG-[W]WW-E', /\d{4}-W\d{2}-\d/],
	        ['GGGG-[W]WW', /\d{4}-W\d{2}/],
	        ['YYYY-DDD', /\d{4}-\d{3}/]
	    ];

	    // iso time formats and regexes
	    var isoTimes = [
	        ['HH:mm:ss.SSSS', /(T| )\d\d:\d\d:\d\d\.\d+/],
	        ['HH:mm:ss', /(T| )\d\d:\d\d:\d\d/],
	        ['HH:mm', /(T| )\d\d:\d\d/],
	        ['HH', /(T| )\d\d/]
	    ];

	    var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

	    // date from iso format
	    function configFromISO(config) {
	        var i, l,
	            string = config._i,
	            match = from_string__isoRegex.exec(string);

	        if (match) {
	            getParsingFlags(config).iso = true;
	            for (i = 0, l = isoDates.length; i < l; i++) {
	                if (isoDates[i][1].exec(string)) {
	                    config._f = isoDates[i][0];
	                    break;
	                }
	            }
	            for (i = 0, l = isoTimes.length; i < l; i++) {
	                if (isoTimes[i][1].exec(string)) {
	                    // match[6] should be 'T' or space
	                    config._f += (match[6] || ' ') + isoTimes[i][0];
	                    break;
	                }
	            }
	            if (string.match(matchOffset)) {
	                config._f += 'Z';
	            }
	            configFromStringAndFormat(config);
	        } else {
	            config._isValid = false;
	        }
	    }

	    // date from iso format or fallback
	    function configFromString(config) {
	        var matched = aspNetJsonRegex.exec(config._i);

	        if (matched !== null) {
	            config._d = new Date(+matched[1]);
	            return;
	        }

	        configFromISO(config);
	        if (config._isValid === false) {
	            delete config._isValid;
	            utils_hooks__hooks.createFromInputFallback(config);
	        }
	    }

	    utils_hooks__hooks.createFromInputFallback = deprecate(
	        'moment construction falls back to js Date. This is ' +
	        'discouraged and will be removed in upcoming major ' +
	        'release. Please refer to ' +
	        'https://github.com/moment/moment/issues/1407 for more info.',
	        function (config) {
	            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
	        }
	    );

	    function createDate (y, m, d, h, M, s, ms) {
	        //can't just apply() to create a date:
	        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
	        var date = new Date(y, m, d, h, M, s, ms);

	        //the date constructor doesn't accept years < 1970
	        if (y < 1970) {
	            date.setFullYear(y);
	        }
	        return date;
	    }

	    function createUTCDate (y) {
	        var date = new Date(Date.UTC.apply(null, arguments));
	        if (y < 1970) {
	            date.setUTCFullYear(y);
	        }
	        return date;
	    }

	    addFormatToken(0, ['YY', 2], 0, function () {
	        return this.year() % 100;
	    });

	    addFormatToken(0, ['YYYY',   4],       0, 'year');
	    addFormatToken(0, ['YYYYY',  5],       0, 'year');
	    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

	    // ALIASES

	    addUnitAlias('year', 'y');

	    // PARSING

	    addRegexToken('Y',      matchSigned);
	    addRegexToken('YY',     match1to2, match2);
	    addRegexToken('YYYY',   match1to4, match4);
	    addRegexToken('YYYYY',  match1to6, match6);
	    addRegexToken('YYYYYY', match1to6, match6);

	    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
	    addParseToken('YYYY', function (input, array) {
	        array[YEAR] = input.length === 2 ? utils_hooks__hooks.parseTwoDigitYear(input) : toInt(input);
	    });
	    addParseToken('YY', function (input, array) {
	        array[YEAR] = utils_hooks__hooks.parseTwoDigitYear(input);
	    });

	    // HELPERS

	    function daysInYear(year) {
	        return isLeapYear(year) ? 366 : 365;
	    }

	    function isLeapYear(year) {
	        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
	    }

	    // HOOKS

	    utils_hooks__hooks.parseTwoDigitYear = function (input) {
	        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
	    };

	    // MOMENTS

	    var getSetYear = makeGetSet('FullYear', false);

	    function getIsLeapYear () {
	        return isLeapYear(this.year());
	    }

	    addFormatToken('w', ['ww', 2], 'wo', 'week');
	    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

	    // ALIASES

	    addUnitAlias('week', 'w');
	    addUnitAlias('isoWeek', 'W');

	    // PARSING

	    addRegexToken('w',  match1to2);
	    addRegexToken('ww', match1to2, match2);
	    addRegexToken('W',  match1to2);
	    addRegexToken('WW', match1to2, match2);

	    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
	        week[token.substr(0, 1)] = toInt(input);
	    });

	    // HELPERS

	    // firstDayOfWeek       0 = sun, 6 = sat
	    //                      the day of the week that starts the week
	    //                      (usually sunday or monday)
	    // firstDayOfWeekOfYear 0 = sun, 6 = sat
	    //                      the first week is the week that contains the first
	    //                      of this day of the week
	    //                      (eg. ISO weeks use thursday (4))
	    function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
	        var end = firstDayOfWeekOfYear - firstDayOfWeek,
	            daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(),
	            adjustedMoment;


	        if (daysToDayOfWeek > end) {
	            daysToDayOfWeek -= 7;
	        }

	        if (daysToDayOfWeek < end - 7) {
	            daysToDayOfWeek += 7;
	        }

	        adjustedMoment = local__createLocal(mom).add(daysToDayOfWeek, 'd');
	        return {
	            week: Math.ceil(adjustedMoment.dayOfYear() / 7),
	            year: adjustedMoment.year()
	        };
	    }

	    // LOCALES

	    function localeWeek (mom) {
	        return weekOfYear(mom, this._week.dow, this._week.doy).week;
	    }

	    var defaultLocaleWeek = {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    };

	    function localeFirstDayOfWeek () {
	        return this._week.dow;
	    }

	    function localeFirstDayOfYear () {
	        return this._week.doy;
	    }

	    // MOMENTS

	    function getSetWeek (input) {
	        var week = this.localeData().week(this);
	        return input == null ? week : this.add((input - week) * 7, 'd');
	    }

	    function getSetISOWeek (input) {
	        var week = weekOfYear(this, 1, 4).week;
	        return input == null ? week : this.add((input - week) * 7, 'd');
	    }

	    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

	    // ALIASES

	    addUnitAlias('dayOfYear', 'DDD');

	    // PARSING

	    addRegexToken('DDD',  match1to3);
	    addRegexToken('DDDD', match3);
	    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
	        config._dayOfYear = toInt(input);
	    });

	    // HELPERS

	    //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
	    function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {
	        var week1Jan = 6 + firstDayOfWeek - firstDayOfWeekOfYear, janX = createUTCDate(year, 0, 1 + week1Jan), d = janX.getUTCDay(), dayOfYear;
	        if (d < firstDayOfWeek) {
	            d += 7;
	        }

	        weekday = weekday != null ? 1 * weekday : firstDayOfWeek;

	        dayOfYear = 1 + week1Jan + 7 * (week - 1) - d + weekday;

	        return {
	            year: dayOfYear > 0 ? year : year - 1,
	            dayOfYear: dayOfYear > 0 ?  dayOfYear : daysInYear(year - 1) + dayOfYear
	        };
	    }

	    // MOMENTS

	    function getSetDayOfYear (input) {
	        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
	        return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
	    }

	    // Pick the first defined of two or three arguments.
	    function defaults(a, b, c) {
	        if (a != null) {
	            return a;
	        }
	        if (b != null) {
	            return b;
	        }
	        return c;
	    }

	    function currentDateArray(config) {
	        var now = new Date();
	        if (config._useUTC) {
	            return [now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()];
	        }
	        return [now.getFullYear(), now.getMonth(), now.getDate()];
	    }

	    // convert an array to a date.
	    // the array should mirror the parameters below
	    // note: all values past the year are optional and will default to the lowest possible value.
	    // [year, month, day , hour, minute, second, millisecond]
	    function configFromArray (config) {
	        var i, date, input = [], currentDate, yearToUse;

	        if (config._d) {
	            return;
	        }

	        currentDate = currentDateArray(config);

	        //compute day of the year from weeks and weekdays
	        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
	            dayOfYearFromWeekInfo(config);
	        }

	        //if the day of the year is set, figure out what it is
	        if (config._dayOfYear) {
	            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

	            if (config._dayOfYear > daysInYear(yearToUse)) {
	                getParsingFlags(config)._overflowDayOfYear = true;
	            }

	            date = createUTCDate(yearToUse, 0, config._dayOfYear);
	            config._a[MONTH] = date.getUTCMonth();
	            config._a[DATE] = date.getUTCDate();
	        }

	        // Default to current date.
	        // * if no year, month, day of month are given, default to today
	        // * if day of month is given, default month and year
	        // * if month is given, default only year
	        // * if year is given, don't default anything
	        for (i = 0; i < 3 && config._a[i] == null; ++i) {
	            config._a[i] = input[i] = currentDate[i];
	        }

	        // Zero out whatever was not defaulted, including time
	        for (; i < 7; i++) {
	            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
	        }

	        // Check for 24:00:00.000
	        if (config._a[HOUR] === 24 &&
	                config._a[MINUTE] === 0 &&
	                config._a[SECOND] === 0 &&
	                config._a[MILLISECOND] === 0) {
	            config._nextDay = true;
	            config._a[HOUR] = 0;
	        }

	        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
	        // Apply timezone offset from input. The actual utcOffset can be changed
	        // with parseZone.
	        if (config._tzm != null) {
	            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
	        }

	        if (config._nextDay) {
	            config._a[HOUR] = 24;
	        }
	    }

	    function dayOfYearFromWeekInfo(config) {
	        var w, weekYear, week, weekday, dow, doy, temp;

	        w = config._w;
	        if (w.GG != null || w.W != null || w.E != null) {
	            dow = 1;
	            doy = 4;

	            // TODO: We need to take the current isoWeekYear, but that depends on
	            // how we interpret now (local, utc, fixed offset). So create
	            // a now version of current config (take local/utc/offset flags, and
	            // create now).
	            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(local__createLocal(), 1, 4).year);
	            week = defaults(w.W, 1);
	            weekday = defaults(w.E, 1);
	        } else {
	            dow = config._locale._week.dow;
	            doy = config._locale._week.doy;

	            weekYear = defaults(w.gg, config._a[YEAR], weekOfYear(local__createLocal(), dow, doy).year);
	            week = defaults(w.w, 1);

	            if (w.d != null) {
	                // weekday -- low day numbers are considered next week
	                weekday = w.d;
	                if (weekday < dow) {
	                    ++week;
	                }
	            } else if (w.e != null) {
	                // local weekday -- counting starts from begining of week
	                weekday = w.e + dow;
	            } else {
	                // default to begining of week
	                weekday = dow;
	            }
	        }
	        temp = dayOfYearFromWeeks(weekYear, week, weekday, doy, dow);

	        config._a[YEAR] = temp.year;
	        config._dayOfYear = temp.dayOfYear;
	    }

	    utils_hooks__hooks.ISO_8601 = function () {};

	    // date from string and format string
	    function configFromStringAndFormat(config) {
	        // TODO: Move this to another part of the creation flow to prevent circular deps
	        if (config._f === utils_hooks__hooks.ISO_8601) {
	            configFromISO(config);
	            return;
	        }

	        config._a = [];
	        getParsingFlags(config).empty = true;

	        // This array is used to make a Date, either with `new Date` or `Date.UTC`
	        var string = '' + config._i,
	            i, parsedInput, tokens, token, skipped,
	            stringLength = string.length,
	            totalParsedInputLength = 0;

	        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

	        for (i = 0; i < tokens.length; i++) {
	            token = tokens[i];
	            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
	            if (parsedInput) {
	                skipped = string.substr(0, string.indexOf(parsedInput));
	                if (skipped.length > 0) {
	                    getParsingFlags(config).unusedInput.push(skipped);
	                }
	                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
	                totalParsedInputLength += parsedInput.length;
	            }
	            // don't parse if it's not a known token
	            if (formatTokenFunctions[token]) {
	                if (parsedInput) {
	                    getParsingFlags(config).empty = false;
	                }
	                else {
	                    getParsingFlags(config).unusedTokens.push(token);
	                }
	                addTimeToArrayFromToken(token, parsedInput, config);
	            }
	            else if (config._strict && !parsedInput) {
	                getParsingFlags(config).unusedTokens.push(token);
	            }
	        }

	        // add remaining unparsed input length to the string
	        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
	        if (string.length > 0) {
	            getParsingFlags(config).unusedInput.push(string);
	        }

	        // clear _12h flag if hour is <= 12
	        if (getParsingFlags(config).bigHour === true &&
	                config._a[HOUR] <= 12 &&
	                config._a[HOUR] > 0) {
	            getParsingFlags(config).bigHour = undefined;
	        }
	        // handle meridiem
	        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

	        configFromArray(config);
	        checkOverflow(config);
	    }


	    function meridiemFixWrap (locale, hour, meridiem) {
	        var isPm;

	        if (meridiem == null) {
	            // nothing to do
	            return hour;
	        }
	        if (locale.meridiemHour != null) {
	            return locale.meridiemHour(hour, meridiem);
	        } else if (locale.isPM != null) {
	            // Fallback
	            isPm = locale.isPM(meridiem);
	            if (isPm && hour < 12) {
	                hour += 12;
	            }
	            if (!isPm && hour === 12) {
	                hour = 0;
	            }
	            return hour;
	        } else {
	            // this is not supposed to happen
	            return hour;
	        }
	    }

	    function configFromStringAndArray(config) {
	        var tempConfig,
	            bestMoment,

	            scoreToBeat,
	            i,
	            currentScore;

	        if (config._f.length === 0) {
	            getParsingFlags(config).invalidFormat = true;
	            config._d = new Date(NaN);
	            return;
	        }

	        for (i = 0; i < config._f.length; i++) {
	            currentScore = 0;
	            tempConfig = copyConfig({}, config);
	            if (config._useUTC != null) {
	                tempConfig._useUTC = config._useUTC;
	            }
	            tempConfig._f = config._f[i];
	            configFromStringAndFormat(tempConfig);

	            if (!valid__isValid(tempConfig)) {
	                continue;
	            }

	            // if there is any input that was not parsed add a penalty for that format
	            currentScore += getParsingFlags(tempConfig).charsLeftOver;

	            //or tokens
	            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

	            getParsingFlags(tempConfig).score = currentScore;

	            if (scoreToBeat == null || currentScore < scoreToBeat) {
	                scoreToBeat = currentScore;
	                bestMoment = tempConfig;
	            }
	        }

	        extend(config, bestMoment || tempConfig);
	    }

	    function configFromObject(config) {
	        if (config._d) {
	            return;
	        }

	        var i = normalizeObjectUnits(config._i);
	        config._a = [i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond];

	        configFromArray(config);
	    }

	    function createFromConfig (config) {
	        var res = new Moment(checkOverflow(prepareConfig(config)));
	        if (res._nextDay) {
	            // Adding is smart enough around DST
	            res.add(1, 'd');
	            res._nextDay = undefined;
	        }

	        return res;
	    }

	    function prepareConfig (config) {
	        var input = config._i,
	            format = config._f;

	        config._locale = config._locale || locale_locales__getLocale(config._l);

	        if (input === null || (format === undefined && input === '')) {
	            return valid__createInvalid({nullInput: true});
	        }

	        if (typeof input === 'string') {
	            config._i = input = config._locale.preparse(input);
	        }

	        if (isMoment(input)) {
	            return new Moment(checkOverflow(input));
	        } else if (isArray(format)) {
	            configFromStringAndArray(config);
	        } else if (format) {
	            configFromStringAndFormat(config);
	        } else if (isDate(input)) {
	            config._d = input;
	        } else {
	            configFromInput(config);
	        }

	        return config;
	    }

	    function configFromInput(config) {
	        var input = config._i;
	        if (input === undefined) {
	            config._d = new Date();
	        } else if (isDate(input)) {
	            config._d = new Date(+input);
	        } else if (typeof input === 'string') {
	            configFromString(config);
	        } else if (isArray(input)) {
	            config._a = map(input.slice(0), function (obj) {
	                return parseInt(obj, 10);
	            });
	            configFromArray(config);
	        } else if (typeof(input) === 'object') {
	            configFromObject(config);
	        } else if (typeof(input) === 'number') {
	            // from milliseconds
	            config._d = new Date(input);
	        } else {
	            utils_hooks__hooks.createFromInputFallback(config);
	        }
	    }

	    function createLocalOrUTC (input, format, locale, strict, isUTC) {
	        var c = {};

	        if (typeof(locale) === 'boolean') {
	            strict = locale;
	            locale = undefined;
	        }
	        // object construction must be done this way.
	        // https://github.com/moment/moment/issues/1423
	        c._isAMomentObject = true;
	        c._useUTC = c._isUTC = isUTC;
	        c._l = locale;
	        c._i = input;
	        c._f = format;
	        c._strict = strict;

	        return createFromConfig(c);
	    }

	    function local__createLocal (input, format, locale, strict) {
	        return createLocalOrUTC(input, format, locale, strict, false);
	    }

	    var prototypeMin = deprecate(
	         'moment().min is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548',
	         function () {
	             var other = local__createLocal.apply(null, arguments);
	             return other < this ? this : other;
	         }
	     );

	    var prototypeMax = deprecate(
	        'moment().max is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548',
	        function () {
	            var other = local__createLocal.apply(null, arguments);
	            return other > this ? this : other;
	        }
	    );

	    // Pick a moment m from moments so that m[fn](other) is true for all
	    // other. This relies on the function fn to be transitive.
	    //
	    // moments should either be an array of moment objects or an array, whose
	    // first element is an array of moment objects.
	    function pickBy(fn, moments) {
	        var res, i;
	        if (moments.length === 1 && isArray(moments[0])) {
	            moments = moments[0];
	        }
	        if (!moments.length) {
	            return local__createLocal();
	        }
	        res = moments[0];
	        for (i = 1; i < moments.length; ++i) {
	            if (!moments[i].isValid() || moments[i][fn](res)) {
	                res = moments[i];
	            }
	        }
	        return res;
	    }

	    // TODO: Use [].sort instead?
	    function min () {
	        var args = [].slice.call(arguments, 0);

	        return pickBy('isBefore', args);
	    }

	    function max () {
	        var args = [].slice.call(arguments, 0);

	        return pickBy('isAfter', args);
	    }

	    function Duration (duration) {
	        var normalizedInput = normalizeObjectUnits(duration),
	            years = normalizedInput.year || 0,
	            quarters = normalizedInput.quarter || 0,
	            months = normalizedInput.month || 0,
	            weeks = normalizedInput.week || 0,
	            days = normalizedInput.day || 0,
	            hours = normalizedInput.hour || 0,
	            minutes = normalizedInput.minute || 0,
	            seconds = normalizedInput.second || 0,
	            milliseconds = normalizedInput.millisecond || 0;

	        // representation for dateAddRemove
	        this._milliseconds = +milliseconds +
	            seconds * 1e3 + // 1000
	            minutes * 6e4 + // 1000 * 60
	            hours * 36e5; // 1000 * 60 * 60
	        // Because of dateAddRemove treats 24 hours as different from a
	        // day when working around DST, we need to store them separately
	        this._days = +days +
	            weeks * 7;
	        // It is impossible translate months into days without knowing
	        // which months you are are talking about, so we have to store
	        // it separately.
	        this._months = +months +
	            quarters * 3 +
	            years * 12;

	        this._data = {};

	        this._locale = locale_locales__getLocale();

	        this._bubble();
	    }

	    function isDuration (obj) {
	        return obj instanceof Duration;
	    }

	    function offset (token, separator) {
	        addFormatToken(token, 0, 0, function () {
	            var offset = this.utcOffset();
	            var sign = '+';
	            if (offset < 0) {
	                offset = -offset;
	                sign = '-';
	            }
	            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
	        });
	    }

	    offset('Z', ':');
	    offset('ZZ', '');

	    // PARSING

	    addRegexToken('Z',  matchOffset);
	    addRegexToken('ZZ', matchOffset);
	    addParseToken(['Z', 'ZZ'], function (input, array, config) {
	        config._useUTC = true;
	        config._tzm = offsetFromString(input);
	    });

	    // HELPERS

	    // timezone chunker
	    // '+10:00' > ['10',  '00']
	    // '-1530'  > ['-15', '30']
	    var chunkOffset = /([\+\-]|\d\d)/gi;

	    function offsetFromString(string) {
	        var matches = ((string || '').match(matchOffset) || []);
	        var chunk   = matches[matches.length - 1] || [];
	        var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
	        var minutes = +(parts[1] * 60) + toInt(parts[2]);

	        return parts[0] === '+' ? minutes : -minutes;
	    }

	    // Return a moment from input, that is local/utc/zone equivalent to model.
	    function cloneWithOffset(input, model) {
	        var res, diff;
	        if (model._isUTC) {
	            res = model.clone();
	            diff = (isMoment(input) || isDate(input) ? +input : +local__createLocal(input)) - (+res);
	            // Use low-level api, because this fn is low-level api.
	            res._d.setTime(+res._d + diff);
	            utils_hooks__hooks.updateOffset(res, false);
	            return res;
	        } else {
	            return local__createLocal(input).local();
	        }
	    }

	    function getDateOffset (m) {
	        // On Firefox.24 Date#getTimezoneOffset returns a floating point.
	        // https://github.com/moment/moment/pull/1871
	        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
	    }

	    // HOOKS

	    // This function will be called whenever a moment is mutated.
	    // It is intended to keep the offset in sync with the timezone.
	    utils_hooks__hooks.updateOffset = function () {};

	    // MOMENTS

	    // keepLocalTime = true means only change the timezone, without
	    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
	    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
	    // +0200, so we adjust the time as needed, to be valid.
	    //
	    // Keeping the time actually adds/subtracts (one hour)
	    // from the actual represented time. That is why we call updateOffset
	    // a second time. In case it wants us to change the offset again
	    // _changeInProgress == true case, then we have to adjust, because
	    // there is no such time in the given timezone.
	    function getSetOffset (input, keepLocalTime) {
	        var offset = this._offset || 0,
	            localAdjust;
	        if (input != null) {
	            if (typeof input === 'string') {
	                input = offsetFromString(input);
	            }
	            if (Math.abs(input) < 16) {
	                input = input * 60;
	            }
	            if (!this._isUTC && keepLocalTime) {
	                localAdjust = getDateOffset(this);
	            }
	            this._offset = input;
	            this._isUTC = true;
	            if (localAdjust != null) {
	                this.add(localAdjust, 'm');
	            }
	            if (offset !== input) {
	                if (!keepLocalTime || this._changeInProgress) {
	                    add_subtract__addSubtract(this, create__createDuration(input - offset, 'm'), 1, false);
	                } else if (!this._changeInProgress) {
	                    this._changeInProgress = true;
	                    utils_hooks__hooks.updateOffset(this, true);
	                    this._changeInProgress = null;
	                }
	            }
	            return this;
	        } else {
	            return this._isUTC ? offset : getDateOffset(this);
	        }
	    }

	    function getSetZone (input, keepLocalTime) {
	        if (input != null) {
	            if (typeof input !== 'string') {
	                input = -input;
	            }

	            this.utcOffset(input, keepLocalTime);

	            return this;
	        } else {
	            return -this.utcOffset();
	        }
	    }

	    function setOffsetToUTC (keepLocalTime) {
	        return this.utcOffset(0, keepLocalTime);
	    }

	    function setOffsetToLocal (keepLocalTime) {
	        if (this._isUTC) {
	            this.utcOffset(0, keepLocalTime);
	            this._isUTC = false;

	            if (keepLocalTime) {
	                this.subtract(getDateOffset(this), 'm');
	            }
	        }
	        return this;
	    }

	    function setOffsetToParsedOffset () {
	        if (this._tzm) {
	            this.utcOffset(this._tzm);
	        } else if (typeof this._i === 'string') {
	            this.utcOffset(offsetFromString(this._i));
	        }
	        return this;
	    }

	    function hasAlignedHourOffset (input) {
	        input = input ? local__createLocal(input).utcOffset() : 0;

	        return (this.utcOffset() - input) % 60 === 0;
	    }

	    function isDaylightSavingTime () {
	        return (
	            this.utcOffset() > this.clone().month(0).utcOffset() ||
	            this.utcOffset() > this.clone().month(5).utcOffset()
	        );
	    }

	    function isDaylightSavingTimeShifted () {
	        if (typeof this._isDSTShifted !== 'undefined') {
	            return this._isDSTShifted;
	        }

	        var c = {};

	        copyConfig(c, this);
	        c = prepareConfig(c);

	        if (c._a) {
	            var other = c._isUTC ? create_utc__createUTC(c._a) : local__createLocal(c._a);
	            this._isDSTShifted = this.isValid() &&
	                compareArrays(c._a, other.toArray()) > 0;
	        } else {
	            this._isDSTShifted = false;
	        }

	        return this._isDSTShifted;
	    }

	    function isLocal () {
	        return !this._isUTC;
	    }

	    function isUtcOffset () {
	        return this._isUTC;
	    }

	    function isUtc () {
	        return this._isUTC && this._offset === 0;
	    }

	    var aspNetRegex = /(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/;

	    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
	    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
	    var create__isoRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/;

	    function create__createDuration (input, key) {
	        var duration = input,
	            // matching against regexp is expensive, do it on demand
	            match = null,
	            sign,
	            ret,
	            diffRes;

	        if (isDuration(input)) {
	            duration = {
	                ms : input._milliseconds,
	                d  : input._days,
	                M  : input._months
	            };
	        } else if (typeof input === 'number') {
	            duration = {};
	            if (key) {
	                duration[key] = input;
	            } else {
	                duration.milliseconds = input;
	            }
	        } else if (!!(match = aspNetRegex.exec(input))) {
	            sign = (match[1] === '-') ? -1 : 1;
	            duration = {
	                y  : 0,
	                d  : toInt(match[DATE])        * sign,
	                h  : toInt(match[HOUR])        * sign,
	                m  : toInt(match[MINUTE])      * sign,
	                s  : toInt(match[SECOND])      * sign,
	                ms : toInt(match[MILLISECOND]) * sign
	            };
	        } else if (!!(match = create__isoRegex.exec(input))) {
	            sign = (match[1] === '-') ? -1 : 1;
	            duration = {
	                y : parseIso(match[2], sign),
	                M : parseIso(match[3], sign),
	                d : parseIso(match[4], sign),
	                h : parseIso(match[5], sign),
	                m : parseIso(match[6], sign),
	                s : parseIso(match[7], sign),
	                w : parseIso(match[8], sign)
	            };
	        } else if (duration == null) {// checks for null or undefined
	            duration = {};
	        } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
	            diffRes = momentsDifference(local__createLocal(duration.from), local__createLocal(duration.to));

	            duration = {};
	            duration.ms = diffRes.milliseconds;
	            duration.M = diffRes.months;
	        }

	        ret = new Duration(duration);

	        if (isDuration(input) && hasOwnProp(input, '_locale')) {
	            ret._locale = input._locale;
	        }

	        return ret;
	    }

	    create__createDuration.fn = Duration.prototype;

	    function parseIso (inp, sign) {
	        // We'd normally use ~~inp for this, but unfortunately it also
	        // converts floats to ints.
	        // inp may be undefined, so careful calling replace on it.
	        var res = inp && parseFloat(inp.replace(',', '.'));
	        // apply sign while we're at it
	        return (isNaN(res) ? 0 : res) * sign;
	    }

	    function positiveMomentsDifference(base, other) {
	        var res = {milliseconds: 0, months: 0};

	        res.months = other.month() - base.month() +
	            (other.year() - base.year()) * 12;
	        if (base.clone().add(res.months, 'M').isAfter(other)) {
	            --res.months;
	        }

	        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

	        return res;
	    }

	    function momentsDifference(base, other) {
	        var res;
	        other = cloneWithOffset(other, base);
	        if (base.isBefore(other)) {
	            res = positiveMomentsDifference(base, other);
	        } else {
	            res = positiveMomentsDifference(other, base);
	            res.milliseconds = -res.milliseconds;
	            res.months = -res.months;
	        }

	        return res;
	    }

	    function createAdder(direction, name) {
	        return function (val, period) {
	            var dur, tmp;
	            //invert the arguments, but complain about it
	            if (period !== null && !isNaN(+period)) {
	                deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period).');
	                tmp = val; val = period; period = tmp;
	            }

	            val = typeof val === 'string' ? +val : val;
	            dur = create__createDuration(val, period);
	            add_subtract__addSubtract(this, dur, direction);
	            return this;
	        };
	    }

	    function add_subtract__addSubtract (mom, duration, isAdding, updateOffset) {
	        var milliseconds = duration._milliseconds,
	            days = duration._days,
	            months = duration._months;
	        updateOffset = updateOffset == null ? true : updateOffset;

	        if (milliseconds) {
	            mom._d.setTime(+mom._d + milliseconds * isAdding);
	        }
	        if (days) {
	            get_set__set(mom, 'Date', get_set__get(mom, 'Date') + days * isAdding);
	        }
	        if (months) {
	            setMonth(mom, get_set__get(mom, 'Month') + months * isAdding);
	        }
	        if (updateOffset) {
	            utils_hooks__hooks.updateOffset(mom, days || months);
	        }
	    }

	    var add_subtract__add      = createAdder(1, 'add');
	    var add_subtract__subtract = createAdder(-1, 'subtract');

	    function moment_calendar__calendar (time, formats) {
	        // We want to compare the start of today, vs this.
	        // Getting start-of-today depends on whether we're local/utc/offset or not.
	        var now = time || local__createLocal(),
	            sod = cloneWithOffset(now, this).startOf('day'),
	            diff = this.diff(sod, 'days', true),
	            format = diff < -6 ? 'sameElse' :
	                diff < -1 ? 'lastWeek' :
	                diff < 0 ? 'lastDay' :
	                diff < 1 ? 'sameDay' :
	                diff < 2 ? 'nextDay' :
	                diff < 7 ? 'nextWeek' : 'sameElse';
	        return this.format(formats && formats[format] || this.localeData().calendar(format, this, local__createLocal(now)));
	    }

	    function clone () {
	        return new Moment(this);
	    }

	    function isAfter (input, units) {
	        var inputMs;
	        units = normalizeUnits(typeof units !== 'undefined' ? units : 'millisecond');
	        if (units === 'millisecond') {
	            input = isMoment(input) ? input : local__createLocal(input);
	            return +this > +input;
	        } else {
	            inputMs = isMoment(input) ? +input : +local__createLocal(input);
	            return inputMs < +this.clone().startOf(units);
	        }
	    }

	    function isBefore (input, units) {
	        var inputMs;
	        units = normalizeUnits(typeof units !== 'undefined' ? units : 'millisecond');
	        if (units === 'millisecond') {
	            input = isMoment(input) ? input : local__createLocal(input);
	            return +this < +input;
	        } else {
	            inputMs = isMoment(input) ? +input : +local__createLocal(input);
	            return +this.clone().endOf(units) < inputMs;
	        }
	    }

	    function isBetween (from, to, units) {
	        return this.isAfter(from, units) && this.isBefore(to, units);
	    }

	    function isSame (input, units) {
	        var inputMs;
	        units = normalizeUnits(units || 'millisecond');
	        if (units === 'millisecond') {
	            input = isMoment(input) ? input : local__createLocal(input);
	            return +this === +input;
	        } else {
	            inputMs = +local__createLocal(input);
	            return +(this.clone().startOf(units)) <= inputMs && inputMs <= +(this.clone().endOf(units));
	        }
	    }

	    function diff (input, units, asFloat) {
	        var that = cloneWithOffset(input, this),
	            zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4,
	            delta, output;

	        units = normalizeUnits(units);

	        if (units === 'year' || units === 'month' || units === 'quarter') {
	            output = monthDiff(this, that);
	            if (units === 'quarter') {
	                output = output / 3;
	            } else if (units === 'year') {
	                output = output / 12;
	            }
	        } else {
	            delta = this - that;
	            output = units === 'second' ? delta / 1e3 : // 1000
	                units === 'minute' ? delta / 6e4 : // 1000 * 60
	                units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60
	                units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
	                units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
	                delta;
	        }
	        return asFloat ? output : absFloor(output);
	    }

	    function monthDiff (a, b) {
	        // difference in months
	        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
	            // b is in (anchor - 1 month, anchor + 1 month)
	            anchor = a.clone().add(wholeMonthDiff, 'months'),
	            anchor2, adjust;

	        if (b - anchor < 0) {
	            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
	            // linear across the month
	            adjust = (b - anchor) / (anchor - anchor2);
	        } else {
	            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
	            // linear across the month
	            adjust = (b - anchor) / (anchor2 - anchor);
	        }

	        return -(wholeMonthDiff + adjust);
	    }

	    utils_hooks__hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';

	    function toString () {
	        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
	    }

	    function moment_format__toISOString () {
	        var m = this.clone().utc();
	        if (0 < m.year() && m.year() <= 9999) {
	            if ('function' === typeof Date.prototype.toISOString) {
	                // native implementation is ~50x faster, use it when we can
	                return this.toDate().toISOString();
	            } else {
	                return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
	            }
	        } else {
	            return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
	        }
	    }

	    function format (inputString) {
	        var output = formatMoment(this, inputString || utils_hooks__hooks.defaultFormat);
	        return this.localeData().postformat(output);
	    }

	    function from (time, withoutSuffix) {
	        if (!this.isValid()) {
	            return this.localeData().invalidDate();
	        }
	        return create__createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
	    }

	    function fromNow (withoutSuffix) {
	        return this.from(local__createLocal(), withoutSuffix);
	    }

	    function to (time, withoutSuffix) {
	        if (!this.isValid()) {
	            return this.localeData().invalidDate();
	        }
	        return create__createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
	    }

	    function toNow (withoutSuffix) {
	        return this.to(local__createLocal(), withoutSuffix);
	    }

	    function locale (key) {
	        var newLocaleData;

	        if (key === undefined) {
	            return this._locale._abbr;
	        } else {
	            newLocaleData = locale_locales__getLocale(key);
	            if (newLocaleData != null) {
	                this._locale = newLocaleData;
	            }
	            return this;
	        }
	    }

	    var lang = deprecate(
	        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
	        function (key) {
	            if (key === undefined) {
	                return this.localeData();
	            } else {
	                return this.locale(key);
	            }
	        }
	    );

	    function localeData () {
	        return this._locale;
	    }

	    function startOf (units) {
	        units = normalizeUnits(units);
	        // the following switch intentionally omits break keywords
	        // to utilize falling through the cases.
	        switch (units) {
	        case 'year':
	            this.month(0);
	            /* falls through */
	        case 'quarter':
	        case 'month':
	            this.date(1);
	            /* falls through */
	        case 'week':
	        case 'isoWeek':
	        case 'day':
	            this.hours(0);
	            /* falls through */
	        case 'hour':
	            this.minutes(0);
	            /* falls through */
	        case 'minute':
	            this.seconds(0);
	            /* falls through */
	        case 'second':
	            this.milliseconds(0);
	        }

	        // weeks are a special case
	        if (units === 'week') {
	            this.weekday(0);
	        }
	        if (units === 'isoWeek') {
	            this.isoWeekday(1);
	        }

	        // quarters are also special
	        if (units === 'quarter') {
	            this.month(Math.floor(this.month() / 3) * 3);
	        }

	        return this;
	    }

	    function endOf (units) {
	        units = normalizeUnits(units);
	        if (units === undefined || units === 'millisecond') {
	            return this;
	        }
	        return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
	    }

	    function to_type__valueOf () {
	        return +this._d - ((this._offset || 0) * 60000);
	    }

	    function unix () {
	        return Math.floor(+this / 1000);
	    }

	    function toDate () {
	        return this._offset ? new Date(+this) : this._d;
	    }

	    function toArray () {
	        var m = this;
	        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
	    }

	    function toObject () {
	        var m = this;
	        return {
	            years: m.year(),
	            months: m.month(),
	            date: m.date(),
	            hours: m.hours(),
	            minutes: m.minutes(),
	            seconds: m.seconds(),
	            milliseconds: m.milliseconds()
	        };
	    }

	    function moment_valid__isValid () {
	        return valid__isValid(this);
	    }

	    function parsingFlags () {
	        return extend({}, getParsingFlags(this));
	    }

	    function invalidAt () {
	        return getParsingFlags(this).overflow;
	    }

	    addFormatToken(0, ['gg', 2], 0, function () {
	        return this.weekYear() % 100;
	    });

	    addFormatToken(0, ['GG', 2], 0, function () {
	        return this.isoWeekYear() % 100;
	    });

	    function addWeekYearFormatToken (token, getter) {
	        addFormatToken(0, [token, token.length], 0, getter);
	    }

	    addWeekYearFormatToken('gggg',     'weekYear');
	    addWeekYearFormatToken('ggggg',    'weekYear');
	    addWeekYearFormatToken('GGGG',  'isoWeekYear');
	    addWeekYearFormatToken('GGGGG', 'isoWeekYear');

	    // ALIASES

	    addUnitAlias('weekYear', 'gg');
	    addUnitAlias('isoWeekYear', 'GG');

	    // PARSING

	    addRegexToken('G',      matchSigned);
	    addRegexToken('g',      matchSigned);
	    addRegexToken('GG',     match1to2, match2);
	    addRegexToken('gg',     match1to2, match2);
	    addRegexToken('GGGG',   match1to4, match4);
	    addRegexToken('gggg',   match1to4, match4);
	    addRegexToken('GGGGG',  match1to6, match6);
	    addRegexToken('ggggg',  match1to6, match6);

	    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
	        week[token.substr(0, 2)] = toInt(input);
	    });

	    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
	        week[token] = utils_hooks__hooks.parseTwoDigitYear(input);
	    });

	    // HELPERS

	    function weeksInYear(year, dow, doy) {
	        return weekOfYear(local__createLocal([year, 11, 31 + dow - doy]), dow, doy).week;
	    }

	    // MOMENTS

	    function getSetWeekYear (input) {
	        var year = weekOfYear(this, this.localeData()._week.dow, this.localeData()._week.doy).year;
	        return input == null ? year : this.add((input - year), 'y');
	    }

	    function getSetISOWeekYear (input) {
	        var year = weekOfYear(this, 1, 4).year;
	        return input == null ? year : this.add((input - year), 'y');
	    }

	    function getISOWeeksInYear () {
	        return weeksInYear(this.year(), 1, 4);
	    }

	    function getWeeksInYear () {
	        var weekInfo = this.localeData()._week;
	        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
	    }

	    addFormatToken('Q', 0, 0, 'quarter');

	    // ALIASES

	    addUnitAlias('quarter', 'Q');

	    // PARSING

	    addRegexToken('Q', match1);
	    addParseToken('Q', function (input, array) {
	        array[MONTH] = (toInt(input) - 1) * 3;
	    });

	    // MOMENTS

	    function getSetQuarter (input) {
	        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
	    }

	    addFormatToken('D', ['DD', 2], 'Do', 'date');

	    // ALIASES

	    addUnitAlias('date', 'D');

	    // PARSING

	    addRegexToken('D',  match1to2);
	    addRegexToken('DD', match1to2, match2);
	    addRegexToken('Do', function (isStrict, locale) {
	        return isStrict ? locale._ordinalParse : locale._ordinalParseLenient;
	    });

	    addParseToken(['D', 'DD'], DATE);
	    addParseToken('Do', function (input, array) {
	        array[DATE] = toInt(input.match(match1to2)[0], 10);
	    });

	    // MOMENTS

	    var getSetDayOfMonth = makeGetSet('Date', true);

	    addFormatToken('d', 0, 'do', 'day');

	    addFormatToken('dd', 0, 0, function (format) {
	        return this.localeData().weekdaysMin(this, format);
	    });

	    addFormatToken('ddd', 0, 0, function (format) {
	        return this.localeData().weekdaysShort(this, format);
	    });

	    addFormatToken('dddd', 0, 0, function (format) {
	        return this.localeData().weekdays(this, format);
	    });

	    addFormatToken('e', 0, 0, 'weekday');
	    addFormatToken('E', 0, 0, 'isoWeekday');

	    // ALIASES

	    addUnitAlias('day', 'd');
	    addUnitAlias('weekday', 'e');
	    addUnitAlias('isoWeekday', 'E');

	    // PARSING

	    addRegexToken('d',    match1to2);
	    addRegexToken('e',    match1to2);
	    addRegexToken('E',    match1to2);
	    addRegexToken('dd',   matchWord);
	    addRegexToken('ddd',  matchWord);
	    addRegexToken('dddd', matchWord);

	    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config) {
	        var weekday = config._locale.weekdaysParse(input);
	        // if we didn't get a weekday name, mark the date as invalid
	        if (weekday != null) {
	            week.d = weekday;
	        } else {
	            getParsingFlags(config).invalidWeekday = input;
	        }
	    });

	    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
	        week[token] = toInt(input);
	    });

	    // HELPERS

	    function parseWeekday(input, locale) {
	        if (typeof input !== 'string') {
	            return input;
	        }

	        if (!isNaN(input)) {
	            return parseInt(input, 10);
	        }

	        input = locale.weekdaysParse(input);
	        if (typeof input === 'number') {
	            return input;
	        }

	        return null;
	    }

	    // LOCALES

	    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
	    function localeWeekdays (m) {
	        return this._weekdays[m.day()];
	    }

	    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
	    function localeWeekdaysShort (m) {
	        return this._weekdaysShort[m.day()];
	    }

	    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
	    function localeWeekdaysMin (m) {
	        return this._weekdaysMin[m.day()];
	    }

	    function localeWeekdaysParse (weekdayName) {
	        var i, mom, regex;

	        this._weekdaysParse = this._weekdaysParse || [];

	        for (i = 0; i < 7; i++) {
	            // make the regex if we don't have it already
	            if (!this._weekdaysParse[i]) {
	                mom = local__createLocal([2000, 1]).day(i);
	                regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
	                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
	            }
	            // test the regex
	            if (this._weekdaysParse[i].test(weekdayName)) {
	                return i;
	            }
	        }
	    }

	    // MOMENTS

	    function getSetDayOfWeek (input) {
	        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
	        if (input != null) {
	            input = parseWeekday(input, this.localeData());
	            return this.add(input - day, 'd');
	        } else {
	            return day;
	        }
	    }

	    function getSetLocaleDayOfWeek (input) {
	        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
	        return input == null ? weekday : this.add(input - weekday, 'd');
	    }

	    function getSetISODayOfWeek (input) {
	        // behaves the same as moment#day except
	        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
	        // as a setter, sunday should belong to the previous week.
	        return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
	    }

	    addFormatToken('H', ['HH', 2], 0, 'hour');
	    addFormatToken('h', ['hh', 2], 0, function () {
	        return this.hours() % 12 || 12;
	    });

	    function meridiem (token, lowercase) {
	        addFormatToken(token, 0, 0, function () {
	            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
	        });
	    }

	    meridiem('a', true);
	    meridiem('A', false);

	    // ALIASES

	    addUnitAlias('hour', 'h');

	    // PARSING

	    function matchMeridiem (isStrict, locale) {
	        return locale._meridiemParse;
	    }

	    addRegexToken('a',  matchMeridiem);
	    addRegexToken('A',  matchMeridiem);
	    addRegexToken('H',  match1to2);
	    addRegexToken('h',  match1to2);
	    addRegexToken('HH', match1to2, match2);
	    addRegexToken('hh', match1to2, match2);

	    addParseToken(['H', 'HH'], HOUR);
	    addParseToken(['a', 'A'], function (input, array, config) {
	        config._isPm = config._locale.isPM(input);
	        config._meridiem = input;
	    });
	    addParseToken(['h', 'hh'], function (input, array, config) {
	        array[HOUR] = toInt(input);
	        getParsingFlags(config).bigHour = true;
	    });

	    // LOCALES

	    function localeIsPM (input) {
	        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
	        // Using charAt should be more compatible.
	        return ((input + '').toLowerCase().charAt(0) === 'p');
	    }

	    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
	    function localeMeridiem (hours, minutes, isLower) {
	        if (hours > 11) {
	            return isLower ? 'pm' : 'PM';
	        } else {
	            return isLower ? 'am' : 'AM';
	        }
	    }


	    // MOMENTS

	    // Setting the hour should keep the time, because the user explicitly
	    // specified which hour he wants. So trying to maintain the same hour (in
	    // a new timezone) makes sense. Adding/subtracting hours does not follow
	    // this rule.
	    var getSetHour = makeGetSet('Hours', true);

	    addFormatToken('m', ['mm', 2], 0, 'minute');

	    // ALIASES

	    addUnitAlias('minute', 'm');

	    // PARSING

	    addRegexToken('m',  match1to2);
	    addRegexToken('mm', match1to2, match2);
	    addParseToken(['m', 'mm'], MINUTE);

	    // MOMENTS

	    var getSetMinute = makeGetSet('Minutes', false);

	    addFormatToken('s', ['ss', 2], 0, 'second');

	    // ALIASES

	    addUnitAlias('second', 's');

	    // PARSING

	    addRegexToken('s',  match1to2);
	    addRegexToken('ss', match1to2, match2);
	    addParseToken(['s', 'ss'], SECOND);

	    // MOMENTS

	    var getSetSecond = makeGetSet('Seconds', false);

	    addFormatToken('S', 0, 0, function () {
	        return ~~(this.millisecond() / 100);
	    });

	    addFormatToken(0, ['SS', 2], 0, function () {
	        return ~~(this.millisecond() / 10);
	    });

	    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
	    addFormatToken(0, ['SSSS', 4], 0, function () {
	        return this.millisecond() * 10;
	    });
	    addFormatToken(0, ['SSSSS', 5], 0, function () {
	        return this.millisecond() * 100;
	    });
	    addFormatToken(0, ['SSSSSS', 6], 0, function () {
	        return this.millisecond() * 1000;
	    });
	    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
	        return this.millisecond() * 10000;
	    });
	    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
	        return this.millisecond() * 100000;
	    });
	    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
	        return this.millisecond() * 1000000;
	    });


	    // ALIASES

	    addUnitAlias('millisecond', 'ms');

	    // PARSING

	    addRegexToken('S',    match1to3, match1);
	    addRegexToken('SS',   match1to3, match2);
	    addRegexToken('SSS',  match1to3, match3);

	    var token;
	    for (token = 'SSSS'; token.length <= 9; token += 'S') {
	        addRegexToken(token, matchUnsigned);
	    }

	    function parseMs(input, array) {
	        array[MILLISECOND] = toInt(('0.' + input) * 1000);
	    }

	    for (token = 'S'; token.length <= 9; token += 'S') {
	        addParseToken(token, parseMs);
	    }
	    // MOMENTS

	    var getSetMillisecond = makeGetSet('Milliseconds', false);

	    addFormatToken('z',  0, 0, 'zoneAbbr');
	    addFormatToken('zz', 0, 0, 'zoneName');

	    // MOMENTS

	    function getZoneAbbr () {
	        return this._isUTC ? 'UTC' : '';
	    }

	    function getZoneName () {
	        return this._isUTC ? 'Coordinated Universal Time' : '';
	    }

	    var momentPrototype__proto = Moment.prototype;

	    momentPrototype__proto.add          = add_subtract__add;
	    momentPrototype__proto.calendar     = moment_calendar__calendar;
	    momentPrototype__proto.clone        = clone;
	    momentPrototype__proto.diff         = diff;
	    momentPrototype__proto.endOf        = endOf;
	    momentPrototype__proto.format       = format;
	    momentPrototype__proto.from         = from;
	    momentPrototype__proto.fromNow      = fromNow;
	    momentPrototype__proto.to           = to;
	    momentPrototype__proto.toNow        = toNow;
	    momentPrototype__proto.get          = getSet;
	    momentPrototype__proto.invalidAt    = invalidAt;
	    momentPrototype__proto.isAfter      = isAfter;
	    momentPrototype__proto.isBefore     = isBefore;
	    momentPrototype__proto.isBetween    = isBetween;
	    momentPrototype__proto.isSame       = isSame;
	    momentPrototype__proto.isValid      = moment_valid__isValid;
	    momentPrototype__proto.lang         = lang;
	    momentPrototype__proto.locale       = locale;
	    momentPrototype__proto.localeData   = localeData;
	    momentPrototype__proto.max          = prototypeMax;
	    momentPrototype__proto.min          = prototypeMin;
	    momentPrototype__proto.parsingFlags = parsingFlags;
	    momentPrototype__proto.set          = getSet;
	    momentPrototype__proto.startOf      = startOf;
	    momentPrototype__proto.subtract     = add_subtract__subtract;
	    momentPrototype__proto.toArray      = toArray;
	    momentPrototype__proto.toObject     = toObject;
	    momentPrototype__proto.toDate       = toDate;
	    momentPrototype__proto.toISOString  = moment_format__toISOString;
	    momentPrototype__proto.toJSON       = moment_format__toISOString;
	    momentPrototype__proto.toString     = toString;
	    momentPrototype__proto.unix         = unix;
	    momentPrototype__proto.valueOf      = to_type__valueOf;

	    // Year
	    momentPrototype__proto.year       = getSetYear;
	    momentPrototype__proto.isLeapYear = getIsLeapYear;

	    // Week Year
	    momentPrototype__proto.weekYear    = getSetWeekYear;
	    momentPrototype__proto.isoWeekYear = getSetISOWeekYear;

	    // Quarter
	    momentPrototype__proto.quarter = momentPrototype__proto.quarters = getSetQuarter;

	    // Month
	    momentPrototype__proto.month       = getSetMonth;
	    momentPrototype__proto.daysInMonth = getDaysInMonth;

	    // Week
	    momentPrototype__proto.week           = momentPrototype__proto.weeks        = getSetWeek;
	    momentPrototype__proto.isoWeek        = momentPrototype__proto.isoWeeks     = getSetISOWeek;
	    momentPrototype__proto.weeksInYear    = getWeeksInYear;
	    momentPrototype__proto.isoWeeksInYear = getISOWeeksInYear;

	    // Day
	    momentPrototype__proto.date       = getSetDayOfMonth;
	    momentPrototype__proto.day        = momentPrototype__proto.days             = getSetDayOfWeek;
	    momentPrototype__proto.weekday    = getSetLocaleDayOfWeek;
	    momentPrototype__proto.isoWeekday = getSetISODayOfWeek;
	    momentPrototype__proto.dayOfYear  = getSetDayOfYear;

	    // Hour
	    momentPrototype__proto.hour = momentPrototype__proto.hours = getSetHour;

	    // Minute
	    momentPrototype__proto.minute = momentPrototype__proto.minutes = getSetMinute;

	    // Second
	    momentPrototype__proto.second = momentPrototype__proto.seconds = getSetSecond;

	    // Millisecond
	    momentPrototype__proto.millisecond = momentPrototype__proto.milliseconds = getSetMillisecond;

	    // Offset
	    momentPrototype__proto.utcOffset            = getSetOffset;
	    momentPrototype__proto.utc                  = setOffsetToUTC;
	    momentPrototype__proto.local                = setOffsetToLocal;
	    momentPrototype__proto.parseZone            = setOffsetToParsedOffset;
	    momentPrototype__proto.hasAlignedHourOffset = hasAlignedHourOffset;
	    momentPrototype__proto.isDST                = isDaylightSavingTime;
	    momentPrototype__proto.isDSTShifted         = isDaylightSavingTimeShifted;
	    momentPrototype__proto.isLocal              = isLocal;
	    momentPrototype__proto.isUtcOffset          = isUtcOffset;
	    momentPrototype__proto.isUtc                = isUtc;
	    momentPrototype__proto.isUTC                = isUtc;

	    // Timezone
	    momentPrototype__proto.zoneAbbr = getZoneAbbr;
	    momentPrototype__proto.zoneName = getZoneName;

	    // Deprecations
	    momentPrototype__proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
	    momentPrototype__proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
	    momentPrototype__proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
	    momentPrototype__proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. https://github.com/moment/moment/issues/1779', getSetZone);

	    var momentPrototype = momentPrototype__proto;

	    function moment__createUnix (input) {
	        return local__createLocal(input * 1000);
	    }

	    function moment__createInZone () {
	        return local__createLocal.apply(null, arguments).parseZone();
	    }

	    var defaultCalendar = {
	        sameDay : '[Today at] LT',
	        nextDay : '[Tomorrow at] LT',
	        nextWeek : 'dddd [at] LT',
	        lastDay : '[Yesterday at] LT',
	        lastWeek : '[Last] dddd [at] LT',
	        sameElse : 'L'
	    };

	    function locale_calendar__calendar (key, mom, now) {
	        var output = this._calendar[key];
	        return typeof output === 'function' ? output.call(mom, now) : output;
	    }

	    var defaultLongDateFormat = {
	        LTS  : 'h:mm:ss A',
	        LT   : 'h:mm A',
	        L    : 'MM/DD/YYYY',
	        LL   : 'MMMM D, YYYY',
	        LLL  : 'MMMM D, YYYY h:mm A',
	        LLLL : 'dddd, MMMM D, YYYY h:mm A'
	    };

	    function longDateFormat (key) {
	        var format = this._longDateFormat[key],
	            formatUpper = this._longDateFormat[key.toUpperCase()];

	        if (format || !formatUpper) {
	            return format;
	        }

	        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
	            return val.slice(1);
	        });

	        return this._longDateFormat[key];
	    }

	    var defaultInvalidDate = 'Invalid date';

	    function invalidDate () {
	        return this._invalidDate;
	    }

	    var defaultOrdinal = '%d';
	    var defaultOrdinalParse = /\d{1,2}/;

	    function ordinal (number) {
	        return this._ordinal.replace('%d', number);
	    }

	    function preParsePostFormat (string) {
	        return string;
	    }

	    var defaultRelativeTime = {
	        future : 'in %s',
	        past   : '%s ago',
	        s  : 'a few seconds',
	        m  : 'a minute',
	        mm : '%d minutes',
	        h  : 'an hour',
	        hh : '%d hours',
	        d  : 'a day',
	        dd : '%d days',
	        M  : 'a month',
	        MM : '%d months',
	        y  : 'a year',
	        yy : '%d years'
	    };

	    function relative__relativeTime (number, withoutSuffix, string, isFuture) {
	        var output = this._relativeTime[string];
	        return (typeof output === 'function') ?
	            output(number, withoutSuffix, string, isFuture) :
	            output.replace(/%d/i, number);
	    }

	    function pastFuture (diff, output) {
	        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
	        return typeof format === 'function' ? format(output) : format.replace(/%s/i, output);
	    }

	    function locale_set__set (config) {
	        var prop, i;
	        for (i in config) {
	            prop = config[i];
	            if (typeof prop === 'function') {
	                this[i] = prop;
	            } else {
	                this['_' + i] = prop;
	            }
	        }
	        // Lenient ordinal parsing accepts just a number in addition to
	        // number + (possibly) stuff coming from _ordinalParseLenient.
	        this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + (/\d{1,2}/).source);
	    }

	    var prototype__proto = Locale.prototype;

	    prototype__proto._calendar       = defaultCalendar;
	    prototype__proto.calendar        = locale_calendar__calendar;
	    prototype__proto._longDateFormat = defaultLongDateFormat;
	    prototype__proto.longDateFormat  = longDateFormat;
	    prototype__proto._invalidDate    = defaultInvalidDate;
	    prototype__proto.invalidDate     = invalidDate;
	    prototype__proto._ordinal        = defaultOrdinal;
	    prototype__proto.ordinal         = ordinal;
	    prototype__proto._ordinalParse   = defaultOrdinalParse;
	    prototype__proto.preparse        = preParsePostFormat;
	    prototype__proto.postformat      = preParsePostFormat;
	    prototype__proto._relativeTime   = defaultRelativeTime;
	    prototype__proto.relativeTime    = relative__relativeTime;
	    prototype__proto.pastFuture      = pastFuture;
	    prototype__proto.set             = locale_set__set;

	    // Month
	    prototype__proto.months       =        localeMonths;
	    prototype__proto._months      = defaultLocaleMonths;
	    prototype__proto.monthsShort  =        localeMonthsShort;
	    prototype__proto._monthsShort = defaultLocaleMonthsShort;
	    prototype__proto.monthsParse  =        localeMonthsParse;

	    // Week
	    prototype__proto.week = localeWeek;
	    prototype__proto._week = defaultLocaleWeek;
	    prototype__proto.firstDayOfYear = localeFirstDayOfYear;
	    prototype__proto.firstDayOfWeek = localeFirstDayOfWeek;

	    // Day of Week
	    prototype__proto.weekdays       =        localeWeekdays;
	    prototype__proto._weekdays      = defaultLocaleWeekdays;
	    prototype__proto.weekdaysMin    =        localeWeekdaysMin;
	    prototype__proto._weekdaysMin   = defaultLocaleWeekdaysMin;
	    prototype__proto.weekdaysShort  =        localeWeekdaysShort;
	    prototype__proto._weekdaysShort = defaultLocaleWeekdaysShort;
	    prototype__proto.weekdaysParse  =        localeWeekdaysParse;

	    // Hours
	    prototype__proto.isPM = localeIsPM;
	    prototype__proto._meridiemParse = defaultLocaleMeridiemParse;
	    prototype__proto.meridiem = localeMeridiem;

	    function lists__get (format, index, field, setter) {
	        var locale = locale_locales__getLocale();
	        var utc = create_utc__createUTC().set(setter, index);
	        return locale[field](utc, format);
	    }

	    function list (format, index, field, count, setter) {
	        if (typeof format === 'number') {
	            index = format;
	            format = undefined;
	        }

	        format = format || '';

	        if (index != null) {
	            return lists__get(format, index, field, setter);
	        }

	        var i;
	        var out = [];
	        for (i = 0; i < count; i++) {
	            out[i] = lists__get(format, i, field, setter);
	        }
	        return out;
	    }

	    function lists__listMonths (format, index) {
	        return list(format, index, 'months', 12, 'month');
	    }

	    function lists__listMonthsShort (format, index) {
	        return list(format, index, 'monthsShort', 12, 'month');
	    }

	    function lists__listWeekdays (format, index) {
	        return list(format, index, 'weekdays', 7, 'day');
	    }

	    function lists__listWeekdaysShort (format, index) {
	        return list(format, index, 'weekdaysShort', 7, 'day');
	    }

	    function lists__listWeekdaysMin (format, index) {
	        return list(format, index, 'weekdaysMin', 7, 'day');
	    }

	    locale_locales__getSetGlobalLocale('en', {
	        ordinalParse: /\d{1,2}(th|st|nd|rd)/,
	        ordinal : function (number) {
	            var b = number % 10,
	                output = (toInt(number % 100 / 10) === 1) ? 'th' :
	                (b === 1) ? 'st' :
	                (b === 2) ? 'nd' :
	                (b === 3) ? 'rd' : 'th';
	            return number + output;
	        }
	    });

	    // Side effect imports
	    utils_hooks__hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', locale_locales__getSetGlobalLocale);
	    utils_hooks__hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', locale_locales__getLocale);

	    var mathAbs = Math.abs;

	    function duration_abs__abs () {
	        var data           = this._data;

	        this._milliseconds = mathAbs(this._milliseconds);
	        this._days         = mathAbs(this._days);
	        this._months       = mathAbs(this._months);

	        data.milliseconds  = mathAbs(data.milliseconds);
	        data.seconds       = mathAbs(data.seconds);
	        data.minutes       = mathAbs(data.minutes);
	        data.hours         = mathAbs(data.hours);
	        data.months        = mathAbs(data.months);
	        data.years         = mathAbs(data.years);

	        return this;
	    }

	    function duration_add_subtract__addSubtract (duration, input, value, direction) {
	        var other = create__createDuration(input, value);

	        duration._milliseconds += direction * other._milliseconds;
	        duration._days         += direction * other._days;
	        duration._months       += direction * other._months;

	        return duration._bubble();
	    }

	    // supports only 2.0-style add(1, 's') or add(duration)
	    function duration_add_subtract__add (input, value) {
	        return duration_add_subtract__addSubtract(this, input, value, 1);
	    }

	    // supports only 2.0-style subtract(1, 's') or subtract(duration)
	    function duration_add_subtract__subtract (input, value) {
	        return duration_add_subtract__addSubtract(this, input, value, -1);
	    }

	    function absCeil (number) {
	        if (number < 0) {
	            return Math.floor(number);
	        } else {
	            return Math.ceil(number);
	        }
	    }

	    function bubble () {
	        var milliseconds = this._milliseconds;
	        var days         = this._days;
	        var months       = this._months;
	        var data         = this._data;
	        var seconds, minutes, hours, years, monthsFromDays;

	        // if we have a mix of positive and negative values, bubble down first
	        // check: https://github.com/moment/moment/issues/2166
	        if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
	                (milliseconds <= 0 && days <= 0 && months <= 0))) {
	            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
	            days = 0;
	            months = 0;
	        }

	        // The following code bubbles up values, see the tests for
	        // examples of what that means.
	        data.milliseconds = milliseconds % 1000;

	        seconds           = absFloor(milliseconds / 1000);
	        data.seconds      = seconds % 60;

	        minutes           = absFloor(seconds / 60);
	        data.minutes      = minutes % 60;

	        hours             = absFloor(minutes / 60);
	        data.hours        = hours % 24;

	        days += absFloor(hours / 24);

	        // convert days to months
	        monthsFromDays = absFloor(daysToMonths(days));
	        months += monthsFromDays;
	        days -= absCeil(monthsToDays(monthsFromDays));

	        // 12 months -> 1 year
	        years = absFloor(months / 12);
	        months %= 12;

	        data.days   = days;
	        data.months = months;
	        data.years  = years;

	        return this;
	    }

	    function daysToMonths (days) {
	        // 400 years have 146097 days (taking into account leap year rules)
	        // 400 years have 12 months === 4800
	        return days * 4800 / 146097;
	    }

	    function monthsToDays (months) {
	        // the reverse of daysToMonths
	        return months * 146097 / 4800;
	    }

	    function as (units) {
	        var days;
	        var months;
	        var milliseconds = this._milliseconds;

	        units = normalizeUnits(units);

	        if (units === 'month' || units === 'year') {
	            days   = this._days   + milliseconds / 864e5;
	            months = this._months + daysToMonths(days);
	            return units === 'month' ? months : months / 12;
	        } else {
	            // handle milliseconds separately because of floating point math errors (issue #1867)
	            days = this._days + Math.round(monthsToDays(this._months));
	            switch (units) {
	                case 'week'   : return days / 7     + milliseconds / 6048e5;
	                case 'day'    : return days         + milliseconds / 864e5;
	                case 'hour'   : return days * 24    + milliseconds / 36e5;
	                case 'minute' : return days * 1440  + milliseconds / 6e4;
	                case 'second' : return days * 86400 + milliseconds / 1000;
	                // Math.floor prevents floating point math errors here
	                case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
	                default: throw new Error('Unknown unit ' + units);
	            }
	        }
	    }

	    // TODO: Use this.as('ms')?
	    function duration_as__valueOf () {
	        return (
	            this._milliseconds +
	            this._days * 864e5 +
	            (this._months % 12) * 2592e6 +
	            toInt(this._months / 12) * 31536e6
	        );
	    }

	    function makeAs (alias) {
	        return function () {
	            return this.as(alias);
	        };
	    }

	    var asMilliseconds = makeAs('ms');
	    var asSeconds      = makeAs('s');
	    var asMinutes      = makeAs('m');
	    var asHours        = makeAs('h');
	    var asDays         = makeAs('d');
	    var asWeeks        = makeAs('w');
	    var asMonths       = makeAs('M');
	    var asYears        = makeAs('y');

	    function duration_get__get (units) {
	        units = normalizeUnits(units);
	        return this[units + 's']();
	    }

	    function makeGetter(name) {
	        return function () {
	            return this._data[name];
	        };
	    }

	    var milliseconds = makeGetter('milliseconds');
	    var seconds      = makeGetter('seconds');
	    var minutes      = makeGetter('minutes');
	    var hours        = makeGetter('hours');
	    var days         = makeGetter('days');
	    var months       = makeGetter('months');
	    var years        = makeGetter('years');

	    function weeks () {
	        return absFloor(this.days() / 7);
	    }

	    var round = Math.round;
	    var thresholds = {
	        s: 45,  // seconds to minute
	        m: 45,  // minutes to hour
	        h: 22,  // hours to day
	        d: 26,  // days to month
	        M: 11   // months to year
	    };

	    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
	    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
	        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
	    }

	    function duration_humanize__relativeTime (posNegDuration, withoutSuffix, locale) {
	        var duration = create__createDuration(posNegDuration).abs();
	        var seconds  = round(duration.as('s'));
	        var minutes  = round(duration.as('m'));
	        var hours    = round(duration.as('h'));
	        var days     = round(duration.as('d'));
	        var months   = round(duration.as('M'));
	        var years    = round(duration.as('y'));

	        var a = seconds < thresholds.s && ['s', seconds]  ||
	                minutes === 1          && ['m']           ||
	                minutes < thresholds.m && ['mm', minutes] ||
	                hours   === 1          && ['h']           ||
	                hours   < thresholds.h && ['hh', hours]   ||
	                days    === 1          && ['d']           ||
	                days    < thresholds.d && ['dd', days]    ||
	                months  === 1          && ['M']           ||
	                months  < thresholds.M && ['MM', months]  ||
	                years   === 1          && ['y']           || ['yy', years];

	        a[2] = withoutSuffix;
	        a[3] = +posNegDuration > 0;
	        a[4] = locale;
	        return substituteTimeAgo.apply(null, a);
	    }

	    // This function allows you to set a threshold for relative time strings
	    function duration_humanize__getSetRelativeTimeThreshold (threshold, limit) {
	        if (thresholds[threshold] === undefined) {
	            return false;
	        }
	        if (limit === undefined) {
	            return thresholds[threshold];
	        }
	        thresholds[threshold] = limit;
	        return true;
	    }

	    function humanize (withSuffix) {
	        var locale = this.localeData();
	        var output = duration_humanize__relativeTime(this, !withSuffix, locale);

	        if (withSuffix) {
	            output = locale.pastFuture(+this, output);
	        }

	        return locale.postformat(output);
	    }

	    var iso_string__abs = Math.abs;

	    function iso_string__toISOString() {
	        // for ISO strings we do not use the normal bubbling rules:
	        //  * milliseconds bubble up until they become hours
	        //  * days do not bubble at all
	        //  * months bubble up until they become years
	        // This is because there is no context-free conversion between hours and days
	        // (think of clock changes)
	        // and also not between days and months (28-31 days per month)
	        var seconds = iso_string__abs(this._milliseconds) / 1000;
	        var days         = iso_string__abs(this._days);
	        var months       = iso_string__abs(this._months);
	        var minutes, hours, years;

	        // 3600 seconds -> 60 minutes -> 1 hour
	        minutes           = absFloor(seconds / 60);
	        hours             = absFloor(minutes / 60);
	        seconds %= 60;
	        minutes %= 60;

	        // 12 months -> 1 year
	        years  = absFloor(months / 12);
	        months %= 12;


	        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
	        var Y = years;
	        var M = months;
	        var D = days;
	        var h = hours;
	        var m = minutes;
	        var s = seconds;
	        var total = this.asSeconds();

	        if (!total) {
	            // this is the same as C#'s (Noda) and python (isodate)...
	            // but not other JS (goog.date)
	            return 'P0D';
	        }

	        return (total < 0 ? '-' : '') +
	            'P' +
	            (Y ? Y + 'Y' : '') +
	            (M ? M + 'M' : '') +
	            (D ? D + 'D' : '') +
	            ((h || m || s) ? 'T' : '') +
	            (h ? h + 'H' : '') +
	            (m ? m + 'M' : '') +
	            (s ? s + 'S' : '');
	    }

	    var duration_prototype__proto = Duration.prototype;

	    duration_prototype__proto.abs            = duration_abs__abs;
	    duration_prototype__proto.add            = duration_add_subtract__add;
	    duration_prototype__proto.subtract       = duration_add_subtract__subtract;
	    duration_prototype__proto.as             = as;
	    duration_prototype__proto.asMilliseconds = asMilliseconds;
	    duration_prototype__proto.asSeconds      = asSeconds;
	    duration_prototype__proto.asMinutes      = asMinutes;
	    duration_prototype__proto.asHours        = asHours;
	    duration_prototype__proto.asDays         = asDays;
	    duration_prototype__proto.asWeeks        = asWeeks;
	    duration_prototype__proto.asMonths       = asMonths;
	    duration_prototype__proto.asYears        = asYears;
	    duration_prototype__proto.valueOf        = duration_as__valueOf;
	    duration_prototype__proto._bubble        = bubble;
	    duration_prototype__proto.get            = duration_get__get;
	    duration_prototype__proto.milliseconds   = milliseconds;
	    duration_prototype__proto.seconds        = seconds;
	    duration_prototype__proto.minutes        = minutes;
	    duration_prototype__proto.hours          = hours;
	    duration_prototype__proto.days           = days;
	    duration_prototype__proto.weeks          = weeks;
	    duration_prototype__proto.months         = months;
	    duration_prototype__proto.years          = years;
	    duration_prototype__proto.humanize       = humanize;
	    duration_prototype__proto.toISOString    = iso_string__toISOString;
	    duration_prototype__proto.toString       = iso_string__toISOString;
	    duration_prototype__proto.toJSON         = iso_string__toISOString;
	    duration_prototype__proto.locale         = locale;
	    duration_prototype__proto.localeData     = localeData;

	    // Deprecations
	    duration_prototype__proto.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', iso_string__toISOString);
	    duration_prototype__proto.lang = lang;

	    // Side effect imports

	    addFormatToken('X', 0, 0, 'unix');
	    addFormatToken('x', 0, 0, 'valueOf');

	    // PARSING

	    addRegexToken('x', matchSigned);
	    addRegexToken('X', matchTimestamp);
	    addParseToken('X', function (input, array, config) {
	        config._d = new Date(parseFloat(input, 10) * 1000);
	    });
	    addParseToken('x', function (input, array, config) {
	        config._d = new Date(toInt(input));
	    });

	    // Side effect imports


	    utils_hooks__hooks.version = '2.10.6';

	    setHookCallback(local__createLocal);

	    utils_hooks__hooks.fn                    = momentPrototype;
	    utils_hooks__hooks.min                   = min;
	    utils_hooks__hooks.max                   = max;
	    utils_hooks__hooks.utc                   = create_utc__createUTC;
	    utils_hooks__hooks.unix                  = moment__createUnix;
	    utils_hooks__hooks.months                = lists__listMonths;
	    utils_hooks__hooks.isDate                = isDate;
	    utils_hooks__hooks.locale                = locale_locales__getSetGlobalLocale;
	    utils_hooks__hooks.invalid               = valid__createInvalid;
	    utils_hooks__hooks.duration              = create__createDuration;
	    utils_hooks__hooks.isMoment              = isMoment;
	    utils_hooks__hooks.weekdays              = lists__listWeekdays;
	    utils_hooks__hooks.parseZone             = moment__createInZone;
	    utils_hooks__hooks.localeData            = locale_locales__getLocale;
	    utils_hooks__hooks.isDuration            = isDuration;
	    utils_hooks__hooks.monthsShort           = lists__listMonthsShort;
	    utils_hooks__hooks.weekdaysMin           = lists__listWeekdaysMin;
	    utils_hooks__hooks.defineLocale          = defineLocale;
	    utils_hooks__hooks.weekdaysShort         = lists__listWeekdaysShort;
	    utils_hooks__hooks.normalizeUnits        = normalizeUnits;
	    utils_hooks__hooks.relativeTimeThreshold = duration_humanize__getSetRelativeTimeThreshold;

	    var _moment = utils_hooks__hooks;

	    return _moment;

	}));
	},{}],"numeral":[function(require,module,exports){
	"use strict";
	(function() {
	  var numeral,
	      VERSION = '1.5.3',
	      languages = {},
	      currentLanguage = 'en',
	      zeroFormat = null,
	      defaultFormat = '0,0',
	      hasModule = (typeof module !== 'undefined' && module.exports);
	  function Numeral(number) {
	    this._value = number;
	  }
	  function toFixed(value, precision, roundingFunction, optionals) {
	    var power = Math.pow(10, precision),
	        optionalsRegExp,
	        output;
	    output = (roundingFunction(value * power) / power).toFixed(precision);
	    if (optionals) {
	      optionalsRegExp = new RegExp('0{1,' + optionals + '}$');
	      output = output.replace(optionalsRegExp, '');
	    }
	    return output;
	  }
	  function formatNumeral(n, format, roundingFunction) {
	    var output;
	    if (format.indexOf('$') > -1) {
	      output = formatCurrency(n, format, roundingFunction);
	    } else if (format.indexOf('%') > -1) {
	      output = formatPercentage(n, format, roundingFunction);
	    } else if (format.indexOf(':') > -1) {
	      output = formatTime(n, format);
	    } else {
	      output = formatNumber(n._value, format, roundingFunction);
	    }
	    return output;
	  }
	  function unformatNumeral(n, string) {
	    var stringOriginal = string,
	        thousandRegExp,
	        millionRegExp,
	        billionRegExp,
	        trillionRegExp,
	        suffixes = ['KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],
	        bytesMultiplier = false,
	        power;
	    if (string.indexOf(':') > -1) {
	      n._value = unformatTime(string);
	    } else {
	      if (string === zeroFormat) {
	        n._value = 0;
	      } else {
	        if (languages[currentLanguage].delimiters.decimal !== '.') {
	          string = string.replace(/\./g, '').replace(languages[currentLanguage].delimiters.decimal, '.');
	        }
	        thousandRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.thousand + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');
	        millionRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.million + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');
	        billionRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.billion + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');
	        trillionRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.trillion + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');
	        for (power = 0; power <= suffixes.length; power++) {
	          bytesMultiplier = (string.indexOf(suffixes[power]) > -1) ? Math.pow(1024, power + 1) : false;
	          if (bytesMultiplier) {
	            break;
	          }
	        }
	        n._value = ((bytesMultiplier) ? bytesMultiplier : 1) * ((stringOriginal.match(thousandRegExp)) ? Math.pow(10, 3) : 1) * ((stringOriginal.match(millionRegExp)) ? Math.pow(10, 6) : 1) * ((stringOriginal.match(billionRegExp)) ? Math.pow(10, 9) : 1) * ((stringOriginal.match(trillionRegExp)) ? Math.pow(10, 12) : 1) * ((string.indexOf('%') > -1) ? 0.01 : 1) * (((string.split('-').length + Math.min(string.split('(').length - 1, string.split(')').length - 1)) % 2) ? 1 : -1) * Number(string.replace(/[^0-9\.]+/g, ''));
	        n._value = (bytesMultiplier) ? Math.ceil(n._value) : n._value;
	      }
	    }
	    return n._value;
	  }
	  function formatCurrency(n, format, roundingFunction) {
	    var symbolIndex = format.indexOf('$'),
	        openParenIndex = format.indexOf('('),
	        minusSignIndex = format.indexOf('-'),
	        space = '',
	        spliceIndex,
	        output;
	    if (format.indexOf(' $') > -1) {
	      space = ' ';
	      format = format.replace(' $', '');
	    } else if (format.indexOf('$ ') > -1) {
	      space = ' ';
	      format = format.replace('$ ', '');
	    } else {
	      format = format.replace('$', '');
	    }
	    output = formatNumber(n._value, format, roundingFunction);
	    if (symbolIndex <= 1) {
	      if (output.indexOf('(') > -1 || output.indexOf('-') > -1) {
	        output = output.split('');
	        spliceIndex = 1;
	        if (symbolIndex < openParenIndex || symbolIndex < minusSignIndex) {
	          spliceIndex = 0;
	        }
	        output.splice(spliceIndex, 0, languages[currentLanguage].currency.symbol + space);
	        output = output.join('');
	      } else {
	        output = languages[currentLanguage].currency.symbol + space + output;
	      }
	    } else {
	      if (output.indexOf(')') > -1) {
	        output = output.split('');
	        output.splice(-1, 0, space + languages[currentLanguage].currency.symbol);
	        output = output.join('');
	      } else {
	        output = output + space + languages[currentLanguage].currency.symbol;
	      }
	    }
	    return output;
	  }
	  function formatPercentage(n, format, roundingFunction) {
	    var space = '',
	        output,
	        value = n._value * 100;
	    if (format.indexOf(' %') > -1) {
	      space = ' ';
	      format = format.replace(' %', '');
	    } else {
	      format = format.replace('%', '');
	    }
	    output = formatNumber(value, format, roundingFunction);
	    if (output.indexOf(')') > -1) {
	      output = output.split('');
	      output.splice(-1, 0, space + '%');
	      output = output.join('');
	    } else {
	      output = output + space + '%';
	    }
	    return output;
	  }
	  function formatTime(n) {
	    var hours = Math.floor(n._value / 60 / 60),
	        minutes = Math.floor((n._value - (hours * 60 * 60)) / 60),
	        seconds = Math.round(n._value - (hours * 60 * 60) - (minutes * 60));
	    return hours + ':' + ((minutes < 10) ? '0' + minutes : minutes) + ':' + ((seconds < 10) ? '0' + seconds : seconds);
	  }
	  function unformatTime(string) {
	    var timeArray = string.split(':'),
	        seconds = 0;
	    if (timeArray.length === 3) {
	      seconds = seconds + (Number(timeArray[0]) * 60 * 60);
	      seconds = seconds + (Number(timeArray[1]) * 60);
	      seconds = seconds + Number(timeArray[2]);
	    } else if (timeArray.length === 2) {
	      seconds = seconds + (Number(timeArray[0]) * 60);
	      seconds = seconds + Number(timeArray[1]);
	    }
	    return Number(seconds);
	  }
	  function formatNumber(value, format, roundingFunction) {
	    var negP = false,
	        signed = false,
	        optDec = false,
	        abbr = '',
	        abbrK = false,
	        abbrM = false,
	        abbrB = false,
	        abbrT = false,
	        abbrForce = false,
	        bytes = '',
	        ord = '',
	        abs = Math.abs(value),
	        suffixes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],
	        min,
	        max,
	        power,
	        w,
	        precision,
	        thousands,
	        d = '',
	        neg = false;
	    if (value === 0 && zeroFormat !== null) {
	      return zeroFormat;
	    } else {
	      if (format.indexOf('(') > -1) {
	        negP = true;
	        format = format.slice(1, -1);
	      } else if (format.indexOf('+') > -1) {
	        signed = true;
	        format = format.replace(/\+/g, '');
	      }
	      if (format.indexOf('a') > -1) {
	        abbrK = format.indexOf('aK') >= 0;
	        abbrM = format.indexOf('aM') >= 0;
	        abbrB = format.indexOf('aB') >= 0;
	        abbrT = format.indexOf('aT') >= 0;
	        abbrForce = abbrK || abbrM || abbrB || abbrT;
	        if (format.indexOf(' a') > -1) {
	          abbr = ' ';
	          format = format.replace(' a', '');
	        } else {
	          format = format.replace('a', '');
	        }
	        if (abs >= Math.pow(10, 12) && !abbrForce || abbrT) {
	          abbr = abbr + languages[currentLanguage].abbreviations.trillion;
	          value = value / Math.pow(10, 12);
	        } else if (abs < Math.pow(10, 12) && abs >= Math.pow(10, 9) && !abbrForce || abbrB) {
	          abbr = abbr + languages[currentLanguage].abbreviations.billion;
	          value = value / Math.pow(10, 9);
	        } else if (abs < Math.pow(10, 9) && abs >= Math.pow(10, 6) && !abbrForce || abbrM) {
	          abbr = abbr + languages[currentLanguage].abbreviations.million;
	          value = value / Math.pow(10, 6);
	        } else if (abs < Math.pow(10, 6) && abs >= Math.pow(10, 3) && !abbrForce || abbrK) {
	          abbr = abbr + languages[currentLanguage].abbreviations.thousand;
	          value = value / Math.pow(10, 3);
	        }
	      }
	      if (format.indexOf('b') > -1) {
	        if (format.indexOf(' b') > -1) {
	          bytes = ' ';
	          format = format.replace(' b', '');
	        } else {
	          format = format.replace('b', '');
	        }
	        for (power = 0; power <= suffixes.length; power++) {
	          min = Math.pow(1024, power);
	          max = Math.pow(1024, power + 1);
	          if (value >= min && value < max) {
	            bytes = bytes + suffixes[power];
	            if (min > 0) {
	              value = value / min;
	            }
	            break;
	          }
	        }
	      }
	      if (format.indexOf('o') > -1) {
	        if (format.indexOf(' o') > -1) {
	          ord = ' ';
	          format = format.replace(' o', '');
	        } else {
	          format = format.replace('o', '');
	        }
	        ord = ord + languages[currentLanguage].ordinal(value);
	      }
	      if (format.indexOf('[.]') > -1) {
	        optDec = true;
	        format = format.replace('[.]', '.');
	      }
	      w = value.toString().split('.')[0];
	      precision = format.split('.')[1];
	      thousands = format.indexOf(',');
	      if (precision) {
	        if (precision.indexOf('[') > -1) {
	          precision = precision.replace(']', '');
	          precision = precision.split('[');
	          d = toFixed(value, (precision[0].length + precision[1].length), roundingFunction, precision[1].length);
	        } else {
	          d = toFixed(value, precision.length, roundingFunction);
	        }
	        w = d.split('.')[0];
	        if (d.split('.')[1].length) {
	          d = languages[currentLanguage].delimiters.decimal + d.split('.')[1];
	        } else {
	          d = '';
	        }
	        if (optDec && Number(d.slice(1)) === 0) {
	          d = '';
	        }
	      } else {
	        w = toFixed(value, null, roundingFunction);
	      }
	      if (w.indexOf('-') > -1) {
	        w = w.slice(1);
	        neg = true;
	      }
	      if (thousands > -1) {
	        w = w.toString().replace(/(\d)(?=(\d{3})+(?!\d))/g, '$1' + languages[currentLanguage].delimiters.thousands);
	      }
	      if (format.indexOf('.') === 0) {
	        w = '';
	      }
	      return ((negP && neg) ? '(' : '') + ((!negP && neg) ? '-' : '') + ((!neg && signed) ? '+' : '') + w + d + ((ord) ? ord : '') + ((abbr) ? abbr : '') + ((bytes) ? bytes : '') + ((negP && neg) ? ')' : '');
	    }
	  }
	  numeral = function(input) {
	    if (numeral.isNumeral(input)) {
	      input = input.value();
	    } else if (input === 0 || typeof input === 'undefined') {
	      input = 0;
	    } else if (!Number(input)) {
	      input = numeral.fn.unformat(input);
	    }
	    return new Numeral(Number(input));
	  };
	  numeral.version = VERSION;
	  numeral.isNumeral = function(obj) {
	    return obj instanceof Numeral;
	  };
	  numeral.language = function(key, values) {
	    if (!key) {
	      return currentLanguage;
	    }
	    if (key && !values) {
	      if (!languages[key]) {
	        throw new Error('Unknown language : ' + key);
	      }
	      currentLanguage = key;
	    }
	    if (values || !languages[key]) {
	      loadLanguage(key, values);
	    }
	    return numeral;
	  };
	  numeral.languageData = function(key) {
	    if (!key) {
	      return languages[currentLanguage];
	    }
	    if (!languages[key]) {
	      throw new Error('Unknown language : ' + key);
	    }
	    return languages[key];
	  };
	  numeral.language('en', {
	    delimiters: {
	      thousands: ',',
	      decimal: '.'
	    },
	    abbreviations: {
	      thousand: 'k',
	      million: 'm',
	      billion: 'b',
	      trillion: 't'
	    },
	    ordinal: function(number) {
	      var b = number % 10;
	      return (~~(number % 100 / 10) === 1) ? 'th' : (b === 1) ? 'st' : (b === 2) ? 'nd' : (b === 3) ? 'rd' : 'th';
	    },
	    currency: {symbol: '$'}
	  });
	  numeral.zeroFormat = function(format) {
	    zeroFormat = typeof(format) === 'string' ? format : null;
	  };
	  numeral.defaultFormat = function(format) {
	    defaultFormat = typeof(format) === 'string' ? format : '0.0';
	  };
	  numeral.validate = function(val, culture) {
	    var _decimalSep,
	        _thousandSep,
	        _currSymbol,
	        _valArray,
	        _abbrObj,
	        _thousandRegEx,
	        languageData,
	        temp;
	    if (typeof val !== 'string') {
	      val += '';
	      if (console.warn) {
	        console.warn('Numeral.js: Value is not string. It has been co-erced to: ', val);
	      }
	    }
	    val = val.trim();
	    if (val === '') {
	      return false;
	    }
	    val = val.replace(/^[+-]?/, '');
	    try {
	      languageData = numeral.languageData(culture);
	    } catch (e) {
	      languageData = numeral.languageData(numeral.language());
	    }
	    _currSymbol = languageData.currency.symbol;
	    _abbrObj = languageData.abbreviations;
	    _decimalSep = languageData.delimiters.decimal;
	    if (languageData.delimiters.thousands === '.') {
	      _thousandSep = '\\.';
	    } else {
	      _thousandSep = languageData.delimiters.thousands;
	    }
	    temp = val.match(/^[^\d\.\,]+/);
	    if (temp !== null) {
	      val = val.substr(1);
	      if (temp[0] !== _currSymbol) {
	        return false;
	      }
	    }
	    temp = val.match(/[^\d]+$/);
	    if (temp !== null) {
	      val = val.slice(0, -1);
	      if (temp[0] !== _abbrObj.thousand && temp[0] !== _abbrObj.million && temp[0] !== _abbrObj.billion && temp[0] !== _abbrObj.trillion) {
	        return false;
	      }
	    }
	    if (!!val.match(/^\d+$/)) {
	      return true;
	    }
	    _thousandRegEx = new RegExp(_thousandSep + '{2}');
	    if (!val.match(/[^\d.,]/g)) {
	      _valArray = val.split(_decimalSep);
	      if (_valArray.length > 2) {
	        return false;
	      } else {
	        if (_valArray.length < 2) {
	          return (!!_valArray[0].match(/^\d+.*\d$/) && !_valArray[0].match(_thousandRegEx));
	        } else {
	          if (_valArray[0] === '') {
	            return (!_valArray[0].match(_thousandRegEx) && !!_valArray[1].match(/^\d+$/));
	          } else if (_valArray[0].length === 1) {
	            return (!!_valArray[0].match(/^\d+$/) && !_valArray[0].match(_thousandRegEx) && !!_valArray[1].match(/^\d+$/));
	          } else {
	            return (!!_valArray[0].match(/^\d+.*\d$/) && !_valArray[0].match(_thousandRegEx) && !!_valArray[1].match(/^\d+$/));
	          }
	        }
	      }
	    }
	    return false;
	  };
	  function loadLanguage(key, values) {
	    languages[key] = values;
	  }
	  if ('function' !== typeof Array.prototype.reduce) {
	    Array.prototype.reduce = function(callback, opt_initialValue) {
	      'use strict';
	      if (null === this || 'undefined' === typeof this) {
	        throw new TypeError('Array.prototype.reduce called on null or undefined');
	      }
	      if ('function' !== typeof callback) {
	        throw new TypeError(callback + ' is not a function');
	      }
	      var index,
	          value,
	          length = this.length >>> 0,
	          isValueSet = false;
	      if (1 < arguments.length) {
	        value = opt_initialValue;
	        isValueSet = true;
	      }
	      for (index = 0; length > index; ++index) {
	        if (this.hasOwnProperty(index)) {
	          if (isValueSet) {
	            value = callback(value, this[index], index, this);
	          } else {
	            value = this[index];
	            isValueSet = true;
	          }
	        }
	      }
	      if (!isValueSet) {
	        throw new TypeError('Reduce of empty array with no initial value');
	      }
	      return value;
	    };
	  }
	  function multiplier(x) {
	    var parts = x.toString().split('.');
	    if (parts.length < 2) {
	      return 1;
	    }
	    return Math.pow(10, parts[1].length);
	  }
	  function correctionFactor() {
	    var args = Array.prototype.slice.call(arguments);
	    return args.reduce(function(prev, next) {
	      var mp = multiplier(prev),
	          mn = multiplier(next);
	      return mp > mn ? mp : mn;
	    }, -Infinity);
	  }
	  numeral.fn = Numeral.prototype = {
	    clone: function() {
	      return numeral(this);
	    },
	    format: function(inputString, roundingFunction) {
	      return formatNumeral(this, inputString ? inputString : defaultFormat, (roundingFunction !== undefined) ? roundingFunction : Math.round);
	    },
	    unformat: function(inputString) {
	      if (Object.prototype.toString.call(inputString) === '[object Number]') {
	        return inputString;
	      }
	      return unformatNumeral(this, inputString ? inputString : defaultFormat);
	    },
	    value: function() {
	      return this._value;
	    },
	    valueOf: function() {
	      return this._value;
	    },
	    set: function(value) {
	      this._value = Number(value);
	      return this;
	    },
	    add: function(value) {
	      var corrFactor = correctionFactor.call(null, this._value, value);
	      function cback(accum, curr, currI, O) {
	        return accum + corrFactor * curr;
	      }
	      this._value = [this._value, value].reduce(cback, 0) / corrFactor;
	      return this;
	    },
	    subtract: function(value) {
	      var corrFactor = correctionFactor.call(null, this._value, value);
	      function cback(accum, curr, currI, O) {
	        return accum - corrFactor * curr;
	      }
	      this._value = [value].reduce(cback, this._value * corrFactor) / corrFactor;
	      return this;
	    },
	    multiply: function(value) {
	      function cback(accum, curr, currI, O) {
	        var corrFactor = correctionFactor(accum, curr);
	        return (accum * corrFactor) * (curr * corrFactor) / (corrFactor * corrFactor);
	      }
	      this._value = [this._value, value].reduce(cback, 1);
	      return this;
	    },
	    divide: function(value) {
	      function cback(accum, curr, currI, O) {
	        var corrFactor = correctionFactor(accum, curr);
	        return (accum * corrFactor) / (curr * corrFactor);
	      }
	      this._value = [this._value, value].reduce(cback);
	      return this;
	    },
	    difference: function(value) {
	      return Math.abs(numeral(this._value).subtract(value).value());
	    }
	  };
	  if (hasModule) {
	    module.exports = numeral;
	  }
	  if (typeof ender === 'undefined') {
	    this['numeral'] = numeral;
	  }
	  if (typeof define === 'function' && define.amd) {
	    define([], function() {
	      return numeral;
	    });
	  }
	}).call(window);

	//# 
	},{}],"pikaday":[function(require,module,exports){
	/*!
	 * Pikaday
	 *
	 * Copyright © 2014 David Bushell | BSD & MIT license | https://github.com/dbushell/Pikaday
	 */

	(function (root, factory)
	{
	    'use strict';

	    var moment;
	    if (typeof exports === 'object') {
	        // CommonJS module
	        // Load moment.js as an optional dependency
	        try { moment = require('moment'); } catch (e) {}
	        module.exports = factory(moment);
	    } else if (typeof define === 'function' && define.amd) {
	        // AMD. Register as an anonymous module.
	        define(function (req)
	        {
	            // Load moment.js as an optional dependency
	            var id = 'moment';
	            try { moment = req(id); } catch (e) {}
	            return factory(moment);
	        });
	    } else {
	        root.Pikaday = factory(root.moment);
	    }
	}(this, function (moment)
	{
	    'use strict';

	    /**
	     * feature detection and helper functions
	     */
	    var hasMoment = typeof moment === 'function',

	    hasEventListeners = !!window.addEventListener,

	    document = window.document,

	    sto = window.setTimeout,

	    addEvent = function(el, e, callback, capture)
	    {
	        if (hasEventListeners) {
	            el.addEventListener(e, callback, !!capture);
	        } else {
	            el.attachEvent('on' + e, callback);
	        }
	    },

	    removeEvent = function(el, e, callback, capture)
	    {
	        if (hasEventListeners) {
	            el.removeEventListener(e, callback, !!capture);
	        } else {
	            el.detachEvent('on' + e, callback);
	        }
	    },

	    fireEvent = function(el, eventName, data)
	    {
	        var ev;

	        if (document.createEvent) {
	            ev = document.createEvent('HTMLEvents');
	            ev.initEvent(eventName, true, false);
	            ev = extend(ev, data);
	            el.dispatchEvent(ev);
	        } else if (document.createEventObject) {
	            ev = document.createEventObject();
	            ev = extend(ev, data);
	            el.fireEvent('on' + eventName, ev);
	        }
	    },

	    trim = function(str)
	    {
	        return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g,'');
	    },

	    hasClass = function(el, cn)
	    {
	        return (' ' + el.className + ' ').indexOf(' ' + cn + ' ') !== -1;
	    },

	    addClass = function(el, cn)
	    {
	        if (!hasClass(el, cn)) {
	            el.className = (el.className === '') ? cn : el.className + ' ' + cn;
	        }
	    },

	    removeClass = function(el, cn)
	    {
	        el.className = trim((' ' + el.className + ' ').replace(' ' + cn + ' ', ' '));
	    },

	    isArray = function(obj)
	    {
	        return (/Array/).test(Object.prototype.toString.call(obj));
	    },

	    isDate = function(obj)
	    {
	        return (/Date/).test(Object.prototype.toString.call(obj)) && !isNaN(obj.getTime());
	    },

	    isWeekend = function(date)
	    {
	        var day = date.getDay();
	        return day === 0 || day === 6;
	    },

	    isLeapYear = function(year)
	    {
	        // solution by Matti Virkkunen: http://stackoverflow.com/a/4881951
	        return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
	    },

	    getDaysInMonth = function(year, month)
	    {
	        return [31, isLeapYear(year) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month];
	    },

	    setToStartOfDay = function(date)
	    {
	        if (isDate(date)) date.setHours(0,0,0,0);
	    },

	    compareDates = function(a,b)
	    {
	        // weak date comparison (use setToStartOfDay(date) to ensure correct result)
	        return a.getTime() === b.getTime();
	    },

	    extend = function(to, from, overwrite)
	    {
	        var prop, hasProp;
	        for (prop in from) {
	            hasProp = to[prop] !== undefined;
	            if (hasProp && typeof from[prop] === 'object' && from[prop] !== null && from[prop].nodeName === undefined) {
	                if (isDate(from[prop])) {
	                    if (overwrite) {
	                        to[prop] = new Date(from[prop].getTime());
	                    }
	                }
	                else if (isArray(from[prop])) {
	                    if (overwrite) {
	                        to[prop] = from[prop].slice(0);
	                    }
	                } else {
	                    to[prop] = extend({}, from[prop], overwrite);
	                }
	            } else if (overwrite || !hasProp) {
	                to[prop] = from[prop];
	            }
	        }
	        return to;
	    },

	    adjustCalendar = function(calendar) {
	        if (calendar.month < 0) {
	            calendar.year -= Math.ceil(Math.abs(calendar.month)/12);
	            calendar.month += 12;
	        }
	        if (calendar.month > 11) {
	            calendar.year += Math.floor(Math.abs(calendar.month)/12);
	            calendar.month -= 12;
	        }
	        return calendar;
	    },

	    /**
	     * defaults and localisation
	     */
	    defaults = {

	        // bind the picker to a form field
	        field: null,

	        // automatically show/hide the picker on `field` focus (default `true` if `field` is set)
	        bound: undefined,

	        // position of the datepicker, relative to the field (default to bottom & left)
	        // ('bottom' & 'left' keywords are not used, 'top' & 'right' are modifier on the bottom/left position)
	        position: 'bottom left',

	        // automatically fit in the viewport even if it means repositioning from the position option
	        reposition: true,

	        // the default output format for `.toString()` and `field` value
	        format: 'YYYY-MM-DD',

	        // the initial date to view when first opened
	        defaultDate: null,

	        // make the `defaultDate` the initial selected value
	        setDefaultDate: false,

	        // first day of week (0: Sunday, 1: Monday etc)
	        firstDay: 0,

	        // the minimum/earliest date that can be selected
	        minDate: null,
	        // the maximum/latest date that can be selected
	        maxDate: null,

	        // number of years either side, or array of upper/lower range
	        yearRange: 10,

	        // show week numbers at head of row
	        showWeekNumber: false,

	        // used internally (don't config outside)
	        minYear: 0,
	        maxYear: 9999,
	        minMonth: undefined,
	        maxMonth: undefined,

	        startRange: null,
	        endRange: null,

	        isRTL: false,

	        // Additional text to append to the year in the calendar title
	        yearSuffix: '',

	        // Render the month after year in the calendar title
	        showMonthAfterYear: false,

	        // how many months are visible
	        numberOfMonths: 1,

	        // when numberOfMonths is used, this will help you to choose where the main calendar will be (default `left`, can be set to `right`)
	        // only used for the first display or when a selected date is not visible
	        mainCalendar: 'left',

	        // Specify a DOM element to render the calendar in
	        container: undefined,

	        // internationalization
	        i18n: {
	            previousMonth : 'Previous Month',
	            nextMonth     : 'Next Month',
	            months        : ['January','February','March','April','May','June','July','August','September','October','November','December'],
	            weekdays      : ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'],
	            weekdaysShort : ['Sun','Mon','Tue','Wed','Thu','Fri','Sat']
	        },

	        // Theme Classname
	        theme: null,

	        // callback function
	        onSelect: null,
	        onOpen: null,
	        onClose: null,
	        onDraw: null
	    },


	    /**
	     * templating functions to abstract HTML rendering
	     */
	    renderDayName = function(opts, day, abbr)
	    {
	        day += opts.firstDay;
	        while (day >= 7) {
	            day -= 7;
	        }
	        return abbr ? opts.i18n.weekdaysShort[day] : opts.i18n.weekdays[day];
	    },

	    renderDay = function(opts)
	    {
	        if (opts.isEmpty) {
	            return '<td class="is-empty"></td>';
	        }
	        var arr = [];
	        if (opts.isDisabled) {
	            arr.push('is-disabled');
	        }
	        if (opts.isToday) {
	            arr.push('is-today');
	        }
	        if (opts.isSelected) {
	            arr.push('is-selected');
	        }
	        if (opts.isInRange) {
	            arr.push('is-inrange');
	        }
	        if (opts.isStartRange) {
	            arr.push('is-startrange');
	        }
	        if (opts.isEndRange) {
	            arr.push('is-endrange');
	        }
	        return '<td data-day="' + opts.day + '" class="' + arr.join(' ') + '">' +
	                 '<button class="pika-button pika-day" type="button" ' +
	                    'data-pika-year="' + opts.year + '" data-pika-month="' + opts.month + '" data-pika-day="' + opts.day + '">' +
	                        opts.day +
	                 '</button>' +
	               '</td>';
	    },

	    renderWeek = function (d, m, y) {
	        // Lifted from http://javascript.about.com/library/blweekyear.htm, lightly modified.
	        var onejan = new Date(y, 0, 1),
	            weekNum = Math.ceil((((new Date(y, m, d) - onejan) / 86400000) + onejan.getDay()+1)/7);
	        return '<td class="pika-week">' + weekNum + '</td>';
	    },

	    renderRow = function(days, isRTL)
	    {
	        return '<tr>' + (isRTL ? days.reverse() : days).join('') + '</tr>';
	    },

	    renderBody = function(rows)
	    {
	        return '<tbody>' + rows.join('') + '</tbody>';
	    },

	    renderHead = function(opts)
	    {
	        var i, arr = [];
	        if (opts.showWeekNumber) {
	            arr.push('<th></th>');
	        }
	        for (i = 0; i < 7; i++) {
	            arr.push('<th scope="col"><abbr title="' + renderDayName(opts, i) + '">' + renderDayName(opts, i, true) + '</abbr></th>');
	        }
	        return '<thead>' + (opts.isRTL ? arr.reverse() : arr).join('') + '</thead>';
	    },

	    renderTitle = function(instance, c, year, month, refYear)
	    {
	        var i, j, arr,
	            opts = instance._o,
	            isMinYear = year === opts.minYear,
	            isMaxYear = year === opts.maxYear,
	            html = '<div class="pika-title">',
	            monthHtml,
	            yearHtml,
	            prev = true,
	            next = true;

	        for (arr = [], i = 0; i < 12; i++) {
	            arr.push('<option value="' + (year === refYear ? i - c : 12 + i - c) + '"' +
	                (i === month ? ' selected': '') +
	                ((isMinYear && i < opts.minMonth) || (isMaxYear && i > opts.maxMonth) ? 'disabled' : '') + '>' +
	                opts.i18n.months[i] + '</option>');
	        }
	        monthHtml = '<div class="pika-label">' + opts.i18n.months[month] + '<select class="pika-select pika-select-month" tabindex="-1">' + arr.join('') + '</select></div>';

	        if (isArray(opts.yearRange)) {
	            i = opts.yearRange[0];
	            j = opts.yearRange[1] + 1;
	        } else {
	            i = year - opts.yearRange;
	            j = 1 + year + opts.yearRange;
	        }

	        for (arr = []; i < j && i <= opts.maxYear; i++) {
	            if (i >= opts.minYear) {
	                arr.push('<option value="' + i + '"' + (i === year ? ' selected': '') + '>' + (i) + '</option>');
	            }
	        }
	        yearHtml = '<div class="pika-label">' + year + opts.yearSuffix + '<select class="pika-select pika-select-year" tabindex="-1">' + arr.join('') + '</select></div>';

	        if (opts.showMonthAfterYear) {
	            html += yearHtml + monthHtml;
	        } else {
	            html += monthHtml + yearHtml;
	        }

	        if (isMinYear && (month === 0 || opts.minMonth >= month)) {
	            prev = false;
	        }

	        if (isMaxYear && (month === 11 || opts.maxMonth <= month)) {
	            next = false;
	        }

	        if (c === 0) {
	            html += '<button class="pika-prev' + (prev ? '' : ' is-disabled') + '" type="button">' + opts.i18n.previousMonth + '</button>';
	        }
	        if (c === (instance._o.numberOfMonths - 1) ) {
	            html += '<button class="pika-next' + (next ? '' : ' is-disabled') + '" type="button">' + opts.i18n.nextMonth + '</button>';
	        }

	        return html += '</div>';
	    },

	    renderTable = function(opts, data)
	    {
	        return '<table cellpadding="0" cellspacing="0" class="pika-table">' + renderHead(opts) + renderBody(data) + '</table>';
	    },


	    /**
	     * Pikaday constructor
	     */
	    Pikaday = function(options)
	    {
	        var self = this,
	            opts = self.config(options);

	        self._onMouseDown = function(e)
	        {
	            if (!self._v) {
	                return;
	            }
	            e = e || window.event;
	            var target = e.target || e.srcElement;
	            if (!target) {
	                return;
	            }

	            if (!hasClass(target.parentNode, 'is-disabled')) {
	                if (hasClass(target, 'pika-button') && !hasClass(target, 'is-empty')) {
	                    self.setDate(new Date(target.getAttribute('data-pika-year'), target.getAttribute('data-pika-month'), target.getAttribute('data-pika-day')));
	                    if (opts.bound) {
	                        sto(function() {
	                            self.hide();
	                            if (opts.field) {
	                                opts.field.blur();
	                            }
	                        }, 100);
	                    }
	                    return;
	                }
	                else if (hasClass(target, 'pika-prev')) {
	                    self.prevMonth();
	                }
	                else if (hasClass(target, 'pika-next')) {
	                    self.nextMonth();
	                }
	            }
	            if (!hasClass(target, 'pika-select')) {
	                if (e.preventDefault) {
	                    e.preventDefault();
	                } else {
	                    e.returnValue = false;
	                    return false;
	                }
	            } else {
	                self._c = true;
	            }
	        };

	        self._onChange = function(e)
	        {
	            e = e || window.event;
	            var target = e.target || e.srcElement;
	            if (!target) {
	                return;
	            }
	            if (hasClass(target, 'pika-select-month')) {
	                self.gotoMonth(target.value);
	            }
	            else if (hasClass(target, 'pika-select-year')) {
	                self.gotoYear(target.value);
	            }
	        };

	        self._onInputChange = function(e)
	        {
	            var date;

	            if (e.firedBy === self) {
	                return;
	            }
	            if (hasMoment) {
	                date = moment(opts.field.value, opts.format);
	                date = (date && date.isValid()) ? date.toDate() : null;
	            }
	            else {
	                date = new Date(Date.parse(opts.field.value));
	            }
	            if (isDate(date)) {
	              self.setDate(date);
	            }
	            if (!self._v) {
	                self.show();
	            }
	        };

	        self._onInputFocus = function()
	        {
	            self.show();
	        };

	        self._onInputClick = function()
	        {
	            self.show();
	        };

	        self._onInputBlur = function()
	        {
	            // IE allows pika div to gain focus; catch blur the input field
	            var pEl = document.activeElement;
	            do {
	                if (hasClass(pEl, 'pika-single')) {
	                    return;
	                }
	            }
	            while ((pEl = pEl.parentNode));

	            if (!self._c) {
	                self._b = sto(function() {
	                    self.hide();
	                }, 50);
	            }
	            self._c = false;
	        };

	        self._onClick = function(e)
	        {
	            e = e || window.event;
	            var target = e.target || e.srcElement,
	                pEl = target;
	            if (!target) {
	                return;
	            }
	            if (!hasEventListeners && hasClass(target, 'pika-select')) {
	                if (!target.onchange) {
	                    target.setAttribute('onchange', 'return;');
	                    addEvent(target, 'change', self._onChange);
	                }
	            }
	            do {
	                if (hasClass(pEl, 'pika-single') || pEl === opts.trigger) {
	                    return;
	                }
	            }
	            while ((pEl = pEl.parentNode));
	            if (self._v && target !== opts.trigger && pEl !== opts.trigger) {
	                self.hide();
	            }
	        };

	        self.el = document.createElement('div');
	        self.el.className = 'pika-single' + (opts.isRTL ? ' is-rtl' : '') + (opts.theme ? ' ' + opts.theme : '');

	        addEvent(self.el, 'ontouchend' in document ? 'touchend' : 'mousedown', self._onMouseDown, true);
	        addEvent(self.el, 'change', self._onChange);

	        if (opts.field) {
	            if (opts.container) {
	                opts.container.appendChild(self.el);
	            } else if (opts.bound) {
	                document.body.appendChild(self.el);
	            } else {
	                opts.field.parentNode.insertBefore(self.el, opts.field.nextSibling);
	            }
	            addEvent(opts.field, 'change', self._onInputChange);

	            if (!opts.defaultDate) {
	                if (hasMoment && opts.field.value) {
	                    opts.defaultDate = moment(opts.field.value, opts.format).toDate();
	                } else {
	                    opts.defaultDate = new Date(Date.parse(opts.field.value));
	                }
	                opts.setDefaultDate = true;
	            }
	        }

	        var defDate = opts.defaultDate;

	        if (isDate(defDate)) {
	            if (opts.setDefaultDate) {
	                self.setDate(defDate, true);
	            } else {
	                self.gotoDate(defDate);
	            }
	        } else {
	            self.gotoDate(new Date());
	        }

	        if (opts.bound) {
	            this.hide();
	            self.el.className += ' is-bound';
	            addEvent(opts.trigger, 'click', self._onInputClick);
	            addEvent(opts.trigger, 'focus', self._onInputFocus);
	            addEvent(opts.trigger, 'blur', self._onInputBlur);
	        } else {
	            this.show();
	        }
	    };


	    /**
	     * public Pikaday API
	     */
	    Pikaday.prototype = {


	        /**
	         * configure functionality
	         */
	        config: function(options)
	        {
	            if (!this._o) {
	                this._o = extend({}, defaults, true);
	            }

	            var opts = extend(this._o, options, true);

	            opts.isRTL = !!opts.isRTL;

	            opts.field = (opts.field && opts.field.nodeName) ? opts.field : null;

	            opts.theme = (typeof opts.theme) === 'string' && opts.theme ? opts.theme : null;

	            opts.bound = !!(opts.bound !== undefined ? opts.field && opts.bound : opts.field);

	            opts.trigger = (opts.trigger && opts.trigger.nodeName) ? opts.trigger : opts.field;

	            opts.disableWeekends = !!opts.disableWeekends;

	            opts.disableDayFn = (typeof opts.disableDayFn) === 'function' ? opts.disableDayFn : null;

	            var nom = parseInt(opts.numberOfMonths, 10) || 1;
	            opts.numberOfMonths = nom > 4 ? 4 : nom;

	            if (!isDate(opts.minDate)) {
	                opts.minDate = false;
	            }
	            if (!isDate(opts.maxDate)) {
	                opts.maxDate = false;
	            }
	            if ((opts.minDate && opts.maxDate) && opts.maxDate < opts.minDate) {
	                opts.maxDate = opts.minDate = false;
	            }
	            if (opts.minDate) {
	                this.setMinDate(opts.minDate);
	            }
	            if (opts.maxDate) {
	                setToStartOfDay(opts.maxDate);
	                opts.maxYear  = opts.maxDate.getFullYear();
	                opts.maxMonth = opts.maxDate.getMonth();
	            }

	            if (isArray(opts.yearRange)) {
	                var fallback = new Date().getFullYear() - 10;
	                opts.yearRange[0] = parseInt(opts.yearRange[0], 10) || fallback;
	                opts.yearRange[1] = parseInt(opts.yearRange[1], 10) || fallback;
	            } else {
	                opts.yearRange = Math.abs(parseInt(opts.yearRange, 10)) || defaults.yearRange;
	                if (opts.yearRange > 100) {
	                    opts.yearRange = 100;
	                }
	            }

	            return opts;
	        },

	        /**
	         * return a formatted string of the current selection (using Moment.js if available)
	         */
	        toString: function(format)
	        {
	            return !isDate(this._d) ? '' : hasMoment ? moment(this._d).format(format || this._o.format) : this._d.toDateString();
	        },

	        /**
	         * return a Moment.js object of the current selection (if available)
	         */
	        getMoment: function()
	        {
	            return hasMoment ? moment(this._d) : null;
	        },

	        /**
	         * set the current selection from a Moment.js object (if available)
	         */
	        setMoment: function(date, preventOnSelect)
	        {
	            if (hasMoment && moment.isMoment(date)) {
	                this.setDate(date.toDate(), preventOnSelect);
	            }
	        },

	        /**
	         * return a Date object of the current selection
	         */
	        getDate: function()
	        {
	            return isDate(this._d) ? new Date(this._d.getTime()) : null;
	        },

	        /**
	         * set the current selection
	         */
	        setDate: function(date, preventOnSelect)
	        {
	            if (!date) {
	                this._d = null;

	                if (this._o.field) {
	                    this._o.field.value = '';
	                    fireEvent(this._o.field, 'change', { firedBy: this });
	                }

	                return this.draw();
	            }
	            if (typeof date === 'string') {
	                date = new Date(Date.parse(date));
	            }
	            if (!isDate(date)) {
	                return;
	            }

	            var min = this._o.minDate,
	                max = this._o.maxDate;

	            if (isDate(min) && date < min) {
	                date = min;
	            } else if (isDate(max) && date > max) {
	                date = max;
	            }

	            this._d = new Date(date.getTime());
	            setToStartOfDay(this._d);
	            this.gotoDate(this._d);

	            if (this._o.field) {
	                this._o.field.value = this.toString();
	                fireEvent(this._o.field, 'change', { firedBy: this });
	            }
	            if (!preventOnSelect && typeof this._o.onSelect === 'function') {
	                this._o.onSelect.call(this, this.getDate());
	            }
	        },

	        /**
	         * change view to a specific date
	         */
	        gotoDate: function(date)
	        {
	            var newCalendar = true;

	            if (!isDate(date)) {
	                return;
	            }

	            if (this.calendars) {
	                var firstVisibleDate = new Date(this.calendars[0].year, this.calendars[0].month, 1),
	                    lastVisibleDate = new Date(this.calendars[this.calendars.length-1].year, this.calendars[this.calendars.length-1].month, 1),
	                    visibleDate = date.getTime();
	                // get the end of the month
	                lastVisibleDate.setMonth(lastVisibleDate.getMonth()+1);
	                lastVisibleDate.setDate(lastVisibleDate.getDate()-1);
	                newCalendar = (visibleDate < firstVisibleDate.getTime() || lastVisibleDate.getTime() < visibleDate);
	            }

	            if (newCalendar) {
	                this.calendars = [{
	                    month: date.getMonth(),
	                    year: date.getFullYear()
	                }];
	                if (this._o.mainCalendar === 'right') {
	                    this.calendars[0].month += 1 - this._o.numberOfMonths;
	                }
	            }

	            this.adjustCalendars();
	        },

	        adjustCalendars: function() {
	            this.calendars[0] = adjustCalendar(this.calendars[0]);
	            for (var c = 1; c < this._o.numberOfMonths; c++) {
	                this.calendars[c] = adjustCalendar({
	                    month: this.calendars[0].month + c,
	                    year: this.calendars[0].year
	                });
	            }
	            this.draw();
	        },

	        gotoToday: function()
	        {
	            this.gotoDate(new Date());
	        },

	        /**
	         * change view to a specific month (zero-index, e.g. 0: January)
	         */
	        gotoMonth: function(month)
	        {
	            if (!isNaN(month)) {
	                this.calendars[0].month = parseInt(month, 10);
	                this.adjustCalendars();
	            }
	        },

	        nextMonth: function()
	        {
	            this.calendars[0].month++;
	            this.adjustCalendars();
	        },

	        prevMonth: function()
	        {
	            this.calendars[0].month--;
	            this.adjustCalendars();
	        },

	        /**
	         * change view to a specific full year (e.g. "2012")
	         */
	        gotoYear: function(year)
	        {
	            if (!isNaN(year)) {
	                this.calendars[0].year = parseInt(year, 10);
	                this.adjustCalendars();
	            }
	        },

	        /**
	         * change the minDate
	         */
	        setMinDate: function(value)
	        {
	            setToStartOfDay(value);
	            this._o.minDate = value;
	            this._o.minYear  = value.getFullYear();
	            this._o.minMonth = value.getMonth();
	        },

	        /**
	         * change the maxDate
	         */
	        setMaxDate: function(value)
	        {
	            this._o.maxDate = value;
	        },

	        setStartRange: function(value)
	        {
	            this._o.startRange = value;
	        },

	        setEndRange: function(value)
	        {
	            this._o.endRange = value;
	        },

	        /**
	         * refresh the HTML
	         */
	        draw: function(force)
	        {
	            if (!this._v && !force) {
	                return;
	            }
	            var opts = this._o,
	                minYear = opts.minYear,
	                maxYear = opts.maxYear,
	                minMonth = opts.minMonth,
	                maxMonth = opts.maxMonth,
	                html = '';

	            if (this._y <= minYear) {
	                this._y = minYear;
	                if (!isNaN(minMonth) && this._m < minMonth) {
	                    this._m = minMonth;
	                }
	            }
	            if (this._y >= maxYear) {
	                this._y = maxYear;
	                if (!isNaN(maxMonth) && this._m > maxMonth) {
	                    this._m = maxMonth;
	                }
	            }

	            for (var c = 0; c < opts.numberOfMonths; c++) {
	                html += '<div class="pika-lendar">' + renderTitle(this, c, this.calendars[c].year, this.calendars[c].month, this.calendars[0].year) + this.render(this.calendars[c].year, this.calendars[c].month) + '</div>';
	            }

	            this.el.innerHTML = html;

	            if (opts.bound) {
	                if(opts.field.type !== 'hidden') {
	                    sto(function() {
	                        opts.trigger.focus();
	                    }, 1);
	                }
	            }

	            if (typeof this._o.onDraw === 'function') {
	                var self = this;
	                sto(function() {
	                    self._o.onDraw.call(self);
	                }, 0);
	            }
	        },

	        adjustPosition: function()
	        {
	            var field, pEl, width, height, viewportWidth, viewportHeight, scrollTop, left, top, clientRect;
	            
	            if (this._o.container) return;
	            
	            this.el.style.position = 'absolute';
	            
	            field = this._o.trigger;
	            pEl = field;
	            width = this.el.offsetWidth;
	            height = this.el.offsetHeight;
	            viewportWidth = window.innerWidth || document.documentElement.clientWidth;
	            viewportHeight = window.innerHeight || document.documentElement.clientHeight;
	            scrollTop = window.pageYOffset || document.body.scrollTop || document.documentElement.scrollTop;

	            if (typeof field.getBoundingClientRect === 'function') {
	                clientRect = field.getBoundingClientRect();
	                left = clientRect.left + window.pageXOffset;
	                top = clientRect.bottom + window.pageYOffset;
	            } else {
	                left = pEl.offsetLeft;
	                top  = pEl.offsetTop + pEl.offsetHeight;
	                while((pEl = pEl.offsetParent)) {
	                    left += pEl.offsetLeft;
	                    top  += pEl.offsetTop;
	                }
	            }

	            // default position is bottom & left
	            if ((this._o.reposition && left + width > viewportWidth) ||
	                (
	                    this._o.position.indexOf('right') > -1 &&
	                    left - width + field.offsetWidth > 0
	                )
	            ) {
	                left = left - width + field.offsetWidth;
	            }
	            if ((this._o.reposition && top + height > viewportHeight + scrollTop) ||
	                (
	                    this._o.position.indexOf('top') > -1 &&
	                    top - height - field.offsetHeight > 0
	                )
	            ) {
	                top = top - height - field.offsetHeight;
	            }

	            this.el.style.left = left + 'px';
	            this.el.style.top = top + 'px';
	        },

	        /**
	         * render HTML for a particular month
	         */
	        render: function(year, month)
	        {
	            var opts   = this._o,
	                now    = new Date(),
	                days   = getDaysInMonth(year, month),
	                before = new Date(year, month, 1).getDay(),
	                data   = [],
	                row    = [];
	            setToStartOfDay(now);
	            if (opts.firstDay > 0) {
	                before -= opts.firstDay;
	                if (before < 0) {
	                    before += 7;
	                }
	            }
	            var cells = days + before,
	                after = cells;
	            while(after > 7) {
	                after -= 7;
	            }
	            cells += 7 - after;
	            for (var i = 0, r = 0; i < cells; i++)
	            {
	                var dayConfig,
	                    day = new Date(year, month, 1 + (i - before)),
	                    isSelected = isDate(this._d) ? compareDates(day, this._d) : false,
	                    isToday = compareDates(day, now),
	                    isEmpty = i < before || i >= (days + before),
	                    isStartRange = opts.startRange && compareDates(opts.startRange, day),
	                    isEndRange = opts.endRange && compareDates(opts.endRange, day),
	                    isInRange = opts.startRange && opts.endRange && opts.startRange < day && day < opts.endRange,
	                    isDisabled = (opts.minDate && day < opts.minDate) ||
	                                 (opts.maxDate && day > opts.maxDate) ||
	                                 (opts.disableWeekends && isWeekend(day)) ||
	                                 (opts.disableDayFn && opts.disableDayFn(day)),
	                    dayConfig = {
	                        day: 1 + (i - before),
	                        month: month,
	                        year: year,
	                        isSelected: isSelected,
	                        isToday: isToday,
	                        isDisabled: isDisabled,
	                        isEmpty: isEmpty,
	                        isStartRange: isStartRange,
	                        isEndRange: isEndRange,
	                        isInRange: isInRange
	                    };

	                row.push(renderDay(dayConfig));

	                if (++r === 7) {
	                    if (opts.showWeekNumber) {
	                        row.unshift(renderWeek(i - before, month, year));
	                    }
	                    data.push(renderRow(row, opts.isRTL));
	                    row = [];
	                    r = 0;
	                }
	            }
	            return renderTable(opts, data);
	        },

	        isVisible: function()
	        {
	            return this._v;
	        },

	        show: function()
	        {
	            if (!this._v) {
	                removeClass(this.el, 'is-hidden');
	                this._v = true;
	                this.draw();
	                if (this._o.bound) {
	                    addEvent(document, 'click', this._onClick);
	                    this.adjustPosition();
	                }
	                if (typeof this._o.onOpen === 'function') {
	                    this._o.onOpen.call(this);
	                }
	            }
	        },

	        hide: function()
	        {
	            var v = this._v;
	            if (v !== false) {
	                if (this._o.bound) {
	                    removeEvent(document, 'click', this._onClick);
	                }
	                this.el.style.position = 'static'; // reset
	                this.el.style.left = 'auto';
	                this.el.style.top = 'auto';
	                addClass(this.el, 'is-hidden');
	                this._v = false;
	                if (v !== undefined && typeof this._o.onClose === 'function') {
	                    this._o.onClose.call(this);
	                }
	            }
	        },

	        /**
	         * GAME OVER
	         */
	        destroy: function()
	        {
	            this.hide();
	            removeEvent(this.el, 'mousedown', this._onMouseDown, true);
	            removeEvent(this.el, 'change', this._onChange);
	            if (this._o.field) {
	                removeEvent(this._o.field, 'change', this._onInputChange);
	                if (this._o.bound) {
	                    removeEvent(this._o.trigger, 'click', this._onInputClick);
	                    removeEvent(this._o.trigger, 'focus', this._onInputFocus);
	                    removeEvent(this._o.trigger, 'blur', this._onInputBlur);
	                }
	            }
	            if (this.el.parentNode) {
	                this.el.parentNode.removeChild(this.el);
	            }
	        }

	    };

	    return Pikaday;

	}));

	},{"moment":"moment"}],"zeroclipboard":[function(require,module,exports){
	/*!
	 * ZeroClipboard
	 * The ZeroClipboard library provides an easy way to copy text to the clipboard using an invisible Adobe Flash movie and a JavaScript interface.
	 * Copyright (c) 2009-2014 Jon Rohan, James M. Greene
	 * Licensed MIT
	 * http://zeroclipboard.org/
	 * v2.2.0
	 */
	(function(window, undefined) {
	  "use strict";
	  /**
	 * Store references to critically important global functions that may be
	 * overridden on certain web pages.
	 */
	  var _window = window, _document = _window.document, _navigator = _window.navigator, _setTimeout = _window.setTimeout, _clearTimeout = _window.clearTimeout, _setInterval = _window.setInterval, _clearInterval = _window.clearInterval, _getComputedStyle = _window.getComputedStyle, _encodeURIComponent = _window.encodeURIComponent, _ActiveXObject = _window.ActiveXObject, _Error = _window.Error, _parseInt = _window.Number.parseInt || _window.parseInt, _parseFloat = _window.Number.parseFloat || _window.parseFloat, _isNaN = _window.Number.isNaN || _window.isNaN, _now = _window.Date.now, _keys = _window.Object.keys, _defineProperty = _window.Object.defineProperty, _hasOwn = _window.Object.prototype.hasOwnProperty, _slice = _window.Array.prototype.slice, _unwrap = function() {
	    var unwrapper = function(el) {
	      return el;
	    };
	    if (typeof _window.wrap === "function" && typeof _window.unwrap === "function") {
	      try {
	        var div = _document.createElement("div");
	        var unwrappedDiv = _window.unwrap(div);
	        if (div.nodeType === 1 && unwrappedDiv && unwrappedDiv.nodeType === 1) {
	          unwrapper = _window.unwrap;
	        }
	      } catch (e) {}
	    }
	    return unwrapper;
	  }();
	  /**
	 * Convert an `arguments` object into an Array.
	 *
	 * @returns The arguments as an Array
	 * @private
	 */
	  var _args = function(argumentsObj) {
	    return _slice.call(argumentsObj, 0);
	  };
	  /**
	 * Shallow-copy the owned, enumerable properties of one object over to another, similar to jQuery's `$.extend`.
	 *
	 * @returns The target object, augmented
	 * @private
	 */
	  var _extend = function() {
	    var i, len, arg, prop, src, copy, args = _args(arguments), target = args[0] || {};
	    for (i = 1, len = args.length; i < len; i++) {
	      if ((arg = args[i]) != null) {
	        for (prop in arg) {
	          if (_hasOwn.call(arg, prop)) {
	            src = target[prop];
	            copy = arg[prop];
	            if (target !== copy && copy !== undefined) {
	              target[prop] = copy;
	            }
	          }
	        }
	      }
	    }
	    return target;
	  };
	  /**
	 * Return a deep copy of the source object or array.
	 *
	 * @returns Object or Array
	 * @private
	 */
	  var _deepCopy = function(source) {
	    var copy, i, len, prop;
	    if (typeof source !== "object" || source == null || typeof source.nodeType === "number") {
	      copy = source;
	    } else if (typeof source.length === "number") {
	      copy = [];
	      for (i = 0, len = source.length; i < len; i++) {
	        if (_hasOwn.call(source, i)) {
	          copy[i] = _deepCopy(source[i]);
	        }
	      }
	    } else {
	      copy = {};
	      for (prop in source) {
	        if (_hasOwn.call(source, prop)) {
	          copy[prop] = _deepCopy(source[prop]);
	        }
	      }
	    }
	    return copy;
	  };
	  /**
	 * Makes a shallow copy of `obj` (like `_extend`) but filters its properties based on a list of `keys` to keep.
	 * The inverse of `_omit`, mostly. The big difference is that these properties do NOT need to be enumerable to
	 * be kept.
	 *
	 * @returns A new filtered object.
	 * @private
	 */
	  var _pick = function(obj, keys) {
	    var newObj = {};
	    for (var i = 0, len = keys.length; i < len; i++) {
	      if (keys[i] in obj) {
	        newObj[keys[i]] = obj[keys[i]];
	      }
	    }
	    return newObj;
	  };
	  /**
	 * Makes a shallow copy of `obj` (like `_extend`) but filters its properties based on a list of `keys` to omit.
	 * The inverse of `_pick`.
	 *
	 * @returns A new filtered object.
	 * @private
	 */
	  var _omit = function(obj, keys) {
	    var newObj = {};
	    for (var prop in obj) {
	      if (keys.indexOf(prop) === -1) {
	        newObj[prop] = obj[prop];
	      }
	    }
	    return newObj;
	  };
	  /**
	 * Remove all owned, enumerable properties from an object.
	 *
	 * @returns The original object without its owned, enumerable properties.
	 * @private
	 */
	  var _deleteOwnProperties = function(obj) {
	    if (obj) {
	      for (var prop in obj) {
	        if (_hasOwn.call(obj, prop)) {
	          delete obj[prop];
	        }
	      }
	    }
	    return obj;
	  };
	  /**
	 * Determine if an element is contained within another element.
	 *
	 * @returns Boolean
	 * @private
	 */
	  var _containedBy = function(el, ancestorEl) {
	    if (el && el.nodeType === 1 && el.ownerDocument && ancestorEl && (ancestorEl.nodeType === 1 && ancestorEl.ownerDocument && ancestorEl.ownerDocument === el.ownerDocument || ancestorEl.nodeType === 9 && !ancestorEl.ownerDocument && ancestorEl === el.ownerDocument)) {
	      do {
	        if (el === ancestorEl) {
	          return true;
	        }
	        el = el.parentNode;
	      } while (el);
	    }
	    return false;
	  };
	  /**
	 * Get the URL path's parent directory.
	 *
	 * @returns String or `undefined`
	 * @private
	 */
	  var _getDirPathOfUrl = function(url) {
	    var dir;
	    if (typeof url === "string" && url) {
	      dir = url.split("#")[0].split("?")[0];
	      dir = url.slice(0, url.lastIndexOf("/") + 1);
	    }
	    return dir;
	  };
	  /**
	 * Get the current script's URL by throwing an `Error` and analyzing it.
	 *
	 * @returns String or `undefined`
	 * @private
	 */
	  var _getCurrentScriptUrlFromErrorStack = function(stack) {
	    var url, matches;
	    if (typeof stack === "string" && stack) {
	      matches = stack.match(/^(?:|[^:@]*@|.+\)@(?=http[s]?|file)|.+?\s+(?: at |@)(?:[^:\(]+ )*[\(]?)((?:http[s]?|file):\/\/[\/]?.+?\/[^:\)]*?)(?::\d+)(?::\d+)?/);
	      if (matches && matches[1]) {
	        url = matches[1];
	      } else {
	        matches = stack.match(/\)@((?:http[s]?|file):\/\/[\/]?.+?\/[^:\)]*?)(?::\d+)(?::\d+)?/);
	        if (matches && matches[1]) {
	          url = matches[1];
	        }
	      }
	    }
	    return url;
	  };
	  /**
	 * Get the current script's URL by throwing an `Error` and analyzing it.
	 *
	 * @returns String or `undefined`
	 * @private
	 */
	  var _getCurrentScriptUrlFromError = function() {
	    var url, err;
	    try {
	      throw new _Error();
	    } catch (e) {
	      err = e;
	    }
	    if (err) {
	      url = err.sourceURL || err.fileName || _getCurrentScriptUrlFromErrorStack(err.stack);
	    }
	    return url;
	  };
	  /**
	 * Get the current script's URL.
	 *
	 * @returns String or `undefined`
	 * @private
	 */
	  var _getCurrentScriptUrl = function() {
	    var jsPath, scripts, i;
	    if (_document.currentScript && (jsPath = _document.currentScript.src)) {
	      return jsPath;
	    }
	    scripts = _document.getElementsByTagName("script");
	    if (scripts.length === 1) {
	      return scripts[0].src || undefined;
	    }
	    if ("readyState" in scripts[0]) {
	      for (i = scripts.length; i--; ) {
	        if (scripts[i].readyState === "interactive" && (jsPath = scripts[i].src)) {
	          return jsPath;
	        }
	      }
	    }
	    if (_document.readyState === "loading" && (jsPath = scripts[scripts.length - 1].src)) {
	      return jsPath;
	    }
	    if (jsPath = _getCurrentScriptUrlFromError()) {
	      return jsPath;
	    }
	    return undefined;
	  };
	  /**
	 * Get the unanimous parent directory of ALL script tags.
	 * If any script tags are either (a) inline or (b) from differing parent
	 * directories, this method must return `undefined`.
	 *
	 * @returns String or `undefined`
	 * @private
	 */
	  var _getUnanimousScriptParentDir = function() {
	    var i, jsDir, jsPath, scripts = _document.getElementsByTagName("script");
	    for (i = scripts.length; i--; ) {
	      if (!(jsPath = scripts[i].src)) {
	        jsDir = null;
	        break;
	      }
	      jsPath = _getDirPathOfUrl(jsPath);
	      if (jsDir == null) {
	        jsDir = jsPath;
	      } else if (jsDir !== jsPath) {
	        jsDir = null;
	        break;
	      }
	    }
	    return jsDir || undefined;
	  };
	  /**
	 * Get the presumed location of the "ZeroClipboard.swf" file, based on the location
	 * of the executing JavaScript file (e.g. "ZeroClipboard.js", etc.).
	 *
	 * @returns String
	 * @private
	 */
	  var _getDefaultSwfPath = function() {
	    var jsDir = _getDirPathOfUrl(_getCurrentScriptUrl()) || _getUnanimousScriptParentDir() || "";
	    return jsDir + "ZeroClipboard.swf";
	  };
	  /**
	 * Keep track of if the page is framed (in an `iframe`). This can never change.
	 * @private
	 */
	  var _pageIsFramed = function() {
	    return window.opener == null && (!!window.top && window != window.top || !!window.parent && window != window.parent);
	  }();
	  /**
	 * Keep track of the state of the Flash object.
	 * @private
	 */
	  var _flashState = {
	    bridge: null,
	    version: "0.0.0",
	    pluginType: "unknown",
	    disabled: null,
	    outdated: null,
	    sandboxed: null,
	    unavailable: null,
	    degraded: null,
	    deactivated: null,
	    overdue: null,
	    ready: null
	  };
	  /**
	 * The minimum Flash Player version required to use ZeroClipboard completely.
	 * @readonly
	 * @private
	 */
	  var _minimumFlashVersion = "11.0.0";
	  /**
	 * The ZeroClipboard library version number, as reported by Flash, at the time the SWF was compiled.
	 */
	  var _zcSwfVersion;
	  /**
	 * Keep track of all event listener registrations.
	 * @private
	 */
	  var _handlers = {};
	  /**
	 * Keep track of the currently activated element.
	 * @private
	 */
	  var _currentElement;
	  /**
	 * Keep track of the element that was activated when a `copy` process started.
	 * @private
	 */
	  var _copyTarget;
	  /**
	 * Keep track of data for the pending clipboard transaction.
	 * @private
	 */
	  var _clipData = {};
	  /**
	 * Keep track of data formats for the pending clipboard transaction.
	 * @private
	 */
	  var _clipDataFormatMap = null;
	  /**
	 * Keep track of the Flash availability check timeout.
	 * @private
	 */
	  var _flashCheckTimeout = 0;
	  /**
	 * Keep track of SWF network errors interval polling.
	 * @private
	 */
	  var _swfFallbackCheckInterval = 0;
	  /**
	 * The `message` store for events
	 * @private
	 */
	  var _eventMessages = {
	    ready: "Flash communication is established",
	    error: {
	      "flash-disabled": "Flash is disabled or not installed. May also be attempting to run Flash in a sandboxed iframe, which is impossible.",
	      "flash-outdated": "Flash is too outdated to support ZeroClipboard",
	      "flash-sandboxed": "Attempting to run Flash in a sandboxed iframe, which is impossible",
	      "flash-unavailable": "Flash is unable to communicate bidirectionally with JavaScript",
	      "flash-degraded": "Flash is unable to preserve data fidelity when communicating with JavaScript",
	      "flash-deactivated": "Flash is too outdated for your browser and/or is configured as click-to-activate.\nThis may also mean that the ZeroClipboard SWF object could not be loaded, so please check your `swfPath` configuration and/or network connectivity.\nMay also be attempting to run Flash in a sandboxed iframe, which is impossible.",
	      "flash-overdue": "Flash communication was established but NOT within the acceptable time limit",
	      "version-mismatch": "ZeroClipboard JS version number does not match ZeroClipboard SWF version number",
	      "clipboard-error": "At least one error was thrown while ZeroClipboard was attempting to inject your data into the clipboard",
	      "config-mismatch": "ZeroClipboard configuration does not match Flash's reality",
	      "swf-not-found": "The ZeroClipboard SWF object could not be loaded, so please check your `swfPath` configuration and/or network connectivity"
	    }
	  };
	  /**
	 * The `name`s of `error` events that can only occur is Flash has at least
	 * been able to load the SWF successfully.
	 * @private
	 */
	  var _errorsThatOnlyOccurAfterFlashLoads = [ "flash-unavailable", "flash-degraded", "flash-overdue", "version-mismatch", "config-mismatch", "clipboard-error" ];
	  /**
	 * The `name`s of `error` events that should likely result in the `_flashState`
	 * variable's property values being updated.
	 * @private
	 */
	  var _flashStateErrorNames = [ "flash-disabled", "flash-outdated", "flash-sandboxed", "flash-unavailable", "flash-degraded", "flash-deactivated", "flash-overdue" ];
	  /**
	 * A RegExp to match the `name` property of `error` events related to Flash.
	 * @private
	 */
	  var _flashStateErrorNameMatchingRegex = new RegExp("^flash-(" + _flashStateErrorNames.map(function(errorName) {
	    return errorName.replace(/^flash-/, "");
	  }).join("|") + ")$");
	  /**
	 * A RegExp to match the `name` property of `error` events related to Flash,
	 * which is enabled.
	 * @private
	 */
	  var _flashStateEnabledErrorNameMatchingRegex = new RegExp("^flash-(" + _flashStateErrorNames.slice(1).map(function(errorName) {
	    return errorName.replace(/^flash-/, "");
	  }).join("|") + ")$");
	  /**
	 * ZeroClipboard configuration defaults for the Core module.
	 * @private
	 */
	  var _globalConfig = {
	    swfPath: _getDefaultSwfPath(),
	    trustedDomains: window.location.host ? [ window.location.host ] : [],
	    cacheBust: true,
	    forceEnhancedClipboard: false,
	    flashLoadTimeout: 3e4,
	    autoActivate: true,
	    bubbleEvents: true,
	    containerId: "global-zeroclipboard-html-bridge",
	    containerClass: "global-zeroclipboard-container",
	    swfObjectId: "global-zeroclipboard-flash-bridge",
	    hoverClass: "zeroclipboard-is-hover",
	    activeClass: "zeroclipboard-is-active",
	    forceHandCursor: false,
	    title: null,
	    zIndex: 999999999
	  };
	  /**
	 * The underlying implementation of `ZeroClipboard.config`.
	 * @private
	 */
	  var _config = function(options) {
	    if (typeof options === "object" && options !== null) {
	      for (var prop in options) {
	        if (_hasOwn.call(options, prop)) {
	          if (/^(?:forceHandCursor|title|zIndex|bubbleEvents)$/.test(prop)) {
	            _globalConfig[prop] = options[prop];
	          } else if (_flashState.bridge == null) {
	            if (prop === "containerId" || prop === "swfObjectId") {
	              if (_isValidHtml4Id(options[prop])) {
	                _globalConfig[prop] = options[prop];
	              } else {
	                throw new Error("The specified `" + prop + "` value is not valid as an HTML4 Element ID");
	              }
	            } else {
	              _globalConfig[prop] = options[prop];
	            }
	          }
	        }
	      }
	    }
	    if (typeof options === "string" && options) {
	      if (_hasOwn.call(_globalConfig, options)) {
	        return _globalConfig[options];
	      }
	      return;
	    }
	    return _deepCopy(_globalConfig);
	  };
	  /**
	 * The underlying implementation of `ZeroClipboard.state`.
	 * @private
	 */
	  var _state = function() {
	    _detectSandbox();
	    return {
	      browser: _pick(_navigator, [ "userAgent", "platform", "appName" ]),
	      flash: _omit(_flashState, [ "bridge" ]),
	      zeroclipboard: {
	        version: ZeroClipboard.version,
	        config: ZeroClipboard.config()
	      }
	    };
	  };
	  /**
	 * The underlying implementation of `ZeroClipboard.isFlashUnusable`.
	 * @private
	 */
	  var _isFlashUnusable = function() {
	    return !!(_flashState.disabled || _flashState.outdated || _flashState.sandboxed || _flashState.unavailable || _flashState.degraded || _flashState.deactivated);
	  };
	  /**
	 * The underlying implementation of `ZeroClipboard.on`.
	 * @private
	 */
	  var _on = function(eventType, listener) {
	    var i, len, events, added = {};
	    if (typeof eventType === "string" && eventType) {
	      events = eventType.toLowerCase().split(/\s+/);
	    } else if (typeof eventType === "object" && eventType && typeof listener === "undefined") {
	      for (i in eventType) {
	        if (_hasOwn.call(eventType, i) && typeof i === "string" && i && typeof eventType[i] === "function") {
	          ZeroClipboard.on(i, eventType[i]);
	        }
	      }
	    }
	    if (events && events.length) {
	      for (i = 0, len = events.length; i < len; i++) {
	        eventType = events[i].replace(/^on/, "");
	        added[eventType] = true;
	        if (!_handlers[eventType]) {
	          _handlers[eventType] = [];
	        }
	        _handlers[eventType].push(listener);
	      }
	      if (added.ready && _flashState.ready) {
	        ZeroClipboard.emit({
	          type: "ready"
	        });
	      }
	      if (added.error) {
	        for (i = 0, len = _flashStateErrorNames.length; i < len; i++) {
	          if (_flashState[_flashStateErrorNames[i].replace(/^flash-/, "")] === true) {
	            ZeroClipboard.emit({
	              type: "error",
	              name: _flashStateErrorNames[i]
	            });
	            break;
	          }
	        }
	        if (_zcSwfVersion !== undefined && ZeroClipboard.version !== _zcSwfVersion) {
	          ZeroClipboard.emit({
	            type: "error",
	            name: "version-mismatch",
	            jsVersion: ZeroClipboard.version,
	            swfVersion: _zcSwfVersion
	          });
	        }
	      }
	    }
	    return ZeroClipboard;
	  };
	  /**
	 * The underlying implementation of `ZeroClipboard.off`.
	 * @private
	 */
	  var _off = function(eventType, listener) {
	    var i, len, foundIndex, events, perEventHandlers;
	    if (arguments.length === 0) {
	      events = _keys(_handlers);
	    } else if (typeof eventType === "string" && eventType) {
	      events = eventType.split(/\s+/);
	    } else if (typeof eventType === "object" && eventType && typeof listener === "undefined") {
	      for (i in eventType) {
	        if (_hasOwn.call(eventType, i) && typeof i === "string" && i && typeof eventType[i] === "function") {
	          ZeroClipboard.off(i, eventType[i]);
	        }
	      }
	    }
	    if (events && events.length) {
	      for (i = 0, len = events.length; i < len; i++) {
	        eventType = events[i].toLowerCase().replace(/^on/, "");
	        perEventHandlers = _handlers[eventType];
	        if (perEventHandlers && perEventHandlers.length) {
	          if (listener) {
	            foundIndex = perEventHandlers.indexOf(listener);
	            while (foundIndex !== -1) {
	              perEventHandlers.splice(foundIndex, 1);
	              foundIndex = perEventHandlers.indexOf(listener, foundIndex);
	            }
	          } else {
	            perEventHandlers.length = 0;
	          }
	        }
	      }
	    }
	    return ZeroClipboard;
	  };
	  /**
	 * The underlying implementation of `ZeroClipboard.handlers`.
	 * @private
	 */
	  var _listeners = function(eventType) {
	    var copy;
	    if (typeof eventType === "string" && eventType) {
	      copy = _deepCopy(_handlers[eventType]) || null;
	    } else {
	      copy = _deepCopy(_handlers);
	    }
	    return copy;
	  };
	  /**
	 * The underlying implementation of `ZeroClipboard.emit`.
	 * @private
	 */
	  var _emit = function(event) {
	    var eventCopy, returnVal, tmp;
	    event = _createEvent(event);
	    if (!event) {
	      return;
	    }
	    if (_preprocessEvent(event)) {
	      return;
	    }
	    if (event.type === "ready" && _flashState.overdue === true) {
	      return ZeroClipboard.emit({
	        type: "error",
	        name: "flash-overdue"
	      });
	    }
	    eventCopy = _extend({}, event);
	    _dispatchCallbacks.call(this, eventCopy);
	    if (event.type === "copy") {
	      tmp = _mapClipDataToFlash(_clipData);
	      returnVal = tmp.data;
	      _clipDataFormatMap = tmp.formatMap;
	    }
	    return returnVal;
	  };
	  /**
	 * The underlying implementation of `ZeroClipboard.create`.
	 * @private
	 */
	  var _create = function() {
	    var previousState = _flashState.sandboxed;
	    _detectSandbox();
	    if (typeof _flashState.ready !== "boolean") {
	      _flashState.ready = false;
	    }
	    if (_flashState.sandboxed !== previousState && _flashState.sandboxed === true) {
	      _flashState.ready = false;
	      ZeroClipboard.emit({
	        type: "error",
	        name: "flash-sandboxed"
	      });
	    } else if (!ZeroClipboard.isFlashUnusable() && _flashState.bridge === null) {
	      var maxWait = _globalConfig.flashLoadTimeout;
	      if (typeof maxWait === "number" && maxWait >= 0) {
	        _flashCheckTimeout = _setTimeout(function() {
	          if (typeof _flashState.deactivated !== "boolean") {
	            _flashState.deactivated = true;
	          }
	          if (_flashState.deactivated === true) {
	            ZeroClipboard.emit({
	              type: "error",
	              name: "flash-deactivated"
	            });
	          }
	        }, maxWait);
	      }
	      _flashState.overdue = false;
	      _embedSwf();
	    }
	  };
	  /**
	 * The underlying implementation of `ZeroClipboard.destroy`.
	 * @private
	 */
	  var _destroy = function() {
	    ZeroClipboard.clearData();
	    ZeroClipboard.blur();
	    ZeroClipboard.emit("destroy");
	    _unembedSwf();
	    ZeroClipboard.off();
	  };
	  /**
	 * The underlying implementation of `ZeroClipboard.setData`.
	 * @private
	 */
	  var _setData = function(format, data) {
	    var dataObj;
	    if (typeof format === "object" && format && typeof data === "undefined") {
	      dataObj = format;
	      ZeroClipboard.clearData();
	    } else if (typeof format === "string" && format) {
	      dataObj = {};
	      dataObj[format] = data;
	    } else {
	      return;
	    }
	    for (var dataFormat in dataObj) {
	      if (typeof dataFormat === "string" && dataFormat && _hasOwn.call(dataObj, dataFormat) && typeof dataObj[dataFormat] === "string" && dataObj[dataFormat]) {
	        _clipData[dataFormat] = dataObj[dataFormat];
	      }
	    }
	  };
	  /**
	 * The underlying implementation of `ZeroClipboard.clearData`.
	 * @private
	 */
	  var _clearData = function(format) {
	    if (typeof format === "undefined") {
	      _deleteOwnProperties(_clipData);
	      _clipDataFormatMap = null;
	    } else if (typeof format === "string" && _hasOwn.call(_clipData, format)) {
	      delete _clipData[format];
	    }
	  };
	  /**
	 * The underlying implementation of `ZeroClipboard.getData`.
	 * @private
	 */
	  var _getData = function(format) {
	    if (typeof format === "undefined") {
	      return _deepCopy(_clipData);
	    } else if (typeof format === "string" && _hasOwn.call(_clipData, format)) {
	      return _clipData[format];
	    }
	  };
	  /**
	 * The underlying implementation of `ZeroClipboard.focus`/`ZeroClipboard.activate`.
	 * @private
	 */
	  var _focus = function(element) {
	    if (!(element && element.nodeType === 1)) {
	      return;
	    }
	    if (_currentElement) {
	      _removeClass(_currentElement, _globalConfig.activeClass);
	      if (_currentElement !== element) {
	        _removeClass(_currentElement, _globalConfig.hoverClass);
	      }
	    }
	    _currentElement = element;
	    _addClass(element, _globalConfig.hoverClass);
	    var newTitle = element.getAttribute("title") || _globalConfig.title;
	    if (typeof newTitle === "string" && newTitle) {
	      var htmlBridge = _getHtmlBridge(_flashState.bridge);
	      if (htmlBridge) {
	        htmlBridge.setAttribute("title", newTitle);
	      }
	    }
	    var useHandCursor = _globalConfig.forceHandCursor === true || _getStyle(element, "cursor") === "pointer";
	    _setHandCursor(useHandCursor);
	    _reposition();
	  };
	  /**
	 * The underlying implementation of `ZeroClipboard.blur`/`ZeroClipboard.deactivate`.
	 * @private
	 */
	  var _blur = function() {
	    var htmlBridge = _getHtmlBridge(_flashState.bridge);
	    if (htmlBridge) {
	      htmlBridge.removeAttribute("title");
	      htmlBridge.style.left = "0px";
	      htmlBridge.style.top = "-9999px";
	      htmlBridge.style.width = "1px";
	      htmlBridge.style.height = "1px";
	    }
	    if (_currentElement) {
	      _removeClass(_currentElement, _globalConfig.hoverClass);
	      _removeClass(_currentElement, _globalConfig.activeClass);
	      _currentElement = null;
	    }
	  };
	  /**
	 * The underlying implementation of `ZeroClipboard.activeElement`.
	 * @private
	 */
	  var _activeElement = function() {
	    return _currentElement || null;
	  };
	  /**
	 * Check if a value is a valid HTML4 `ID` or `Name` token.
	 * @private
	 */
	  var _isValidHtml4Id = function(id) {
	    return typeof id === "string" && id && /^[A-Za-z][A-Za-z0-9_:\-\.]*$/.test(id);
	  };
	  /**
	 * Create or update an `event` object, based on the `eventType`.
	 * @private
	 */
	  var _createEvent = function(event) {
	    var eventType;
	    if (typeof event === "string" && event) {
	      eventType = event;
	      event = {};
	    } else if (typeof event === "object" && event && typeof event.type === "string" && event.type) {
	      eventType = event.type;
	    }
	    if (!eventType) {
	      return;
	    }
	    eventType = eventType.toLowerCase();
	    if (!event.target && (/^(copy|aftercopy|_click)$/.test(eventType) || eventType === "error" && event.name === "clipboard-error")) {
	      event.target = _copyTarget;
	    }
	    _extend(event, {
	      type: eventType,
	      target: event.target || _currentElement || null,
	      relatedTarget: event.relatedTarget || null,
	      currentTarget: _flashState && _flashState.bridge || null,
	      timeStamp: event.timeStamp || _now() || null
	    });
	    var msg = _eventMessages[event.type];
	    if (event.type === "error" && event.name && msg) {
	      msg = msg[event.name];
	    }
	    if (msg) {
	      event.message = msg;
	    }
	    if (event.type === "ready") {
	      _extend(event, {
	        target: null,
	        version: _flashState.version
	      });
	    }
	    if (event.type === "error") {
	      if (_flashStateErrorNameMatchingRegex.test(event.name)) {
	        _extend(event, {
	          target: null,
	          minimumVersion: _minimumFlashVersion
	        });
	      }
	      if (_flashStateEnabledErrorNameMatchingRegex.test(event.name)) {
	        _extend(event, {
	          version: _flashState.version
	        });
	      }
	    }
	    if (event.type === "copy") {
	      event.clipboardData = {
	        setData: ZeroClipboard.setData,
	        clearData: ZeroClipboard.clearData
	      };
	    }
	    if (event.type === "aftercopy") {
	      event = _mapClipResultsFromFlash(event, _clipDataFormatMap);
	    }
	    if (event.target && !event.relatedTarget) {
	      event.relatedTarget = _getRelatedTarget(event.target);
	    }
	    return _addMouseData(event);
	  };
	  /**
	 * Get a relatedTarget from the target's `data-clipboard-target` attribute
	 * @private
	 */
	  var _getRelatedTarget = function(targetEl) {
	    var relatedTargetId = targetEl && targetEl.getAttribute && targetEl.getAttribute("data-clipboard-target");
	    return relatedTargetId ? _document.getElementById(relatedTargetId) : null;
	  };
	  /**
	 * Add element and position data to `MouseEvent` instances
	 * @private
	 */
	  var _addMouseData = function(event) {
	    if (event && /^_(?:click|mouse(?:over|out|down|up|move))$/.test(event.type)) {
	      var srcElement = event.target;
	      var fromElement = event.type === "_mouseover" && event.relatedTarget ? event.relatedTarget : undefined;
	      var toElement = event.type === "_mouseout" && event.relatedTarget ? event.relatedTarget : undefined;
	      var pos = _getElementPosition(srcElement);
	      var screenLeft = _window.screenLeft || _window.screenX || 0;
	      var screenTop = _window.screenTop || _window.screenY || 0;
	      var scrollLeft = _document.body.scrollLeft + _document.documentElement.scrollLeft;
	      var scrollTop = _document.body.scrollTop + _document.documentElement.scrollTop;
	      var pageX = pos.left + (typeof event._stageX === "number" ? event._stageX : 0);
	      var pageY = pos.top + (typeof event._stageY === "number" ? event._stageY : 0);
	      var clientX = pageX - scrollLeft;
	      var clientY = pageY - scrollTop;
	      var screenX = screenLeft + clientX;
	      var screenY = screenTop + clientY;
	      var moveX = typeof event.movementX === "number" ? event.movementX : 0;
	      var moveY = typeof event.movementY === "number" ? event.movementY : 0;
	      delete event._stageX;
	      delete event._stageY;
	      _extend(event, {
	        srcElement: srcElement,
	        fromElement: fromElement,
	        toElement: toElement,
	        screenX: screenX,
	        screenY: screenY,
	        pageX: pageX,
	        pageY: pageY,
	        clientX: clientX,
	        clientY: clientY,
	        x: clientX,
	        y: clientY,
	        movementX: moveX,
	        movementY: moveY,
	        offsetX: 0,
	        offsetY: 0,
	        layerX: 0,
	        layerY: 0
	      });
	    }
	    return event;
	  };
	  /**
	 * Determine if an event's registered handlers should be execute synchronously or asynchronously.
	 *
	 * @returns {boolean}
	 * @private
	 */
	  var _shouldPerformAsync = function(event) {
	    var eventType = event && typeof event.type === "string" && event.type || "";
	    return !/^(?:(?:before)?copy|destroy)$/.test(eventType);
	  };
	  /**
	 * Control if a callback should be executed asynchronously or not.
	 *
	 * @returns `undefined`
	 * @private
	 */
	  var _dispatchCallback = function(func, context, args, async) {
	    if (async) {
	      _setTimeout(function() {
	        func.apply(context, args);
	      }, 0);
	    } else {
	      func.apply(context, args);
	    }
	  };
	  /**
	 * Handle the actual dispatching of events to client instances.
	 *
	 * @returns `undefined`
	 * @private
	 */
	  var _dispatchCallbacks = function(event) {
	    if (!(typeof event === "object" && event && event.type)) {
	      return;
	    }
	    var async = _shouldPerformAsync(event);
	    var wildcardTypeHandlers = _handlers["*"] || [];
	    var specificTypeHandlers = _handlers[event.type] || [];
	    var handlers = wildcardTypeHandlers.concat(specificTypeHandlers);
	    if (handlers && handlers.length) {
	      var i, len, func, context, eventCopy, originalContext = this;
	      for (i = 0, len = handlers.length; i < len; i++) {
	        func = handlers[i];
	        context = originalContext;
	        if (typeof func === "string" && typeof _window[func] === "function") {
	          func = _window[func];
	        }
	        if (typeof func === "object" && func && typeof func.handleEvent === "function") {
	          context = func;
	          func = func.handleEvent;
	        }
	        if (typeof func === "function") {
	          eventCopy = _extend({}, event);
	          _dispatchCallback(func, context, [ eventCopy ], async);
	        }
	      }
	    }
	    return this;
	  };
	  /**
	 * Check an `error` event's `name` property to see if Flash has
	 * already loaded, which rules out possible `iframe` sandboxing.
	 * @private
	 */
	  var _getSandboxStatusFromErrorEvent = function(event) {
	    var isSandboxed = null;
	    if (_pageIsFramed === false || event && event.type === "error" && event.name && _errorsThatOnlyOccurAfterFlashLoads.indexOf(event.name) !== -1) {
	      isSandboxed = false;
	    }
	    return isSandboxed;
	  };
	  /**
	 * Preprocess any special behaviors, reactions, or state changes after receiving this event.
	 * Executes only once per event emitted, NOT once per client.
	 * @private
	 */
	  var _preprocessEvent = function(event) {
	    var element = event.target || _currentElement || null;
	    var sourceIsSwf = event._source === "swf";
	    delete event._source;
	    switch (event.type) {
	     case "error":
	      var isSandboxed = event.name === "flash-sandboxed" || _getSandboxStatusFromErrorEvent(event);
	      if (typeof isSandboxed === "boolean") {
	        _flashState.sandboxed = isSandboxed;
	      }
	      if (_flashStateErrorNames.indexOf(event.name) !== -1) {
	        _extend(_flashState, {
	          disabled: event.name === "flash-disabled",
	          outdated: event.name === "flash-outdated",
	          unavailable: event.name === "flash-unavailable",
	          degraded: event.name === "flash-degraded",
	          deactivated: event.name === "flash-deactivated",
	          overdue: event.name === "flash-overdue",
	          ready: false
	        });
	      } else if (event.name === "version-mismatch") {
	        _zcSwfVersion = event.swfVersion;
	        _extend(_flashState, {
	          disabled: false,
	          outdated: false,
	          unavailable: false,
	          degraded: false,
	          deactivated: false,
	          overdue: false,
	          ready: false
	        });
	      }
	      _clearTimeoutsAndPolling();
	      break;

	     case "ready":
	      _zcSwfVersion = event.swfVersion;
	      var wasDeactivated = _flashState.deactivated === true;
	      _extend(_flashState, {
	        disabled: false,
	        outdated: false,
	        sandboxed: false,
	        unavailable: false,
	        degraded: false,
	        deactivated: false,
	        overdue: wasDeactivated,
	        ready: !wasDeactivated
	      });
	      _clearTimeoutsAndPolling();
	      break;

	     case "beforecopy":
	      _copyTarget = element;
	      break;

	     case "copy":
	      var textContent, htmlContent, targetEl = event.relatedTarget;
	      if (!(_clipData["text/html"] || _clipData["text/plain"]) && targetEl && (htmlContent = targetEl.value || targetEl.outerHTML || targetEl.innerHTML) && (textContent = targetEl.value || targetEl.textContent || targetEl.innerText)) {
	        event.clipboardData.clearData();
	        event.clipboardData.setData("text/plain", textContent);
	        if (htmlContent !== textContent) {
	          event.clipboardData.setData("text/html", htmlContent);
	        }
	      } else if (!_clipData["text/plain"] && event.target && (textContent = event.target.getAttribute("data-clipboard-text"))) {
	        event.clipboardData.clearData();
	        event.clipboardData.setData("text/plain", textContent);
	      }
	      break;

	     case "aftercopy":
	      _queueEmitClipboardErrors(event);
	      ZeroClipboard.clearData();
	      if (element && element !== _safeActiveElement() && element.focus) {
	        element.focus();
	      }
	      break;

	     case "_mouseover":
	      ZeroClipboard.focus(element);
	      if (_globalConfig.bubbleEvents === true && sourceIsSwf) {
	        if (element && element !== event.relatedTarget && !_containedBy(event.relatedTarget, element)) {
	          _fireMouseEvent(_extend({}, event, {
	            type: "mouseenter",
	            bubbles: false,
	            cancelable: false
	          }));
	        }
	        _fireMouseEvent(_extend({}, event, {
	          type: "mouseover"
	        }));
	      }
	      break;

	     case "_mouseout":
	      ZeroClipboard.blur();
	      if (_globalConfig.bubbleEvents === true && sourceIsSwf) {
	        if (element && element !== event.relatedTarget && !_containedBy(event.relatedTarget, element)) {
	          _fireMouseEvent(_extend({}, event, {
	            type: "mouseleave",
	            bubbles: false,
	            cancelable: false
	          }));
	        }
	        _fireMouseEvent(_extend({}, event, {
	          type: "mouseout"
	        }));
	      }
	      break;

	     case "_mousedown":
	      _addClass(element, _globalConfig.activeClass);
	      if (_globalConfig.bubbleEvents === true && sourceIsSwf) {
	        _fireMouseEvent(_extend({}, event, {
	          type: event.type.slice(1)
	        }));
	      }
	      break;

	     case "_mouseup":
	      _removeClass(element, _globalConfig.activeClass);
	      if (_globalConfig.bubbleEvents === true && sourceIsSwf) {
	        _fireMouseEvent(_extend({}, event, {
	          type: event.type.slice(1)
	        }));
	      }
	      break;

	     case "_click":
	      _copyTarget = null;
	      if (_globalConfig.bubbleEvents === true && sourceIsSwf) {
	        _fireMouseEvent(_extend({}, event, {
	          type: event.type.slice(1)
	        }));
	      }
	      break;

	     case "_mousemove":
	      if (_globalConfig.bubbleEvents === true && sourceIsSwf) {
	        _fireMouseEvent(_extend({}, event, {
	          type: event.type.slice(1)
	        }));
	      }
	      break;
	    }
	    if (/^_(?:click|mouse(?:over|out|down|up|move))$/.test(event.type)) {
	      return true;
	    }
	  };
	  /**
	 * Check an "aftercopy" event for clipboard errors and emit a corresponding "error" event.
	 * @private
	 */
	  var _queueEmitClipboardErrors = function(aftercopyEvent) {
	    if (aftercopyEvent.errors && aftercopyEvent.errors.length > 0) {
	      var errorEvent = _deepCopy(aftercopyEvent);
	      _extend(errorEvent, {
	        type: "error",
	        name: "clipboard-error"
	      });
	      delete errorEvent.success;
	      _setTimeout(function() {
	        ZeroClipboard.emit(errorEvent);
	      }, 0);
	    }
	  };
	  /**
	 * Dispatch a synthetic MouseEvent.
	 *
	 * @returns `undefined`
	 * @private
	 */
	  var _fireMouseEvent = function(event) {
	    if (!(event && typeof event.type === "string" && event)) {
	      return;
	    }
	    var e, target = event.target || null, doc = target && target.ownerDocument || _document, defaults = {
	      view: doc.defaultView || _window,
	      canBubble: true,
	      cancelable: true,
	      detail: event.type === "click" ? 1 : 0,
	      button: typeof event.which === "number" ? event.which - 1 : typeof event.button === "number" ? event.button : doc.createEvent ? 0 : 1
	    }, args = _extend(defaults, event);
	    if (!target) {
	      return;
	    }
	    if (doc.createEvent && target.dispatchEvent) {
	      args = [ args.type, args.canBubble, args.cancelable, args.view, args.detail, args.screenX, args.screenY, args.clientX, args.clientY, args.ctrlKey, args.altKey, args.shiftKey, args.metaKey, args.button, args.relatedTarget ];
	      e = doc.createEvent("MouseEvents");
	      if (e.initMouseEvent) {
	        e.initMouseEvent.apply(e, args);
	        e._source = "js";
	        target.dispatchEvent(e);
	      }
	    }
	  };
	  /**
	 * Continuously poll the DOM until either:
	 *  (a) the fallback content becomes visible, or
	 *  (b) we receive an event from SWF (handled elsewhere)
	 *
	 * IMPORTANT:
	 * This is NOT a necessary check but it can result in significantly faster
	 * detection of bad `swfPath` configuration and/or network/server issues [in
	 * supported browsers] than waiting for the entire `flashLoadTimeout` duration
	 * to elapse before detecting that the SWF cannot be loaded. The detection
	 * duration can be anywhere from 10-30 times faster [in supported browsers] by
	 * using this approach.
	 *
	 * @returns `undefined`
	 * @private
	 */
	  var _watchForSwfFallbackContent = function() {
	    var maxWait = _globalConfig.flashLoadTimeout;
	    if (typeof maxWait === "number" && maxWait >= 0) {
	      var pollWait = Math.min(1e3, maxWait / 10);
	      var fallbackContentId = _globalConfig.swfObjectId + "_fallbackContent";
	      _swfFallbackCheckInterval = _setInterval(function() {
	        var el = _document.getElementById(fallbackContentId);
	        if (_isElementVisible(el)) {
	          _clearTimeoutsAndPolling();
	          _flashState.deactivated = null;
	          ZeroClipboard.emit({
	            type: "error",
	            name: "swf-not-found"
	          });
	        }
	      }, pollWait);
	    }
	  };
	  /**
	 * Create the HTML bridge element to embed the Flash object into.
	 * @private
	 */
	  var _createHtmlBridge = function() {
	    var container = _document.createElement("div");
	    container.id = _globalConfig.containerId;
	    container.className = _globalConfig.containerClass;
	    container.style.position = "absolute";
	    container.style.left = "0px";
	    container.style.top = "-9999px";
	    container.style.width = "1px";
	    container.style.height = "1px";
	    container.style.zIndex = "" + _getSafeZIndex(_globalConfig.zIndex);
	    return container;
	  };
	  /**
	 * Get the HTML element container that wraps the Flash bridge object/element.
	 * @private
	 */
	  var _getHtmlBridge = function(flashBridge) {
	    var htmlBridge = flashBridge && flashBridge.parentNode;
	    while (htmlBridge && htmlBridge.nodeName === "OBJECT" && htmlBridge.parentNode) {
	      htmlBridge = htmlBridge.parentNode;
	    }
	    return htmlBridge || null;
	  };
	  /**
	 * Create the SWF object.
	 *
	 * @returns The SWF object reference.
	 * @private
	 */
	  var _embedSwf = function() {
	    var len, flashBridge = _flashState.bridge, container = _getHtmlBridge(flashBridge);
	    if (!flashBridge) {
	      var allowScriptAccess = _determineScriptAccess(_window.location.host, _globalConfig);
	      var allowNetworking = allowScriptAccess === "never" ? "none" : "all";
	      var flashvars = _vars(_extend({
	        jsVersion: ZeroClipboard.version
	      }, _globalConfig));
	      var swfUrl = _globalConfig.swfPath + _cacheBust(_globalConfig.swfPath, _globalConfig);
	      container = _createHtmlBridge();
	      var divToBeReplaced = _document.createElement("div");
	      container.appendChild(divToBeReplaced);
	      _document.body.appendChild(container);
	      var tmpDiv = _document.createElement("div");
	      var usingActiveX = _flashState.pluginType === "activex";
	      tmpDiv.innerHTML = '<object id="' + _globalConfig.swfObjectId + '" name="' + _globalConfig.swfObjectId + '" ' + 'width="100%" height="100%" ' + (usingActiveX ? 'classid="clsid:d27cdb6e-ae6d-11cf-96b8-444553540000"' : 'type="application/x-shockwave-flash" data="' + swfUrl + '"') + ">" + (usingActiveX ? '<param name="movie" value="' + swfUrl + '"/>' : "") + '<param name="allowScriptAccess" value="' + allowScriptAccess + '"/>' + '<param name="allowNetworking" value="' + allowNetworking + '"/>' + '<param name="menu" value="false"/>' + '<param name="wmode" value="transparent"/>' + '<param name="flashvars" value="' + flashvars + '"/>' + '<div id="' + _globalConfig.swfObjectId + '_fallbackContent">&nbsp;</div>' + "</object>";
	      flashBridge = tmpDiv.firstChild;
	      tmpDiv = null;
	      _unwrap(flashBridge).ZeroClipboard = ZeroClipboard;
	      container.replaceChild(flashBridge, divToBeReplaced);
	      _watchForSwfFallbackContent();
	    }
	    if (!flashBridge) {
	      flashBridge = _document[_globalConfig.swfObjectId];
	      if (flashBridge && (len = flashBridge.length)) {
	        flashBridge = flashBridge[len - 1];
	      }
	      if (!flashBridge && container) {
	        flashBridge = container.firstChild;
	      }
	    }
	    _flashState.bridge = flashBridge || null;
	    return flashBridge;
	  };
	  /**
	 * Destroy the SWF object.
	 * @private
	 */
	  var _unembedSwf = function() {
	    var flashBridge = _flashState.bridge;
	    if (flashBridge) {
	      var htmlBridge = _getHtmlBridge(flashBridge);
	      if (htmlBridge) {
	        if (_flashState.pluginType === "activex" && "readyState" in flashBridge) {
	          flashBridge.style.display = "none";
	          (function removeSwfFromIE() {
	            if (flashBridge.readyState === 4) {
	              for (var prop in flashBridge) {
	                if (typeof flashBridge[prop] === "function") {
	                  flashBridge[prop] = null;
	                }
	              }
	              if (flashBridge.parentNode) {
	                flashBridge.parentNode.removeChild(flashBridge);
	              }
	              if (htmlBridge.parentNode) {
	                htmlBridge.parentNode.removeChild(htmlBridge);
	              }
	            } else {
	              _setTimeout(removeSwfFromIE, 10);
	            }
	          })();
	        } else {
	          if (flashBridge.parentNode) {
	            flashBridge.parentNode.removeChild(flashBridge);
	          }
	          if (htmlBridge.parentNode) {
	            htmlBridge.parentNode.removeChild(htmlBridge);
	          }
	        }
	      }
	      _clearTimeoutsAndPolling();
	      _flashState.ready = null;
	      _flashState.bridge = null;
	      _flashState.deactivated = null;
	      _zcSwfVersion = undefined;
	    }
	  };
	  /**
	 * Map the data format names of the "clipData" to Flash-friendly names.
	 *
	 * @returns A new transformed object.
	 * @private
	 */
	  var _mapClipDataToFlash = function(clipData) {
	    var newClipData = {}, formatMap = {};
	    if (!(typeof clipData === "object" && clipData)) {
	      return;
	    }
	    for (var dataFormat in clipData) {
	      if (dataFormat && _hasOwn.call(clipData, dataFormat) && typeof clipData[dataFormat] === "string" && clipData[dataFormat]) {
	        switch (dataFormat.toLowerCase()) {
	         case "text/plain":
	         case "text":
	         case "air:text":
	         case "flash:text":
	          newClipData.text = clipData[dataFormat];
	          formatMap.text = dataFormat;
	          break;

	         case "text/html":
	         case "html":
	         case "air:html":
	         case "flash:html":
	          newClipData.html = clipData[dataFormat];
	          formatMap.html = dataFormat;
	          break;

	         case "application/rtf":
	         case "text/rtf":
	         case "rtf":
	         case "richtext":
	         case "air:rtf":
	         case "flash:rtf":
	          newClipData.rtf = clipData[dataFormat];
	          formatMap.rtf = dataFormat;
	          break;

	         default:
	          break;
	        }
	      }
	    }
	    return {
	      data: newClipData,
	      formatMap: formatMap
	    };
	  };
	  /**
	 * Map the data format names from Flash-friendly names back to their original "clipData" names (via a format mapping).
	 *
	 * @returns A new transformed object.
	 * @private
	 */
	  var _mapClipResultsFromFlash = function(clipResults, formatMap) {
	    if (!(typeof clipResults === "object" && clipResults && typeof formatMap === "object" && formatMap)) {
	      return clipResults;
	    }
	    var newResults = {};
	    for (var prop in clipResults) {
	      if (_hasOwn.call(clipResults, prop)) {
	        if (prop === "errors") {
	          newResults[prop] = clipResults[prop] ? clipResults[prop].slice() : [];
	          for (var i = 0, len = newResults[prop].length; i < len; i++) {
	            newResults[prop][i].format = formatMap[newResults[prop][i].format];
	          }
	        } else if (prop !== "success" && prop !== "data") {
	          newResults[prop] = clipResults[prop];
	        } else {
	          newResults[prop] = {};
	          var tmpHash = clipResults[prop];
	          for (var dataFormat in tmpHash) {
	            if (dataFormat && _hasOwn.call(tmpHash, dataFormat) && _hasOwn.call(formatMap, dataFormat)) {
	              newResults[prop][formatMap[dataFormat]] = tmpHash[dataFormat];
	            }
	          }
	        }
	      }
	    }
	    return newResults;
	  };
	  /**
	 * Will look at a path, and will create a "?noCache={time}" or "&noCache={time}"
	 * query param string to return. Does NOT append that string to the original path.
	 * This is useful because ExternalInterface often breaks when a Flash SWF is cached.
	 *
	 * @returns The `noCache` query param with necessary "?"/"&" prefix.
	 * @private
	 */
	  var _cacheBust = function(path, options) {
	    var cacheBust = options == null || options && options.cacheBust === true;
	    if (cacheBust) {
	      return (path.indexOf("?") === -1 ? "?" : "&") + "noCache=" + _now();
	    } else {
	      return "";
	    }
	  };
	  /**
	 * Creates a query string for the FlashVars param.
	 * Does NOT include the cache-busting query param.
	 *
	 * @returns FlashVars query string
	 * @private
	 */
	  var _vars = function(options) {
	    var i, len, domain, domains, str = "", trustedOriginsExpanded = [];
	    if (options.trustedDomains) {
	      if (typeof options.trustedDomains === "string") {
	        domains = [ options.trustedDomains ];
	      } else if (typeof options.trustedDomains === "object" && "length" in options.trustedDomains) {
	        domains = options.trustedDomains;
	      }
	    }
	    if (domains && domains.length) {
	      for (i = 0, len = domains.length; i < len; i++) {
	        if (_hasOwn.call(domains, i) && domains[i] && typeof domains[i] === "string") {
	          domain = _extractDomain(domains[i]);
	          if (!domain) {
	            continue;
	          }
	          if (domain === "*") {
	            trustedOriginsExpanded.length = 0;
	            trustedOriginsExpanded.push(domain);
	            break;
	          }
	          trustedOriginsExpanded.push.apply(trustedOriginsExpanded, [ domain, "//" + domain, _window.location.protocol + "//" + domain ]);
	        }
	      }
	    }
	    if (trustedOriginsExpanded.length) {
	      str += "trustedOrigins=" + _encodeURIComponent(trustedOriginsExpanded.join(","));
	    }
	    if (options.forceEnhancedClipboard === true) {
	      str += (str ? "&" : "") + "forceEnhancedClipboard=true";
	    }
	    if (typeof options.swfObjectId === "string" && options.swfObjectId) {
	      str += (str ? "&" : "") + "swfObjectId=" + _encodeURIComponent(options.swfObjectId);
	    }
	    if (typeof options.jsVersion === "string" && options.jsVersion) {
	      str += (str ? "&" : "") + "jsVersion=" + _encodeURIComponent(options.jsVersion);
	    }
	    return str;
	  };
	  /**
	 * Extract the domain (e.g. "github.com") from an origin (e.g. "https://github.com") or
	 * URL (e.g. "https://github.com/zeroclipboard/zeroclipboard/").
	 *
	 * @returns the domain
	 * @private
	 */
	  var _extractDomain = function(originOrUrl) {
	    if (originOrUrl == null || originOrUrl === "") {
	      return null;
	    }
	    originOrUrl = originOrUrl.replace(/^\s+|\s+$/g, "");
	    if (originOrUrl === "") {
	      return null;
	    }
	    var protocolIndex = originOrUrl.indexOf("//");
	    originOrUrl = protocolIndex === -1 ? originOrUrl : originOrUrl.slice(protocolIndex + 2);
	    var pathIndex = originOrUrl.indexOf("/");
	    originOrUrl = pathIndex === -1 ? originOrUrl : protocolIndex === -1 || pathIndex === 0 ? null : originOrUrl.slice(0, pathIndex);
	    if (originOrUrl && originOrUrl.slice(-4).toLowerCase() === ".swf") {
	      return null;
	    }
	    return originOrUrl || null;
	  };
	  /**
	 * Set `allowScriptAccess` based on `trustedDomains` and `window.location.host` vs. `swfPath`.
	 *
	 * @returns The appropriate script access level.
	 * @private
	 */
	  var _determineScriptAccess = function() {
	    var _extractAllDomains = function(origins) {
	      var i, len, tmp, resultsArray = [];
	      if (typeof origins === "string") {
	        origins = [ origins ];
	      }
	      if (!(typeof origins === "object" && origins && typeof origins.length === "number")) {
	        return resultsArray;
	      }
	      for (i = 0, len = origins.length; i < len; i++) {
	        if (_hasOwn.call(origins, i) && (tmp = _extractDomain(origins[i]))) {
	          if (tmp === "*") {
	            resultsArray.length = 0;
	            resultsArray.push("*");
	            break;
	          }
	          if (resultsArray.indexOf(tmp) === -1) {
	            resultsArray.push(tmp);
	          }
	        }
	      }
	      return resultsArray;
	    };
	    return function(currentDomain, configOptions) {
	      var swfDomain = _extractDomain(configOptions.swfPath);
	      if (swfDomain === null) {
	        swfDomain = currentDomain;
	      }
	      var trustedDomains = _extractAllDomains(configOptions.trustedDomains);
	      var len = trustedDomains.length;
	      if (len > 0) {
	        if (len === 1 && trustedDomains[0] === "*") {
	          return "always";
	        }
	        if (trustedDomains.indexOf(currentDomain) !== -1) {
	          if (len === 1 && currentDomain === swfDomain) {
	            return "sameDomain";
	          }
	          return "always";
	        }
	      }
	      return "never";
	    };
	  }();
	  /**
	 * Get the currently active/focused DOM element.
	 *
	 * @returns the currently active/focused element, or `null`
	 * @private
	 */
	  var _safeActiveElement = function() {
	    try {
	      return _document.activeElement;
	    } catch (err) {
	      return null;
	    }
	  };
	  /**
	 * Add a class to an element, if it doesn't already have it.
	 *
	 * @returns The element, with its new class added.
	 * @private
	 */
	  var _addClass = function(element, value) {
	    var c, cl, className, classNames = [];
	    if (typeof value === "string" && value) {
	      classNames = value.split(/\s+/);
	    }
	    if (element && element.nodeType === 1 && classNames.length > 0) {
	      if (element.classList) {
	        for (c = 0, cl = classNames.length; c < cl; c++) {
	          element.classList.add(classNames[c]);
	        }
	      } else if (element.hasOwnProperty("className")) {
	        className = " " + element.className + " ";
	        for (c = 0, cl = classNames.length; c < cl; c++) {
	          if (className.indexOf(" " + classNames[c] + " ") === -1) {
	            className += classNames[c] + " ";
	          }
	        }
	        element.className = className.replace(/^\s+|\s+$/g, "");
	      }
	    }
	    return element;
	  };
	  /**
	 * Remove a class from an element, if it has it.
	 *
	 * @returns The element, with its class removed.
	 * @private
	 */
	  var _removeClass = function(element, value) {
	    var c, cl, className, classNames = [];
	    if (typeof value === "string" && value) {
	      classNames = value.split(/\s+/);
	    }
	    if (element && element.nodeType === 1 && classNames.length > 0) {
	      if (element.classList && element.classList.length > 0) {
	        for (c = 0, cl = classNames.length; c < cl; c++) {
	          element.classList.remove(classNames[c]);
	        }
	      } else if (element.className) {
	        className = (" " + element.className + " ").replace(/[\r\n\t]/g, " ");
	        for (c = 0, cl = classNames.length; c < cl; c++) {
	          className = className.replace(" " + classNames[c] + " ", " ");
	        }
	        element.className = className.replace(/^\s+|\s+$/g, "");
	      }
	    }
	    return element;
	  };
	  /**
	 * Attempt to interpret the element's CSS styling. If `prop` is `"cursor"`,
	 * then we assume that it should be a hand ("pointer") cursor if the element
	 * is an anchor element ("a" tag).
	 *
	 * @returns The computed style property.
	 * @private
	 */
	  var _getStyle = function(el, prop) {
	    var value = _getComputedStyle(el, null).getPropertyValue(prop);
	    if (prop === "cursor") {
	      if (!value || value === "auto") {
	        if (el.nodeName === "A") {
	          return "pointer";
	        }
	      }
	    }
	    return value;
	  };
	  /**
	 * Get the absolutely positioned coordinates of a DOM element.
	 *
	 * @returns Object containing the element's position, width, and height.
	 * @private
	 */
	  var _getElementPosition = function(el) {
	    var pos = {
	      left: 0,
	      top: 0,
	      width: 0,
	      height: 0
	    };
	    if (el.getBoundingClientRect) {
	      var elRect = el.getBoundingClientRect();
	      var pageXOffset = _window.pageXOffset;
	      var pageYOffset = _window.pageYOffset;
	      var leftBorderWidth = _document.documentElement.clientLeft || 0;
	      var topBorderWidth = _document.documentElement.clientTop || 0;
	      var leftBodyOffset = 0;
	      var topBodyOffset = 0;
	      if (_getStyle(_document.body, "position") === "relative") {
	        var bodyRect = _document.body.getBoundingClientRect();
	        var htmlRect = _document.documentElement.getBoundingClientRect();
	        leftBodyOffset = bodyRect.left - htmlRect.left || 0;
	        topBodyOffset = bodyRect.top - htmlRect.top || 0;
	      }
	      pos.left = elRect.left + pageXOffset - leftBorderWidth - leftBodyOffset;
	      pos.top = elRect.top + pageYOffset - topBorderWidth - topBodyOffset;
	      pos.width = "width" in elRect ? elRect.width : elRect.right - elRect.left;
	      pos.height = "height" in elRect ? elRect.height : elRect.bottom - elRect.top;
	    }
	    return pos;
	  };
	  /**
	 * Determine is an element is visible somewhere within the document (page).
	 *
	 * @returns Boolean
	 * @private
	 */
	  var _isElementVisible = function(el) {
	    if (!el) {
	      return false;
	    }
	    var styles = _getComputedStyle(el, null);
	    var hasCssHeight = _parseFloat(styles.height) > 0;
	    var hasCssWidth = _parseFloat(styles.width) > 0;
	    var hasCssTop = _parseFloat(styles.top) >= 0;
	    var hasCssLeft = _parseFloat(styles.left) >= 0;
	    var cssKnows = hasCssHeight && hasCssWidth && hasCssTop && hasCssLeft;
	    var rect = cssKnows ? null : _getElementPosition(el);
	    var isVisible = styles.display !== "none" && styles.visibility !== "collapse" && (cssKnows || !!rect && (hasCssHeight || rect.height > 0) && (hasCssWidth || rect.width > 0) && (hasCssTop || rect.top >= 0) && (hasCssLeft || rect.left >= 0));
	    return isVisible;
	  };
	  /**
	 * Clear all existing timeouts and interval polling delegates.
	 *
	 * @returns `undefined`
	 * @private
	 */
	  var _clearTimeoutsAndPolling = function() {
	    _clearTimeout(_flashCheckTimeout);
	    _flashCheckTimeout = 0;
	    _clearInterval(_swfFallbackCheckInterval);
	    _swfFallbackCheckInterval = 0;
	  };
	  /**
	 * Reposition the Flash object to cover the currently activated element.
	 *
	 * @returns `undefined`
	 * @private
	 */
	  var _reposition = function() {
	    var htmlBridge;
	    if (_currentElement && (htmlBridge = _getHtmlBridge(_flashState.bridge))) {
	      var pos = _getElementPosition(_currentElement);
	      _extend(htmlBridge.style, {
	        width: pos.width + "px",
	        height: pos.height + "px",
	        top: pos.top + "px",
	        left: pos.left + "px",
	        zIndex: "" + _getSafeZIndex(_globalConfig.zIndex)
	      });
	    }
	  };
	  /**
	 * Sends a signal to the Flash object to display the hand cursor if `true`.
	 *
	 * @returns `undefined`
	 * @private
	 */
	  var _setHandCursor = function(enabled) {
	    if (_flashState.ready === true) {
	      if (_flashState.bridge && typeof _flashState.bridge.setHandCursor === "function") {
	        _flashState.bridge.setHandCursor(enabled);
	      } else {
	        _flashState.ready = false;
	      }
	    }
	  };
	  /**
	 * Get a safe value for `zIndex`
	 *
	 * @returns an integer, or "auto"
	 * @private
	 */
	  var _getSafeZIndex = function(val) {
	    if (/^(?:auto|inherit)$/.test(val)) {
	      return val;
	    }
	    var zIndex;
	    if (typeof val === "number" && !_isNaN(val)) {
	      zIndex = val;
	    } else if (typeof val === "string") {
	      zIndex = _getSafeZIndex(_parseInt(val, 10));
	    }
	    return typeof zIndex === "number" ? zIndex : "auto";
	  };
	  /**
	 * Attempt to detect if ZeroClipboard is executing inside of a sandboxed iframe.
	 * If it is, Flash Player cannot be used, so ZeroClipboard is dead in the water.
	 *
	 * @see {@link http://lists.w3.org/Archives/Public/public-whatwg-archive/2014Dec/0002.html}
	 * @see {@link https://github.com/zeroclipboard/zeroclipboard/issues/511}
	 * @see {@link http://zeroclipboard.org/test-iframes.html}
	 *
	 * @returns `true` (is sandboxed), `false` (is not sandboxed), or `null` (uncertain) 
	 * @private
	 */
	  var _detectSandbox = function(doNotReassessFlashSupport) {
	    var effectiveScriptOrigin, frame, frameError, previousState = _flashState.sandboxed, isSandboxed = null;
	    doNotReassessFlashSupport = doNotReassessFlashSupport === true;
	    if (_pageIsFramed === false) {
	      isSandboxed = false;
	    } else {
	      try {
	        frame = window.frameElement || null;
	      } catch (e) {
	        frameError = {
	          name: e.name,
	          message: e.message
	        };
	      }
	      if (frame && frame.nodeType === 1 && frame.nodeName === "IFRAME") {
	        try {
	          isSandboxed = frame.hasAttribute("sandbox");
	        } catch (e) {
	          isSandboxed = null;
	        }
	      } else {
	        try {
	          effectiveScriptOrigin = document.domain || null;
	        } catch (e) {
	          effectiveScriptOrigin = null;
	        }
	        if (effectiveScriptOrigin === null || frameError && frameError.name === "SecurityError" && /(^|[\s\(\[@])sandbox(es|ed|ing|[\s\.,!\)\]@]|$)/.test(frameError.message.toLowerCase())) {
	          isSandboxed = true;
	        }
	      }
	    }
	    _flashState.sandboxed = isSandboxed;
	    if (previousState !== isSandboxed && !doNotReassessFlashSupport) {
	      _detectFlashSupport(_ActiveXObject);
	    }
	    return isSandboxed;
	  };
	  /**
	 * Detect the Flash Player status, version, and plugin type.
	 *
	 * @see {@link https://code.google.com/p/doctype-mirror/wiki/ArticleDetectFlash#The_code}
	 * @see {@link http://stackoverflow.com/questions/12866060/detecting-pepper-ppapi-flash-with-javascript}
	 *
	 * @returns `undefined`
	 * @private
	 */
	  var _detectFlashSupport = function(ActiveXObject) {
	    var plugin, ax, mimeType, hasFlash = false, isActiveX = false, isPPAPI = false, flashVersion = "";
	    /**
	   * Derived from Apple's suggested sniffer.
	   * @param {String} desc e.g. "Shockwave Flash 7.0 r61"
	   * @returns {String} "7.0.61"
	   * @private
	   */
	    function parseFlashVersion(desc) {
	      var matches = desc.match(/[\d]+/g);
	      matches.length = 3;
	      return matches.join(".");
	    }
	    function isPepperFlash(flashPlayerFileName) {
	      return !!flashPlayerFileName && (flashPlayerFileName = flashPlayerFileName.toLowerCase()) && (/^(pepflashplayer\.dll|libpepflashplayer\.so|pepperflashplayer\.plugin)$/.test(flashPlayerFileName) || flashPlayerFileName.slice(-13) === "chrome.plugin");
	    }
	    function inspectPlugin(plugin) {
	      if (plugin) {
	        hasFlash = true;
	        if (plugin.version) {
	          flashVersion = parseFlashVersion(plugin.version);
	        }
	        if (!flashVersion && plugin.description) {
	          flashVersion = parseFlashVersion(plugin.description);
	        }
	        if (plugin.filename) {
	          isPPAPI = isPepperFlash(plugin.filename);
	        }
	      }
	    }
	    if (_navigator.plugins && _navigator.plugins.length) {
	      plugin = _navigator.plugins["Shockwave Flash"];
	      inspectPlugin(plugin);
	      if (_navigator.plugins["Shockwave Flash 2.0"]) {
	        hasFlash = true;
	        flashVersion = "2.0.0.11";
	      }
	    } else if (_navigator.mimeTypes && _navigator.mimeTypes.length) {
	      mimeType = _navigator.mimeTypes["application/x-shockwave-flash"];
	      plugin = mimeType && mimeType.enabledPlugin;
	      inspectPlugin(plugin);
	    } else if (typeof ActiveXObject !== "undefined") {
	      isActiveX = true;
	      try {
	        ax = new ActiveXObject("ShockwaveFlash.ShockwaveFlash.7");
	        hasFlash = true;
	        flashVersion = parseFlashVersion(ax.GetVariable("$version"));
	      } catch (e1) {
	        try {
	          ax = new ActiveXObject("ShockwaveFlash.ShockwaveFlash.6");
	          hasFlash = true;
	          flashVersion = "6.0.21";
	        } catch (e2) {
	          try {
	            ax = new ActiveXObject("ShockwaveFlash.ShockwaveFlash");
	            hasFlash = true;
	            flashVersion = parseFlashVersion(ax.GetVariable("$version"));
	          } catch (e3) {
	            isActiveX = false;
	          }
	        }
	      }
	    }
	    _flashState.disabled = hasFlash !== true;
	    _flashState.outdated = flashVersion && _parseFloat(flashVersion) < _parseFloat(_minimumFlashVersion);
	    _flashState.version = flashVersion || "0.0.0";
	    _flashState.pluginType = isPPAPI ? "pepper" : isActiveX ? "activex" : hasFlash ? "netscape" : "unknown";
	  };
	  /**
	 * Invoke the Flash detection algorithms immediately upon inclusion so we're not waiting later.
	 */
	  _detectFlashSupport(_ActiveXObject);
	  /**
	 * Always assess the `sandboxed` state of the page at important Flash-related moments.
	 */
	  _detectSandbox(true);
	  /**
	 * A shell constructor for `ZeroClipboard` client instances.
	 *
	 * @constructor
	 */
	  var ZeroClipboard = function() {
	    if (!(this instanceof ZeroClipboard)) {
	      return new ZeroClipboard();
	    }
	    if (typeof ZeroClipboard._createClient === "function") {
	      ZeroClipboard._createClient.apply(this, _args(arguments));
	    }
	  };
	  /**
	 * The ZeroClipboard library's version number.
	 *
	 * @static
	 * @readonly
	 * @property {string}
	 */
	  _defineProperty(ZeroClipboard, "version", {
	    value: "2.2.0",
	    writable: false,
	    configurable: true,
	    enumerable: true
	  });
	  /**
	 * Update or get a copy of the ZeroClipboard global configuration.
	 * Returns a copy of the current/updated configuration.
	 *
	 * @returns Object
	 * @static
	 */
	  ZeroClipboard.config = function() {
	    return _config.apply(this, _args(arguments));
	  };
	  /**
	 * Diagnostic method that describes the state of the browser, Flash Player, and ZeroClipboard.
	 *
	 * @returns Object
	 * @static
	 */
	  ZeroClipboard.state = function() {
	    return _state.apply(this, _args(arguments));
	  };
	  /**
	 * Check if Flash is unusable for any reason: disabled, outdated, deactivated, etc.
	 *
	 * @returns Boolean
	 * @static
	 */
	  ZeroClipboard.isFlashUnusable = function() {
	    return _isFlashUnusable.apply(this, _args(arguments));
	  };
	  /**
	 * Register an event listener.
	 *
	 * @returns `ZeroClipboard`
	 * @static
	 */
	  ZeroClipboard.on = function() {
	    return _on.apply(this, _args(arguments));
	  };
	  /**
	 * Unregister an event listener.
	 * If no `listener` function/object is provided, it will unregister all listeners for the provided `eventType`.
	 * If no `eventType` is provided, it will unregister all listeners for every event type.
	 *
	 * @returns `ZeroClipboard`
	 * @static
	 */
	  ZeroClipboard.off = function() {
	    return _off.apply(this, _args(arguments));
	  };
	  /**
	 * Retrieve event listeners for an `eventType`.
	 * If no `eventType` is provided, it will retrieve all listeners for every event type.
	 *
	 * @returns array of listeners for the `eventType`; if no `eventType`, then a map/hash object of listeners for all event types; or `null`
	 */
	  ZeroClipboard.handlers = function() {
	    return _listeners.apply(this, _args(arguments));
	  };
	  /**
	 * Event emission receiver from the Flash object, forwarding to any registered JavaScript event listeners.
	 *
	 * @returns For the "copy" event, returns the Flash-friendly "clipData" object; otherwise `undefined`.
	 * @static
	 */
	  ZeroClipboard.emit = function() {
	    return _emit.apply(this, _args(arguments));
	  };
	  /**
	 * Create and embed the Flash object.
	 *
	 * @returns The Flash object
	 * @static
	 */
	  ZeroClipboard.create = function() {
	    return _create.apply(this, _args(arguments));
	  };
	  /**
	 * Self-destruct and clean up everything, including the embedded Flash object.
	 *
	 * @returns `undefined`
	 * @static
	 */
	  ZeroClipboard.destroy = function() {
	    return _destroy.apply(this, _args(arguments));
	  };
	  /**
	 * Set the pending data for clipboard injection.
	 *
	 * @returns `undefined`
	 * @static
	 */
	  ZeroClipboard.setData = function() {
	    return _setData.apply(this, _args(arguments));
	  };
	  /**
	 * Clear the pending data for clipboard injection.
	 * If no `format` is provided, all pending data formats will be cleared.
	 *
	 * @returns `undefined`
	 * @static
	 */
	  ZeroClipboard.clearData = function() {
	    return _clearData.apply(this, _args(arguments));
	  };
	  /**
	 * Get a copy of the pending data for clipboard injection.
	 * If no `format` is provided, a copy of ALL pending data formats will be returned.
	 *
	 * @returns `String` or `Object`
	 * @static
	 */
	  ZeroClipboard.getData = function() {
	    return _getData.apply(this, _args(arguments));
	  };
	  /**
	 * Sets the current HTML object that the Flash object should overlay. This will put the global
	 * Flash object on top of the current element; depending on the setup, this may also set the
	 * pending clipboard text data as well as the Flash object's wrapping element's title attribute
	 * based on the underlying HTML element and ZeroClipboard configuration.
	 *
	 * @returns `undefined`
	 * @static
	 */
	  ZeroClipboard.focus = ZeroClipboard.activate = function() {
	    return _focus.apply(this, _args(arguments));
	  };
	  /**
	 * Un-overlays the Flash object. This will put the global Flash object off-screen; depending on
	 * the setup, this may also unset the Flash object's wrapping element's title attribute based on
	 * the underlying HTML element and ZeroClipboard configuration.
	 *
	 * @returns `undefined`
	 * @static
	 */
	  ZeroClipboard.blur = ZeroClipboard.deactivate = function() {
	    return _blur.apply(this, _args(arguments));
	  };
	  /**
	 * Returns the currently focused/"activated" HTML element that the Flash object is wrapping.
	 *
	 * @returns `HTMLElement` or `null`
	 * @static
	 */
	  ZeroClipboard.activeElement = function() {
	    return _activeElement.apply(this, _args(arguments));
	  };
	  /**
	 * Keep track of the ZeroClipboard client instance counter.
	 */
	  var _clientIdCounter = 0;
	  /**
	 * Keep track of the state of the client instances.
	 *
	 * Entry structure:
	 *   _clientMeta[client.id] = {
	 *     instance: client,
	 *     elements: [],
	 *     handlers: {}
	 *   };
	 */
	  var _clientMeta = {};
	  /**
	 * Keep track of the ZeroClipboard clipped elements counter.
	 */
	  var _elementIdCounter = 0;
	  /**
	 * Keep track of the state of the clipped element relationships to clients.
	 *
	 * Entry structure:
	 *   _elementMeta[element.zcClippingId] = [client1.id, client2.id];
	 */
	  var _elementMeta = {};
	  /**
	 * Keep track of the state of the mouse event handlers for clipped elements.
	 *
	 * Entry structure:
	 *   _mouseHandlers[element.zcClippingId] = {
	 *     mouseover:  function(event) {},
	 *     mouseout:   function(event) {},
	 *     mouseenter: function(event) {},
	 *     mouseleave: function(event) {},
	 *     mousemove:  function(event) {}
	 *   };
	 */
	  var _mouseHandlers = {};
	  /**
	 * Extending the ZeroClipboard configuration defaults for the Client module.
	 */
	  _extend(_globalConfig, {
	    autoActivate: true
	  });
	  /**
	 * The real constructor for `ZeroClipboard` client instances.
	 * @private
	 */
	  var _clientConstructor = function(elements) {
	    var client = this;
	    client.id = "" + _clientIdCounter++;
	    _clientMeta[client.id] = {
	      instance: client,
	      elements: [],
	      handlers: {}
	    };
	    if (elements) {
	      client.clip(elements);
	    }
	    ZeroClipboard.on("*", function(event) {
	      return client.emit(event);
	    });
	    ZeroClipboard.on("destroy", function() {
	      client.destroy();
	    });
	    ZeroClipboard.create();
	  };
	  /**
	 * The underlying implementation of `ZeroClipboard.Client.prototype.on`.
	 * @private
	 */
	  var _clientOn = function(eventType, listener) {
	    var i, len, events, added = {}, meta = _clientMeta[this.id], handlers = meta && meta.handlers;
	    if (!meta) {
	      throw new Error("Attempted to add new listener(s) to a destroyed ZeroClipboard client instance");
	    }
	    if (typeof eventType === "string" && eventType) {
	      events = eventType.toLowerCase().split(/\s+/);
	    } else if (typeof eventType === "object" && eventType && typeof listener === "undefined") {
	      for (i in eventType) {
	        if (_hasOwn.call(eventType, i) && typeof i === "string" && i && typeof eventType[i] === "function") {
	          this.on(i, eventType[i]);
	        }
	      }
	    }
	    if (events && events.length) {
	      for (i = 0, len = events.length; i < len; i++) {
	        eventType = events[i].replace(/^on/, "");
	        added[eventType] = true;
	        if (!handlers[eventType]) {
	          handlers[eventType] = [];
	        }
	        handlers[eventType].push(listener);
	      }
	      if (added.ready && _flashState.ready) {
	        this.emit({
	          type: "ready",
	          client: this
	        });
	      }
	      if (added.error) {
	        for (i = 0, len = _flashStateErrorNames.length; i < len; i++) {
	          if (_flashState[_flashStateErrorNames[i].replace(/^flash-/, "")]) {
	            this.emit({
	              type: "error",
	              name: _flashStateErrorNames[i],
	              client: this
	            });
	            break;
	          }
	        }
	        if (_zcSwfVersion !== undefined && ZeroClipboard.version !== _zcSwfVersion) {
	          this.emit({
	            type: "error",
	            name: "version-mismatch",
	            jsVersion: ZeroClipboard.version,
	            swfVersion: _zcSwfVersion
	          });
	        }
	      }
	    }
	    return this;
	  };
	  /**
	 * The underlying implementation of `ZeroClipboard.Client.prototype.off`.
	 * @private
	 */
	  var _clientOff = function(eventType, listener) {
	    var i, len, foundIndex, events, perEventHandlers, meta = _clientMeta[this.id], handlers = meta && meta.handlers;
	    if (!handlers) {
	      return this;
	    }
	    if (arguments.length === 0) {
	      events = _keys(handlers);
	    } else if (typeof eventType === "string" && eventType) {
	      events = eventType.split(/\s+/);
	    } else if (typeof eventType === "object" && eventType && typeof listener === "undefined") {
	      for (i in eventType) {
	        if (_hasOwn.call(eventType, i) && typeof i === "string" && i && typeof eventType[i] === "function") {
	          this.off(i, eventType[i]);
	        }
	      }
	    }
	    if (events && events.length) {
	      for (i = 0, len = events.length; i < len; i++) {
	        eventType = events[i].toLowerCase().replace(/^on/, "");
	        perEventHandlers = handlers[eventType];
	        if (perEventHandlers && perEventHandlers.length) {
	          if (listener) {
	            foundIndex = perEventHandlers.indexOf(listener);
	            while (foundIndex !== -1) {
	              perEventHandlers.splice(foundIndex, 1);
	              foundIndex = perEventHandlers.indexOf(listener, foundIndex);
	            }
	          } else {
	            perEventHandlers.length = 0;
	          }
	        }
	      }
	    }
	    return this;
	  };
	  /**
	 * The underlying implementation of `ZeroClipboard.Client.prototype.handlers`.
	 * @private
	 */
	  var _clientListeners = function(eventType) {
	    var copy = null, handlers = _clientMeta[this.id] && _clientMeta[this.id].handlers;
	    if (handlers) {
	      if (typeof eventType === "string" && eventType) {
	        copy = handlers[eventType] ? handlers[eventType].slice(0) : [];
	      } else {
	        copy = _deepCopy(handlers);
	      }
	    }
	    return copy;
	  };
	  /**
	 * The underlying implementation of `ZeroClipboard.Client.prototype.emit`.
	 * @private
	 */
	  var _clientEmit = function(event) {
	    if (_clientShouldEmit.call(this, event)) {
	      if (typeof event === "object" && event && typeof event.type === "string" && event.type) {
	        event = _extend({}, event);
	      }
	      var eventCopy = _extend({}, _createEvent(event), {
	        client: this
	      });
	      _clientDispatchCallbacks.call(this, eventCopy);
	    }
	    return this;
	  };
	  /**
	 * The underlying implementation of `ZeroClipboard.Client.prototype.clip`.
	 * @private
	 */
	  var _clientClip = function(elements) {
	    if (!_clientMeta[this.id]) {
	      throw new Error("Attempted to clip element(s) to a destroyed ZeroClipboard client instance");
	    }
	    elements = _prepClip(elements);
	    for (var i = 0; i < elements.length; i++) {
	      if (_hasOwn.call(elements, i) && elements[i] && elements[i].nodeType === 1) {
	        if (!elements[i].zcClippingId) {
	          elements[i].zcClippingId = "zcClippingId_" + _elementIdCounter++;
	          _elementMeta[elements[i].zcClippingId] = [ this.id ];
	          if (_globalConfig.autoActivate === true) {
	            _addMouseHandlers(elements[i]);
	          }
	        } else if (_elementMeta[elements[i].zcClippingId].indexOf(this.id) === -1) {
	          _elementMeta[elements[i].zcClippingId].push(this.id);
	        }
	        var clippedElements = _clientMeta[this.id] && _clientMeta[this.id].elements;
	        if (clippedElements.indexOf(elements[i]) === -1) {
	          clippedElements.push(elements[i]);
	        }
	      }
	    }
	    return this;
	  };
	  /**
	 * The underlying implementation of `ZeroClipboard.Client.prototype.unclip`.
	 * @private
	 */
	  var _clientUnclip = function(elements) {
	    var meta = _clientMeta[this.id];
	    if (!meta) {
	      return this;
	    }
	    var clippedElements = meta.elements;
	    var arrayIndex;
	    if (typeof elements === "undefined") {
	      elements = clippedElements.slice(0);
	    } else {
	      elements = _prepClip(elements);
	    }
	    for (var i = elements.length; i--; ) {
	      if (_hasOwn.call(elements, i) && elements[i] && elements[i].nodeType === 1) {
	        arrayIndex = 0;
	        while ((arrayIndex = clippedElements.indexOf(elements[i], arrayIndex)) !== -1) {
	          clippedElements.splice(arrayIndex, 1);
	        }
	        var clientIds = _elementMeta[elements[i].zcClippingId];
	        if (clientIds) {
	          arrayIndex = 0;
	          while ((arrayIndex = clientIds.indexOf(this.id, arrayIndex)) !== -1) {
	            clientIds.splice(arrayIndex, 1);
	          }
	          if (clientIds.length === 0) {
	            if (_globalConfig.autoActivate === true) {
	              _removeMouseHandlers(elements[i]);
	            }
	            delete elements[i].zcClippingId;
	          }
	        }
	      }
	    }
	    return this;
	  };
	  /**
	 * The underlying implementation of `ZeroClipboard.Client.prototype.elements`.
	 * @private
	 */
	  var _clientElements = function() {
	    var meta = _clientMeta[this.id];
	    return meta && meta.elements ? meta.elements.slice(0) : [];
	  };
	  /**
	 * The underlying implementation of `ZeroClipboard.Client.prototype.destroy`.
	 * @private
	 */
	  var _clientDestroy = function() {
	    if (!_clientMeta[this.id]) {
	      return;
	    }
	    this.unclip();
	    this.off();
	    delete _clientMeta[this.id];
	  };
	  /**
	 * Inspect an Event to see if the Client (`this`) should honor it for emission.
	 * @private
	 */
	  var _clientShouldEmit = function(event) {
	    if (!(event && event.type)) {
	      return false;
	    }
	    if (event.client && event.client !== this) {
	      return false;
	    }
	    var meta = _clientMeta[this.id];
	    var clippedEls = meta && meta.elements;
	    var hasClippedEls = !!clippedEls && clippedEls.length > 0;
	    var goodTarget = !event.target || hasClippedEls && clippedEls.indexOf(event.target) !== -1;
	    var goodRelTarget = event.relatedTarget && hasClippedEls && clippedEls.indexOf(event.relatedTarget) !== -1;
	    var goodClient = event.client && event.client === this;
	    if (!meta || !(goodTarget || goodRelTarget || goodClient)) {
	      return false;
	    }
	    return true;
	  };
	  /**
	 * Handle the actual dispatching of events to a client instance.
	 *
	 * @returns `undefined`
	 * @private
	 */
	  var _clientDispatchCallbacks = function(event) {
	    var meta = _clientMeta[this.id];
	    if (!(typeof event === "object" && event && event.type && meta)) {
	      return;
	    }
	    var async = _shouldPerformAsync(event);
	    var wildcardTypeHandlers = meta && meta.handlers["*"] || [];
	    var specificTypeHandlers = meta && meta.handlers[event.type] || [];
	    var handlers = wildcardTypeHandlers.concat(specificTypeHandlers);
	    if (handlers && handlers.length) {
	      var i, len, func, context, eventCopy, originalContext = this;
	      for (i = 0, len = handlers.length; i < len; i++) {
	        func = handlers[i];
	        context = originalContext;
	        if (typeof func === "string" && typeof _window[func] === "function") {
	          func = _window[func];
	        }
	        if (typeof func === "object" && func && typeof func.handleEvent === "function") {
	          context = func;
	          func = func.handleEvent;
	        }
	        if (typeof func === "function") {
	          eventCopy = _extend({}, event);
	          _dispatchCallback(func, context, [ eventCopy ], async);
	        }
	      }
	    }
	  };
	  /**
	 * Prepares the elements for clipping/unclipping.
	 *
	 * @returns An Array of elements.
	 * @private
	 */
	  var _prepClip = function(elements) {
	    if (typeof elements === "string") {
	      elements = [];
	    }
	    return typeof elements.length !== "number" ? [ elements ] : elements;
	  };
	  /**
	 * Add a `mouseover` handler function for a clipped element.
	 *
	 * @returns `undefined`
	 * @private
	 */
	  var _addMouseHandlers = function(element) {
	    if (!(element && element.nodeType === 1)) {
	      return;
	    }
	    var _suppressMouseEvents = function(event) {
	      if (!(event || (event = _window.event))) {
	        return;
	      }
	      if (event._source !== "js") {
	        event.stopImmediatePropagation();
	        event.preventDefault();
	      }
	      delete event._source;
	    };
	    var _elementMouseOver = function(event) {
	      if (!(event || (event = _window.event))) {
	        return;
	      }
	      _suppressMouseEvents(event);
	      ZeroClipboard.focus(element);
	    };
	    element.addEventListener("mouseover", _elementMouseOver, false);
	    element.addEventListener("mouseout", _suppressMouseEvents, false);
	    element.addEventListener("mouseenter", _suppressMouseEvents, false);
	    element.addEventListener("mouseleave", _suppressMouseEvents, false);
	    element.addEventListener("mousemove", _suppressMouseEvents, false);
	    _mouseHandlers[element.zcClippingId] = {
	      mouseover: _elementMouseOver,
	      mouseout: _suppressMouseEvents,
	      mouseenter: _suppressMouseEvents,
	      mouseleave: _suppressMouseEvents,
	      mousemove: _suppressMouseEvents
	    };
	  };
	  /**
	 * Remove a `mouseover` handler function for a clipped element.
	 *
	 * @returns `undefined`
	 * @private
	 */
	  var _removeMouseHandlers = function(element) {
	    if (!(element && element.nodeType === 1)) {
	      return;
	    }
	    var mouseHandlers = _mouseHandlers[element.zcClippingId];
	    if (!(typeof mouseHandlers === "object" && mouseHandlers)) {
	      return;
	    }
	    var key, val, mouseEvents = [ "move", "leave", "enter", "out", "over" ];
	    for (var i = 0, len = mouseEvents.length; i < len; i++) {
	      key = "mouse" + mouseEvents[i];
	      val = mouseHandlers[key];
	      if (typeof val === "function") {
	        element.removeEventListener(key, val, false);
	      }
	    }
	    delete _mouseHandlers[element.zcClippingId];
	  };
	  /**
	 * Creates a new ZeroClipboard client instance.
	 * Optionally, auto-`clip` an element or collection of elements.
	 *
	 * @constructor
	 */
	  ZeroClipboard._createClient = function() {
	    _clientConstructor.apply(this, _args(arguments));
	  };
	  /**
	 * Register an event listener to the client.
	 *
	 * @returns `this`
	 */
	  ZeroClipboard.prototype.on = function() {
	    return _clientOn.apply(this, _args(arguments));
	  };
	  /**
	 * Unregister an event handler from the client.
	 * If no `listener` function/object is provided, it will unregister all handlers for the provided `eventType`.
	 * If no `eventType` is provided, it will unregister all handlers for every event type.
	 *
	 * @returns `this`
	 */
	  ZeroClipboard.prototype.off = function() {
	    return _clientOff.apply(this, _args(arguments));
	  };
	  /**
	 * Retrieve event listeners for an `eventType` from the client.
	 * If no `eventType` is provided, it will retrieve all listeners for every event type.
	 *
	 * @returns array of listeners for the `eventType`; if no `eventType`, then a map/hash object of listeners for all event types; or `null`
	 */
	  ZeroClipboard.prototype.handlers = function() {
	    return _clientListeners.apply(this, _args(arguments));
	  };
	  /**
	 * Event emission receiver from the Flash object for this client's registered JavaScript event listeners.
	 *
	 * @returns For the "copy" event, returns the Flash-friendly "clipData" object; otherwise `undefined`.
	 */
	  ZeroClipboard.prototype.emit = function() {
	    return _clientEmit.apply(this, _args(arguments));
	  };
	  /**
	 * Register clipboard actions for new element(s) to the client.
	 *
	 * @returns `this`
	 */
	  ZeroClipboard.prototype.clip = function() {
	    return _clientClip.apply(this, _args(arguments));
	  };
	  /**
	 * Unregister the clipboard actions of previously registered element(s) on the page.
	 * If no elements are provided, ALL registered elements will be unregistered.
	 *
	 * @returns `this`
	 */
	  ZeroClipboard.prototype.unclip = function() {
	    return _clientUnclip.apply(this, _args(arguments));
	  };
	  /**
	 * Get all of the elements to which this client is clipped.
	 *
	 * @returns array of clipped elements
	 */
	  ZeroClipboard.prototype.elements = function() {
	    return _clientElements.apply(this, _args(arguments));
	  };
	  /**
	 * Self-destruct and clean up everything for a single client.
	 * This will NOT destroy the embedded Flash object.
	 *
	 * @returns `undefined`
	 */
	  ZeroClipboard.prototype.destroy = function() {
	    return _clientDestroy.apply(this, _args(arguments));
	  };
	  /**
	 * Stores the pending plain text to inject into the clipboard.
	 *
	 * @returns `this`
	 */
	  ZeroClipboard.prototype.setText = function(text) {
	    if (!_clientMeta[this.id]) {
	      throw new Error("Attempted to set pending clipboard data from a destroyed ZeroClipboard client instance");
	    }
	    ZeroClipboard.setData("text/plain", text);
	    return this;
	  };
	  /**
	 * Stores the pending HTML text to inject into the clipboard.
	 *
	 * @returns `this`
	 */
	  ZeroClipboard.prototype.setHtml = function(html) {
	    if (!_clientMeta[this.id]) {
	      throw new Error("Attempted to set pending clipboard data from a destroyed ZeroClipboard client instance");
	    }
	    ZeroClipboard.setData("text/html", html);
	    return this;
	  };
	  /**
	 * Stores the pending rich text (RTF) to inject into the clipboard.
	 *
	 * @returns `this`
	 */
	  ZeroClipboard.prototype.setRichText = function(richText) {
	    if (!_clientMeta[this.id]) {
	      throw new Error("Attempted to set pending clipboard data from a destroyed ZeroClipboard client instance");
	    }
	    ZeroClipboard.setData("application/rtf", richText);
	    return this;
	  };
	  /**
	 * Stores the pending data to inject into the clipboard.
	 *
	 * @returns `this`
	 */
	  ZeroClipboard.prototype.setData = function() {
	    if (!_clientMeta[this.id]) {
	      throw new Error("Attempted to set pending clipboard data from a destroyed ZeroClipboard client instance");
	    }
	    ZeroClipboard.setData.apply(this, _args(arguments));
	    return this;
	  };
	  /**
	 * Clears the pending data to inject into the clipboard.
	 * If no `format` is provided, all pending data formats will be cleared.
	 *
	 * @returns `this`
	 */
	  ZeroClipboard.prototype.clearData = function() {
	    if (!_clientMeta[this.id]) {
	      throw new Error("Attempted to clear pending clipboard data from a destroyed ZeroClipboard client instance");
	    }
	    ZeroClipboard.clearData.apply(this, _args(arguments));
	    return this;
	  };
	  /**
	 * Gets a copy of the pending data to inject into the clipboard.
	 * If no `format` is provided, a copy of ALL pending data formats will be returned.
	 *
	 * @returns `String` or `Object`
	 */
	  ZeroClipboard.prototype.getData = function() {
	    if (!_clientMeta[this.id]) {
	      throw new Error("Attempted to get pending clipboard data from a destroyed ZeroClipboard client instance");
	    }
	    return ZeroClipboard.getData.apply(this, _args(arguments));
	  };
	  if (typeof define === "function" && define.amd) {
	    define(function() {
	      return ZeroClipboard;
	    });
	  } else if (typeof module === "object" && module && typeof module.exports === "object" && module.exports) {
	    module.exports = ZeroClipboard;
	  } else {
	    window.ZeroClipboard = ZeroClipboard;
	  }
	})(function() {
	  return this || window;
	}());
	},{}]},{},[23,59,61,60,62,83,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,84,85,86,87,100,101,102,90,91,92,93,94,95,31,35,32,33,40,34,36,37,38,39])("zeroclipboard")
	});
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(15), (function() { return this; }())))

/***/ },
/* 15 */
/***/ function(module, exports) {

	// shim for using process in browser

	var process = module.exports = {};
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = setTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    clearTimeout(timeout);
	}

	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        setTimeout(drainQueue, 0);
	    }
	};

	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 16 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
	    _ = __webpack_require__(18);

	    var that = {};
	    var dataSet = [];
	    that.get = function(){
	        return _.cloneDeep(dataSet);
	    };

	    that.getSeries = function(){

	    };

	    that.set = function(newDataSet){
	        dataSet = _.cloneDeep(newDataSet);
	    };

	    module.exports = that;

	})();



/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/**
	 * @license
	 * lodash 3.10.1 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern -d -o ./index.js`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */
	;(function() {

	  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
	  var undefined;

	  /** Used as the semantic version number. */
	  var VERSION = '3.10.1';

	  /** Used to compose bitmasks for wrapper metadata. */
	  var BIND_FLAG = 1,
	      BIND_KEY_FLAG = 2,
	      CURRY_BOUND_FLAG = 4,
	      CURRY_FLAG = 8,
	      CURRY_RIGHT_FLAG = 16,
	      PARTIAL_FLAG = 32,
	      PARTIAL_RIGHT_FLAG = 64,
	      ARY_FLAG = 128,
	      REARG_FLAG = 256;

	  /** Used as default options for `_.trunc`. */
	  var DEFAULT_TRUNC_LENGTH = 30,
	      DEFAULT_TRUNC_OMISSION = '...';

	  /** Used to detect when a function becomes hot. */
	  var HOT_COUNT = 150,
	      HOT_SPAN = 16;

	  /** Used as the size to enable large array optimizations. */
	  var LARGE_ARRAY_SIZE = 200;

	  /** Used to indicate the type of lazy iteratees. */
	  var LAZY_FILTER_FLAG = 1,
	      LAZY_MAP_FLAG = 2;

	  /** Used as the `TypeError` message for "Functions" methods. */
	  var FUNC_ERROR_TEXT = 'Expected a function';

	  /** Used as the internal argument placeholder. */
	  var PLACEHOLDER = '__lodash_placeholder__';

	  /** `Object#toString` result references. */
	  var argsTag = '[object Arguments]',
	      arrayTag = '[object Array]',
	      boolTag = '[object Boolean]',
	      dateTag = '[object Date]',
	      errorTag = '[object Error]',
	      funcTag = '[object Function]',
	      mapTag = '[object Map]',
	      numberTag = '[object Number]',
	      objectTag = '[object Object]',
	      regexpTag = '[object RegExp]',
	      setTag = '[object Set]',
	      stringTag = '[object String]',
	      weakMapTag = '[object WeakMap]';

	  var arrayBufferTag = '[object ArrayBuffer]',
	      float32Tag = '[object Float32Array]',
	      float64Tag = '[object Float64Array]',
	      int8Tag = '[object Int8Array]',
	      int16Tag = '[object Int16Array]',
	      int32Tag = '[object Int32Array]',
	      uint8Tag = '[object Uint8Array]',
	      uint8ClampedTag = '[object Uint8ClampedArray]',
	      uint16Tag = '[object Uint16Array]',
	      uint32Tag = '[object Uint32Array]';

	  /** Used to match empty string literals in compiled template source. */
	  var reEmptyStringLeading = /\b__p \+= '';/g,
	      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
	      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

	  /** Used to match HTML entities and HTML characters. */
	  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g,
	      reUnescapedHtml = /[&<>"'`]/g,
	      reHasEscapedHtml = RegExp(reEscapedHtml.source),
	      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

	  /** Used to match template delimiters. */
	  var reEscape = /<%-([\s\S]+?)%>/g,
	      reEvaluate = /<%([\s\S]+?)%>/g,
	      reInterpolate = /<%=([\s\S]+?)%>/g;

	  /** Used to match property names within property paths. */
	  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\n\\]|\\.)*?\1)\]/,
	      reIsPlainProp = /^\w*$/,
	      rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\n\\]|\\.)*?)\2)\]/g;

	  /**
	   * Used to match `RegExp` [syntax characters](http://ecma-international.org/ecma-262/6.0/#sec-patterns)
	   * and those outlined by [`EscapeRegExpPattern`](http://ecma-international.org/ecma-262/6.0/#sec-escaperegexppattern).
	   */
	  var reRegExpChars = /^[:!,]|[\\^$.*+?()[\]{}|\/]|(^[0-9a-fA-Fnrtuvx])|([\n\r\u2028\u2029])/g,
	      reHasRegExpChars = RegExp(reRegExpChars.source);

	  /** Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks). */
	  var reComboMark = /[\u0300-\u036f\ufe20-\ufe23]/g;

	  /** Used to match backslashes in property paths. */
	  var reEscapeChar = /\\(\\)?/g;

	  /** Used to match [ES template delimiters](http://ecma-international.org/ecma-262/6.0/#sec-template-literal-lexical-components). */
	  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

	  /** Used to match `RegExp` flags from their coerced string values. */
	  var reFlags = /\w*$/;

	  /** Used to detect hexadecimal string values. */
	  var reHasHexPrefix = /^0[xX]/;

	  /** Used to detect host constructors (Safari > 5). */
	  var reIsHostCtor = /^\[object .+?Constructor\]$/;

	  /** Used to detect unsigned integer values. */
	  var reIsUint = /^\d+$/;

	  /** Used to match latin-1 supplementary letters (excluding mathematical operators). */
	  var reLatin1 = /[\xc0-\xd6\xd8-\xde\xdf-\xf6\xf8-\xff]/g;

	  /** Used to ensure capturing order of template delimiters. */
	  var reNoMatch = /($^)/;

	  /** Used to match unescaped characters in compiled string literals. */
	  var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

	  /** Used to match words to create compound words. */
	  var reWords = (function() {
	    var upper = '[A-Z\\xc0-\\xd6\\xd8-\\xde]',
	        lower = '[a-z\\xdf-\\xf6\\xf8-\\xff]+';

	    return RegExp(upper + '+(?=' + upper + lower + ')|' + upper + '?' + lower + '|' + upper + '+|[0-9]+', 'g');
	  }());

	  /** Used to assign default `context` object properties. */
	  var contextProps = [
	    'Array', 'ArrayBuffer', 'Date', 'Error', 'Float32Array', 'Float64Array',
	    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Math', 'Number',
	    'Object', 'RegExp', 'Set', 'String', '_', 'clearTimeout', 'isFinite',
	    'parseFloat', 'parseInt', 'setTimeout', 'TypeError', 'Uint8Array',
	    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap'
	  ];

	  /** Used to make template sourceURLs easier to identify. */
	  var templateCounter = -1;

	  /** Used to identify `toStringTag` values of typed arrays. */
	  var typedArrayTags = {};
	  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
	  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
	  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
	  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
	  typedArrayTags[uint32Tag] = true;
	  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
	  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
	  typedArrayTags[dateTag] = typedArrayTags[errorTag] =
	  typedArrayTags[funcTag] = typedArrayTags[mapTag] =
	  typedArrayTags[numberTag] = typedArrayTags[objectTag] =
	  typedArrayTags[regexpTag] = typedArrayTags[setTag] =
	  typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

	  /** Used to identify `toStringTag` values supported by `_.clone`. */
	  var cloneableTags = {};
	  cloneableTags[argsTag] = cloneableTags[arrayTag] =
	  cloneableTags[arrayBufferTag] = cloneableTags[boolTag] =
	  cloneableTags[dateTag] = cloneableTags[float32Tag] =
	  cloneableTags[float64Tag] = cloneableTags[int8Tag] =
	  cloneableTags[int16Tag] = cloneableTags[int32Tag] =
	  cloneableTags[numberTag] = cloneableTags[objectTag] =
	  cloneableTags[regexpTag] = cloneableTags[stringTag] =
	  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
	  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
	  cloneableTags[errorTag] = cloneableTags[funcTag] =
	  cloneableTags[mapTag] = cloneableTags[setTag] =
	  cloneableTags[weakMapTag] = false;

	  /** Used to map latin-1 supplementary letters to basic latin letters. */
	  var deburredLetters = {
	    '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
	    '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
	    '\xc7': 'C',  '\xe7': 'c',
	    '\xd0': 'D',  '\xf0': 'd',
	    '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
	    '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
	    '\xcC': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
	    '\xeC': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
	    '\xd1': 'N',  '\xf1': 'n',
	    '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
	    '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
	    '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
	    '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
	    '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
	    '\xc6': 'Ae', '\xe6': 'ae',
	    '\xde': 'Th', '\xfe': 'th',
	    '\xdf': 'ss'
	  };

	  /** Used to map characters to HTML entities. */
	  var htmlEscapes = {
	    '&': '&amp;',
	    '<': '&lt;',
	    '>': '&gt;',
	    '"': '&quot;',
	    "'": '&#39;',
	    '`': '&#96;'
	  };

	  /** Used to map HTML entities to characters. */
	  var htmlUnescapes = {
	    '&amp;': '&',
	    '&lt;': '<',
	    '&gt;': '>',
	    '&quot;': '"',
	    '&#39;': "'",
	    '&#96;': '`'
	  };

	  /** Used to determine if values are of the language type `Object`. */
	  var objectTypes = {
	    'function': true,
	    'object': true
	  };

	  /** Used to escape characters for inclusion in compiled regexes. */
	  var regexpEscapes = {
	    '0': 'x30', '1': 'x31', '2': 'x32', '3': 'x33', '4': 'x34',
	    '5': 'x35', '6': 'x36', '7': 'x37', '8': 'x38', '9': 'x39',
	    'A': 'x41', 'B': 'x42', 'C': 'x43', 'D': 'x44', 'E': 'x45', 'F': 'x46',
	    'a': 'x61', 'b': 'x62', 'c': 'x63', 'd': 'x64', 'e': 'x65', 'f': 'x66',
	    'n': 'x6e', 'r': 'x72', 't': 'x74', 'u': 'x75', 'v': 'x76', 'x': 'x78'
	  };

	  /** Used to escape characters for inclusion in compiled string literals. */
	  var stringEscapes = {
	    '\\': '\\',
	    "'": "'",
	    '\n': 'n',
	    '\r': 'r',
	    '\u2028': 'u2028',
	    '\u2029': 'u2029'
	  };

	  /** Detect free variable `exports`. */
	  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

	  /** Detect free variable `module`. */
	  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;

	  /** Detect free variable `global` from Node.js. */
	  var freeGlobal = freeExports && freeModule && typeof global == 'object' && global && global.Object && global;

	  /** Detect free variable `self`. */
	  var freeSelf = objectTypes[typeof self] && self && self.Object && self;

	  /** Detect free variable `window`. */
	  var freeWindow = objectTypes[typeof window] && window && window.Object && window;

	  /** Detect the popular CommonJS extension `module.exports`. */
	  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;

	  /**
	   * Used as a reference to the global object.
	   *
	   * The `this` value is used if it's the global object to avoid Greasemonkey's
	   * restricted `window` object, otherwise the `window` object is used.
	   */
	  var root = freeGlobal || ((freeWindow !== (this && this.window)) && freeWindow) || freeSelf || this;

	  /*--------------------------------------------------------------------------*/

	  /**
	   * The base implementation of `compareAscending` which compares values and
	   * sorts them in ascending order without guaranteeing a stable sort.
	   *
	   * @private
	   * @param {*} value The value to compare.
	   * @param {*} other The other value to compare.
	   * @returns {number} Returns the sort order indicator for `value`.
	   */
	  function baseCompareAscending(value, other) {
	    if (value !== other) {
	      var valIsNull = value === null,
	          valIsUndef = value === undefined,
	          valIsReflexive = value === value;

	      var othIsNull = other === null,
	          othIsUndef = other === undefined,
	          othIsReflexive = other === other;

	      if ((value > other && !othIsNull) || !valIsReflexive ||
	          (valIsNull && !othIsUndef && othIsReflexive) ||
	          (valIsUndef && othIsReflexive)) {
	        return 1;
	      }
	      if ((value < other && !valIsNull) || !othIsReflexive ||
	          (othIsNull && !valIsUndef && valIsReflexive) ||
	          (othIsUndef && valIsReflexive)) {
	        return -1;
	      }
	    }
	    return 0;
	  }

	  /**
	   * The base implementation of `_.findIndex` and `_.findLastIndex` without
	   * support for callback shorthands and `this` binding.
	   *
	   * @private
	   * @param {Array} array The array to search.
	   * @param {Function} predicate The function invoked per iteration.
	   * @param {boolean} [fromRight] Specify iterating from right to left.
	   * @returns {number} Returns the index of the matched value, else `-1`.
	   */
	  function baseFindIndex(array, predicate, fromRight) {
	    var length = array.length,
	        index = fromRight ? length : -1;

	    while ((fromRight ? index-- : ++index < length)) {
	      if (predicate(array[index], index, array)) {
	        return index;
	      }
	    }
	    return -1;
	  }

	  /**
	   * The base implementation of `_.indexOf` without support for binary searches.
	   *
	   * @private
	   * @param {Array} array The array to search.
	   * @param {*} value The value to search for.
	   * @param {number} fromIndex The index to search from.
	   * @returns {number} Returns the index of the matched value, else `-1`.
	   */
	  function baseIndexOf(array, value, fromIndex) {
	    if (value !== value) {
	      return indexOfNaN(array, fromIndex);
	    }
	    var index = fromIndex - 1,
	        length = array.length;

	    while (++index < length) {
	      if (array[index] === value) {
	        return index;
	      }
	    }
	    return -1;
	  }

	  /**
	   * The base implementation of `_.isFunction` without support for environments
	   * with incorrect `typeof` results.
	   *
	   * @private
	   * @param {*} value The value to check.
	   * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	   */
	  function baseIsFunction(value) {
	    // Avoid a Chakra JIT bug in compatibility modes of IE 11.
	    // See https://github.com/jashkenas/underscore/issues/1621 for more details.
	    return typeof value == 'function' || false;
	  }

	  /**
	   * Converts `value` to a string if it's not one. An empty string is returned
	   * for `null` or `undefined` values.
	   *
	   * @private
	   * @param {*} value The value to process.
	   * @returns {string} Returns the string.
	   */
	  function baseToString(value) {
	    return value == null ? '' : (value + '');
	  }

	  /**
	   * Used by `_.trim` and `_.trimLeft` to get the index of the first character
	   * of `string` that is not found in `chars`.
	   *
	   * @private
	   * @param {string} string The string to inspect.
	   * @param {string} chars The characters to find.
	   * @returns {number} Returns the index of the first character not found in `chars`.
	   */
	  function charsLeftIndex(string, chars) {
	    var index = -1,
	        length = string.length;

	    while (++index < length && chars.indexOf(string.charAt(index)) > -1) {}
	    return index;
	  }

	  /**
	   * Used by `_.trim` and `_.trimRight` to get the index of the last character
	   * of `string` that is not found in `chars`.
	   *
	   * @private
	   * @param {string} string The string to inspect.
	   * @param {string} chars The characters to find.
	   * @returns {number} Returns the index of the last character not found in `chars`.
	   */
	  function charsRightIndex(string, chars) {
	    var index = string.length;

	    while (index-- && chars.indexOf(string.charAt(index)) > -1) {}
	    return index;
	  }

	  /**
	   * Used by `_.sortBy` to compare transformed elements of a collection and stable
	   * sort them in ascending order.
	   *
	   * @private
	   * @param {Object} object The object to compare.
	   * @param {Object} other The other object to compare.
	   * @returns {number} Returns the sort order indicator for `object`.
	   */
	  function compareAscending(object, other) {
	    return baseCompareAscending(object.criteria, other.criteria) || (object.index - other.index);
	  }

	  /**
	   * Used by `_.sortByOrder` to compare multiple properties of a value to another
	   * and stable sort them.
	   *
	   * If `orders` is unspecified, all valuess are sorted in ascending order. Otherwise,
	   * a value is sorted in ascending order if its corresponding order is "asc", and
	   * descending if "desc".
	   *
	   * @private
	   * @param {Object} object The object to compare.
	   * @param {Object} other The other object to compare.
	   * @param {boolean[]} orders The order to sort by for each property.
	   * @returns {number} Returns the sort order indicator for `object`.
	   */
	  function compareMultiple(object, other, orders) {
	    var index = -1,
	        objCriteria = object.criteria,
	        othCriteria = other.criteria,
	        length = objCriteria.length,
	        ordersLength = orders.length;

	    while (++index < length) {
	      var result = baseCompareAscending(objCriteria[index], othCriteria[index]);
	      if (result) {
	        if (index >= ordersLength) {
	          return result;
	        }
	        var order = orders[index];
	        return result * ((order === 'asc' || order === true) ? 1 : -1);
	      }
	    }
	    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
	    // that causes it, under certain circumstances, to provide the same value for
	    // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
	    // for more details.
	    //
	    // This also ensures a stable sort in V8 and other engines.
	    // See https://code.google.com/p/v8/issues/detail?id=90 for more details.
	    return object.index - other.index;
	  }

	  /**
	   * Used by `_.deburr` to convert latin-1 supplementary letters to basic latin letters.
	   *
	   * @private
	   * @param {string} letter The matched letter to deburr.
	   * @returns {string} Returns the deburred letter.
	   */
	  function deburrLetter(letter) {
	    return deburredLetters[letter];
	  }

	  /**
	   * Used by `_.escape` to convert characters to HTML entities.
	   *
	   * @private
	   * @param {string} chr The matched character to escape.
	   * @returns {string} Returns the escaped character.
	   */
	  function escapeHtmlChar(chr) {
	    return htmlEscapes[chr];
	  }

	  /**
	   * Used by `_.escapeRegExp` to escape characters for inclusion in compiled regexes.
	   *
	   * @private
	   * @param {string} chr The matched character to escape.
	   * @param {string} leadingChar The capture group for a leading character.
	   * @param {string} whitespaceChar The capture group for a whitespace character.
	   * @returns {string} Returns the escaped character.
	   */
	  function escapeRegExpChar(chr, leadingChar, whitespaceChar) {
	    if (leadingChar) {
	      chr = regexpEscapes[chr];
	    } else if (whitespaceChar) {
	      chr = stringEscapes[chr];
	    }
	    return '\\' + chr;
	  }

	  /**
	   * Used by `_.template` to escape characters for inclusion in compiled string literals.
	   *
	   * @private
	   * @param {string} chr The matched character to escape.
	   * @returns {string} Returns the escaped character.
	   */
	  function escapeStringChar(chr) {
	    return '\\' + stringEscapes[chr];
	  }

	  /**
	   * Gets the index at which the first occurrence of `NaN` is found in `array`.
	   *
	   * @private
	   * @param {Array} array The array to search.
	   * @param {number} fromIndex The index to search from.
	   * @param {boolean} [fromRight] Specify iterating from right to left.
	   * @returns {number} Returns the index of the matched `NaN`, else `-1`.
	   */
	  function indexOfNaN(array, fromIndex, fromRight) {
	    var length = array.length,
	        index = fromIndex + (fromRight ? 0 : -1);

	    while ((fromRight ? index-- : ++index < length)) {
	      var other = array[index];
	      if (other !== other) {
	        return index;
	      }
	    }
	    return -1;
	  }

	  /**
	   * Checks if `value` is object-like.
	   *
	   * @private
	   * @param {*} value The value to check.
	   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	   */
	  function isObjectLike(value) {
	    return !!value && typeof value == 'object';
	  }

	  /**
	   * Used by `trimmedLeftIndex` and `trimmedRightIndex` to determine if a
	   * character code is whitespace.
	   *
	   * @private
	   * @param {number} charCode The character code to inspect.
	   * @returns {boolean} Returns `true` if `charCode` is whitespace, else `false`.
	   */
	  function isSpace(charCode) {
	    return ((charCode <= 160 && (charCode >= 9 && charCode <= 13) || charCode == 32 || charCode == 160) || charCode == 5760 || charCode == 6158 ||
	      (charCode >= 8192 && (charCode <= 8202 || charCode == 8232 || charCode == 8233 || charCode == 8239 || charCode == 8287 || charCode == 12288 || charCode == 65279)));
	  }

	  /**
	   * Replaces all `placeholder` elements in `array` with an internal placeholder
	   * and returns an array of their indexes.
	   *
	   * @private
	   * @param {Array} array The array to modify.
	   * @param {*} placeholder The placeholder to replace.
	   * @returns {Array} Returns the new array of placeholder indexes.
	   */
	  function replaceHolders(array, placeholder) {
	    var index = -1,
	        length = array.length,
	        resIndex = -1,
	        result = [];

	    while (++index < length) {
	      if (array[index] === placeholder) {
	        array[index] = PLACEHOLDER;
	        result[++resIndex] = index;
	      }
	    }
	    return result;
	  }

	  /**
	   * An implementation of `_.uniq` optimized for sorted arrays without support
	   * for callback shorthands and `this` binding.
	   *
	   * @private
	   * @param {Array} array The array to inspect.
	   * @param {Function} [iteratee] The function invoked per iteration.
	   * @returns {Array} Returns the new duplicate-value-free array.
	   */
	  function sortedUniq(array, iteratee) {
	    var seen,
	        index = -1,
	        length = array.length,
	        resIndex = -1,
	        result = [];

	    while (++index < length) {
	      var value = array[index],
	          computed = iteratee ? iteratee(value, index, array) : value;

	      if (!index || seen !== computed) {
	        seen = computed;
	        result[++resIndex] = value;
	      }
	    }
	    return result;
	  }

	  /**
	   * Used by `_.trim` and `_.trimLeft` to get the index of the first non-whitespace
	   * character of `string`.
	   *
	   * @private
	   * @param {string} string The string to inspect.
	   * @returns {number} Returns the index of the first non-whitespace character.
	   */
	  function trimmedLeftIndex(string) {
	    var index = -1,
	        length = string.length;

	    while (++index < length && isSpace(string.charCodeAt(index))) {}
	    return index;
	  }

	  /**
	   * Used by `_.trim` and `_.trimRight` to get the index of the last non-whitespace
	   * character of `string`.
	   *
	   * @private
	   * @param {string} string The string to inspect.
	   * @returns {number} Returns the index of the last non-whitespace character.
	   */
	  function trimmedRightIndex(string) {
	    var index = string.length;

	    while (index-- && isSpace(string.charCodeAt(index))) {}
	    return index;
	  }

	  /**
	   * Used by `_.unescape` to convert HTML entities to characters.
	   *
	   * @private
	   * @param {string} chr The matched character to unescape.
	   * @returns {string} Returns the unescaped character.
	   */
	  function unescapeHtmlChar(chr) {
	    return htmlUnescapes[chr];
	  }

	  /*--------------------------------------------------------------------------*/

	  /**
	   * Create a new pristine `lodash` function using the given `context` object.
	   *
	   * @static
	   * @memberOf _
	   * @category Utility
	   * @param {Object} [context=root] The context object.
	   * @returns {Function} Returns a new `lodash` function.
	   * @example
	   *
	   * _.mixin({ 'foo': _.constant('foo') });
	   *
	   * var lodash = _.runInContext();
	   * lodash.mixin({ 'bar': lodash.constant('bar') });
	   *
	   * _.isFunction(_.foo);
	   * // => true
	   * _.isFunction(_.bar);
	   * // => false
	   *
	   * lodash.isFunction(lodash.foo);
	   * // => false
	   * lodash.isFunction(lodash.bar);
	   * // => true
	   *
	   * // using `context` to mock `Date#getTime` use in `_.now`
	   * var mock = _.runInContext({
	   *   'Date': function() {
	   *     return { 'getTime': getTimeMock };
	   *   }
	   * });
	   *
	   * // or creating a suped-up `defer` in Node.js
	   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
	   */
	  function runInContext(context) {
	    // Avoid issues with some ES3 environments that attempt to use values, named
	    // after built-in constructors like `Object`, for the creation of literals.
	    // ES5 clears this up by stating that literals must use built-in constructors.
	    // See https://es5.github.io/#x11.1.5 for more details.
	    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;

	    /** Native constructor references. */
	    var Array = context.Array,
	        Date = context.Date,
	        Error = context.Error,
	        Function = context.Function,
	        Math = context.Math,
	        Number = context.Number,
	        Object = context.Object,
	        RegExp = context.RegExp,
	        String = context.String,
	        TypeError = context.TypeError;

	    /** Used for native method references. */
	    var arrayProto = Array.prototype,
	        objectProto = Object.prototype,
	        stringProto = String.prototype;

	    /** Used to resolve the decompiled source of functions. */
	    var fnToString = Function.prototype.toString;

	    /** Used to check objects for own properties. */
	    var hasOwnProperty = objectProto.hasOwnProperty;

	    /** Used to generate unique IDs. */
	    var idCounter = 0;

	    /**
	     * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	     * of values.
	     */
	    var objToString = objectProto.toString;

	    /** Used to restore the original `_` reference in `_.noConflict`. */
	    var oldDash = root._;

	    /** Used to detect if a method is native. */
	    var reIsNative = RegExp('^' +
	      fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
	      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	    );

	    /** Native method references. */
	    var ArrayBuffer = context.ArrayBuffer,
	        clearTimeout = context.clearTimeout,
	        parseFloat = context.parseFloat,
	        pow = Math.pow,
	        propertyIsEnumerable = objectProto.propertyIsEnumerable,
	        Set = getNative(context, 'Set'),
	        setTimeout = context.setTimeout,
	        splice = arrayProto.splice,
	        Uint8Array = context.Uint8Array,
	        WeakMap = getNative(context, 'WeakMap');

	    /* Native method references for those with the same name as other `lodash` methods. */
	    var nativeCeil = Math.ceil,
	        nativeCreate = getNative(Object, 'create'),
	        nativeFloor = Math.floor,
	        nativeIsArray = getNative(Array, 'isArray'),
	        nativeIsFinite = context.isFinite,
	        nativeKeys = getNative(Object, 'keys'),
	        nativeMax = Math.max,
	        nativeMin = Math.min,
	        nativeNow = getNative(Date, 'now'),
	        nativeParseInt = context.parseInt,
	        nativeRandom = Math.random;

	    /** Used as references for `-Infinity` and `Infinity`. */
	    var NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY,
	        POSITIVE_INFINITY = Number.POSITIVE_INFINITY;

	    /** Used as references for the maximum length and index of an array. */
	    var MAX_ARRAY_LENGTH = 4294967295,
	        MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
	        HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

	    /**
	     * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
	     * of an array-like value.
	     */
	    var MAX_SAFE_INTEGER = 9007199254740991;

	    /** Used to store function metadata. */
	    var metaMap = WeakMap && new WeakMap;

	    /** Used to lookup unminified function names. */
	    var realNames = {};

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates a `lodash` object which wraps `value` to enable implicit chaining.
	     * Methods that operate on and return arrays, collections, and functions can
	     * be chained together. Methods that retrieve a single value or may return a
	     * primitive value will automatically end the chain returning the unwrapped
	     * value. Explicit chaining may be enabled using `_.chain`. The execution of
	     * chained methods is lazy, that is, execution is deferred until `_#value`
	     * is implicitly or explicitly called.
	     *
	     * Lazy evaluation allows several methods to support shortcut fusion. Shortcut
	     * fusion is an optimization strategy which merge iteratee calls; this can help
	     * to avoid the creation of intermediate data structures and greatly reduce the
	     * number of iteratee executions.
	     *
	     * Chaining is supported in custom builds as long as the `_#value` method is
	     * directly or indirectly included in the build.
	     *
	     * In addition to lodash methods, wrappers have `Array` and `String` methods.
	     *
	     * The wrapper `Array` methods are:
	     * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`,
	     * `splice`, and `unshift`
	     *
	     * The wrapper `String` methods are:
	     * `replace` and `split`
	     *
	     * The wrapper methods that support shortcut fusion are:
	     * `compact`, `drop`, `dropRight`, `dropRightWhile`, `dropWhile`, `filter`,
	     * `first`, `initial`, `last`, `map`, `pluck`, `reject`, `rest`, `reverse`,
	     * `slice`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, `toArray`,
	     * and `where`
	     *
	     * The chainable wrapper methods are:
	     * `after`, `ary`, `assign`, `at`, `before`, `bind`, `bindAll`, `bindKey`,
	     * `callback`, `chain`, `chunk`, `commit`, `compact`, `concat`, `constant`,
	     * `countBy`, `create`, `curry`, `debounce`, `defaults`, `defaultsDeep`,
	     * `defer`, `delay`, `difference`, `drop`, `dropRight`, `dropRightWhile`,
	     * `dropWhile`, `fill`, `filter`, `flatten`, `flattenDeep`, `flow`, `flowRight`,
	     * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,
	     * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,
	     * `invoke`, `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`,
	     * `matchesProperty`, `memoize`, `merge`, `method`, `methodOf`, `mixin`,
	     * `modArgs`, `negate`, `omit`, `once`, `pairs`, `partial`, `partialRight`,
	     * `partition`, `pick`, `plant`, `pluck`, `property`, `propertyOf`, `pull`,
	     * `pullAt`, `push`, `range`, `rearg`, `reject`, `remove`, `rest`, `restParam`,
	     * `reverse`, `set`, `shuffle`, `slice`, `sort`, `sortBy`, `sortByAll`,
	     * `sortByOrder`, `splice`, `spread`, `take`, `takeRight`, `takeRightWhile`,
	     * `takeWhile`, `tap`, `throttle`, `thru`, `times`, `toArray`, `toPlainObject`,
	     * `transform`, `union`, `uniq`, `unshift`, `unzip`, `unzipWith`, `values`,
	     * `valuesIn`, `where`, `without`, `wrap`, `xor`, `zip`, `zipObject`, `zipWith`
	     *
	     * The wrapper methods that are **not** chainable by default are:
	     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clone`, `cloneDeep`,
	     * `deburr`, `endsWith`, `escape`, `escapeRegExp`, `every`, `find`, `findIndex`,
	     * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `findWhere`, `first`,
	     * `floor`, `get`, `gt`, `gte`, `has`, `identity`, `includes`, `indexOf`,
	     * `inRange`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,
	     * `isEmpty`, `isEqual`, `isError`, `isFinite` `isFunction`, `isMatch`,
	     * `isNative`, `isNaN`, `isNull`, `isNumber`, `isObject`, `isPlainObject`,
	     * `isRegExp`, `isString`, `isUndefined`, `isTypedArray`, `join`, `kebabCase`,
	     * `last`, `lastIndexOf`, `lt`, `lte`, `max`, `min`, `noConflict`, `noop`,
	     * `now`, `pad`, `padLeft`, `padRight`, `parseInt`, `pop`, `random`, `reduce`,
	     * `reduceRight`, `repeat`, `result`, `round`, `runInContext`, `shift`, `size`,
	     * `snakeCase`, `some`, `sortedIndex`, `sortedLastIndex`, `startCase`,
	     * `startsWith`, `sum`, `template`, `trim`, `trimLeft`, `trimRight`, `trunc`,
	     * `unescape`, `uniqueId`, `value`, and `words`
	     *
	     * The wrapper method `sample` will return a wrapped value when `n` is provided,
	     * otherwise an unwrapped value is returned.
	     *
	     * @name _
	     * @constructor
	     * @category Chain
	     * @param {*} value The value to wrap in a `lodash` instance.
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var wrapped = _([1, 2, 3]);
	     *
	     * // returns an unwrapped value
	     * wrapped.reduce(function(total, n) {
	     *   return total + n;
	     * });
	     * // => 6
	     *
	     * // returns a wrapped value
	     * var squares = wrapped.map(function(n) {
	     *   return n * n;
	     * });
	     *
	     * _.isArray(squares);
	     * // => false
	     *
	     * _.isArray(squares.value());
	     * // => true
	     */
	    function lodash(value) {
	      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
	        if (value instanceof LodashWrapper) {
	          return value;
	        }
	        if (hasOwnProperty.call(value, '__chain__') && hasOwnProperty.call(value, '__wrapped__')) {
	          return wrapperClone(value);
	        }
	      }
	      return new LodashWrapper(value);
	    }

	    /**
	     * The function whose prototype all chaining wrappers inherit from.
	     *
	     * @private
	     */
	    function baseLodash() {
	      // No operation performed.
	    }

	    /**
	     * The base constructor for creating `lodash` wrapper objects.
	     *
	     * @private
	     * @param {*} value The value to wrap.
	     * @param {boolean} [chainAll] Enable chaining for all wrapper methods.
	     * @param {Array} [actions=[]] Actions to peform to resolve the unwrapped value.
	     */
	    function LodashWrapper(value, chainAll, actions) {
	      this.__wrapped__ = value;
	      this.__actions__ = actions || [];
	      this.__chain__ = !!chainAll;
	    }

	    /**
	     * An object environment feature flags.
	     *
	     * @static
	     * @memberOf _
	     * @type Object
	     */
	    var support = lodash.support = {};

	    /**
	     * By default, the template delimiters used by lodash are like those in
	     * embedded Ruby (ERB). Change the following template settings to use
	     * alternative delimiters.
	     *
	     * @static
	     * @memberOf _
	     * @type Object
	     */
	    lodash.templateSettings = {

	      /**
	       * Used to detect `data` property values to be HTML-escaped.
	       *
	       * @memberOf _.templateSettings
	       * @type RegExp
	       */
	      'escape': reEscape,

	      /**
	       * Used to detect code to be evaluated.
	       *
	       * @memberOf _.templateSettings
	       * @type RegExp
	       */
	      'evaluate': reEvaluate,

	      /**
	       * Used to detect `data` property values to inject.
	       *
	       * @memberOf _.templateSettings
	       * @type RegExp
	       */
	      'interpolate': reInterpolate,

	      /**
	       * Used to reference the data object in the template text.
	       *
	       * @memberOf _.templateSettings
	       * @type string
	       */
	      'variable': '',

	      /**
	       * Used to import variables into the compiled template.
	       *
	       * @memberOf _.templateSettings
	       * @type Object
	       */
	      'imports': {

	        /**
	         * A reference to the `lodash` function.
	         *
	         * @memberOf _.templateSettings.imports
	         * @type Function
	         */
	        '_': lodash
	      }
	    };

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
	     *
	     * @private
	     * @param {*} value The value to wrap.
	     */
	    function LazyWrapper(value) {
	      this.__wrapped__ = value;
	      this.__actions__ = [];
	      this.__dir__ = 1;
	      this.__filtered__ = false;
	      this.__iteratees__ = [];
	      this.__takeCount__ = POSITIVE_INFINITY;
	      this.__views__ = [];
	    }

	    /**
	     * Creates a clone of the lazy wrapper object.
	     *
	     * @private
	     * @name clone
	     * @memberOf LazyWrapper
	     * @returns {Object} Returns the cloned `LazyWrapper` object.
	     */
	    function lazyClone() {
	      var result = new LazyWrapper(this.__wrapped__);
	      result.__actions__ = arrayCopy(this.__actions__);
	      result.__dir__ = this.__dir__;
	      result.__filtered__ = this.__filtered__;
	      result.__iteratees__ = arrayCopy(this.__iteratees__);
	      result.__takeCount__ = this.__takeCount__;
	      result.__views__ = arrayCopy(this.__views__);
	      return result;
	    }

	    /**
	     * Reverses the direction of lazy iteration.
	     *
	     * @private
	     * @name reverse
	     * @memberOf LazyWrapper
	     * @returns {Object} Returns the new reversed `LazyWrapper` object.
	     */
	    function lazyReverse() {
	      if (this.__filtered__) {
	        var result = new LazyWrapper(this);
	        result.__dir__ = -1;
	        result.__filtered__ = true;
	      } else {
	        result = this.clone();
	        result.__dir__ *= -1;
	      }
	      return result;
	    }

	    /**
	     * Extracts the unwrapped value from its lazy wrapper.
	     *
	     * @private
	     * @name value
	     * @memberOf LazyWrapper
	     * @returns {*} Returns the unwrapped value.
	     */
	    function lazyValue() {
	      var array = this.__wrapped__.value(),
	          dir = this.__dir__,
	          isArr = isArray(array),
	          isRight = dir < 0,
	          arrLength = isArr ? array.length : 0,
	          view = getView(0, arrLength, this.__views__),
	          start = view.start,
	          end = view.end,
	          length = end - start,
	          index = isRight ? end : (start - 1),
	          iteratees = this.__iteratees__,
	          iterLength = iteratees.length,
	          resIndex = 0,
	          takeCount = nativeMin(length, this.__takeCount__);

	      if (!isArr || arrLength < LARGE_ARRAY_SIZE || (arrLength == length && takeCount == length)) {
	        return baseWrapperValue((isRight && isArr) ? array.reverse() : array, this.__actions__);
	      }
	      var result = [];

	      outer:
	      while (length-- && resIndex < takeCount) {
	        index += dir;

	        var iterIndex = -1,
	            value = array[index];

	        while (++iterIndex < iterLength) {
	          var data = iteratees[iterIndex],
	              iteratee = data.iteratee,
	              type = data.type,
	              computed = iteratee(value);

	          if (type == LAZY_MAP_FLAG) {
	            value = computed;
	          } else if (!computed) {
	            if (type == LAZY_FILTER_FLAG) {
	              continue outer;
	            } else {
	              break outer;
	            }
	          }
	        }
	        result[resIndex++] = value;
	      }
	      return result;
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates a cache object to store key/value pairs.
	     *
	     * @private
	     * @static
	     * @name Cache
	     * @memberOf _.memoize
	     */
	    function MapCache() {
	      this.__data__ = {};
	    }

	    /**
	     * Removes `key` and its value from the cache.
	     *
	     * @private
	     * @name delete
	     * @memberOf _.memoize.Cache
	     * @param {string} key The key of the value to remove.
	     * @returns {boolean} Returns `true` if the entry was removed successfully, else `false`.
	     */
	    function mapDelete(key) {
	      return this.has(key) && delete this.__data__[key];
	    }

	    /**
	     * Gets the cached value for `key`.
	     *
	     * @private
	     * @name get
	     * @memberOf _.memoize.Cache
	     * @param {string} key The key of the value to get.
	     * @returns {*} Returns the cached value.
	     */
	    function mapGet(key) {
	      return key == '__proto__' ? undefined : this.__data__[key];
	    }

	    /**
	     * Checks if a cached value for `key` exists.
	     *
	     * @private
	     * @name has
	     * @memberOf _.memoize.Cache
	     * @param {string} key The key of the entry to check.
	     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	     */
	    function mapHas(key) {
	      return key != '__proto__' && hasOwnProperty.call(this.__data__, key);
	    }

	    /**
	     * Sets `value` to `key` of the cache.
	     *
	     * @private
	     * @name set
	     * @memberOf _.memoize.Cache
	     * @param {string} key The key of the value to cache.
	     * @param {*} value The value to cache.
	     * @returns {Object} Returns the cache object.
	     */
	    function mapSet(key, value) {
	      if (key != '__proto__') {
	        this.__data__[key] = value;
	      }
	      return this;
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     *
	     * Creates a cache object to store unique values.
	     *
	     * @private
	     * @param {Array} [values] The values to cache.
	     */
	    function SetCache(values) {
	      var length = values ? values.length : 0;

	      this.data = { 'hash': nativeCreate(null), 'set': new Set };
	      while (length--) {
	        this.push(values[length]);
	      }
	    }

	    /**
	     * Checks if `value` is in `cache` mimicking the return signature of
	     * `_.indexOf` by returning `0` if the value is found, else `-1`.
	     *
	     * @private
	     * @param {Object} cache The cache to search.
	     * @param {*} value The value to search for.
	     * @returns {number} Returns `0` if `value` is found, else `-1`.
	     */
	    function cacheIndexOf(cache, value) {
	      var data = cache.data,
	          result = (typeof value == 'string' || isObject(value)) ? data.set.has(value) : data.hash[value];

	      return result ? 0 : -1;
	    }

	    /**
	     * Adds `value` to the cache.
	     *
	     * @private
	     * @name push
	     * @memberOf SetCache
	     * @param {*} value The value to cache.
	     */
	    function cachePush(value) {
	      var data = this.data;
	      if (typeof value == 'string' || isObject(value)) {
	        data.set.add(value);
	      } else {
	        data.hash[value] = true;
	      }
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates a new array joining `array` with `other`.
	     *
	     * @private
	     * @param {Array} array The array to join.
	     * @param {Array} other The other array to join.
	     * @returns {Array} Returns the new concatenated array.
	     */
	    function arrayConcat(array, other) {
	      var index = -1,
	          length = array.length,
	          othIndex = -1,
	          othLength = other.length,
	          result = Array(length + othLength);

	      while (++index < length) {
	        result[index] = array[index];
	      }
	      while (++othIndex < othLength) {
	        result[index++] = other[othIndex];
	      }
	      return result;
	    }

	    /**
	     * Copies the values of `source` to `array`.
	     *
	     * @private
	     * @param {Array} source The array to copy values from.
	     * @param {Array} [array=[]] The array to copy values to.
	     * @returns {Array} Returns `array`.
	     */
	    function arrayCopy(source, array) {
	      var index = -1,
	          length = source.length;

	      array || (array = Array(length));
	      while (++index < length) {
	        array[index] = source[index];
	      }
	      return array;
	    }

	    /**
	     * A specialized version of `_.forEach` for arrays without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array} Returns `array`.
	     */
	    function arrayEach(array, iteratee) {
	      var index = -1,
	          length = array.length;

	      while (++index < length) {
	        if (iteratee(array[index], index, array) === false) {
	          break;
	        }
	      }
	      return array;
	    }

	    /**
	     * A specialized version of `_.forEachRight` for arrays without support for
	     * callback shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array} Returns `array`.
	     */
	    function arrayEachRight(array, iteratee) {
	      var length = array.length;

	      while (length--) {
	        if (iteratee(array[length], length, array) === false) {
	          break;
	        }
	      }
	      return array;
	    }

	    /**
	     * A specialized version of `_.every` for arrays without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {boolean} Returns `true` if all elements pass the predicate check,
	     *  else `false`.
	     */
	    function arrayEvery(array, predicate) {
	      var index = -1,
	          length = array.length;

	      while (++index < length) {
	        if (!predicate(array[index], index, array)) {
	          return false;
	        }
	      }
	      return true;
	    }

	    /**
	     * A specialized version of `baseExtremum` for arrays which invokes `iteratee`
	     * with one argument: (value).
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {Function} comparator The function used to compare values.
	     * @param {*} exValue The initial extremum value.
	     * @returns {*} Returns the extremum value.
	     */
	    function arrayExtremum(array, iteratee, comparator, exValue) {
	      var index = -1,
	          length = array.length,
	          computed = exValue,
	          result = computed;

	      while (++index < length) {
	        var value = array[index],
	            current = +iteratee(value);

	        if (comparator(current, computed)) {
	          computed = current;
	          result = value;
	        }
	      }
	      return result;
	    }

	    /**
	     * A specialized version of `_.filter` for arrays without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {Array} Returns the new filtered array.
	     */
	    function arrayFilter(array, predicate) {
	      var index = -1,
	          length = array.length,
	          resIndex = -1,
	          result = [];

	      while (++index < length) {
	        var value = array[index];
	        if (predicate(value, index, array)) {
	          result[++resIndex] = value;
	        }
	      }
	      return result;
	    }

	    /**
	     * A specialized version of `_.map` for arrays without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array} Returns the new mapped array.
	     */
	    function arrayMap(array, iteratee) {
	      var index = -1,
	          length = array.length,
	          result = Array(length);

	      while (++index < length) {
	        result[index] = iteratee(array[index], index, array);
	      }
	      return result;
	    }

	    /**
	     * Appends the elements of `values` to `array`.
	     *
	     * @private
	     * @param {Array} array The array to modify.
	     * @param {Array} values The values to append.
	     * @returns {Array} Returns `array`.
	     */
	    function arrayPush(array, values) {
	      var index = -1,
	          length = values.length,
	          offset = array.length;

	      while (++index < length) {
	        array[offset + index] = values[index];
	      }
	      return array;
	    }

	    /**
	     * A specialized version of `_.reduce` for arrays without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {*} [accumulator] The initial value.
	     * @param {boolean} [initFromArray] Specify using the first element of `array`
	     *  as the initial value.
	     * @returns {*} Returns the accumulated value.
	     */
	    function arrayReduce(array, iteratee, accumulator, initFromArray) {
	      var index = -1,
	          length = array.length;

	      if (initFromArray && length) {
	        accumulator = array[++index];
	      }
	      while (++index < length) {
	        accumulator = iteratee(accumulator, array[index], index, array);
	      }
	      return accumulator;
	    }

	    /**
	     * A specialized version of `_.reduceRight` for arrays without support for
	     * callback shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {*} [accumulator] The initial value.
	     * @param {boolean} [initFromArray] Specify using the last element of `array`
	     *  as the initial value.
	     * @returns {*} Returns the accumulated value.
	     */
	    function arrayReduceRight(array, iteratee, accumulator, initFromArray) {
	      var length = array.length;
	      if (initFromArray && length) {
	        accumulator = array[--length];
	      }
	      while (length--) {
	        accumulator = iteratee(accumulator, array[length], length, array);
	      }
	      return accumulator;
	    }

	    /**
	     * A specialized version of `_.some` for arrays without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {boolean} Returns `true` if any element passes the predicate check,
	     *  else `false`.
	     */
	    function arraySome(array, predicate) {
	      var index = -1,
	          length = array.length;

	      while (++index < length) {
	        if (predicate(array[index], index, array)) {
	          return true;
	        }
	      }
	      return false;
	    }

	    /**
	     * A specialized version of `_.sum` for arrays without support for callback
	     * shorthands and `this` binding..
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {number} Returns the sum.
	     */
	    function arraySum(array, iteratee) {
	      var length = array.length,
	          result = 0;

	      while (length--) {
	        result += +iteratee(array[length]) || 0;
	      }
	      return result;
	    }

	    /**
	     * Used by `_.defaults` to customize its `_.assign` use.
	     *
	     * @private
	     * @param {*} objectValue The destination object property value.
	     * @param {*} sourceValue The source object property value.
	     * @returns {*} Returns the value to assign to the destination object.
	     */
	    function assignDefaults(objectValue, sourceValue) {
	      return objectValue === undefined ? sourceValue : objectValue;
	    }

	    /**
	     * Used by `_.template` to customize its `_.assign` use.
	     *
	     * **Note:** This function is like `assignDefaults` except that it ignores
	     * inherited property values when checking if a property is `undefined`.
	     *
	     * @private
	     * @param {*} objectValue The destination object property value.
	     * @param {*} sourceValue The source object property value.
	     * @param {string} key The key associated with the object and source values.
	     * @param {Object} object The destination object.
	     * @returns {*} Returns the value to assign to the destination object.
	     */
	    function assignOwnDefaults(objectValue, sourceValue, key, object) {
	      return (objectValue === undefined || !hasOwnProperty.call(object, key))
	        ? sourceValue
	        : objectValue;
	    }

	    /**
	     * A specialized version of `_.assign` for customizing assigned values without
	     * support for argument juggling, multiple sources, and `this` binding `customizer`
	     * functions.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @param {Function} customizer The function to customize assigned values.
	     * @returns {Object} Returns `object`.
	     */
	    function assignWith(object, source, customizer) {
	      var index = -1,
	          props = keys(source),
	          length = props.length;

	      while (++index < length) {
	        var key = props[index],
	            value = object[key],
	            result = customizer(value, source[key], key, object, source);

	        if ((result === result ? (result !== value) : (value === value)) ||
	            (value === undefined && !(key in object))) {
	          object[key] = result;
	        }
	      }
	      return object;
	    }

	    /**
	     * The base implementation of `_.assign` without support for argument juggling,
	     * multiple sources, and `customizer` functions.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @returns {Object} Returns `object`.
	     */
	    function baseAssign(object, source) {
	      return source == null
	        ? object
	        : baseCopy(source, keys(source), object);
	    }

	    /**
	     * The base implementation of `_.at` without support for string collections
	     * and individual key arguments.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {number[]|string[]} props The property names or indexes of elements to pick.
	     * @returns {Array} Returns the new array of picked elements.
	     */
	    function baseAt(collection, props) {
	      var index = -1,
	          isNil = collection == null,
	          isArr = !isNil && isArrayLike(collection),
	          length = isArr ? collection.length : 0,
	          propsLength = props.length,
	          result = Array(propsLength);

	      while(++index < propsLength) {
	        var key = props[index];
	        if (isArr) {
	          result[index] = isIndex(key, length) ? collection[key] : undefined;
	        } else {
	          result[index] = isNil ? undefined : collection[key];
	        }
	      }
	      return result;
	    }

	    /**
	     * Copies properties of `source` to `object`.
	     *
	     * @private
	     * @param {Object} source The object to copy properties from.
	     * @param {Array} props The property names to copy.
	     * @param {Object} [object={}] The object to copy properties to.
	     * @returns {Object} Returns `object`.
	     */
	    function baseCopy(source, props, object) {
	      object || (object = {});

	      var index = -1,
	          length = props.length;

	      while (++index < length) {
	        var key = props[index];
	        object[key] = source[key];
	      }
	      return object;
	    }

	    /**
	     * The base implementation of `_.callback` which supports specifying the
	     * number of arguments to provide to `func`.
	     *
	     * @private
	     * @param {*} [func=_.identity] The value to convert to a callback.
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @param {number} [argCount] The number of arguments to provide to `func`.
	     * @returns {Function} Returns the callback.
	     */
	    function baseCallback(func, thisArg, argCount) {
	      var type = typeof func;
	      if (type == 'function') {
	        return thisArg === undefined
	          ? func
	          : bindCallback(func, thisArg, argCount);
	      }
	      if (func == null) {
	        return identity;
	      }
	      if (type == 'object') {
	        return baseMatches(func);
	      }
	      return thisArg === undefined
	        ? property(func)
	        : baseMatchesProperty(func, thisArg);
	    }

	    /**
	     * The base implementation of `_.clone` without support for argument juggling
	     * and `this` binding `customizer` functions.
	     *
	     * @private
	     * @param {*} value The value to clone.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @param {Function} [customizer] The function to customize cloning values.
	     * @param {string} [key] The key of `value`.
	     * @param {Object} [object] The object `value` belongs to.
	     * @param {Array} [stackA=[]] Tracks traversed source objects.
	     * @param {Array} [stackB=[]] Associates clones with source counterparts.
	     * @returns {*} Returns the cloned value.
	     */
	    function baseClone(value, isDeep, customizer, key, object, stackA, stackB) {
	      var result;
	      if (customizer) {
	        result = object ? customizer(value, key, object) : customizer(value);
	      }
	      if (result !== undefined) {
	        return result;
	      }
	      if (!isObject(value)) {
	        return value;
	      }
	      var isArr = isArray(value);
	      if (isArr) {
	        result = initCloneArray(value);
	        if (!isDeep) {
	          return arrayCopy(value, result);
	        }
	      } else {
	        var tag = objToString.call(value),
	            isFunc = tag == funcTag;

	        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
	          result = initCloneObject(isFunc ? {} : value);
	          if (!isDeep) {
	            return baseAssign(result, value);
	          }
	        } else {
	          return cloneableTags[tag]
	            ? initCloneByTag(value, tag, isDeep)
	            : (object ? value : {});
	        }
	      }
	      // Check for circular references and return its corresponding clone.
	      stackA || (stackA = []);
	      stackB || (stackB = []);

	      var length = stackA.length;
	      while (length--) {
	        if (stackA[length] == value) {
	          return stackB[length];
	        }
	      }
	      // Add the source value to the stack of traversed objects and associate it with its clone.
	      stackA.push(value);
	      stackB.push(result);

	      // Recursively populate clone (susceptible to call stack limits).
	      (isArr ? arrayEach : baseForOwn)(value, function(subValue, key) {
	        result[key] = baseClone(subValue, isDeep, customizer, key, value, stackA, stackB);
	      });
	      return result;
	    }

	    /**
	     * The base implementation of `_.create` without support for assigning
	     * properties to the created object.
	     *
	     * @private
	     * @param {Object} prototype The object to inherit from.
	     * @returns {Object} Returns the new object.
	     */
	    var baseCreate = (function() {
	      function object() {}
	      return function(prototype) {
	        if (isObject(prototype)) {
	          object.prototype = prototype;
	          var result = new object;
	          object.prototype = undefined;
	        }
	        return result || {};
	      };
	    }());

	    /**
	     * The base implementation of `_.delay` and `_.defer` which accepts an index
	     * of where to slice the arguments to provide to `func`.
	     *
	     * @private
	     * @param {Function} func The function to delay.
	     * @param {number} wait The number of milliseconds to delay invocation.
	     * @param {Object} args The arguments provide to `func`.
	     * @returns {number} Returns the timer id.
	     */
	    function baseDelay(func, wait, args) {
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      return setTimeout(function() { func.apply(undefined, args); }, wait);
	    }

	    /**
	     * The base implementation of `_.difference` which accepts a single array
	     * of values to exclude.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @param {Array} values The values to exclude.
	     * @returns {Array} Returns the new array of filtered values.
	     */
	    function baseDifference(array, values) {
	      var length = array ? array.length : 0,
	          result = [];

	      if (!length) {
	        return result;
	      }
	      var index = -1,
	          indexOf = getIndexOf(),
	          isCommon = indexOf == baseIndexOf,
	          cache = (isCommon && values.length >= LARGE_ARRAY_SIZE) ? createCache(values) : null,
	          valuesLength = values.length;

	      if (cache) {
	        indexOf = cacheIndexOf;
	        isCommon = false;
	        values = cache;
	      }
	      outer:
	      while (++index < length) {
	        var value = array[index];

	        if (isCommon && value === value) {
	          var valuesIndex = valuesLength;
	          while (valuesIndex--) {
	            if (values[valuesIndex] === value) {
	              continue outer;
	            }
	          }
	          result.push(value);
	        }
	        else if (indexOf(values, value, 0) < 0) {
	          result.push(value);
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.forEach` without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array|Object|string} Returns `collection`.
	     */
	    var baseEach = createBaseEach(baseForOwn);

	    /**
	     * The base implementation of `_.forEachRight` without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array|Object|string} Returns `collection`.
	     */
	    var baseEachRight = createBaseEach(baseForOwnRight, true);

	    /**
	     * The base implementation of `_.every` without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {boolean} Returns `true` if all elements pass the predicate check,
	     *  else `false`
	     */
	    function baseEvery(collection, predicate) {
	      var result = true;
	      baseEach(collection, function(value, index, collection) {
	        result = !!predicate(value, index, collection);
	        return result;
	      });
	      return result;
	    }

	    /**
	     * Gets the extremum value of `collection` invoking `iteratee` for each value
	     * in `collection` to generate the criterion by which the value is ranked.
	     * The `iteratee` is invoked with three arguments: (value, index|key, collection).
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {Function} comparator The function used to compare values.
	     * @param {*} exValue The initial extremum value.
	     * @returns {*} Returns the extremum value.
	     */
	    function baseExtremum(collection, iteratee, comparator, exValue) {
	      var computed = exValue,
	          result = computed;

	      baseEach(collection, function(value, index, collection) {
	        var current = +iteratee(value, index, collection);
	        if (comparator(current, computed) || (current === exValue && current === result)) {
	          computed = current;
	          result = value;
	        }
	      });
	      return result;
	    }

	    /**
	     * The base implementation of `_.fill` without an iteratee call guard.
	     *
	     * @private
	     * @param {Array} array The array to fill.
	     * @param {*} value The value to fill `array` with.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns `array`.
	     */
	    function baseFill(array, value, start, end) {
	      var length = array.length;

	      start = start == null ? 0 : (+start || 0);
	      if (start < 0) {
	        start = -start > length ? 0 : (length + start);
	      }
	      end = (end === undefined || end > length) ? length : (+end || 0);
	      if (end < 0) {
	        end += length;
	      }
	      length = start > end ? 0 : (end >>> 0);
	      start >>>= 0;

	      while (start < length) {
	        array[start++] = value;
	      }
	      return array;
	    }

	    /**
	     * The base implementation of `_.filter` without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {Array} Returns the new filtered array.
	     */
	    function baseFilter(collection, predicate) {
	      var result = [];
	      baseEach(collection, function(value, index, collection) {
	        if (predicate(value, index, collection)) {
	          result.push(value);
	        }
	      });
	      return result;
	    }

	    /**
	     * The base implementation of `_.find`, `_.findLast`, `_.findKey`, and `_.findLastKey`,
	     * without support for callback shorthands and `this` binding, which iterates
	     * over `collection` using the provided `eachFunc`.
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to search.
	     * @param {Function} predicate The function invoked per iteration.
	     * @param {Function} eachFunc The function to iterate over `collection`.
	     * @param {boolean} [retKey] Specify returning the key of the found element
	     *  instead of the element itself.
	     * @returns {*} Returns the found element or its key, else `undefined`.
	     */
	    function baseFind(collection, predicate, eachFunc, retKey) {
	      var result;
	      eachFunc(collection, function(value, key, collection) {
	        if (predicate(value, key, collection)) {
	          result = retKey ? key : value;
	          return false;
	        }
	      });
	      return result;
	    }

	    /**
	     * The base implementation of `_.flatten` with added support for restricting
	     * flattening and specifying the start index.
	     *
	     * @private
	     * @param {Array} array The array to flatten.
	     * @param {boolean} [isDeep] Specify a deep flatten.
	     * @param {boolean} [isStrict] Restrict flattening to arrays-like objects.
	     * @param {Array} [result=[]] The initial result value.
	     * @returns {Array} Returns the new flattened array.
	     */
	    function baseFlatten(array, isDeep, isStrict, result) {
	      result || (result = []);

	      var index = -1,
	          length = array.length;

	      while (++index < length) {
	        var value = array[index];
	        if (isObjectLike(value) && isArrayLike(value) &&
	            (isStrict || isArray(value) || isArguments(value))) {
	          if (isDeep) {
	            // Recursively flatten arrays (susceptible to call stack limits).
	            baseFlatten(value, isDeep, isStrict, result);
	          } else {
	            arrayPush(result, value);
	          }
	        } else if (!isStrict) {
	          result[result.length] = value;
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `baseForIn` and `baseForOwn` which iterates
	     * over `object` properties returned by `keysFunc` invoking `iteratee` for
	     * each property. Iteratee functions may exit iteration early by explicitly
	     * returning `false`.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {Function} keysFunc The function to get the keys of `object`.
	     * @returns {Object} Returns `object`.
	     */
	    var baseFor = createBaseFor();

	    /**
	     * This function is like `baseFor` except that it iterates over properties
	     * in the opposite order.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {Function} keysFunc The function to get the keys of `object`.
	     * @returns {Object} Returns `object`.
	     */
	    var baseForRight = createBaseFor(true);

	    /**
	     * The base implementation of `_.forIn` without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     */
	    function baseForIn(object, iteratee) {
	      return baseFor(object, iteratee, keysIn);
	    }

	    /**
	     * The base implementation of `_.forOwn` without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     */
	    function baseForOwn(object, iteratee) {
	      return baseFor(object, iteratee, keys);
	    }

	    /**
	     * The base implementation of `_.forOwnRight` without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     */
	    function baseForOwnRight(object, iteratee) {
	      return baseForRight(object, iteratee, keys);
	    }

	    /**
	     * The base implementation of `_.functions` which creates an array of
	     * `object` function property names filtered from those provided.
	     *
	     * @private
	     * @param {Object} object The object to inspect.
	     * @param {Array} props The property names to filter.
	     * @returns {Array} Returns the new array of filtered property names.
	     */
	    function baseFunctions(object, props) {
	      var index = -1,
	          length = props.length,
	          resIndex = -1,
	          result = [];

	      while (++index < length) {
	        var key = props[index];
	        if (isFunction(object[key])) {
	          result[++resIndex] = key;
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `get` without support for string paths
	     * and default values.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Array} path The path of the property to get.
	     * @param {string} [pathKey] The key representation of path.
	     * @returns {*} Returns the resolved value.
	     */
	    function baseGet(object, path, pathKey) {
	      if (object == null) {
	        return;
	      }
	      if (pathKey !== undefined && pathKey in toObject(object)) {
	        path = [pathKey];
	      }
	      var index = 0,
	          length = path.length;

	      while (object != null && index < length) {
	        object = object[path[index++]];
	      }
	      return (index && index == length) ? object : undefined;
	    }

	    /**
	     * The base implementation of `_.isEqual` without support for `this` binding
	     * `customizer` functions.
	     *
	     * @private
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @param {Function} [customizer] The function to customize comparing values.
	     * @param {boolean} [isLoose] Specify performing partial comparisons.
	     * @param {Array} [stackA] Tracks traversed `value` objects.
	     * @param {Array} [stackB] Tracks traversed `other` objects.
	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	     */
	    function baseIsEqual(value, other, customizer, isLoose, stackA, stackB) {
	      if (value === other) {
	        return true;
	      }
	      if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
	        return value !== value && other !== other;
	      }
	      return baseIsEqualDeep(value, other, baseIsEqual, customizer, isLoose, stackA, stackB);
	    }

	    /**
	     * A specialized version of `baseIsEqual` for arrays and objects which performs
	     * deep comparisons and tracks traversed objects enabling objects with circular
	     * references to be compared.
	     *
	     * @private
	     * @param {Object} object The object to compare.
	     * @param {Object} other The other object to compare.
	     * @param {Function} equalFunc The function to determine equivalents of values.
	     * @param {Function} [customizer] The function to customize comparing objects.
	     * @param {boolean} [isLoose] Specify performing partial comparisons.
	     * @param {Array} [stackA=[]] Tracks traversed `value` objects.
	     * @param {Array} [stackB=[]] Tracks traversed `other` objects.
	     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	     */
	    function baseIsEqualDeep(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
	      var objIsArr = isArray(object),
	          othIsArr = isArray(other),
	          objTag = arrayTag,
	          othTag = arrayTag;

	      if (!objIsArr) {
	        objTag = objToString.call(object);
	        if (objTag == argsTag) {
	          objTag = objectTag;
	        } else if (objTag != objectTag) {
	          objIsArr = isTypedArray(object);
	        }
	      }
	      if (!othIsArr) {
	        othTag = objToString.call(other);
	        if (othTag == argsTag) {
	          othTag = objectTag;
	        } else if (othTag != objectTag) {
	          othIsArr = isTypedArray(other);
	        }
	      }
	      var objIsObj = objTag == objectTag,
	          othIsObj = othTag == objectTag,
	          isSameTag = objTag == othTag;

	      if (isSameTag && !(objIsArr || objIsObj)) {
	        return equalByTag(object, other, objTag);
	      }
	      if (!isLoose) {
	        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
	            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

	        if (objIsWrapped || othIsWrapped) {
	          return equalFunc(objIsWrapped ? object.value() : object, othIsWrapped ? other.value() : other, customizer, isLoose, stackA, stackB);
	        }
	      }
	      if (!isSameTag) {
	        return false;
	      }
	      // Assume cyclic values are equal.
	      // For more information on detecting circular references see https://es5.github.io/#JO.
	      stackA || (stackA = []);
	      stackB || (stackB = []);

	      var length = stackA.length;
	      while (length--) {
	        if (stackA[length] == object) {
	          return stackB[length] == other;
	        }
	      }
	      // Add `object` and `other` to the stack of traversed objects.
	      stackA.push(object);
	      stackB.push(other);

	      var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isLoose, stackA, stackB);

	      stackA.pop();
	      stackB.pop();

	      return result;
	    }

	    /**
	     * The base implementation of `_.isMatch` without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Object} object The object to inspect.
	     * @param {Array} matchData The propery names, values, and compare flags to match.
	     * @param {Function} [customizer] The function to customize comparing objects.
	     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	     */
	    function baseIsMatch(object, matchData, customizer) {
	      var index = matchData.length,
	          length = index,
	          noCustomizer = !customizer;

	      if (object == null) {
	        return !length;
	      }
	      object = toObject(object);
	      while (index--) {
	        var data = matchData[index];
	        if ((noCustomizer && data[2])
	              ? data[1] !== object[data[0]]
	              : !(data[0] in object)
	            ) {
	          return false;
	        }
	      }
	      while (++index < length) {
	        data = matchData[index];
	        var key = data[0],
	            objValue = object[key],
	            srcValue = data[1];

	        if (noCustomizer && data[2]) {
	          if (objValue === undefined && !(key in object)) {
	            return false;
	          }
	        } else {
	          var result = customizer ? customizer(objValue, srcValue, key) : undefined;
	          if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, true) : result)) {
	            return false;
	          }
	        }
	      }
	      return true;
	    }

	    /**
	     * The base implementation of `_.map` without support for callback shorthands
	     * and `this` binding.
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array} Returns the new mapped array.
	     */
	    function baseMap(collection, iteratee) {
	      var index = -1,
	          result = isArrayLike(collection) ? Array(collection.length) : [];

	      baseEach(collection, function(value, key, collection) {
	        result[++index] = iteratee(value, key, collection);
	      });
	      return result;
	    }

	    /**
	     * The base implementation of `_.matches` which does not clone `source`.
	     *
	     * @private
	     * @param {Object} source The object of property values to match.
	     * @returns {Function} Returns the new function.
	     */
	    function baseMatches(source) {
	      var matchData = getMatchData(source);
	      if (matchData.length == 1 && matchData[0][2]) {
	        var key = matchData[0][0],
	            value = matchData[0][1];

	        return function(object) {
	          if (object == null) {
	            return false;
	          }
	          return object[key] === value && (value !== undefined || (key in toObject(object)));
	        };
	      }
	      return function(object) {
	        return baseIsMatch(object, matchData);
	      };
	    }

	    /**
	     * The base implementation of `_.matchesProperty` which does not clone `srcValue`.
	     *
	     * @private
	     * @param {string} path The path of the property to get.
	     * @param {*} srcValue The value to compare.
	     * @returns {Function} Returns the new function.
	     */
	    function baseMatchesProperty(path, srcValue) {
	      var isArr = isArray(path),
	          isCommon = isKey(path) && isStrictComparable(srcValue),
	          pathKey = (path + '');

	      path = toPath(path);
	      return function(object) {
	        if (object == null) {
	          return false;
	        }
	        var key = pathKey;
	        object = toObject(object);
	        if ((isArr || !isCommon) && !(key in object)) {
	          object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
	          if (object == null) {
	            return false;
	          }
	          key = last(path);
	          object = toObject(object);
	        }
	        return object[key] === srcValue
	          ? (srcValue !== undefined || (key in object))
	          : baseIsEqual(srcValue, object[key], undefined, true);
	      };
	    }

	    /**
	     * The base implementation of `_.merge` without support for argument juggling,
	     * multiple sources, and `this` binding `customizer` functions.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @param {Function} [customizer] The function to customize merged values.
	     * @param {Array} [stackA=[]] Tracks traversed source objects.
	     * @param {Array} [stackB=[]] Associates values with source counterparts.
	     * @returns {Object} Returns `object`.
	     */
	    function baseMerge(object, source, customizer, stackA, stackB) {
	      if (!isObject(object)) {
	        return object;
	      }
	      var isSrcArr = isArrayLike(source) && (isArray(source) || isTypedArray(source)),
	          props = isSrcArr ? undefined : keys(source);

	      arrayEach(props || source, function(srcValue, key) {
	        if (props) {
	          key = srcValue;
	          srcValue = source[key];
	        }
	        if (isObjectLike(srcValue)) {
	          stackA || (stackA = []);
	          stackB || (stackB = []);
	          baseMergeDeep(object, source, key, baseMerge, customizer, stackA, stackB);
	        }
	        else {
	          var value = object[key],
	              result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
	              isCommon = result === undefined;

	          if (isCommon) {
	            result = srcValue;
	          }
	          if ((result !== undefined || (isSrcArr && !(key in object))) &&
	              (isCommon || (result === result ? (result !== value) : (value === value)))) {
	            object[key] = result;
	          }
	        }
	      });
	      return object;
	    }

	    /**
	     * A specialized version of `baseMerge` for arrays and objects which performs
	     * deep merges and tracks traversed objects enabling objects with circular
	     * references to be merged.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @param {string} key The key of the value to merge.
	     * @param {Function} mergeFunc The function to merge values.
	     * @param {Function} [customizer] The function to customize merged values.
	     * @param {Array} [stackA=[]] Tracks traversed source objects.
	     * @param {Array} [stackB=[]] Associates values with source counterparts.
	     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	     */
	    function baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {
	      var length = stackA.length,
	          srcValue = source[key];

	      while (length--) {
	        if (stackA[length] == srcValue) {
	          object[key] = stackB[length];
	          return;
	        }
	      }
	      var value = object[key],
	          result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
	          isCommon = result === undefined;

	      if (isCommon) {
	        result = srcValue;
	        if (isArrayLike(srcValue) && (isArray(srcValue) || isTypedArray(srcValue))) {
	          result = isArray(value)
	            ? value
	            : (isArrayLike(value) ? arrayCopy(value) : []);
	        }
	        else if (isPlainObject(srcValue) || isArguments(srcValue)) {
	          result = isArguments(value)
	            ? toPlainObject(value)
	            : (isPlainObject(value) ? value : {});
	        }
	        else {
	          isCommon = false;
	        }
	      }
	      // Add the source value to the stack of traversed objects and associate
	      // it with its merged value.
	      stackA.push(srcValue);
	      stackB.push(result);

	      if (isCommon) {
	        // Recursively merge objects and arrays (susceptible to call stack limits).
	        object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB);
	      } else if (result === result ? (result !== value) : (value === value)) {
	        object[key] = result;
	      }
	    }

	    /**
	     * The base implementation of `_.property` without support for deep paths.
	     *
	     * @private
	     * @param {string} key The key of the property to get.
	     * @returns {Function} Returns the new function.
	     */
	    function baseProperty(key) {
	      return function(object) {
	        return object == null ? undefined : object[key];
	      };
	    }

	    /**
	     * A specialized version of `baseProperty` which supports deep paths.
	     *
	     * @private
	     * @param {Array|string} path The path of the property to get.
	     * @returns {Function} Returns the new function.
	     */
	    function basePropertyDeep(path) {
	      var pathKey = (path + '');
	      path = toPath(path);
	      return function(object) {
	        return baseGet(object, path, pathKey);
	      };
	    }

	    /**
	     * The base implementation of `_.pullAt` without support for individual
	     * index arguments and capturing the removed elements.
	     *
	     * @private
	     * @param {Array} array The array to modify.
	     * @param {number[]} indexes The indexes of elements to remove.
	     * @returns {Array} Returns `array`.
	     */
	    function basePullAt(array, indexes) {
	      var length = array ? indexes.length : 0;
	      while (length--) {
	        var index = indexes[length];
	        if (index != previous && isIndex(index)) {
	          var previous = index;
	          splice.call(array, index, 1);
	        }
	      }
	      return array;
	    }

	    /**
	     * The base implementation of `_.random` without support for argument juggling
	     * and returning floating-point numbers.
	     *
	     * @private
	     * @param {number} min The minimum possible value.
	     * @param {number} max The maximum possible value.
	     * @returns {number} Returns the random number.
	     */
	    function baseRandom(min, max) {
	      return min + nativeFloor(nativeRandom() * (max - min + 1));
	    }

	    /**
	     * The base implementation of `_.reduce` and `_.reduceRight` without support
	     * for callback shorthands and `this` binding, which iterates over `collection`
	     * using the provided `eachFunc`.
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {*} accumulator The initial value.
	     * @param {boolean} initFromCollection Specify using the first or last element
	     *  of `collection` as the initial value.
	     * @param {Function} eachFunc The function to iterate over `collection`.
	     * @returns {*} Returns the accumulated value.
	     */
	    function baseReduce(collection, iteratee, accumulator, initFromCollection, eachFunc) {
	      eachFunc(collection, function(value, index, collection) {
	        accumulator = initFromCollection
	          ? (initFromCollection = false, value)
	          : iteratee(accumulator, value, index, collection);
	      });
	      return accumulator;
	    }

	    /**
	     * The base implementation of `setData` without support for hot loop detection.
	     *
	     * @private
	     * @param {Function} func The function to associate metadata with.
	     * @param {*} data The metadata.
	     * @returns {Function} Returns `func`.
	     */
	    var baseSetData = !metaMap ? identity : function(func, data) {
	      metaMap.set(func, data);
	      return func;
	    };

	    /**
	     * The base implementation of `_.slice` without an iteratee call guard.
	     *
	     * @private
	     * @param {Array} array The array to slice.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns the slice of `array`.
	     */
	    function baseSlice(array, start, end) {
	      var index = -1,
	          length = array.length;

	      start = start == null ? 0 : (+start || 0);
	      if (start < 0) {
	        start = -start > length ? 0 : (length + start);
	      }
	      end = (end === undefined || end > length) ? length : (+end || 0);
	      if (end < 0) {
	        end += length;
	      }
	      length = start > end ? 0 : ((end - start) >>> 0);
	      start >>>= 0;

	      var result = Array(length);
	      while (++index < length) {
	        result[index] = array[index + start];
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.some` without support for callback shorthands
	     * and `this` binding.
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {boolean} Returns `true` if any element passes the predicate check,
	     *  else `false`.
	     */
	    function baseSome(collection, predicate) {
	      var result;

	      baseEach(collection, function(value, index, collection) {
	        result = predicate(value, index, collection);
	        return !result;
	      });
	      return !!result;
	    }

	    /**
	     * The base implementation of `_.sortBy` which uses `comparer` to define
	     * the sort order of `array` and replaces criteria objects with their
	     * corresponding values.
	     *
	     * @private
	     * @param {Array} array The array to sort.
	     * @param {Function} comparer The function to define sort order.
	     * @returns {Array} Returns `array`.
	     */
	    function baseSortBy(array, comparer) {
	      var length = array.length;

	      array.sort(comparer);
	      while (length--) {
	        array[length] = array[length].value;
	      }
	      return array;
	    }

	    /**
	     * The base implementation of `_.sortByOrder` without param guards.
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
	     * @param {boolean[]} orders The sort orders of `iteratees`.
	     * @returns {Array} Returns the new sorted array.
	     */
	    function baseSortByOrder(collection, iteratees, orders) {
	      var callback = getCallback(),
	          index = -1;

	      iteratees = arrayMap(iteratees, function(iteratee) { return callback(iteratee); });

	      var result = baseMap(collection, function(value) {
	        var criteria = arrayMap(iteratees, function(iteratee) { return iteratee(value); });
	        return { 'criteria': criteria, 'index': ++index, 'value': value };
	      });

	      return baseSortBy(result, function(object, other) {
	        return compareMultiple(object, other, orders);
	      });
	    }

	    /**
	     * The base implementation of `_.sum` without support for callback shorthands
	     * and `this` binding.
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {number} Returns the sum.
	     */
	    function baseSum(collection, iteratee) {
	      var result = 0;
	      baseEach(collection, function(value, index, collection) {
	        result += +iteratee(value, index, collection) || 0;
	      });
	      return result;
	    }

	    /**
	     * The base implementation of `_.uniq` without support for callback shorthands
	     * and `this` binding.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @param {Function} [iteratee] The function invoked per iteration.
	     * @returns {Array} Returns the new duplicate-value-free array.
	     */
	    function baseUniq(array, iteratee) {
	      var index = -1,
	          indexOf = getIndexOf(),
	          length = array.length,
	          isCommon = indexOf == baseIndexOf,
	          isLarge = isCommon && length >= LARGE_ARRAY_SIZE,
	          seen = isLarge ? createCache() : null,
	          result = [];

	      if (seen) {
	        indexOf = cacheIndexOf;
	        isCommon = false;
	      } else {
	        isLarge = false;
	        seen = iteratee ? [] : result;
	      }
	      outer:
	      while (++index < length) {
	        var value = array[index],
	            computed = iteratee ? iteratee(value, index, array) : value;

	        if (isCommon && value === value) {
	          var seenIndex = seen.length;
	          while (seenIndex--) {
	            if (seen[seenIndex] === computed) {
	              continue outer;
	            }
	          }
	          if (iteratee) {
	            seen.push(computed);
	          }
	          result.push(value);
	        }
	        else if (indexOf(seen, computed, 0) < 0) {
	          if (iteratee || isLarge) {
	            seen.push(computed);
	          }
	          result.push(value);
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.values` and `_.valuesIn` which creates an
	     * array of `object` property values corresponding to the property names
	     * of `props`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Array} props The property names to get values for.
	     * @returns {Object} Returns the array of property values.
	     */
	    function baseValues(object, props) {
	      var index = -1,
	          length = props.length,
	          result = Array(length);

	      while (++index < length) {
	        result[index] = object[props[index]];
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.dropRightWhile`, `_.dropWhile`, `_.takeRightWhile`,
	     * and `_.takeWhile` without support for callback shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array} array The array to query.
	     * @param {Function} predicate The function invoked per iteration.
	     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Array} Returns the slice of `array`.
	     */
	    function baseWhile(array, predicate, isDrop, fromRight) {
	      var length = array.length,
	          index = fromRight ? length : -1;

	      while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {}
	      return isDrop
	        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
	        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
	    }

	    /**
	     * The base implementation of `wrapperValue` which returns the result of
	     * performing a sequence of actions on the unwrapped `value`, where each
	     * successive action is supplied the return value of the previous.
	     *
	     * @private
	     * @param {*} value The unwrapped value.
	     * @param {Array} actions Actions to peform to resolve the unwrapped value.
	     * @returns {*} Returns the resolved value.
	     */
	    function baseWrapperValue(value, actions) {
	      var result = value;
	      if (result instanceof LazyWrapper) {
	        result = result.value();
	      }
	      var index = -1,
	          length = actions.length;

	      while (++index < length) {
	        var action = actions[index];
	        result = action.func.apply(action.thisArg, arrayPush([result], action.args));
	      }
	      return result;
	    }

	    /**
	     * Performs a binary search of `array` to determine the index at which `value`
	     * should be inserted into `array` in order to maintain its sort order.
	     *
	     * @private
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {boolean} [retHighest] Specify returning the highest qualified index.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     */
	    function binaryIndex(array, value, retHighest) {
	      var low = 0,
	          high = array ? array.length : low;

	      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
	        while (low < high) {
	          var mid = (low + high) >>> 1,
	              computed = array[mid];

	          if ((retHighest ? (computed <= value) : (computed < value)) && computed !== null) {
	            low = mid + 1;
	          } else {
	            high = mid;
	          }
	        }
	        return high;
	      }
	      return binaryIndexBy(array, value, identity, retHighest);
	    }

	    /**
	     * This function is like `binaryIndex` except that it invokes `iteratee` for
	     * `value` and each element of `array` to compute their sort ranking. The
	     * iteratee is invoked with one argument; (value).
	     *
	     * @private
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {boolean} [retHighest] Specify returning the highest qualified index.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     */
	    function binaryIndexBy(array, value, iteratee, retHighest) {
	      value = iteratee(value);

	      var low = 0,
	          high = array ? array.length : 0,
	          valIsNaN = value !== value,
	          valIsNull = value === null,
	          valIsUndef = value === undefined;

	      while (low < high) {
	        var mid = nativeFloor((low + high) / 2),
	            computed = iteratee(array[mid]),
	            isDef = computed !== undefined,
	            isReflexive = computed === computed;

	        if (valIsNaN) {
	          var setLow = isReflexive || retHighest;
	        } else if (valIsNull) {
	          setLow = isReflexive && isDef && (retHighest || computed != null);
	        } else if (valIsUndef) {
	          setLow = isReflexive && (retHighest || isDef);
	        } else if (computed == null) {
	          setLow = false;
	        } else {
	          setLow = retHighest ? (computed <= value) : (computed < value);
	        }
	        if (setLow) {
	          low = mid + 1;
	        } else {
	          high = mid;
	        }
	      }
	      return nativeMin(high, MAX_ARRAY_INDEX);
	    }

	    /**
	     * A specialized version of `baseCallback` which only supports `this` binding
	     * and specifying the number of arguments to provide to `func`.
	     *
	     * @private
	     * @param {Function} func The function to bind.
	     * @param {*} thisArg The `this` binding of `func`.
	     * @param {number} [argCount] The number of arguments to provide to `func`.
	     * @returns {Function} Returns the callback.
	     */
	    function bindCallback(func, thisArg, argCount) {
	      if (typeof func != 'function') {
	        return identity;
	      }
	      if (thisArg === undefined) {
	        return func;
	      }
	      switch (argCount) {
	        case 1: return function(value) {
	          return func.call(thisArg, value);
	        };
	        case 3: return function(value, index, collection) {
	          return func.call(thisArg, value, index, collection);
	        };
	        case 4: return function(accumulator, value, index, collection) {
	          return func.call(thisArg, accumulator, value, index, collection);
	        };
	        case 5: return function(value, other, key, object, source) {
	          return func.call(thisArg, value, other, key, object, source);
	        };
	      }
	      return function() {
	        return func.apply(thisArg, arguments);
	      };
	    }

	    /**
	     * Creates a clone of the given array buffer.
	     *
	     * @private
	     * @param {ArrayBuffer} buffer The array buffer to clone.
	     * @returns {ArrayBuffer} Returns the cloned array buffer.
	     */
	    function bufferClone(buffer) {
	      var result = new ArrayBuffer(buffer.byteLength),
	          view = new Uint8Array(result);

	      view.set(new Uint8Array(buffer));
	      return result;
	    }

	    /**
	     * Creates an array that is the composition of partially applied arguments,
	     * placeholders, and provided arguments into a single array of arguments.
	     *
	     * @private
	     * @param {Array|Object} args The provided arguments.
	     * @param {Array} partials The arguments to prepend to those provided.
	     * @param {Array} holders The `partials` placeholder indexes.
	     * @returns {Array} Returns the new array of composed arguments.
	     */
	    function composeArgs(args, partials, holders) {
	      var holdersLength = holders.length,
	          argsIndex = -1,
	          argsLength = nativeMax(args.length - holdersLength, 0),
	          leftIndex = -1,
	          leftLength = partials.length,
	          result = Array(leftLength + argsLength);

	      while (++leftIndex < leftLength) {
	        result[leftIndex] = partials[leftIndex];
	      }
	      while (++argsIndex < holdersLength) {
	        result[holders[argsIndex]] = args[argsIndex];
	      }
	      while (argsLength--) {
	        result[leftIndex++] = args[argsIndex++];
	      }
	      return result;
	    }

	    /**
	     * This function is like `composeArgs` except that the arguments composition
	     * is tailored for `_.partialRight`.
	     *
	     * @private
	     * @param {Array|Object} args The provided arguments.
	     * @param {Array} partials The arguments to append to those provided.
	     * @param {Array} holders The `partials` placeholder indexes.
	     * @returns {Array} Returns the new array of composed arguments.
	     */
	    function composeArgsRight(args, partials, holders) {
	      var holdersIndex = -1,
	          holdersLength = holders.length,
	          argsIndex = -1,
	          argsLength = nativeMax(args.length - holdersLength, 0),
	          rightIndex = -1,
	          rightLength = partials.length,
	          result = Array(argsLength + rightLength);

	      while (++argsIndex < argsLength) {
	        result[argsIndex] = args[argsIndex];
	      }
	      var offset = argsIndex;
	      while (++rightIndex < rightLength) {
	        result[offset + rightIndex] = partials[rightIndex];
	      }
	      while (++holdersIndex < holdersLength) {
	        result[offset + holders[holdersIndex]] = args[argsIndex++];
	      }
	      return result;
	    }

	    /**
	     * Creates a `_.countBy`, `_.groupBy`, `_.indexBy`, or `_.partition` function.
	     *
	     * @private
	     * @param {Function} setter The function to set keys and values of the accumulator object.
	     * @param {Function} [initializer] The function to initialize the accumulator object.
	     * @returns {Function} Returns the new aggregator function.
	     */
	    function createAggregator(setter, initializer) {
	      return function(collection, iteratee, thisArg) {
	        var result = initializer ? initializer() : {};
	        iteratee = getCallback(iteratee, thisArg, 3);

	        if (isArray(collection)) {
	          var index = -1,
	              length = collection.length;

	          while (++index < length) {
	            var value = collection[index];
	            setter(result, value, iteratee(value, index, collection), collection);
	          }
	        } else {
	          baseEach(collection, function(value, key, collection) {
	            setter(result, value, iteratee(value, key, collection), collection);
	          });
	        }
	        return result;
	      };
	    }

	    /**
	     * Creates a `_.assign`, `_.defaults`, or `_.merge` function.
	     *
	     * @private
	     * @param {Function} assigner The function to assign values.
	     * @returns {Function} Returns the new assigner function.
	     */
	    function createAssigner(assigner) {
	      return restParam(function(object, sources) {
	        var index = -1,
	            length = object == null ? 0 : sources.length,
	            customizer = length > 2 ? sources[length - 2] : undefined,
	            guard = length > 2 ? sources[2] : undefined,
	            thisArg = length > 1 ? sources[length - 1] : undefined;

	        if (typeof customizer == 'function') {
	          customizer = bindCallback(customizer, thisArg, 5);
	          length -= 2;
	        } else {
	          customizer = typeof thisArg == 'function' ? thisArg : undefined;
	          length -= (customizer ? 1 : 0);
	        }
	        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
	          customizer = length < 3 ? undefined : customizer;
	          length = 1;
	        }
	        while (++index < length) {
	          var source = sources[index];
	          if (source) {
	            assigner(object, source, customizer);
	          }
	        }
	        return object;
	      });
	    }

	    /**
	     * Creates a `baseEach` or `baseEachRight` function.
	     *
	     * @private
	     * @param {Function} eachFunc The function to iterate over a collection.
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new base function.
	     */
	    function createBaseEach(eachFunc, fromRight) {
	      return function(collection, iteratee) {
	        var length = collection ? getLength(collection) : 0;
	        if (!isLength(length)) {
	          return eachFunc(collection, iteratee);
	        }
	        var index = fromRight ? length : -1,
	            iterable = toObject(collection);

	        while ((fromRight ? index-- : ++index < length)) {
	          if (iteratee(iterable[index], index, iterable) === false) {
	            break;
	          }
	        }
	        return collection;
	      };
	    }

	    /**
	     * Creates a base function for `_.forIn` or `_.forInRight`.
	     *
	     * @private
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new base function.
	     */
	    function createBaseFor(fromRight) {
	      return function(object, iteratee, keysFunc) {
	        var iterable = toObject(object),
	            props = keysFunc(object),
	            length = props.length,
	            index = fromRight ? length : -1;

	        while ((fromRight ? index-- : ++index < length)) {
	          var key = props[index];
	          if (iteratee(iterable[key], key, iterable) === false) {
	            break;
	          }
	        }
	        return object;
	      };
	    }

	    /**
	     * Creates a function that wraps `func` and invokes it with the `this`
	     * binding of `thisArg`.
	     *
	     * @private
	     * @param {Function} func The function to bind.
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @returns {Function} Returns the new bound function.
	     */
	    function createBindWrapper(func, thisArg) {
	      var Ctor = createCtorWrapper(func);

	      function wrapper() {
	        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
	        return fn.apply(thisArg, arguments);
	      }
	      return wrapper;
	    }

	    /**
	     * Creates a `Set` cache object to optimize linear searches of large arrays.
	     *
	     * @private
	     * @param {Array} [values] The values to cache.
	     * @returns {null|Object} Returns the new cache object if `Set` is supported, else `null`.
	     */
	    function createCache(values) {
	      return (nativeCreate && Set) ? new SetCache(values) : null;
	    }

	    /**
	     * Creates a function that produces compound words out of the words in a
	     * given string.
	     *
	     * @private
	     * @param {Function} callback The function to combine each word.
	     * @returns {Function} Returns the new compounder function.
	     */
	    function createCompounder(callback) {
	      return function(string) {
	        var index = -1,
	            array = words(deburr(string)),
	            length = array.length,
	            result = '';

	        while (++index < length) {
	          result = callback(result, array[index], index);
	        }
	        return result;
	      };
	    }

	    /**
	     * Creates a function that produces an instance of `Ctor` regardless of
	     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
	     *
	     * @private
	     * @param {Function} Ctor The constructor to wrap.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createCtorWrapper(Ctor) {
	      return function() {
	        // Use a `switch` statement to work with class constructors.
	        // See http://ecma-international.org/ecma-262/6.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
	        // for more details.
	        var args = arguments;
	        switch (args.length) {
	          case 0: return new Ctor;
	          case 1: return new Ctor(args[0]);
	          case 2: return new Ctor(args[0], args[1]);
	          case 3: return new Ctor(args[0], args[1], args[2]);
	          case 4: return new Ctor(args[0], args[1], args[2], args[3]);
	          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
	          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
	          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
	        }
	        var thisBinding = baseCreate(Ctor.prototype),
	            result = Ctor.apply(thisBinding, args);

	        // Mimic the constructor's `return` behavior.
	        // See https://es5.github.io/#x13.2.2 for more details.
	        return isObject(result) ? result : thisBinding;
	      };
	    }

	    /**
	     * Creates a `_.curry` or `_.curryRight` function.
	     *
	     * @private
	     * @param {boolean} flag The curry bit flag.
	     * @returns {Function} Returns the new curry function.
	     */
	    function createCurry(flag) {
	      function curryFunc(func, arity, guard) {
	        if (guard && isIterateeCall(func, arity, guard)) {
	          arity = undefined;
	        }
	        var result = createWrapper(func, flag, undefined, undefined, undefined, undefined, undefined, arity);
	        result.placeholder = curryFunc.placeholder;
	        return result;
	      }
	      return curryFunc;
	    }

	    /**
	     * Creates a `_.defaults` or `_.defaultsDeep` function.
	     *
	     * @private
	     * @param {Function} assigner The function to assign values.
	     * @param {Function} customizer The function to customize assigned values.
	     * @returns {Function} Returns the new defaults function.
	     */
	    function createDefaults(assigner, customizer) {
	      return restParam(function(args) {
	        var object = args[0];
	        if (object == null) {
	          return object;
	        }
	        args.push(customizer);
	        return assigner.apply(undefined, args);
	      });
	    }

	    /**
	     * Creates a `_.max` or `_.min` function.
	     *
	     * @private
	     * @param {Function} comparator The function used to compare values.
	     * @param {*} exValue The initial extremum value.
	     * @returns {Function} Returns the new extremum function.
	     */
	    function createExtremum(comparator, exValue) {
	      return function(collection, iteratee, thisArg) {
	        if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
	          iteratee = undefined;
	        }
	        iteratee = getCallback(iteratee, thisArg, 3);
	        if (iteratee.length == 1) {
	          collection = isArray(collection) ? collection : toIterable(collection);
	          var result = arrayExtremum(collection, iteratee, comparator, exValue);
	          if (!(collection.length && result === exValue)) {
	            return result;
	          }
	        }
	        return baseExtremum(collection, iteratee, comparator, exValue);
	      };
	    }

	    /**
	     * Creates a `_.find` or `_.findLast` function.
	     *
	     * @private
	     * @param {Function} eachFunc The function to iterate over a collection.
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new find function.
	     */
	    function createFind(eachFunc, fromRight) {
	      return function(collection, predicate, thisArg) {
	        predicate = getCallback(predicate, thisArg, 3);
	        if (isArray(collection)) {
	          var index = baseFindIndex(collection, predicate, fromRight);
	          return index > -1 ? collection[index] : undefined;
	        }
	        return baseFind(collection, predicate, eachFunc);
	      };
	    }

	    /**
	     * Creates a `_.findIndex` or `_.findLastIndex` function.
	     *
	     * @private
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new find function.
	     */
	    function createFindIndex(fromRight) {
	      return function(array, predicate, thisArg) {
	        if (!(array && array.length)) {
	          return -1;
	        }
	        predicate = getCallback(predicate, thisArg, 3);
	        return baseFindIndex(array, predicate, fromRight);
	      };
	    }

	    /**
	     * Creates a `_.findKey` or `_.findLastKey` function.
	     *
	     * @private
	     * @param {Function} objectFunc The function to iterate over an object.
	     * @returns {Function} Returns the new find function.
	     */
	    function createFindKey(objectFunc) {
	      return function(object, predicate, thisArg) {
	        predicate = getCallback(predicate, thisArg, 3);
	        return baseFind(object, predicate, objectFunc, true);
	      };
	    }

	    /**
	     * Creates a `_.flow` or `_.flowRight` function.
	     *
	     * @private
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new flow function.
	     */
	    function createFlow(fromRight) {
	      return function() {
	        var wrapper,
	            length = arguments.length,
	            index = fromRight ? length : -1,
	            leftIndex = 0,
	            funcs = Array(length);

	        while ((fromRight ? index-- : ++index < length)) {
	          var func = funcs[leftIndex++] = arguments[index];
	          if (typeof func != 'function') {
	            throw new TypeError(FUNC_ERROR_TEXT);
	          }
	          if (!wrapper && LodashWrapper.prototype.thru && getFuncName(func) == 'wrapper') {
	            wrapper = new LodashWrapper([], true);
	          }
	        }
	        index = wrapper ? -1 : length;
	        while (++index < length) {
	          func = funcs[index];

	          var funcName = getFuncName(func),
	              data = funcName == 'wrapper' ? getData(func) : undefined;

	          if (data && isLaziable(data[0]) && data[1] == (ARY_FLAG | CURRY_FLAG | PARTIAL_FLAG | REARG_FLAG) && !data[4].length && data[9] == 1) {
	            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
	          } else {
	            wrapper = (func.length == 1 && isLaziable(func)) ? wrapper[funcName]() : wrapper.thru(func);
	          }
	        }
	        return function() {
	          var args = arguments,
	              value = args[0];

	          if (wrapper && args.length == 1 && isArray(value) && value.length >= LARGE_ARRAY_SIZE) {
	            return wrapper.plant(value).value();
	          }
	          var index = 0,
	              result = length ? funcs[index].apply(this, args) : value;

	          while (++index < length) {
	            result = funcs[index].call(this, result);
	          }
	          return result;
	        };
	      };
	    }

	    /**
	     * Creates a function for `_.forEach` or `_.forEachRight`.
	     *
	     * @private
	     * @param {Function} arrayFunc The function to iterate over an array.
	     * @param {Function} eachFunc The function to iterate over a collection.
	     * @returns {Function} Returns the new each function.
	     */
	    function createForEach(arrayFunc, eachFunc) {
	      return function(collection, iteratee, thisArg) {
	        return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))
	          ? arrayFunc(collection, iteratee)
	          : eachFunc(collection, bindCallback(iteratee, thisArg, 3));
	      };
	    }

	    /**
	     * Creates a function for `_.forIn` or `_.forInRight`.
	     *
	     * @private
	     * @param {Function} objectFunc The function to iterate over an object.
	     * @returns {Function} Returns the new each function.
	     */
	    function createForIn(objectFunc) {
	      return function(object, iteratee, thisArg) {
	        if (typeof iteratee != 'function' || thisArg !== undefined) {
	          iteratee = bindCallback(iteratee, thisArg, 3);
	        }
	        return objectFunc(object, iteratee, keysIn);
	      };
	    }

	    /**
	     * Creates a function for `_.forOwn` or `_.forOwnRight`.
	     *
	     * @private
	     * @param {Function} objectFunc The function to iterate over an object.
	     * @returns {Function} Returns the new each function.
	     */
	    function createForOwn(objectFunc) {
	      return function(object, iteratee, thisArg) {
	        if (typeof iteratee != 'function' || thisArg !== undefined) {
	          iteratee = bindCallback(iteratee, thisArg, 3);
	        }
	        return objectFunc(object, iteratee);
	      };
	    }

	    /**
	     * Creates a function for `_.mapKeys` or `_.mapValues`.
	     *
	     * @private
	     * @param {boolean} [isMapKeys] Specify mapping keys instead of values.
	     * @returns {Function} Returns the new map function.
	     */
	    function createObjectMapper(isMapKeys) {
	      return function(object, iteratee, thisArg) {
	        var result = {};
	        iteratee = getCallback(iteratee, thisArg, 3);

	        baseForOwn(object, function(value, key, object) {
	          var mapped = iteratee(value, key, object);
	          key = isMapKeys ? mapped : key;
	          value = isMapKeys ? value : mapped;
	          result[key] = value;
	        });
	        return result;
	      };
	    }

	    /**
	     * Creates a function for `_.padLeft` or `_.padRight`.
	     *
	     * @private
	     * @param {boolean} [fromRight] Specify padding from the right.
	     * @returns {Function} Returns the new pad function.
	     */
	    function createPadDir(fromRight) {
	      return function(string, length, chars) {
	        string = baseToString(string);
	        return (fromRight ? string : '') + createPadding(string, length, chars) + (fromRight ? '' : string);
	      };
	    }

	    /**
	     * Creates a `_.partial` or `_.partialRight` function.
	     *
	     * @private
	     * @param {boolean} flag The partial bit flag.
	     * @returns {Function} Returns the new partial function.
	     */
	    function createPartial(flag) {
	      var partialFunc = restParam(function(func, partials) {
	        var holders = replaceHolders(partials, partialFunc.placeholder);
	        return createWrapper(func, flag, undefined, partials, holders);
	      });
	      return partialFunc;
	    }

	    /**
	     * Creates a function for `_.reduce` or `_.reduceRight`.
	     *
	     * @private
	     * @param {Function} arrayFunc The function to iterate over an array.
	     * @param {Function} eachFunc The function to iterate over a collection.
	     * @returns {Function} Returns the new each function.
	     */
	    function createReduce(arrayFunc, eachFunc) {
	      return function(collection, iteratee, accumulator, thisArg) {
	        var initFromArray = arguments.length < 3;
	        return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))
	          ? arrayFunc(collection, iteratee, accumulator, initFromArray)
	          : baseReduce(collection, getCallback(iteratee, thisArg, 4), accumulator, initFromArray, eachFunc);
	      };
	    }

	    /**
	     * Creates a function that wraps `func` and invokes it with optional `this`
	     * binding of, partial application, and currying.
	     *
	     * @private
	     * @param {Function|string} func The function or method name to reference.
	     * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @param {Array} [partials] The arguments to prepend to those provided to the new function.
	     * @param {Array} [holders] The `partials` placeholder indexes.
	     * @param {Array} [partialsRight] The arguments to append to those provided to the new function.
	     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
	     * @param {Array} [argPos] The argument positions of the new function.
	     * @param {number} [ary] The arity cap of `func`.
	     * @param {number} [arity] The arity of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
	      var isAry = bitmask & ARY_FLAG,
	          isBind = bitmask & BIND_FLAG,
	          isBindKey = bitmask & BIND_KEY_FLAG,
	          isCurry = bitmask & CURRY_FLAG,
	          isCurryBound = bitmask & CURRY_BOUND_FLAG,
	          isCurryRight = bitmask & CURRY_RIGHT_FLAG,
	          Ctor = isBindKey ? undefined : createCtorWrapper(func);

	      function wrapper() {
	        // Avoid `arguments` object use disqualifying optimizations by
	        // converting it to an array before providing it to other functions.
	        var length = arguments.length,
	            index = length,
	            args = Array(length);

	        while (index--) {
	          args[index] = arguments[index];
	        }
	        if (partials) {
	          args = composeArgs(args, partials, holders);
	        }
	        if (partialsRight) {
	          args = composeArgsRight(args, partialsRight, holdersRight);
	        }
	        if (isCurry || isCurryRight) {
	          var placeholder = wrapper.placeholder,
	              argsHolders = replaceHolders(args, placeholder);

	          length -= argsHolders.length;
	          if (length < arity) {
	            var newArgPos = argPos ? arrayCopy(argPos) : undefined,
	                newArity = nativeMax(arity - length, 0),
	                newsHolders = isCurry ? argsHolders : undefined,
	                newHoldersRight = isCurry ? undefined : argsHolders,
	                newPartials = isCurry ? args : undefined,
	                newPartialsRight = isCurry ? undefined : args;

	            bitmask |= (isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG);
	            bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);

	            if (!isCurryBound) {
	              bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
	            }
	            var newData = [func, bitmask, thisArg, newPartials, newsHolders, newPartialsRight, newHoldersRight, newArgPos, ary, newArity],
	                result = createHybridWrapper.apply(undefined, newData);

	            if (isLaziable(func)) {
	              setData(result, newData);
	            }
	            result.placeholder = placeholder;
	            return result;
	          }
	        }
	        var thisBinding = isBind ? thisArg : this,
	            fn = isBindKey ? thisBinding[func] : func;

	        if (argPos) {
	          args = reorder(args, argPos);
	        }
	        if (isAry && ary < args.length) {
	          args.length = ary;
	        }
	        if (this && this !== root && this instanceof wrapper) {
	          fn = Ctor || createCtorWrapper(func);
	        }
	        return fn.apply(thisBinding, args);
	      }
	      return wrapper;
	    }

	    /**
	     * Creates the padding required for `string` based on the given `length`.
	     * The `chars` string is truncated if the number of characters exceeds `length`.
	     *
	     * @private
	     * @param {string} string The string to create padding for.
	     * @param {number} [length=0] The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the pad for `string`.
	     */
	    function createPadding(string, length, chars) {
	      var strLength = string.length;
	      length = +length;

	      if (strLength >= length || !nativeIsFinite(length)) {
	        return '';
	      }
	      var padLength = length - strLength;
	      chars = chars == null ? ' ' : (chars + '');
	      return repeat(chars, nativeCeil(padLength / chars.length)).slice(0, padLength);
	    }

	    /**
	     * Creates a function that wraps `func` and invokes it with the optional `this`
	     * binding of `thisArg` and the `partials` prepended to those provided to
	     * the wrapper.
	     *
	     * @private
	     * @param {Function} func The function to partially apply arguments to.
	     * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
	     * @param {*} thisArg The `this` binding of `func`.
	     * @param {Array} partials The arguments to prepend to those provided to the new function.
	     * @returns {Function} Returns the new bound function.
	     */
	    function createPartialWrapper(func, bitmask, thisArg, partials) {
	      var isBind = bitmask & BIND_FLAG,
	          Ctor = createCtorWrapper(func);

	      function wrapper() {
	        // Avoid `arguments` object use disqualifying optimizations by
	        // converting it to an array before providing it `func`.
	        var argsIndex = -1,
	            argsLength = arguments.length,
	            leftIndex = -1,
	            leftLength = partials.length,
	            args = Array(leftLength + argsLength);

	        while (++leftIndex < leftLength) {
	          args[leftIndex] = partials[leftIndex];
	        }
	        while (argsLength--) {
	          args[leftIndex++] = arguments[++argsIndex];
	        }
	        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
	        return fn.apply(isBind ? thisArg : this, args);
	      }
	      return wrapper;
	    }

	    /**
	     * Creates a `_.ceil`, `_.floor`, or `_.round` function.
	     *
	     * @private
	     * @param {string} methodName The name of the `Math` method to use when rounding.
	     * @returns {Function} Returns the new round function.
	     */
	    function createRound(methodName) {
	      var func = Math[methodName];
	      return function(number, precision) {
	        precision = precision === undefined ? 0 : (+precision || 0);
	        if (precision) {
	          precision = pow(10, precision);
	          return func(number * precision) / precision;
	        }
	        return func(number);
	      };
	    }

	    /**
	     * Creates a `_.sortedIndex` or `_.sortedLastIndex` function.
	     *
	     * @private
	     * @param {boolean} [retHighest] Specify returning the highest qualified index.
	     * @returns {Function} Returns the new index function.
	     */
	    function createSortedIndex(retHighest) {
	      return function(array, value, iteratee, thisArg) {
	        var callback = getCallback(iteratee);
	        return (iteratee == null && callback === baseCallback)
	          ? binaryIndex(array, value, retHighest)
	          : binaryIndexBy(array, value, callback(iteratee, thisArg, 1), retHighest);
	      };
	    }

	    /**
	     * Creates a function that either curries or invokes `func` with optional
	     * `this` binding and partially applied arguments.
	     *
	     * @private
	     * @param {Function|string} func The function or method name to reference.
	     * @param {number} bitmask The bitmask of flags.
	     *  The bitmask may be composed of the following flags:
	     *     1 - `_.bind`
	     *     2 - `_.bindKey`
	     *     4 - `_.curry` or `_.curryRight` of a bound function
	     *     8 - `_.curry`
	     *    16 - `_.curryRight`
	     *    32 - `_.partial`
	     *    64 - `_.partialRight`
	     *   128 - `_.rearg`
	     *   256 - `_.ary`
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @param {Array} [partials] The arguments to be partially applied.
	     * @param {Array} [holders] The `partials` placeholder indexes.
	     * @param {Array} [argPos] The argument positions of the new function.
	     * @param {number} [ary] The arity cap of `func`.
	     * @param {number} [arity] The arity of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
	      var isBindKey = bitmask & BIND_KEY_FLAG;
	      if (!isBindKey && typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      var length = partials ? partials.length : 0;
	      if (!length) {
	        bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
	        partials = holders = undefined;
	      }
	      length -= (holders ? holders.length : 0);
	      if (bitmask & PARTIAL_RIGHT_FLAG) {
	        var partialsRight = partials,
	            holdersRight = holders;

	        partials = holders = undefined;
	      }
	      var data = isBindKey ? undefined : getData(func),
	          newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];

	      if (data) {
	        mergeData(newData, data);
	        bitmask = newData[1];
	        arity = newData[9];
	      }
	      newData[9] = arity == null
	        ? (isBindKey ? 0 : func.length)
	        : (nativeMax(arity - length, 0) || 0);

	      if (bitmask == BIND_FLAG) {
	        var result = createBindWrapper(newData[0], newData[2]);
	      } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !newData[4].length) {
	        result = createPartialWrapper.apply(undefined, newData);
	      } else {
	        result = createHybridWrapper.apply(undefined, newData);
	      }
	      var setter = data ? baseSetData : setData;
	      return setter(result, newData);
	    }

	    /**
	     * A specialized version of `baseIsEqualDeep` for arrays with support for
	     * partial deep comparisons.
	     *
	     * @private
	     * @param {Array} array The array to compare.
	     * @param {Array} other The other array to compare.
	     * @param {Function} equalFunc The function to determine equivalents of values.
	     * @param {Function} [customizer] The function to customize comparing arrays.
	     * @param {boolean} [isLoose] Specify performing partial comparisons.
	     * @param {Array} [stackA] Tracks traversed `value` objects.
	     * @param {Array} [stackB] Tracks traversed `other` objects.
	     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
	     */
	    function equalArrays(array, other, equalFunc, customizer, isLoose, stackA, stackB) {
	      var index = -1,
	          arrLength = array.length,
	          othLength = other.length;

	      if (arrLength != othLength && !(isLoose && othLength > arrLength)) {
	        return false;
	      }
	      // Ignore non-index properties.
	      while (++index < arrLength) {
	        var arrValue = array[index],
	            othValue = other[index],
	            result = customizer ? customizer(isLoose ? othValue : arrValue, isLoose ? arrValue : othValue, index) : undefined;

	        if (result !== undefined) {
	          if (result) {
	            continue;
	          }
	          return false;
	        }
	        // Recursively compare arrays (susceptible to call stack limits).
	        if (isLoose) {
	          if (!arraySome(other, function(othValue) {
	                return arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB);
	              })) {
	            return false;
	          }
	        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB))) {
	          return false;
	        }
	      }
	      return true;
	    }

	    /**
	     * A specialized version of `baseIsEqualDeep` for comparing objects of
	     * the same `toStringTag`.
	     *
	     * **Note:** This function only supports comparing values with tags of
	     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	     *
	     * @private
	     * @param {Object} object The object to compare.
	     * @param {Object} other The other object to compare.
	     * @param {string} tag The `toStringTag` of the objects to compare.
	     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	     */
	    function equalByTag(object, other, tag) {
	      switch (tag) {
	        case boolTag:
	        case dateTag:
	          // Coerce dates and booleans to numbers, dates to milliseconds and booleans
	          // to `1` or `0` treating invalid dates coerced to `NaN` as not equal.
	          return +object == +other;

	        case errorTag:
	          return object.name == other.name && object.message == other.message;

	        case numberTag:
	          // Treat `NaN` vs. `NaN` as equal.
	          return (object != +object)
	            ? other != +other
	            : object == +other;

	        case regexpTag:
	        case stringTag:
	          // Coerce regexes to strings and treat strings primitives and string
	          // objects as equal. See https://es5.github.io/#x15.10.6.4 for more details.
	          return object == (other + '');
	      }
	      return false;
	    }

	    /**
	     * A specialized version of `baseIsEqualDeep` for objects with support for
	     * partial deep comparisons.
	     *
	     * @private
	     * @param {Object} object The object to compare.
	     * @param {Object} other The other object to compare.
	     * @param {Function} equalFunc The function to determine equivalents of values.
	     * @param {Function} [customizer] The function to customize comparing values.
	     * @param {boolean} [isLoose] Specify performing partial comparisons.
	     * @param {Array} [stackA] Tracks traversed `value` objects.
	     * @param {Array} [stackB] Tracks traversed `other` objects.
	     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	     */
	    function equalObjects(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
	      var objProps = keys(object),
	          objLength = objProps.length,
	          othProps = keys(other),
	          othLength = othProps.length;

	      if (objLength != othLength && !isLoose) {
	        return false;
	      }
	      var index = objLength;
	      while (index--) {
	        var key = objProps[index];
	        if (!(isLoose ? key in other : hasOwnProperty.call(other, key))) {
	          return false;
	        }
	      }
	      var skipCtor = isLoose;
	      while (++index < objLength) {
	        key = objProps[index];
	        var objValue = object[key],
	            othValue = other[key],
	            result = customizer ? customizer(isLoose ? othValue : objValue, isLoose? objValue : othValue, key) : undefined;

	        // Recursively compare objects (susceptible to call stack limits).
	        if (!(result === undefined ? equalFunc(objValue, othValue, customizer, isLoose, stackA, stackB) : result)) {
	          return false;
	        }
	        skipCtor || (skipCtor = key == 'constructor');
	      }
	      if (!skipCtor) {
	        var objCtor = object.constructor,
	            othCtor = other.constructor;

	        // Non `Object` object instances with different constructors are not equal.
	        if (objCtor != othCtor &&
	            ('constructor' in object && 'constructor' in other) &&
	            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
	              typeof othCtor == 'function' && othCtor instanceof othCtor)) {
	          return false;
	        }
	      }
	      return true;
	    }

	    /**
	     * Gets the appropriate "callback" function. If the `_.callback` method is
	     * customized this function returns the custom method, otherwise it returns
	     * the `baseCallback` function. If arguments are provided the chosen function
	     * is invoked with them and its result is returned.
	     *
	     * @private
	     * @returns {Function} Returns the chosen function or its result.
	     */
	    function getCallback(func, thisArg, argCount) {
	      var result = lodash.callback || callback;
	      result = result === callback ? baseCallback : result;
	      return argCount ? result(func, thisArg, argCount) : result;
	    }

	    /**
	     * Gets metadata for `func`.
	     *
	     * @private
	     * @param {Function} func The function to query.
	     * @returns {*} Returns the metadata for `func`.
	     */
	    var getData = !metaMap ? noop : function(func) {
	      return metaMap.get(func);
	    };

	    /**
	     * Gets the name of `func`.
	     *
	     * @private
	     * @param {Function} func The function to query.
	     * @returns {string} Returns the function name.
	     */
	    function getFuncName(func) {
	      var result = func.name,
	          array = realNames[result],
	          length = array ? array.length : 0;

	      while (length--) {
	        var data = array[length],
	            otherFunc = data.func;
	        if (otherFunc == null || otherFunc == func) {
	          return data.name;
	        }
	      }
	      return result;
	    }

	    /**
	     * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
	     * customized this function returns the custom method, otherwise it returns
	     * the `baseIndexOf` function. If arguments are provided the chosen function
	     * is invoked with them and its result is returned.
	     *
	     * @private
	     * @returns {Function|number} Returns the chosen function or its result.
	     */
	    function getIndexOf(collection, target, fromIndex) {
	      var result = lodash.indexOf || indexOf;
	      result = result === indexOf ? baseIndexOf : result;
	      return collection ? result(collection, target, fromIndex) : result;
	    }

	    /**
	     * Gets the "length" property value of `object`.
	     *
	     * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
	     * that affects Safari on at least iOS 8.1-8.3 ARM64.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {*} Returns the "length" value.
	     */
	    var getLength = baseProperty('length');

	    /**
	     * Gets the propery names, values, and compare flags of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the match data of `object`.
	     */
	    function getMatchData(object) {
	      var result = pairs(object),
	          length = result.length;

	      while (length--) {
	        result[length][2] = isStrictComparable(result[length][1]);
	      }
	      return result;
	    }

	    /**
	     * Gets the native function at `key` of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {string} key The key of the method to get.
	     * @returns {*} Returns the function if it's native, else `undefined`.
	     */
	    function getNative(object, key) {
	      var value = object == null ? undefined : object[key];
	      return isNative(value) ? value : undefined;
	    }

	    /**
	     * Gets the view, applying any `transforms` to the `start` and `end` positions.
	     *
	     * @private
	     * @param {number} start The start of the view.
	     * @param {number} end The end of the view.
	     * @param {Array} transforms The transformations to apply to the view.
	     * @returns {Object} Returns an object containing the `start` and `end`
	     *  positions of the view.
	     */
	    function getView(start, end, transforms) {
	      var index = -1,
	          length = transforms.length;

	      while (++index < length) {
	        var data = transforms[index],
	            size = data.size;

	        switch (data.type) {
	          case 'drop':      start += size; break;
	          case 'dropRight': end -= size; break;
	          case 'take':      end = nativeMin(end, start + size); break;
	          case 'takeRight': start = nativeMax(start, end - size); break;
	        }
	      }
	      return { 'start': start, 'end': end };
	    }

	    /**
	     * Initializes an array clone.
	     *
	     * @private
	     * @param {Array} array The array to clone.
	     * @returns {Array} Returns the initialized clone.
	     */
	    function initCloneArray(array) {
	      var length = array.length,
	          result = new array.constructor(length);

	      // Add array properties assigned by `RegExp#exec`.
	      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
	        result.index = array.index;
	        result.input = array.input;
	      }
	      return result;
	    }

	    /**
	     * Initializes an object clone.
	     *
	     * @private
	     * @param {Object} object The object to clone.
	     * @returns {Object} Returns the initialized clone.
	     */
	    function initCloneObject(object) {
	      var Ctor = object.constructor;
	      if (!(typeof Ctor == 'function' && Ctor instanceof Ctor)) {
	        Ctor = Object;
	      }
	      return new Ctor;
	    }

	    /**
	     * Initializes an object clone based on its `toStringTag`.
	     *
	     * **Note:** This function only supports cloning values with tags of
	     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	     *
	     * @private
	     * @param {Object} object The object to clone.
	     * @param {string} tag The `toStringTag` of the object to clone.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @returns {Object} Returns the initialized clone.
	     */
	    function initCloneByTag(object, tag, isDeep) {
	      var Ctor = object.constructor;
	      switch (tag) {
	        case arrayBufferTag:
	          return bufferClone(object);

	        case boolTag:
	        case dateTag:
	          return new Ctor(+object);

	        case float32Tag: case float64Tag:
	        case int8Tag: case int16Tag: case int32Tag:
	        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
	          var buffer = object.buffer;
	          return new Ctor(isDeep ? bufferClone(buffer) : buffer, object.byteOffset, object.length);

	        case numberTag:
	        case stringTag:
	          return new Ctor(object);

	        case regexpTag:
	          var result = new Ctor(object.source, reFlags.exec(object));
	          result.lastIndex = object.lastIndex;
	      }
	      return result;
	    }

	    /**
	     * Invokes the method at `path` on `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the method to invoke.
	     * @param {Array} args The arguments to invoke the method with.
	     * @returns {*} Returns the result of the invoked method.
	     */
	    function invokePath(object, path, args) {
	      if (object != null && !isKey(path, object)) {
	        path = toPath(path);
	        object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
	        path = last(path);
	      }
	      var func = object == null ? object : object[path];
	      return func == null ? undefined : func.apply(object, args);
	    }

	    /**
	     * Checks if `value` is array-like.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	     */
	    function isArrayLike(value) {
	      return value != null && isLength(getLength(value));
	    }

	    /**
	     * Checks if `value` is a valid array-like index.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	     */
	    function isIndex(value, length) {
	      value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
	      length = length == null ? MAX_SAFE_INTEGER : length;
	      return value > -1 && value % 1 == 0 && value < length;
	    }

	    /**
	     * Checks if the provided arguments are from an iteratee call.
	     *
	     * @private
	     * @param {*} value The potential iteratee value argument.
	     * @param {*} index The potential iteratee index or key argument.
	     * @param {*} object The potential iteratee object argument.
	     * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.
	     */
	    function isIterateeCall(value, index, object) {
	      if (!isObject(object)) {
	        return false;
	      }
	      var type = typeof index;
	      if (type == 'number'
	          ? (isArrayLike(object) && isIndex(index, object.length))
	          : (type == 'string' && index in object)) {
	        var other = object[index];
	        return value === value ? (value === other) : (other !== other);
	      }
	      return false;
	    }

	    /**
	     * Checks if `value` is a property name and not a property path.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @param {Object} [object] The object to query keys on.
	     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
	     */
	    function isKey(value, object) {
	      var type = typeof value;
	      if ((type == 'string' && reIsPlainProp.test(value)) || type == 'number') {
	        return true;
	      }
	      if (isArray(value)) {
	        return false;
	      }
	      var result = !reIsDeepProp.test(value);
	      return result || (object != null && value in toObject(object));
	    }

	    /**
	     * Checks if `func` has a lazy counterpart.
	     *
	     * @private
	     * @param {Function} func The function to check.
	     * @returns {boolean} Returns `true` if `func` has a lazy counterpart, else `false`.
	     */
	    function isLaziable(func) {
	      var funcName = getFuncName(func);
	      if (!(funcName in LazyWrapper.prototype)) {
	        return false;
	      }
	      var other = lodash[funcName];
	      if (func === other) {
	        return true;
	      }
	      var data = getData(other);
	      return !!data && func === data[0];
	    }

	    /**
	     * Checks if `value` is a valid array-like length.
	     *
	     * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	     */
	    function isLength(value) {
	      return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	    }

	    /**
	     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` if suitable for strict
	     *  equality comparisons, else `false`.
	     */
	    function isStrictComparable(value) {
	      return value === value && !isObject(value);
	    }

	    /**
	     * Merges the function metadata of `source` into `data`.
	     *
	     * Merging metadata reduces the number of wrappers required to invoke a function.
	     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
	     * may be applied regardless of execution order. Methods like `_.ary` and `_.rearg`
	     * augment function arguments, making the order in which they are executed important,
	     * preventing the merging of metadata. However, we make an exception for a safe
	     * common case where curried functions have `_.ary` and or `_.rearg` applied.
	     *
	     * @private
	     * @param {Array} data The destination metadata.
	     * @param {Array} source The source metadata.
	     * @returns {Array} Returns `data`.
	     */
	    function mergeData(data, source) {
	      var bitmask = data[1],
	          srcBitmask = source[1],
	          newBitmask = bitmask | srcBitmask,
	          isCommon = newBitmask < ARY_FLAG;

	      var isCombo =
	        (srcBitmask == ARY_FLAG && bitmask == CURRY_FLAG) ||
	        (srcBitmask == ARY_FLAG && bitmask == REARG_FLAG && data[7].length <= source[8]) ||
	        (srcBitmask == (ARY_FLAG | REARG_FLAG) && bitmask == CURRY_FLAG);

	      // Exit early if metadata can't be merged.
	      if (!(isCommon || isCombo)) {
	        return data;
	      }
	      // Use source `thisArg` if available.
	      if (srcBitmask & BIND_FLAG) {
	        data[2] = source[2];
	        // Set when currying a bound function.
	        newBitmask |= (bitmask & BIND_FLAG) ? 0 : CURRY_BOUND_FLAG;
	      }
	      // Compose partial arguments.
	      var value = source[3];
	      if (value) {
	        var partials = data[3];
	        data[3] = partials ? composeArgs(partials, value, source[4]) : arrayCopy(value);
	        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : arrayCopy(source[4]);
	      }
	      // Compose partial right arguments.
	      value = source[5];
	      if (value) {
	        partials = data[5];
	        data[5] = partials ? composeArgsRight(partials, value, source[6]) : arrayCopy(value);
	        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : arrayCopy(source[6]);
	      }
	      // Use source `argPos` if available.
	      value = source[7];
	      if (value) {
	        data[7] = arrayCopy(value);
	      }
	      // Use source `ary` if it's smaller.
	      if (srcBitmask & ARY_FLAG) {
	        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
	      }
	      // Use source `arity` if one is not provided.
	      if (data[9] == null) {
	        data[9] = source[9];
	      }
	      // Use source `func` and merge bitmasks.
	      data[0] = source[0];
	      data[1] = newBitmask;

	      return data;
	    }

	    /**
	     * Used by `_.defaultsDeep` to customize its `_.merge` use.
	     *
	     * @private
	     * @param {*} objectValue The destination object property value.
	     * @param {*} sourceValue The source object property value.
	     * @returns {*} Returns the value to assign to the destination object.
	     */
	    function mergeDefaults(objectValue, sourceValue) {
	      return objectValue === undefined ? sourceValue : merge(objectValue, sourceValue, mergeDefaults);
	    }

	    /**
	     * A specialized version of `_.pick` which picks `object` properties specified
	     * by `props`.
	     *
	     * @private
	     * @param {Object} object The source object.
	     * @param {string[]} props The property names to pick.
	     * @returns {Object} Returns the new object.
	     */
	    function pickByArray(object, props) {
	      object = toObject(object);

	      var index = -1,
	          length = props.length,
	          result = {};

	      while (++index < length) {
	        var key = props[index];
	        if (key in object) {
	          result[key] = object[key];
	        }
	      }
	      return result;
	    }

	    /**
	     * A specialized version of `_.pick` which picks `object` properties `predicate`
	     * returns truthy for.
	     *
	     * @private
	     * @param {Object} object The source object.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {Object} Returns the new object.
	     */
	    function pickByCallback(object, predicate) {
	      var result = {};
	      baseForIn(object, function(value, key, object) {
	        if (predicate(value, key, object)) {
	          result[key] = value;
	        }
	      });
	      return result;
	    }

	    /**
	     * Reorder `array` according to the specified indexes where the element at
	     * the first index is assigned as the first element, the element at
	     * the second index is assigned as the second element, and so on.
	     *
	     * @private
	     * @param {Array} array The array to reorder.
	     * @param {Array} indexes The arranged array indexes.
	     * @returns {Array} Returns `array`.
	     */
	    function reorder(array, indexes) {
	      var arrLength = array.length,
	          length = nativeMin(indexes.length, arrLength),
	          oldArray = arrayCopy(array);

	      while (length--) {
	        var index = indexes[length];
	        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
	      }
	      return array;
	    }

	    /**
	     * Sets metadata for `func`.
	     *
	     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
	     * period of time, it will trip its breaker and transition to an identity function
	     * to avoid garbage collection pauses in V8. See [V8 issue 2070](https://code.google.com/p/v8/issues/detail?id=2070)
	     * for more details.
	     *
	     * @private
	     * @param {Function} func The function to associate metadata with.
	     * @param {*} data The metadata.
	     * @returns {Function} Returns `func`.
	     */
	    var setData = (function() {
	      var count = 0,
	          lastCalled = 0;

	      return function(key, value) {
	        var stamp = now(),
	            remaining = HOT_SPAN - (stamp - lastCalled);

	        lastCalled = stamp;
	        if (remaining > 0) {
	          if (++count >= HOT_COUNT) {
	            return key;
	          }
	        } else {
	          count = 0;
	        }
	        return baseSetData(key, value);
	      };
	    }());

	    /**
	     * A fallback implementation of `Object.keys` which creates an array of the
	     * own enumerable property names of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     */
	    function shimKeys(object) {
	      var props = keysIn(object),
	          propsLength = props.length,
	          length = propsLength && object.length;

	      var allowIndexes = !!length && isLength(length) &&
	        (isArray(object) || isArguments(object));

	      var index = -1,
	          result = [];

	      while (++index < propsLength) {
	        var key = props[index];
	        if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
	          result.push(key);
	        }
	      }
	      return result;
	    }

	    /**
	     * Converts `value` to an array-like object if it's not one.
	     *
	     * @private
	     * @param {*} value The value to process.
	     * @returns {Array|Object} Returns the array-like object.
	     */
	    function toIterable(value) {
	      if (value == null) {
	        return [];
	      }
	      if (!isArrayLike(value)) {
	        return values(value);
	      }
	      return isObject(value) ? value : Object(value);
	    }

	    /**
	     * Converts `value` to an object if it's not one.
	     *
	     * @private
	     * @param {*} value The value to process.
	     * @returns {Object} Returns the object.
	     */
	    function toObject(value) {
	      return isObject(value) ? value : Object(value);
	    }

	    /**
	     * Converts `value` to property path array if it's not one.
	     *
	     * @private
	     * @param {*} value The value to process.
	     * @returns {Array} Returns the property path array.
	     */
	    function toPath(value) {
	      if (isArray(value)) {
	        return value;
	      }
	      var result = [];
	      baseToString(value).replace(rePropName, function(match, number, quote, string) {
	        result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
	      });
	      return result;
	    }

	    /**
	     * Creates a clone of `wrapper`.
	     *
	     * @private
	     * @param {Object} wrapper The wrapper to clone.
	     * @returns {Object} Returns the cloned wrapper.
	     */
	    function wrapperClone(wrapper) {
	      return wrapper instanceof LazyWrapper
	        ? wrapper.clone()
	        : new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__, arrayCopy(wrapper.__actions__));
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates an array of elements split into groups the length of `size`.
	     * If `collection` can't be split evenly, the final chunk will be the remaining
	     * elements.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to process.
	     * @param {number} [size=1] The length of each chunk.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Array} Returns the new array containing chunks.
	     * @example
	     *
	     * _.chunk(['a', 'b', 'c', 'd'], 2);
	     * // => [['a', 'b'], ['c', 'd']]
	     *
	     * _.chunk(['a', 'b', 'c', 'd'], 3);
	     * // => [['a', 'b', 'c'], ['d']]
	     */
	    function chunk(array, size, guard) {
	      if (guard ? isIterateeCall(array, size, guard) : size == null) {
	        size = 1;
	      } else {
	        size = nativeMax(nativeFloor(size) || 1, 1);
	      }
	      var index = 0,
	          length = array ? array.length : 0,
	          resIndex = -1,
	          result = Array(nativeCeil(length / size));

	      while (index < length) {
	        result[++resIndex] = baseSlice(array, index, (index += size));
	      }
	      return result;
	    }

	    /**
	     * Creates an array with all falsey values removed. The values `false`, `null`,
	     * `0`, `""`, `undefined`, and `NaN` are falsey.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to compact.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * _.compact([0, 1, false, 2, '', 3]);
	     * // => [1, 2, 3]
	     */
	    function compact(array) {
	      var index = -1,
	          length = array ? array.length : 0,
	          resIndex = -1,
	          result = [];

	      while (++index < length) {
	        var value = array[index];
	        if (value) {
	          result[++resIndex] = value;
	        }
	      }
	      return result;
	    }

	    /**
	     * Creates an array of unique `array` values not included in the other
	     * provided arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {...Array} [values] The arrays of values to exclude.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * _.difference([1, 2, 3], [4, 2]);
	     * // => [1, 3]
	     */
	    var difference = restParam(function(array, values) {
	      return (isObjectLike(array) && isArrayLike(array))
	        ? baseDifference(array, baseFlatten(values, false, true))
	        : [];
	    });

	    /**
	     * Creates a slice of `array` with `n` elements dropped from the beginning.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to drop.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.drop([1, 2, 3]);
	     * // => [2, 3]
	     *
	     * _.drop([1, 2, 3], 2);
	     * // => [3]
	     *
	     * _.drop([1, 2, 3], 5);
	     * // => []
	     *
	     * _.drop([1, 2, 3], 0);
	     * // => [1, 2, 3]
	     */
	    function drop(array, n, guard) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return [];
	      }
	      if (guard ? isIterateeCall(array, n, guard) : n == null) {
	        n = 1;
	      }
	      return baseSlice(array, n < 0 ? 0 : n);
	    }

	    /**
	     * Creates a slice of `array` with `n` elements dropped from the end.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to drop.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.dropRight([1, 2, 3]);
	     * // => [1, 2]
	     *
	     * _.dropRight([1, 2, 3], 2);
	     * // => [1]
	     *
	     * _.dropRight([1, 2, 3], 5);
	     * // => []
	     *
	     * _.dropRight([1, 2, 3], 0);
	     * // => [1, 2, 3]
	     */
	    function dropRight(array, n, guard) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return [];
	      }
	      if (guard ? isIterateeCall(array, n, guard) : n == null) {
	        n = 1;
	      }
	      n = length - (+n || 0);
	      return baseSlice(array, 0, n < 0 ? 0 : n);
	    }

	    /**
	     * Creates a slice of `array` excluding elements dropped from the end.
	     * Elements are dropped until `predicate` returns falsey. The predicate is
	     * bound to `thisArg` and invoked with three arguments: (value, index, array).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that match the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.dropRightWhile([1, 2, 3], function(n) {
	     *   return n > 1;
	     * });
	     * // => [1]
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': true },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': false }
	     * ];
	     *
	     * // using the `_.matches` callback shorthand
	     * _.pluck(_.dropRightWhile(users, { 'user': 'pebbles', 'active': false }), 'user');
	     * // => ['barney', 'fred']
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.pluck(_.dropRightWhile(users, 'active', false), 'user');
	     * // => ['barney']
	     *
	     * // using the `_.property` callback shorthand
	     * _.pluck(_.dropRightWhile(users, 'active'), 'user');
	     * // => ['barney', 'fred', 'pebbles']
	     */
	    function dropRightWhile(array, predicate, thisArg) {
	      return (array && array.length)
	        ? baseWhile(array, getCallback(predicate, thisArg, 3), true, true)
	        : [];
	    }

	    /**
	     * Creates a slice of `array` excluding elements dropped from the beginning.
	     * Elements are dropped until `predicate` returns falsey. The predicate is
	     * bound to `thisArg` and invoked with three arguments: (value, index, array).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.dropWhile([1, 2, 3], function(n) {
	     *   return n < 3;
	     * });
	     * // => [3]
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': false },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': true }
	     * ];
	     *
	     * // using the `_.matches` callback shorthand
	     * _.pluck(_.dropWhile(users, { 'user': 'barney', 'active': false }), 'user');
	     * // => ['fred', 'pebbles']
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.pluck(_.dropWhile(users, 'active', false), 'user');
	     * // => ['pebbles']
	     *
	     * // using the `_.property` callback shorthand
	     * _.pluck(_.dropWhile(users, 'active'), 'user');
	     * // => ['barney', 'fred', 'pebbles']
	     */
	    function dropWhile(array, predicate, thisArg) {
	      return (array && array.length)
	        ? baseWhile(array, getCallback(predicate, thisArg, 3), true)
	        : [];
	    }

	    /**
	     * Fills elements of `array` with `value` from `start` up to, but not
	     * including, `end`.
	     *
	     * **Note:** This method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to fill.
	     * @param {*} value The value to fill `array` with.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = [1, 2, 3];
	     *
	     * _.fill(array, 'a');
	     * console.log(array);
	     * // => ['a', 'a', 'a']
	     *
	     * _.fill(Array(3), 2);
	     * // => [2, 2, 2]
	     *
	     * _.fill([4, 6, 8], '*', 1, 2);
	     * // => [4, '*', 8]
	     */
	    function fill(array, value, start, end) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return [];
	      }
	      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
	        start = 0;
	        end = length;
	      }
	      return baseFill(array, value, start, end);
	    }

	    /**
	     * This method is like `_.find` except that it returns the index of the first
	     * element `predicate` returns truthy for instead of the element itself.
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to search.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {number} Returns the index of the found element, else `-1`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': false },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': true }
	     * ];
	     *
	     * _.findIndex(users, function(chr) {
	     *   return chr.user == 'barney';
	     * });
	     * // => 0
	     *
	     * // using the `_.matches` callback shorthand
	     * _.findIndex(users, { 'user': 'fred', 'active': false });
	     * // => 1
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.findIndex(users, 'active', false);
	     * // => 0
	     *
	     * // using the `_.property` callback shorthand
	     * _.findIndex(users, 'active');
	     * // => 2
	     */
	    var findIndex = createFindIndex();

	    /**
	     * This method is like `_.findIndex` except that it iterates over elements
	     * of `collection` from right to left.
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to search.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {number} Returns the index of the found element, else `-1`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': true },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': false }
	     * ];
	     *
	     * _.findLastIndex(users, function(chr) {
	     *   return chr.user == 'pebbles';
	     * });
	     * // => 2
	     *
	     * // using the `_.matches` callback shorthand
	     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
	     * // => 0
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.findLastIndex(users, 'active', false);
	     * // => 2
	     *
	     * // using the `_.property` callback shorthand
	     * _.findLastIndex(users, 'active');
	     * // => 0
	     */
	    var findLastIndex = createFindIndex(true);

	    /**
	     * Gets the first element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @alias head
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {*} Returns the first element of `array`.
	     * @example
	     *
	     * _.first([1, 2, 3]);
	     * // => 1
	     *
	     * _.first([]);
	     * // => undefined
	     */
	    function first(array) {
	      return array ? array[0] : undefined;
	    }

	    /**
	     * Flattens a nested array. If `isDeep` is `true` the array is recursively
	     * flattened, otherwise it is only flattened a single level.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to flatten.
	     * @param {boolean} [isDeep] Specify a deep flatten.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * _.flatten([1, [2, 3, [4]]]);
	     * // => [1, 2, 3, [4]]
	     *
	     * // using `isDeep`
	     * _.flatten([1, [2, 3, [4]]], true);
	     * // => [1, 2, 3, 4]
	     */
	    function flatten(array, isDeep, guard) {
	      var length = array ? array.length : 0;
	      if (guard && isIterateeCall(array, isDeep, guard)) {
	        isDeep = false;
	      }
	      return length ? baseFlatten(array, isDeep) : [];
	    }

	    /**
	     * Recursively flattens a nested array.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to recursively flatten.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * _.flattenDeep([1, [2, 3, [4]]]);
	     * // => [1, 2, 3, 4]
	     */
	    function flattenDeep(array) {
	      var length = array ? array.length : 0;
	      return length ? baseFlatten(array, true) : [];
	    }

	    /**
	     * Gets the index at which the first occurrence of `value` is found in `array`
	     * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
	     * for equality comparisons. If `fromIndex` is negative, it is used as the offset
	     * from the end of `array`. If `array` is sorted providing `true` for `fromIndex`
	     * performs a faster binary search.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to search.
	     * @param {*} value The value to search for.
	     * @param {boolean|number} [fromIndex=0] The index to search from or `true`
	     *  to perform a binary search on a sorted array.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     * @example
	     *
	     * _.indexOf([1, 2, 1, 2], 2);
	     * // => 1
	     *
	     * // using `fromIndex`
	     * _.indexOf([1, 2, 1, 2], 2, 2);
	     * // => 3
	     *
	     * // performing a binary search
	     * _.indexOf([1, 1, 2, 2], 2, true);
	     * // => 2
	     */
	    function indexOf(array, value, fromIndex) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return -1;
	      }
	      if (typeof fromIndex == 'number') {
	        fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : fromIndex;
	      } else if (fromIndex) {
	        var index = binaryIndex(array, value);
	        if (index < length &&
	            (value === value ? (value === array[index]) : (array[index] !== array[index]))) {
	          return index;
	        }
	        return -1;
	      }
	      return baseIndexOf(array, value, fromIndex || 0);
	    }

	    /**
	     * Gets all but the last element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.initial([1, 2, 3]);
	     * // => [1, 2]
	     */
	    function initial(array) {
	      return dropRight(array, 1);
	    }

	    /**
	     * Creates an array of unique values that are included in all of the provided
	     * arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @returns {Array} Returns the new array of shared values.
	     * @example
	     * _.intersection([1, 2], [4, 2], [2, 1]);
	     * // => [2]
	     */
	    var intersection = restParam(function(arrays) {
	      var othLength = arrays.length,
	          othIndex = othLength,
	          caches = Array(length),
	          indexOf = getIndexOf(),
	          isCommon = indexOf == baseIndexOf,
	          result = [];

	      while (othIndex--) {
	        var value = arrays[othIndex] = isArrayLike(value = arrays[othIndex]) ? value : [];
	        caches[othIndex] = (isCommon && value.length >= 120) ? createCache(othIndex && value) : null;
	      }
	      var array = arrays[0],
	          index = -1,
	          length = array ? array.length : 0,
	          seen = caches[0];

	      outer:
	      while (++index < length) {
	        value = array[index];
	        if ((seen ? cacheIndexOf(seen, value) : indexOf(result, value, 0)) < 0) {
	          var othIndex = othLength;
	          while (--othIndex) {
	            var cache = caches[othIndex];
	            if ((cache ? cacheIndexOf(cache, value) : indexOf(arrays[othIndex], value, 0)) < 0) {
	              continue outer;
	            }
	          }
	          if (seen) {
	            seen.push(value);
	          }
	          result.push(value);
	        }
	      }
	      return result;
	    });

	    /**
	     * Gets the last element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {*} Returns the last element of `array`.
	     * @example
	     *
	     * _.last([1, 2, 3]);
	     * // => 3
	     */
	    function last(array) {
	      var length = array ? array.length : 0;
	      return length ? array[length - 1] : undefined;
	    }

	    /**
	     * This method is like `_.indexOf` except that it iterates over elements of
	     * `array` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to search.
	     * @param {*} value The value to search for.
	     * @param {boolean|number} [fromIndex=array.length-1] The index to search from
	     *  or `true` to perform a binary search on a sorted array.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     * @example
	     *
	     * _.lastIndexOf([1, 2, 1, 2], 2);
	     * // => 3
	     *
	     * // using `fromIndex`
	     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
	     * // => 1
	     *
	     * // performing a binary search
	     * _.lastIndexOf([1, 1, 2, 2], 2, true);
	     * // => 3
	     */
	    function lastIndexOf(array, value, fromIndex) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return -1;
	      }
	      var index = length;
	      if (typeof fromIndex == 'number') {
	        index = (fromIndex < 0 ? nativeMax(length + fromIndex, 0) : nativeMin(fromIndex || 0, length - 1)) + 1;
	      } else if (fromIndex) {
	        index = binaryIndex(array, value, true) - 1;
	        var other = array[index];
	        if (value === value ? (value === other) : (other !== other)) {
	          return index;
	        }
	        return -1;
	      }
	      if (value !== value) {
	        return indexOfNaN(array, index, true);
	      }
	      while (index--) {
	        if (array[index] === value) {
	          return index;
	        }
	      }
	      return -1;
	    }

	    /**
	     * Removes all provided values from `array` using
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * **Note:** Unlike `_.without`, this method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {...*} [values] The values to remove.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = [1, 2, 3, 1, 2, 3];
	     *
	     * _.pull(array, 2, 3);
	     * console.log(array);
	     * // => [1, 1]
	     */
	    function pull() {
	      var args = arguments,
	          array = args[0];

	      if (!(array && array.length)) {
	        return array;
	      }
	      var index = 0,
	          indexOf = getIndexOf(),
	          length = args.length;

	      while (++index < length) {
	        var fromIndex = 0,
	            value = args[index];

	        while ((fromIndex = indexOf(array, value, fromIndex)) > -1) {
	          splice.call(array, fromIndex, 1);
	        }
	      }
	      return array;
	    }

	    /**
	     * Removes elements from `array` corresponding to the given indexes and returns
	     * an array of the removed elements. Indexes may be specified as an array of
	     * indexes or as individual arguments.
	     *
	     * **Note:** Unlike `_.at`, this method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {...(number|number[])} [indexes] The indexes of elements to remove,
	     *  specified as individual indexes or arrays of indexes.
	     * @returns {Array} Returns the new array of removed elements.
	     * @example
	     *
	     * var array = [5, 10, 15, 20];
	     * var evens = _.pullAt(array, 1, 3);
	     *
	     * console.log(array);
	     * // => [5, 15]
	     *
	     * console.log(evens);
	     * // => [10, 20]
	     */
	    var pullAt = restParam(function(array, indexes) {
	      indexes = baseFlatten(indexes);

	      var result = baseAt(array, indexes);
	      basePullAt(array, indexes.sort(baseCompareAscending));
	      return result;
	    });

	    /**
	     * Removes all elements from `array` that `predicate` returns truthy for
	     * and returns an array of the removed elements. The predicate is bound to
	     * `thisArg` and invoked with three arguments: (value, index, array).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * **Note:** Unlike `_.filter`, this method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Array} Returns the new array of removed elements.
	     * @example
	     *
	     * var array = [1, 2, 3, 4];
	     * var evens = _.remove(array, function(n) {
	     *   return n % 2 == 0;
	     * });
	     *
	     * console.log(array);
	     * // => [1, 3]
	     *
	     * console.log(evens);
	     * // => [2, 4]
	     */
	    function remove(array, predicate, thisArg) {
	      var result = [];
	      if (!(array && array.length)) {
	        return result;
	      }
	      var index = -1,
	          indexes = [],
	          length = array.length;

	      predicate = getCallback(predicate, thisArg, 3);
	      while (++index < length) {
	        var value = array[index];
	        if (predicate(value, index, array)) {
	          result.push(value);
	          indexes.push(index);
	        }
	      }
	      basePullAt(array, indexes);
	      return result;
	    }

	    /**
	     * Gets all but the first element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @alias tail
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.rest([1, 2, 3]);
	     * // => [2, 3]
	     */
	    function rest(array) {
	      return drop(array, 1);
	    }

	    /**
	     * Creates a slice of `array` from `start` up to, but not including, `end`.
	     *
	     * **Note:** This method is used instead of `Array#slice` to support node
	     * lists in IE < 9 and to ensure dense arrays are returned.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to slice.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns the slice of `array`.
	     */
	    function slice(array, start, end) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return [];
	      }
	      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
	        start = 0;
	        end = length;
	      }
	      return baseSlice(array, start, end);
	    }

	    /**
	     * Uses a binary search to determine the lowest index at which `value` should
	     * be inserted into `array` in order to maintain its sort order. If an iteratee
	     * function is provided it is invoked for `value` and each element of `array`
	     * to compute their sort ranking. The iteratee is bound to `thisArg` and
	     * invoked with one argument; (value).
	     *
	     * If a property name is provided for `iteratee` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `iteratee` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     * @example
	     *
	     * _.sortedIndex([30, 50], 40);
	     * // => 1
	     *
	     * _.sortedIndex([4, 4, 5, 5], 5);
	     * // => 2
	     *
	     * var dict = { 'data': { 'thirty': 30, 'forty': 40, 'fifty': 50 } };
	     *
	     * // using an iteratee function
	     * _.sortedIndex(['thirty', 'fifty'], 'forty', function(word) {
	     *   return this.data[word];
	     * }, dict);
	     * // => 1
	     *
	     * // using the `_.property` callback shorthand
	     * _.sortedIndex([{ 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
	     * // => 1
	     */
	    var sortedIndex = createSortedIndex();

	    /**
	     * This method is like `_.sortedIndex` except that it returns the highest
	     * index at which `value` should be inserted into `array` in order to
	     * maintain its sort order.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     * @example
	     *
	     * _.sortedLastIndex([4, 4, 5, 5], 5);
	     * // => 4
	     */
	    var sortedLastIndex = createSortedIndex(true);

	    /**
	     * Creates a slice of `array` with `n` elements taken from the beginning.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to take.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.take([1, 2, 3]);
	     * // => [1]
	     *
	     * _.take([1, 2, 3], 2);
	     * // => [1, 2]
	     *
	     * _.take([1, 2, 3], 5);
	     * // => [1, 2, 3]
	     *
	     * _.take([1, 2, 3], 0);
	     * // => []
	     */
	    function take(array, n, guard) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return [];
	      }
	      if (guard ? isIterateeCall(array, n, guard) : n == null) {
	        n = 1;
	      }
	      return baseSlice(array, 0, n < 0 ? 0 : n);
	    }

	    /**
	     * Creates a slice of `array` with `n` elements taken from the end.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to take.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.takeRight([1, 2, 3]);
	     * // => [3]
	     *
	     * _.takeRight([1, 2, 3], 2);
	     * // => [2, 3]
	     *
	     * _.takeRight([1, 2, 3], 5);
	     * // => [1, 2, 3]
	     *
	     * _.takeRight([1, 2, 3], 0);
	     * // => []
	     */
	    function takeRight(array, n, guard) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return [];
	      }
	      if (guard ? isIterateeCall(array, n, guard) : n == null) {
	        n = 1;
	      }
	      n = length - (+n || 0);
	      return baseSlice(array, n < 0 ? 0 : n);
	    }

	    /**
	     * Creates a slice of `array` with elements taken from the end. Elements are
	     * taken until `predicate` returns falsey. The predicate is bound to `thisArg`
	     * and invoked with three arguments: (value, index, array).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.takeRightWhile([1, 2, 3], function(n) {
	     *   return n > 1;
	     * });
	     * // => [2, 3]
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': true },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': false }
	     * ];
	     *
	     * // using the `_.matches` callback shorthand
	     * _.pluck(_.takeRightWhile(users, { 'user': 'pebbles', 'active': false }), 'user');
	     * // => ['pebbles']
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.pluck(_.takeRightWhile(users, 'active', false), 'user');
	     * // => ['fred', 'pebbles']
	     *
	     * // using the `_.property` callback shorthand
	     * _.pluck(_.takeRightWhile(users, 'active'), 'user');
	     * // => []
	     */
	    function takeRightWhile(array, predicate, thisArg) {
	      return (array && array.length)
	        ? baseWhile(array, getCallback(predicate, thisArg, 3), false, true)
	        : [];
	    }

	    /**
	     * Creates a slice of `array` with elements taken from the beginning. Elements
	     * are taken until `predicate` returns falsey. The predicate is bound to
	     * `thisArg` and invoked with three arguments: (value, index, array).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.takeWhile([1, 2, 3], function(n) {
	     *   return n < 3;
	     * });
	     * // => [1, 2]
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': false },
	     *   { 'user': 'fred',    'active': false},
	     *   { 'user': 'pebbles', 'active': true }
	     * ];
	     *
	     * // using the `_.matches` callback shorthand
	     * _.pluck(_.takeWhile(users, { 'user': 'barney', 'active': false }), 'user');
	     * // => ['barney']
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.pluck(_.takeWhile(users, 'active', false), 'user');
	     * // => ['barney', 'fred']
	     *
	     * // using the `_.property` callback shorthand
	     * _.pluck(_.takeWhile(users, 'active'), 'user');
	     * // => []
	     */
	    function takeWhile(array, predicate, thisArg) {
	      return (array && array.length)
	        ? baseWhile(array, getCallback(predicate, thisArg, 3))
	        : [];
	    }

	    /**
	     * Creates an array of unique values, in order, from all of the provided arrays
	     * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @returns {Array} Returns the new array of combined values.
	     * @example
	     *
	     * _.union([1, 2], [4, 2], [2, 1]);
	     * // => [1, 2, 4]
	     */
	    var union = restParam(function(arrays) {
	      return baseUniq(baseFlatten(arrays, false, true));
	    });

	    /**
	     * Creates a duplicate-free version of an array, using
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
	     * for equality comparisons, in which only the first occurence of each element
	     * is kept. Providing `true` for `isSorted` performs a faster search algorithm
	     * for sorted arrays. If an iteratee function is provided it is invoked for
	     * each element in the array to generate the criterion by which uniqueness
	     * is computed. The `iteratee` is bound to `thisArg` and invoked with three
	     * arguments: (value, index, array).
	     *
	     * If a property name is provided for `iteratee` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `iteratee` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @alias unique
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {boolean} [isSorted] Specify the array is sorted.
	     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Array} Returns the new duplicate-value-free array.
	     * @example
	     *
	     * _.uniq([2, 1, 2]);
	     * // => [2, 1]
	     *
	     * // using `isSorted`
	     * _.uniq([1, 1, 2], true);
	     * // => [1, 2]
	     *
	     * // using an iteratee function
	     * _.uniq([1, 2.5, 1.5, 2], function(n) {
	     *   return this.floor(n);
	     * }, Math);
	     * // => [1, 2.5]
	     *
	     * // using the `_.property` callback shorthand
	     * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
	     * // => [{ 'x': 1 }, { 'x': 2 }]
	     */
	    function uniq(array, isSorted, iteratee, thisArg) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return [];
	      }
	      if (isSorted != null && typeof isSorted != 'boolean') {
	        thisArg = iteratee;
	        iteratee = isIterateeCall(array, isSorted, thisArg) ? undefined : isSorted;
	        isSorted = false;
	      }
	      var callback = getCallback();
	      if (!(iteratee == null && callback === baseCallback)) {
	        iteratee = callback(iteratee, thisArg, 3);
	      }
	      return (isSorted && getIndexOf() == baseIndexOf)
	        ? sortedUniq(array, iteratee)
	        : baseUniq(array, iteratee);
	    }

	    /**
	     * This method is like `_.zip` except that it accepts an array of grouped
	     * elements and creates an array regrouping the elements to their pre-zip
	     * configuration.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array of grouped elements to process.
	     * @returns {Array} Returns the new array of regrouped elements.
	     * @example
	     *
	     * var zipped = _.zip(['fred', 'barney'], [30, 40], [true, false]);
	     * // => [['fred', 30, true], ['barney', 40, false]]
	     *
	     * _.unzip(zipped);
	     * // => [['fred', 'barney'], [30, 40], [true, false]]
	     */
	    function unzip(array) {
	      if (!(array && array.length)) {
	        return [];
	      }
	      var index = -1,
	          length = 0;

	      array = arrayFilter(array, function(group) {
	        if (isArrayLike(group)) {
	          length = nativeMax(group.length, length);
	          return true;
	        }
	      });
	      var result = Array(length);
	      while (++index < length) {
	        result[index] = arrayMap(array, baseProperty(index));
	      }
	      return result;
	    }

	    /**
	     * This method is like `_.unzip` except that it accepts an iteratee to specify
	     * how regrouped values should be combined. The `iteratee` is bound to `thisArg`
	     * and invoked with four arguments: (accumulator, value, index, group).
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array of grouped elements to process.
	     * @param {Function} [iteratee] The function to combine regrouped values.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Array} Returns the new array of regrouped elements.
	     * @example
	     *
	     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
	     * // => [[1, 10, 100], [2, 20, 200]]
	     *
	     * _.unzipWith(zipped, _.add);
	     * // => [3, 30, 300]
	     */
	    function unzipWith(array, iteratee, thisArg) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return [];
	      }
	      var result = unzip(array);
	      if (iteratee == null) {
	        return result;
	      }
	      iteratee = bindCallback(iteratee, thisArg, 4);
	      return arrayMap(result, function(group) {
	        return arrayReduce(group, iteratee, undefined, true);
	      });
	    }

	    /**
	     * Creates an array excluding all provided values using
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to filter.
	     * @param {...*} [values] The values to exclude.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * _.without([1, 2, 1, 3], 1, 2);
	     * // => [3]
	     */
	    var without = restParam(function(array, values) {
	      return isArrayLike(array)
	        ? baseDifference(array, values)
	        : [];
	    });

	    /**
	     * Creates an array of unique values that is the [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
	     * of the provided arrays.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @returns {Array} Returns the new array of values.
	     * @example
	     *
	     * _.xor([1, 2], [4, 2]);
	     * // => [1, 4]
	     */
	    function xor() {
	      var index = -1,
	          length = arguments.length;

	      while (++index < length) {
	        var array = arguments[index];
	        if (isArrayLike(array)) {
	          var result = result
	            ? arrayPush(baseDifference(result, array), baseDifference(array, result))
	            : array;
	        }
	      }
	      return result ? baseUniq(result) : [];
	    }

	    /**
	     * Creates an array of grouped elements, the first of which contains the first
	     * elements of the given arrays, the second of which contains the second elements
	     * of the given arrays, and so on.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {...Array} [arrays] The arrays to process.
	     * @returns {Array} Returns the new array of grouped elements.
	     * @example
	     *
	     * _.zip(['fred', 'barney'], [30, 40], [true, false]);
	     * // => [['fred', 30, true], ['barney', 40, false]]
	     */
	    var zip = restParam(unzip);

	    /**
	     * The inverse of `_.pairs`; this method returns an object composed from arrays
	     * of property names and values. Provide either a single two dimensional array,
	     * e.g. `[[key1, value1], [key2, value2]]` or two arrays, one of property names
	     * and one of corresponding values.
	     *
	     * @static
	     * @memberOf _
	     * @alias object
	     * @category Array
	     * @param {Array} props The property names.
	     * @param {Array} [values=[]] The property values.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * _.zipObject([['fred', 30], ['barney', 40]]);
	     * // => { 'fred': 30, 'barney': 40 }
	     *
	     * _.zipObject(['fred', 'barney'], [30, 40]);
	     * // => { 'fred': 30, 'barney': 40 }
	     */
	    function zipObject(props, values) {
	      var index = -1,
	          length = props ? props.length : 0,
	          result = {};

	      if (length && !values && !isArray(props[0])) {
	        values = [];
	      }
	      while (++index < length) {
	        var key = props[index];
	        if (values) {
	          result[key] = values[index];
	        } else if (key) {
	          result[key[0]] = key[1];
	        }
	      }
	      return result;
	    }

	    /**
	     * This method is like `_.zip` except that it accepts an iteratee to specify
	     * how grouped values should be combined. The `iteratee` is bound to `thisArg`
	     * and invoked with four arguments: (accumulator, value, index, group).
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {...Array} [arrays] The arrays to process.
	     * @param {Function} [iteratee] The function to combine grouped values.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Array} Returns the new array of grouped elements.
	     * @example
	     *
	     * _.zipWith([1, 2], [10, 20], [100, 200], _.add);
	     * // => [111, 222]
	     */
	    var zipWith = restParam(function(arrays) {
	      var length = arrays.length,
	          iteratee = length > 2 ? arrays[length - 2] : undefined,
	          thisArg = length > 1 ? arrays[length - 1] : undefined;

	      if (length > 2 && typeof iteratee == 'function') {
	        length -= 2;
	      } else {
	        iteratee = (length > 1 && typeof thisArg == 'function') ? (--length, thisArg) : undefined;
	        thisArg = undefined;
	      }
	      arrays.length = length;
	      return unzipWith(arrays, iteratee, thisArg);
	    });

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates a `lodash` object that wraps `value` with explicit method
	     * chaining enabled.
	     *
	     * @static
	     * @memberOf _
	     * @category Chain
	     * @param {*} value The value to wrap.
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'age': 36 },
	     *   { 'user': 'fred',    'age': 40 },
	     *   { 'user': 'pebbles', 'age': 1 }
	     * ];
	     *
	     * var youngest = _.chain(users)
	     *   .sortBy('age')
	     *   .map(function(chr) {
	     *     return chr.user + ' is ' + chr.age;
	     *   })
	     *   .first()
	     *   .value();
	     * // => 'pebbles is 1'
	     */
	    function chain(value) {
	      var result = lodash(value);
	      result.__chain__ = true;
	      return result;
	    }

	    /**
	     * This method invokes `interceptor` and returns `value`. The interceptor is
	     * bound to `thisArg` and invoked with one argument; (value). The purpose of
	     * this method is to "tap into" a method chain in order to perform operations
	     * on intermediate results within the chain.
	     *
	     * @static
	     * @memberOf _
	     * @category Chain
	     * @param {*} value The value to provide to `interceptor`.
	     * @param {Function} interceptor The function to invoke.
	     * @param {*} [thisArg] The `this` binding of `interceptor`.
	     * @returns {*} Returns `value`.
	     * @example
	     *
	     * _([1, 2, 3])
	     *  .tap(function(array) {
	     *    array.pop();
	     *  })
	     *  .reverse()
	     *  .value();
	     * // => [2, 1]
	     */
	    function tap(value, interceptor, thisArg) {
	      interceptor.call(thisArg, value);
	      return value;
	    }

	    /**
	     * This method is like `_.tap` except that it returns the result of `interceptor`.
	     *
	     * @static
	     * @memberOf _
	     * @category Chain
	     * @param {*} value The value to provide to `interceptor`.
	     * @param {Function} interceptor The function to invoke.
	     * @param {*} [thisArg] The `this` binding of `interceptor`.
	     * @returns {*} Returns the result of `interceptor`.
	     * @example
	     *
	     * _('  abc  ')
	     *  .chain()
	     *  .trim()
	     *  .thru(function(value) {
	     *    return [value];
	     *  })
	     *  .value();
	     * // => ['abc']
	     */
	    function thru(value, interceptor, thisArg) {
	      return interceptor.call(thisArg, value);
	    }

	    /**
	     * Enables explicit method chaining on the wrapper object.
	     *
	     * @name chain
	     * @memberOf _
	     * @category Chain
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36 },
	     *   { 'user': 'fred',   'age': 40 }
	     * ];
	     *
	     * // without explicit chaining
	     * _(users).first();
	     * // => { 'user': 'barney', 'age': 36 }
	     *
	     * // with explicit chaining
	     * _(users).chain()
	     *   .first()
	     *   .pick('user')
	     *   .value();
	     * // => { 'user': 'barney' }
	     */
	    function wrapperChain() {
	      return chain(this);
	    }

	    /**
	     * Executes the chained sequence and returns the wrapped result.
	     *
	     * @name commit
	     * @memberOf _
	     * @category Chain
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var array = [1, 2];
	     * var wrapped = _(array).push(3);
	     *
	     * console.log(array);
	     * // => [1, 2]
	     *
	     * wrapped = wrapped.commit();
	     * console.log(array);
	     * // => [1, 2, 3]
	     *
	     * wrapped.last();
	     * // => 3
	     *
	     * console.log(array);
	     * // => [1, 2, 3]
	     */
	    function wrapperCommit() {
	      return new LodashWrapper(this.value(), this.__chain__);
	    }

	    /**
	     * Creates a new array joining a wrapped array with any additional arrays
	     * and/or values.
	     *
	     * @name concat
	     * @memberOf _
	     * @category Chain
	     * @param {...*} [values] The values to concatenate.
	     * @returns {Array} Returns the new concatenated array.
	     * @example
	     *
	     * var array = [1];
	     * var wrapped = _(array).concat(2, [3], [[4]]);
	     *
	     * console.log(wrapped.value());
	     * // => [1, 2, 3, [4]]
	     *
	     * console.log(array);
	     * // => [1]
	     */
	    var wrapperConcat = restParam(function(values) {
	      values = baseFlatten(values);
	      return this.thru(function(array) {
	        return arrayConcat(isArray(array) ? array : [toObject(array)], values);
	      });
	    });

	    /**
	     * Creates a clone of the chained sequence planting `value` as the wrapped value.
	     *
	     * @name plant
	     * @memberOf _
	     * @category Chain
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var array = [1, 2];
	     * var wrapped = _(array).map(function(value) {
	     *   return Math.pow(value, 2);
	     * });
	     *
	     * var other = [3, 4];
	     * var otherWrapped = wrapped.plant(other);
	     *
	     * otherWrapped.value();
	     * // => [9, 16]
	     *
	     * wrapped.value();
	     * // => [1, 4]
	     */
	    function wrapperPlant(value) {
	      var result,
	          parent = this;

	      while (parent instanceof baseLodash) {
	        var clone = wrapperClone(parent);
	        if (result) {
	          previous.__wrapped__ = clone;
	        } else {
	          result = clone;
	        }
	        var previous = clone;
	        parent = parent.__wrapped__;
	      }
	      previous.__wrapped__ = value;
	      return result;
	    }

	    /**
	     * Reverses the wrapped array so the first element becomes the last, the
	     * second element becomes the second to last, and so on.
	     *
	     * **Note:** This method mutates the wrapped array.
	     *
	     * @name reverse
	     * @memberOf _
	     * @category Chain
	     * @returns {Object} Returns the new reversed `lodash` wrapper instance.
	     * @example
	     *
	     * var array = [1, 2, 3];
	     *
	     * _(array).reverse().value()
	     * // => [3, 2, 1]
	     *
	     * console.log(array);
	     * // => [3, 2, 1]
	     */
	    function wrapperReverse() {
	      var value = this.__wrapped__;

	      var interceptor = function(value) {
	        return (wrapped && wrapped.__dir__ < 0) ? value : value.reverse();
	      };
	      if (value instanceof LazyWrapper) {
	        var wrapped = value;
	        if (this.__actions__.length) {
	          wrapped = new LazyWrapper(this);
	        }
	        wrapped = wrapped.reverse();
	        wrapped.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });
	        return new LodashWrapper(wrapped, this.__chain__);
	      }
	      return this.thru(interceptor);
	    }

	    /**
	     * Produces the result of coercing the unwrapped value to a string.
	     *
	     * @name toString
	     * @memberOf _
	     * @category Chain
	     * @returns {string} Returns the coerced string value.
	     * @example
	     *
	     * _([1, 2, 3]).toString();
	     * // => '1,2,3'
	     */
	    function wrapperToString() {
	      return (this.value() + '');
	    }

	    /**
	     * Executes the chained sequence to extract the unwrapped value.
	     *
	     * @name value
	     * @memberOf _
	     * @alias run, toJSON, valueOf
	     * @category Chain
	     * @returns {*} Returns the resolved unwrapped value.
	     * @example
	     *
	     * _([1, 2, 3]).value();
	     * // => [1, 2, 3]
	     */
	    function wrapperValue() {
	      return baseWrapperValue(this.__wrapped__, this.__actions__);
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates an array of elements corresponding to the given keys, or indexes,
	     * of `collection`. Keys may be specified as individual arguments or as arrays
	     * of keys.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {...(number|number[]|string|string[])} [props] The property names
	     *  or indexes of elements to pick, specified individually or in arrays.
	     * @returns {Array} Returns the new array of picked elements.
	     * @example
	     *
	     * _.at(['a', 'b', 'c'], [0, 2]);
	     * // => ['a', 'c']
	     *
	     * _.at(['barney', 'fred', 'pebbles'], 0, 2);
	     * // => ['barney', 'pebbles']
	     */
	    var at = restParam(function(collection, props) {
	      return baseAt(collection, baseFlatten(props));
	    });

	    /**
	     * Creates an object composed of keys generated from the results of running
	     * each element of `collection` through `iteratee`. The corresponding value
	     * of each key is the number of times the key was returned by `iteratee`.
	     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
	     * (value, index|key, collection).
	     *
	     * If a property name is provided for `iteratee` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `iteratee` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Object} Returns the composed aggregate object.
	     * @example
	     *
	     * _.countBy([4.3, 6.1, 6.4], function(n) {
	     *   return Math.floor(n);
	     * });
	     * // => { '4': 1, '6': 2 }
	     *
	     * _.countBy([4.3, 6.1, 6.4], function(n) {
	     *   return this.floor(n);
	     * }, Math);
	     * // => { '4': 1, '6': 2 }
	     *
	     * _.countBy(['one', 'two', 'three'], 'length');
	     * // => { '3': 2, '5': 1 }
	     */
	    var countBy = createAggregator(function(result, value, key) {
	      hasOwnProperty.call(result, key) ? ++result[key] : (result[key] = 1);
	    });

	    /**
	     * Checks if `predicate` returns truthy for **all** elements of `collection`.
	     * The predicate is bound to `thisArg` and invoked with three arguments:
	     * (value, index|key, collection).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @alias all
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {boolean} Returns `true` if all elements pass the predicate check,
	     *  else `false`.
	     * @example
	     *
	     * _.every([true, 1, null, 'yes'], Boolean);
	     * // => false
	     *
	     * var users = [
	     *   { 'user': 'barney', 'active': false },
	     *   { 'user': 'fred',   'active': false }
	     * ];
	     *
	     * // using the `_.matches` callback shorthand
	     * _.every(users, { 'user': 'barney', 'active': false });
	     * // => false
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.every(users, 'active', false);
	     * // => true
	     *
	     * // using the `_.property` callback shorthand
	     * _.every(users, 'active');
	     * // => false
	     */
	    function every(collection, predicate, thisArg) {
	      var func = isArray(collection) ? arrayEvery : baseEvery;
	      if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
	        predicate = undefined;
	      }
	      if (typeof predicate != 'function' || thisArg !== undefined) {
	        predicate = getCallback(predicate, thisArg, 3);
	      }
	      return func(collection, predicate);
	    }

	    /**
	     * Iterates over elements of `collection`, returning an array of all elements
	     * `predicate` returns truthy for. The predicate is bound to `thisArg` and
	     * invoked with three arguments: (value, index|key, collection).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @alias select
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Array} Returns the new filtered array.
	     * @example
	     *
	     * _.filter([4, 5, 6], function(n) {
	     *   return n % 2 == 0;
	     * });
	     * // => [4, 6]
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': true },
	     *   { 'user': 'fred',   'age': 40, 'active': false }
	     * ];
	     *
	     * // using the `_.matches` callback shorthand
	     * _.pluck(_.filter(users, { 'age': 36, 'active': true }), 'user');
	     * // => ['barney']
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.pluck(_.filter(users, 'active', false), 'user');
	     * // => ['fred']
	     *
	     * // using the `_.property` callback shorthand
	     * _.pluck(_.filter(users, 'active'), 'user');
	     * // => ['barney']
	     */
	    function filter(collection, predicate, thisArg) {
	      var func = isArray(collection) ? arrayFilter : baseFilter;
	      predicate = getCallback(predicate, thisArg, 3);
	      return func(collection, predicate);
	    }

	    /**
	     * Iterates over elements of `collection`, returning the first element
	     * `predicate` returns truthy for. The predicate is bound to `thisArg` and
	     * invoked with three arguments: (value, index|key, collection).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @alias detect
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to search.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {*} Returns the matched element, else `undefined`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'age': 36, 'active': true },
	     *   { 'user': 'fred',    'age': 40, 'active': false },
	     *   { 'user': 'pebbles', 'age': 1,  'active': true }
	     * ];
	     *
	     * _.result(_.find(users, function(chr) {
	     *   return chr.age < 40;
	     * }), 'user');
	     * // => 'barney'
	     *
	     * // using the `_.matches` callback shorthand
	     * _.result(_.find(users, { 'age': 1, 'active': true }), 'user');
	     * // => 'pebbles'
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.result(_.find(users, 'active', false), 'user');
	     * // => 'fred'
	     *
	     * // using the `_.property` callback shorthand
	     * _.result(_.find(users, 'active'), 'user');
	     * // => 'barney'
	     */
	    var find = createFind(baseEach);

	    /**
	     * This method is like `_.find` except that it iterates over elements of
	     * `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to search.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {*} Returns the matched element, else `undefined`.
	     * @example
	     *
	     * _.findLast([1, 2, 3, 4], function(n) {
	     *   return n % 2 == 1;
	     * });
	     * // => 3
	     */
	    var findLast = createFind(baseEachRight, true);

	    /**
	     * Performs a deep comparison between each element in `collection` and the
	     * source object, returning the first element that has equivalent property
	     * values.
	     *
	     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
	     * numbers, `Object` objects, regexes, and strings. Objects are compared by
	     * their own, not inherited, enumerable properties. For comparing a single
	     * own or inherited property value see `_.matchesProperty`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to search.
	     * @param {Object} source The object of property values to match.
	     * @returns {*} Returns the matched element, else `undefined`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': true },
	     *   { 'user': 'fred',   'age': 40, 'active': false }
	     * ];
	     *
	     * _.result(_.findWhere(users, { 'age': 36, 'active': true }), 'user');
	     * // => 'barney'
	     *
	     * _.result(_.findWhere(users, { 'age': 40, 'active': false }), 'user');
	     * // => 'fred'
	     */
	    function findWhere(collection, source) {
	      return find(collection, baseMatches(source));
	    }

	    /**
	     * Iterates over elements of `collection` invoking `iteratee` for each element.
	     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
	     * (value, index|key, collection). Iteratee functions may exit iteration early
	     * by explicitly returning `false`.
	     *
	     * **Note:** As with other "Collections" methods, objects with a "length" property
	     * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
	     * may be used for object iteration.
	     *
	     * @static
	     * @memberOf _
	     * @alias each
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Array|Object|string} Returns `collection`.
	     * @example
	     *
	     * _([1, 2]).forEach(function(n) {
	     *   console.log(n);
	     * }).value();
	     * // => logs each value from left to right and returns the array
	     *
	     * _.forEach({ 'a': 1, 'b': 2 }, function(n, key) {
	     *   console.log(n, key);
	     * });
	     * // => logs each value-key pair and returns the object (iteration order is not guaranteed)
	     */
	    var forEach = createForEach(arrayEach, baseEach);

	    /**
	     * This method is like `_.forEach` except that it iterates over elements of
	     * `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @alias eachRight
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Array|Object|string} Returns `collection`.
	     * @example
	     *
	     * _([1, 2]).forEachRight(function(n) {
	     *   console.log(n);
	     * }).value();
	     * // => logs each value from right to left and returns the array
	     */
	    var forEachRight = createForEach(arrayEachRight, baseEachRight);

	    /**
	     * Creates an object composed of keys generated from the results of running
	     * each element of `collection` through `iteratee`. The corresponding value
	     * of each key is an array of the elements responsible for generating the key.
	     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
	     * (value, index|key, collection).
	     *
	     * If a property name is provided for `iteratee` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `iteratee` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Object} Returns the composed aggregate object.
	     * @example
	     *
	     * _.groupBy([4.2, 6.1, 6.4], function(n) {
	     *   return Math.floor(n);
	     * });
	     * // => { '4': [4.2], '6': [6.1, 6.4] }
	     *
	     * _.groupBy([4.2, 6.1, 6.4], function(n) {
	     *   return this.floor(n);
	     * }, Math);
	     * // => { '4': [4.2], '6': [6.1, 6.4] }
	     *
	     * // using the `_.property` callback shorthand
	     * _.groupBy(['one', 'two', 'three'], 'length');
	     * // => { '3': ['one', 'two'], '5': ['three'] }
	     */
	    var groupBy = createAggregator(function(result, value, key) {
	      if (hasOwnProperty.call(result, key)) {
	        result[key].push(value);
	      } else {
	        result[key] = [value];
	      }
	    });

	    /**
	     * Checks if `value` is in `collection` using
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
	     * for equality comparisons. If `fromIndex` is negative, it is used as the offset
	     * from the end of `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @alias contains, include
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to search.
	     * @param {*} target The value to search for.
	     * @param {number} [fromIndex=0] The index to search from.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.reduce`.
	     * @returns {boolean} Returns `true` if a matching element is found, else `false`.
	     * @example
	     *
	     * _.includes([1, 2, 3], 1);
	     * // => true
	     *
	     * _.includes([1, 2, 3], 1, 2);
	     * // => false
	     *
	     * _.includes({ 'user': 'fred', 'age': 40 }, 'fred');
	     * // => true
	     *
	     * _.includes('pebbles', 'eb');
	     * // => true
	     */
	    function includes(collection, target, fromIndex, guard) {
	      var length = collection ? getLength(collection) : 0;
	      if (!isLength(length)) {
	        collection = values(collection);
	        length = collection.length;
	      }
	      if (typeof fromIndex != 'number' || (guard && isIterateeCall(target, fromIndex, guard))) {
	        fromIndex = 0;
	      } else {
	        fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : (fromIndex || 0);
	      }
	      return (typeof collection == 'string' || !isArray(collection) && isString(collection))
	        ? (fromIndex <= length && collection.indexOf(target, fromIndex) > -1)
	        : (!!length && getIndexOf(collection, target, fromIndex) > -1);
	    }

	    /**
	     * Creates an object composed of keys generated from the results of running
	     * each element of `collection` through `iteratee`. The corresponding value
	     * of each key is the last element responsible for generating the key. The
	     * iteratee function is bound to `thisArg` and invoked with three arguments:
	     * (value, index|key, collection).
	     *
	     * If a property name is provided for `iteratee` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `iteratee` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Object} Returns the composed aggregate object.
	     * @example
	     *
	     * var keyData = [
	     *   { 'dir': 'left', 'code': 97 },
	     *   { 'dir': 'right', 'code': 100 }
	     * ];
	     *
	     * _.indexBy(keyData, 'dir');
	     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
	     *
	     * _.indexBy(keyData, function(object) {
	     *   return String.fromCharCode(object.code);
	     * });
	     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
	     *
	     * _.indexBy(keyData, function(object) {
	     *   return this.fromCharCode(object.code);
	     * }, String);
	     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
	     */
	    var indexBy = createAggregator(function(result, value, key) {
	      result[key] = value;
	    });

	    /**
	     * Invokes the method at `path` of each element in `collection`, returning
	     * an array of the results of each invoked method. Any additional arguments
	     * are provided to each invoked method. If `methodName` is a function it is
	     * invoked for, and `this` bound to, each element in `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Array|Function|string} path The path of the method to invoke or
	     *  the function invoked per iteration.
	     * @param {...*} [args] The arguments to invoke the method with.
	     * @returns {Array} Returns the array of results.
	     * @example
	     *
	     * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
	     * // => [[1, 5, 7], [1, 2, 3]]
	     *
	     * _.invoke([123, 456], String.prototype.split, '');
	     * // => [['1', '2', '3'], ['4', '5', '6']]
	     */
	    var invoke = restParam(function(collection, path, args) {
	      var index = -1,
	          isFunc = typeof path == 'function',
	          isProp = isKey(path),
	          result = isArrayLike(collection) ? Array(collection.length) : [];

	      baseEach(collection, function(value) {
	        var func = isFunc ? path : ((isProp && value != null) ? value[path] : undefined);
	        result[++index] = func ? func.apply(value, args) : invokePath(value, path, args);
	      });
	      return result;
	    });

	    /**
	     * Creates an array of values by running each element in `collection` through
	     * `iteratee`. The `iteratee` is bound to `thisArg` and invoked with three
	     * arguments: (value, index|key, collection).
	     *
	     * If a property name is provided for `iteratee` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `iteratee` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * Many lodash methods are guarded to work as iteratees for methods like
	     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
	     *
	     * The guarded methods are:
	     * `ary`, `callback`, `chunk`, `clone`, `create`, `curry`, `curryRight`,
	     * `drop`, `dropRight`, `every`, `fill`, `flatten`, `invert`, `max`, `min`,
	     * `parseInt`, `slice`, `sortBy`, `take`, `takeRight`, `template`, `trim`,
	     * `trimLeft`, `trimRight`, `trunc`, `random`, `range`, `sample`, `some`,
	     * `sum`, `uniq`, and `words`
	     *
	     * @static
	     * @memberOf _
	     * @alias collect
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Array} Returns the new mapped array.
	     * @example
	     *
	     * function timesThree(n) {
	     *   return n * 3;
	     * }
	     *
	     * _.map([1, 2], timesThree);
	     * // => [3, 6]
	     *
	     * _.map({ 'a': 1, 'b': 2 }, timesThree);
	     * // => [3, 6] (iteration order is not guaranteed)
	     *
	     * var users = [
	     *   { 'user': 'barney' },
	     *   { 'user': 'fred' }
	     * ];
	     *
	     * // using the `_.property` callback shorthand
	     * _.map(users, 'user');
	     * // => ['barney', 'fred']
	     */
	    function map(collection, iteratee, thisArg) {
	      var func = isArray(collection) ? arrayMap : baseMap;
	      iteratee = getCallback(iteratee, thisArg, 3);
	      return func(collection, iteratee);
	    }

	    /**
	     * Creates an array of elements split into two groups, the first of which
	     * contains elements `predicate` returns truthy for, while the second of which
	     * contains elements `predicate` returns falsey for. The predicate is bound
	     * to `thisArg` and invoked with three arguments: (value, index|key, collection).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Array} Returns the array of grouped elements.
	     * @example
	     *
	     * _.partition([1, 2, 3], function(n) {
	     *   return n % 2;
	     * });
	     * // => [[1, 3], [2]]
	     *
	     * _.partition([1.2, 2.3, 3.4], function(n) {
	     *   return this.floor(n) % 2;
	     * }, Math);
	     * // => [[1.2, 3.4], [2.3]]
	     *
	     * var users = [
	     *   { 'user': 'barney',  'age': 36, 'active': false },
	     *   { 'user': 'fred',    'age': 40, 'active': true },
	     *   { 'user': 'pebbles', 'age': 1,  'active': false }
	     * ];
	     *
	     * var mapper = function(array) {
	     *   return _.pluck(array, 'user');
	     * };
	     *
	     * // using the `_.matches` callback shorthand
	     * _.map(_.partition(users, { 'age': 1, 'active': false }), mapper);
	     * // => [['pebbles'], ['barney', 'fred']]
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.map(_.partition(users, 'active', false), mapper);
	     * // => [['barney', 'pebbles'], ['fred']]
	     *
	     * // using the `_.property` callback shorthand
	     * _.map(_.partition(users, 'active'), mapper);
	     * // => [['fred'], ['barney', 'pebbles']]
	     */
	    var partition = createAggregator(function(result, value, key) {
	      result[key ? 0 : 1].push(value);
	    }, function() { return [[], []]; });

	    /**
	     * Gets the property value of `path` from all elements in `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Array|string} path The path of the property to pluck.
	     * @returns {Array} Returns the property values.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36 },
	     *   { 'user': 'fred',   'age': 40 }
	     * ];
	     *
	     * _.pluck(users, 'user');
	     * // => ['barney', 'fred']
	     *
	     * var userIndex = _.indexBy(users, 'user');
	     * _.pluck(userIndex, 'age');
	     * // => [36, 40] (iteration order is not guaranteed)
	     */
	    function pluck(collection, path) {
	      return map(collection, property(path));
	    }

	    /**
	     * Reduces `collection` to a value which is the accumulated result of running
	     * each element in `collection` through `iteratee`, where each successive
	     * invocation is supplied the return value of the previous. If `accumulator`
	     * is not provided the first element of `collection` is used as the initial
	     * value. The `iteratee` is bound to `thisArg` and invoked with four arguments:
	     * (accumulator, value, index|key, collection).
	     *
	     * Many lodash methods are guarded to work as iteratees for methods like
	     * `_.reduce`, `_.reduceRight`, and `_.transform`.
	     *
	     * The guarded methods are:
	     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `sortByAll`,
	     * and `sortByOrder`
	     *
	     * @static
	     * @memberOf _
	     * @alias foldl, inject
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [accumulator] The initial value.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {*} Returns the accumulated value.
	     * @example
	     *
	     * _.reduce([1, 2], function(total, n) {
	     *   return total + n;
	     * });
	     * // => 3
	     *
	     * _.reduce({ 'a': 1, 'b': 2 }, function(result, n, key) {
	     *   result[key] = n * 3;
	     *   return result;
	     * }, {});
	     * // => { 'a': 3, 'b': 6 } (iteration order is not guaranteed)
	     */
	    var reduce = createReduce(arrayReduce, baseEach);

	    /**
	     * This method is like `_.reduce` except that it iterates over elements of
	     * `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @alias foldr
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [accumulator] The initial value.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {*} Returns the accumulated value.
	     * @example
	     *
	     * var array = [[0, 1], [2, 3], [4, 5]];
	     *
	     * _.reduceRight(array, function(flattened, other) {
	     *   return flattened.concat(other);
	     * }, []);
	     * // => [4, 5, 2, 3, 0, 1]
	     */
	    var reduceRight = createReduce(arrayReduceRight, baseEachRight);

	    /**
	     * The opposite of `_.filter`; this method returns the elements of `collection`
	     * that `predicate` does **not** return truthy for.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Array} Returns the new filtered array.
	     * @example
	     *
	     * _.reject([1, 2, 3, 4], function(n) {
	     *   return n % 2 == 0;
	     * });
	     * // => [1, 3]
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': false },
	     *   { 'user': 'fred',   'age': 40, 'active': true }
	     * ];
	     *
	     * // using the `_.matches` callback shorthand
	     * _.pluck(_.reject(users, { 'age': 40, 'active': true }), 'user');
	     * // => ['barney']
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.pluck(_.reject(users, 'active', false), 'user');
	     * // => ['fred']
	     *
	     * // using the `_.property` callback shorthand
	     * _.pluck(_.reject(users, 'active'), 'user');
	     * // => ['barney']
	     */
	    function reject(collection, predicate, thisArg) {
	      var func = isArray(collection) ? arrayFilter : baseFilter;
	      predicate = getCallback(predicate, thisArg, 3);
	      return func(collection, function(value, index, collection) {
	        return !predicate(value, index, collection);
	      });
	    }

	    /**
	     * Gets a random element or `n` random elements from a collection.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to sample.
	     * @param {number} [n] The number of elements to sample.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {*} Returns the random sample(s).
	     * @example
	     *
	     * _.sample([1, 2, 3, 4]);
	     * // => 2
	     *
	     * _.sample([1, 2, 3, 4], 2);
	     * // => [3, 1]
	     */
	    function sample(collection, n, guard) {
	      if (guard ? isIterateeCall(collection, n, guard) : n == null) {
	        collection = toIterable(collection);
	        var length = collection.length;
	        return length > 0 ? collection[baseRandom(0, length - 1)] : undefined;
	      }
	      var index = -1,
	          result = toArray(collection),
	          length = result.length,
	          lastIndex = length - 1;

	      n = nativeMin(n < 0 ? 0 : (+n || 0), length);
	      while (++index < n) {
	        var rand = baseRandom(index, lastIndex),
	            value = result[rand];

	        result[rand] = result[index];
	        result[index] = value;
	      }
	      result.length = n;
	      return result;
	    }

	    /**
	     * Creates an array of shuffled values, using a version of the
	     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to shuffle.
	     * @returns {Array} Returns the new shuffled array.
	     * @example
	     *
	     * _.shuffle([1, 2, 3, 4]);
	     * // => [4, 1, 3, 2]
	     */
	    function shuffle(collection) {
	      return sample(collection, POSITIVE_INFINITY);
	    }

	    /**
	     * Gets the size of `collection` by returning its length for array-like
	     * values or the number of own enumerable properties for objects.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to inspect.
	     * @returns {number} Returns the size of `collection`.
	     * @example
	     *
	     * _.size([1, 2, 3]);
	     * // => 3
	     *
	     * _.size({ 'a': 1, 'b': 2 });
	     * // => 2
	     *
	     * _.size('pebbles');
	     * // => 7
	     */
	    function size(collection) {
	      var length = collection ? getLength(collection) : 0;
	      return isLength(length) ? length : keys(collection).length;
	    }

	    /**
	     * Checks if `predicate` returns truthy for **any** element of `collection`.
	     * The function returns as soon as it finds a passing value and does not iterate
	     * over the entire collection. The predicate is bound to `thisArg` and invoked
	     * with three arguments: (value, index|key, collection).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @alias any
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {boolean} Returns `true` if any element passes the predicate check,
	     *  else `false`.
	     * @example
	     *
	     * _.some([null, 0, 'yes', false], Boolean);
	     * // => true
	     *
	     * var users = [
	     *   { 'user': 'barney', 'active': true },
	     *   { 'user': 'fred',   'active': false }
	     * ];
	     *
	     * // using the `_.matches` callback shorthand
	     * _.some(users, { 'user': 'barney', 'active': false });
	     * // => false
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.some(users, 'active', false);
	     * // => true
	     *
	     * // using the `_.property` callback shorthand
	     * _.some(users, 'active');
	     * // => true
	     */
	    function some(collection, predicate, thisArg) {
	      var func = isArray(collection) ? arraySome : baseSome;
	      if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
	        predicate = undefined;
	      }
	      if (typeof predicate != 'function' || thisArg !== undefined) {
	        predicate = getCallback(predicate, thisArg, 3);
	      }
	      return func(collection, predicate);
	    }

	    /**
	     * Creates an array of elements, sorted in ascending order by the results of
	     * running each element in a collection through `iteratee`. This method performs
	     * a stable sort, that is, it preserves the original sort order of equal elements.
	     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
	     * (value, index|key, collection).
	     *
	     * If a property name is provided for `iteratee` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `iteratee` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Array} Returns the new sorted array.
	     * @example
	     *
	     * _.sortBy([1, 2, 3], function(n) {
	     *   return Math.sin(n);
	     * });
	     * // => [3, 1, 2]
	     *
	     * _.sortBy([1, 2, 3], function(n) {
	     *   return this.sin(n);
	     * }, Math);
	     * // => [3, 1, 2]
	     *
	     * var users = [
	     *   { 'user': 'fred' },
	     *   { 'user': 'pebbles' },
	     *   { 'user': 'barney' }
	     * ];
	     *
	     * // using the `_.property` callback shorthand
	     * _.pluck(_.sortBy(users, 'user'), 'user');
	     * // => ['barney', 'fred', 'pebbles']
	     */
	    function sortBy(collection, iteratee, thisArg) {
	      if (collection == null) {
	        return [];
	      }
	      if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
	        iteratee = undefined;
	      }
	      var index = -1;
	      iteratee = getCallback(iteratee, thisArg, 3);

	      var result = baseMap(collection, function(value, key, collection) {
	        return { 'criteria': iteratee(value, key, collection), 'index': ++index, 'value': value };
	      });
	      return baseSortBy(result, compareAscending);
	    }

	    /**
	     * This method is like `_.sortBy` except that it can sort by multiple iteratees
	     * or property names.
	     *
	     * If a property name is provided for an iteratee the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If an object is provided for an iteratee the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {...(Function|Function[]|Object|Object[]|string|string[])} iteratees
	     *  The iteratees to sort by, specified as individual values or arrays of values.
	     * @returns {Array} Returns the new sorted array.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'fred',   'age': 48 },
	     *   { 'user': 'barney', 'age': 36 },
	     *   { 'user': 'fred',   'age': 42 },
	     *   { 'user': 'barney', 'age': 34 }
	     * ];
	     *
	     * _.map(_.sortByAll(users, ['user', 'age']), _.values);
	     * // => [['barney', 34], ['barney', 36], ['fred', 42], ['fred', 48]]
	     *
	     * _.map(_.sortByAll(users, 'user', function(chr) {
	     *   return Math.floor(chr.age / 10);
	     * }), _.values);
	     * // => [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]
	     */
	    var sortByAll = restParam(function(collection, iteratees) {
	      if (collection == null) {
	        return [];
	      }
	      var guard = iteratees[2];
	      if (guard && isIterateeCall(iteratees[0], iteratees[1], guard)) {
	        iteratees.length = 1;
	      }
	      return baseSortByOrder(collection, baseFlatten(iteratees), []);
	    });

	    /**
	     * This method is like `_.sortByAll` except that it allows specifying the
	     * sort orders of the iteratees to sort by. If `orders` is unspecified, all
	     * values are sorted in ascending order. Otherwise, a value is sorted in
	     * ascending order if its corresponding order is "asc", and descending if "desc".
	     *
	     * If a property name is provided for an iteratee the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If an object is provided for an iteratee the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
	     * @param {boolean[]} [orders] The sort orders of `iteratees`.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.reduce`.
	     * @returns {Array} Returns the new sorted array.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'fred',   'age': 48 },
	     *   { 'user': 'barney', 'age': 34 },
	     *   { 'user': 'fred',   'age': 42 },
	     *   { 'user': 'barney', 'age': 36 }
	     * ];
	     *
	     * // sort by `user` in ascending order and by `age` in descending order
	     * _.map(_.sortByOrder(users, ['user', 'age'], ['asc', 'desc']), _.values);
	     * // => [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]
	     */
	    function sortByOrder(collection, iteratees, orders, guard) {
	      if (collection == null) {
	        return [];
	      }
	      if (guard && isIterateeCall(iteratees, orders, guard)) {
	        orders = undefined;
	      }
	      if (!isArray(iteratees)) {
	        iteratees = iteratees == null ? [] : [iteratees];
	      }
	      if (!isArray(orders)) {
	        orders = orders == null ? [] : [orders];
	      }
	      return baseSortByOrder(collection, iteratees, orders);
	    }

	    /**
	     * Performs a deep comparison between each element in `collection` and the
	     * source object, returning an array of all elements that have equivalent
	     * property values.
	     *
	     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
	     * numbers, `Object` objects, regexes, and strings. Objects are compared by
	     * their own, not inherited, enumerable properties. For comparing a single
	     * own or inherited property value see `_.matchesProperty`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to search.
	     * @param {Object} source The object of property values to match.
	     * @returns {Array} Returns the new filtered array.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': false, 'pets': ['hoppy'] },
	     *   { 'user': 'fred',   'age': 40, 'active': true, 'pets': ['baby puss', 'dino'] }
	     * ];
	     *
	     * _.pluck(_.where(users, { 'age': 36, 'active': false }), 'user');
	     * // => ['barney']
	     *
	     * _.pluck(_.where(users, { 'pets': ['dino'] }), 'user');
	     * // => ['fred']
	     */
	    function where(collection, source) {
	      return filter(collection, baseMatches(source));
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Gets the number of milliseconds that have elapsed since the Unix epoch
	     * (1 January 1970 00:00:00 UTC).
	     *
	     * @static
	     * @memberOf _
	     * @category Date
	     * @example
	     *
	     * _.defer(function(stamp) {
	     *   console.log(_.now() - stamp);
	     * }, _.now());
	     * // => logs the number of milliseconds it took for the deferred function to be invoked
	     */
	    var now = nativeNow || function() {
	      return new Date().getTime();
	    };

	    /*------------------------------------------------------------------------*/

	    /**
	     * The opposite of `_.before`; this method creates a function that invokes
	     * `func` once it is called `n` or more times.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {number} n The number of calls before `func` is invoked.
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new restricted function.
	     * @example
	     *
	     * var saves = ['profile', 'settings'];
	     *
	     * var done = _.after(saves.length, function() {
	     *   console.log('done saving!');
	     * });
	     *
	     * _.forEach(saves, function(type) {
	     *   asyncSave({ 'type': type, 'complete': done });
	     * });
	     * // => logs 'done saving!' after the two async saves have completed
	     */
	    function after(n, func) {
	      if (typeof func != 'function') {
	        if (typeof n == 'function') {
	          var temp = n;
	          n = func;
	          func = temp;
	        } else {
	          throw new TypeError(FUNC_ERROR_TEXT);
	        }
	      }
	      n = nativeIsFinite(n = +n) ? n : 0;
	      return function() {
	        if (--n < 1) {
	          return func.apply(this, arguments);
	        }
	      };
	    }

	    /**
	     * Creates a function that accepts up to `n` arguments ignoring any
	     * additional arguments.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to cap arguments for.
	     * @param {number} [n=func.length] The arity cap.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
	     * // => [6, 8, 10]
	     */
	    function ary(func, n, guard) {
	      if (guard && isIterateeCall(func, n, guard)) {
	        n = undefined;
	      }
	      n = (func && n == null) ? func.length : nativeMax(+n || 0, 0);
	      return createWrapper(func, ARY_FLAG, undefined, undefined, undefined, undefined, n);
	    }

	    /**
	     * Creates a function that invokes `func`, with the `this` binding and arguments
	     * of the created function, while it is called less than `n` times. Subsequent
	     * calls to the created function return the result of the last `func` invocation.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {number} n The number of calls at which `func` is no longer invoked.
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new restricted function.
	     * @example
	     *
	     * jQuery('#add').on('click', _.before(5, addContactToList));
	     * // => allows adding up to 4 contacts to the list
	     */
	    function before(n, func) {
	      var result;
	      if (typeof func != 'function') {
	        if (typeof n == 'function') {
	          var temp = n;
	          n = func;
	          func = temp;
	        } else {
	          throw new TypeError(FUNC_ERROR_TEXT);
	        }
	      }
	      return function() {
	        if (--n > 0) {
	          result = func.apply(this, arguments);
	        }
	        if (n <= 1) {
	          func = undefined;
	        }
	        return result;
	      };
	    }

	    /**
	     * Creates a function that invokes `func` with the `this` binding of `thisArg`
	     * and prepends any additional `_.bind` arguments to those provided to the
	     * bound function.
	     *
	     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
	     * may be used as a placeholder for partially applied arguments.
	     *
	     * **Note:** Unlike native `Function#bind` this method does not set the "length"
	     * property of bound functions.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to bind.
	     * @param {*} thisArg The `this` binding of `func`.
	     * @param {...*} [partials] The arguments to be partially applied.
	     * @returns {Function} Returns the new bound function.
	     * @example
	     *
	     * var greet = function(greeting, punctuation) {
	     *   return greeting + ' ' + this.user + punctuation;
	     * };
	     *
	     * var object = { 'user': 'fred' };
	     *
	     * var bound = _.bind(greet, object, 'hi');
	     * bound('!');
	     * // => 'hi fred!'
	     *
	     * // using placeholders
	     * var bound = _.bind(greet, object, _, '!');
	     * bound('hi');
	     * // => 'hi fred!'
	     */
	    var bind = restParam(function(func, thisArg, partials) {
	      var bitmask = BIND_FLAG;
	      if (partials.length) {
	        var holders = replaceHolders(partials, bind.placeholder);
	        bitmask |= PARTIAL_FLAG;
	      }
	      return createWrapper(func, bitmask, thisArg, partials, holders);
	    });

	    /**
	     * Binds methods of an object to the object itself, overwriting the existing
	     * method. Method names may be specified as individual arguments or as arrays
	     * of method names. If no method names are provided all enumerable function
	     * properties, own and inherited, of `object` are bound.
	     *
	     * **Note:** This method does not set the "length" property of bound functions.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Object} object The object to bind and assign the bound methods to.
	     * @param {...(string|string[])} [methodNames] The object method names to bind,
	     *  specified as individual method names or arrays of method names.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var view = {
	     *   'label': 'docs',
	     *   'onClick': function() {
	     *     console.log('clicked ' + this.label);
	     *   }
	     * };
	     *
	     * _.bindAll(view);
	     * jQuery('#docs').on('click', view.onClick);
	     * // => logs 'clicked docs' when the element is clicked
	     */
	    var bindAll = restParam(function(object, methodNames) {
	      methodNames = methodNames.length ? baseFlatten(methodNames) : functions(object);

	      var index = -1,
	          length = methodNames.length;

	      while (++index < length) {
	        var key = methodNames[index];
	        object[key] = createWrapper(object[key], BIND_FLAG, object);
	      }
	      return object;
	    });

	    /**
	     * Creates a function that invokes the method at `object[key]` and prepends
	     * any additional `_.bindKey` arguments to those provided to the bound function.
	     *
	     * This method differs from `_.bind` by allowing bound functions to reference
	     * methods that may be redefined or don't yet exist.
	     * See [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
	     * for more details.
	     *
	     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for partially applied arguments.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Object} object The object the method belongs to.
	     * @param {string} key The key of the method.
	     * @param {...*} [partials] The arguments to be partially applied.
	     * @returns {Function} Returns the new bound function.
	     * @example
	     *
	     * var object = {
	     *   'user': 'fred',
	     *   'greet': function(greeting, punctuation) {
	     *     return greeting + ' ' + this.user + punctuation;
	     *   }
	     * };
	     *
	     * var bound = _.bindKey(object, 'greet', 'hi');
	     * bound('!');
	     * // => 'hi fred!'
	     *
	     * object.greet = function(greeting, punctuation) {
	     *   return greeting + 'ya ' + this.user + punctuation;
	     * };
	     *
	     * bound('!');
	     * // => 'hiya fred!'
	     *
	     * // using placeholders
	     * var bound = _.bindKey(object, 'greet', _, '!');
	     * bound('hi');
	     * // => 'hiya fred!'
	     */
	    var bindKey = restParam(function(object, key, partials) {
	      var bitmask = BIND_FLAG | BIND_KEY_FLAG;
	      if (partials.length) {
	        var holders = replaceHolders(partials, bindKey.placeholder);
	        bitmask |= PARTIAL_FLAG;
	      }
	      return createWrapper(key, bitmask, object, partials, holders);
	    });

	    /**
	     * Creates a function that accepts one or more arguments of `func` that when
	     * called either invokes `func` returning its result, if all `func` arguments
	     * have been provided, or returns a function that accepts one or more of the
	     * remaining `func` arguments, and so on. The arity of `func` may be specified
	     * if `func.length` is not sufficient.
	     *
	     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
	     * may be used as a placeholder for provided arguments.
	     *
	     * **Note:** This method does not set the "length" property of curried functions.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to curry.
	     * @param {number} [arity=func.length] The arity of `func`.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Function} Returns the new curried function.
	     * @example
	     *
	     * var abc = function(a, b, c) {
	     *   return [a, b, c];
	     * };
	     *
	     * var curried = _.curry(abc);
	     *
	     * curried(1)(2)(3);
	     * // => [1, 2, 3]
	     *
	     * curried(1, 2)(3);
	     * // => [1, 2, 3]
	     *
	     * curried(1, 2, 3);
	     * // => [1, 2, 3]
	     *
	     * // using placeholders
	     * curried(1)(_, 3)(2);
	     * // => [1, 2, 3]
	     */
	    var curry = createCurry(CURRY_FLAG);

	    /**
	     * This method is like `_.curry` except that arguments are applied to `func`
	     * in the manner of `_.partialRight` instead of `_.partial`.
	     *
	     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for provided arguments.
	     *
	     * **Note:** This method does not set the "length" property of curried functions.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to curry.
	     * @param {number} [arity=func.length] The arity of `func`.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Function} Returns the new curried function.
	     * @example
	     *
	     * var abc = function(a, b, c) {
	     *   return [a, b, c];
	     * };
	     *
	     * var curried = _.curryRight(abc);
	     *
	     * curried(3)(2)(1);
	     * // => [1, 2, 3]
	     *
	     * curried(2, 3)(1);
	     * // => [1, 2, 3]
	     *
	     * curried(1, 2, 3);
	     * // => [1, 2, 3]
	     *
	     * // using placeholders
	     * curried(3)(1, _)(2);
	     * // => [1, 2, 3]
	     */
	    var curryRight = createCurry(CURRY_RIGHT_FLAG);

	    /**
	     * Creates a debounced function that delays invoking `func` until after `wait`
	     * milliseconds have elapsed since the last time the debounced function was
	     * invoked. The debounced function comes with a `cancel` method to cancel
	     * delayed invocations. Provide an options object to indicate that `func`
	     * should be invoked on the leading and/or trailing edge of the `wait` timeout.
	     * Subsequent calls to the debounced function return the result of the last
	     * `func` invocation.
	     *
	     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
	     * on the trailing edge of the timeout only if the the debounced function is
	     * invoked more than once during the `wait` timeout.
	     *
	     * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
	     * for details over the differences between `_.debounce` and `_.throttle`.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to debounce.
	     * @param {number} [wait=0] The number of milliseconds to delay.
	     * @param {Object} [options] The options object.
	     * @param {boolean} [options.leading=false] Specify invoking on the leading
	     *  edge of the timeout.
	     * @param {number} [options.maxWait] The maximum time `func` is allowed to be
	     *  delayed before it is invoked.
	     * @param {boolean} [options.trailing=true] Specify invoking on the trailing
	     *  edge of the timeout.
	     * @returns {Function} Returns the new debounced function.
	     * @example
	     *
	     * // avoid costly calculations while the window size is in flux
	     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
	     *
	     * // invoke `sendMail` when the click event is fired, debouncing subsequent calls
	     * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
	     *   'leading': true,
	     *   'trailing': false
	     * }));
	     *
	     * // ensure `batchLog` is invoked once after 1 second of debounced calls
	     * var source = new EventSource('/stream');
	     * jQuery(source).on('message', _.debounce(batchLog, 250, {
	     *   'maxWait': 1000
	     * }));
	     *
	     * // cancel a debounced call
	     * var todoChanges = _.debounce(batchLog, 1000);
	     * Object.observe(models.todo, todoChanges);
	     *
	     * Object.observe(models, function(changes) {
	     *   if (_.find(changes, { 'user': 'todo', 'type': 'delete'})) {
	     *     todoChanges.cancel();
	     *   }
	     * }, ['delete']);
	     *
	     * // ...at some point `models.todo` is changed
	     * models.todo.completed = true;
	     *
	     * // ...before 1 second has passed `models.todo` is deleted
	     * // which cancels the debounced `todoChanges` call
	     * delete models.todo;
	     */
	    function debounce(func, wait, options) {
	      var args,
	          maxTimeoutId,
	          result,
	          stamp,
	          thisArg,
	          timeoutId,
	          trailingCall,
	          lastCalled = 0,
	          maxWait = false,
	          trailing = true;

	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      wait = wait < 0 ? 0 : (+wait || 0);
	      if (options === true) {
	        var leading = true;
	        trailing = false;
	      } else if (isObject(options)) {
	        leading = !!options.leading;
	        maxWait = 'maxWait' in options && nativeMax(+options.maxWait || 0, wait);
	        trailing = 'trailing' in options ? !!options.trailing : trailing;
	      }

	      function cancel() {
	        if (timeoutId) {
	          clearTimeout(timeoutId);
	        }
	        if (maxTimeoutId) {
	          clearTimeout(maxTimeoutId);
	        }
	        lastCalled = 0;
	        maxTimeoutId = timeoutId = trailingCall = undefined;
	      }

	      function complete(isCalled, id) {
	        if (id) {
	          clearTimeout(id);
	        }
	        maxTimeoutId = timeoutId = trailingCall = undefined;
	        if (isCalled) {
	          lastCalled = now();
	          result = func.apply(thisArg, args);
	          if (!timeoutId && !maxTimeoutId) {
	            args = thisArg = undefined;
	          }
	        }
	      }

	      function delayed() {
	        var remaining = wait - (now() - stamp);
	        if (remaining <= 0 || remaining > wait) {
	          complete(trailingCall, maxTimeoutId);
	        } else {
	          timeoutId = setTimeout(delayed, remaining);
	        }
	      }

	      function maxDelayed() {
	        complete(trailing, timeoutId);
	      }

	      function debounced() {
	        args = arguments;
	        stamp = now();
	        thisArg = this;
	        trailingCall = trailing && (timeoutId || !leading);

	        if (maxWait === false) {
	          var leadingCall = leading && !timeoutId;
	        } else {
	          if (!maxTimeoutId && !leading) {
	            lastCalled = stamp;
	          }
	          var remaining = maxWait - (stamp - lastCalled),
	              isCalled = remaining <= 0 || remaining > maxWait;

	          if (isCalled) {
	            if (maxTimeoutId) {
	              maxTimeoutId = clearTimeout(maxTimeoutId);
	            }
	            lastCalled = stamp;
	            result = func.apply(thisArg, args);
	          }
	          else if (!maxTimeoutId) {
	            maxTimeoutId = setTimeout(maxDelayed, remaining);
	          }
	        }
	        if (isCalled && timeoutId) {
	          timeoutId = clearTimeout(timeoutId);
	        }
	        else if (!timeoutId && wait !== maxWait) {
	          timeoutId = setTimeout(delayed, wait);
	        }
	        if (leadingCall) {
	          isCalled = true;
	          result = func.apply(thisArg, args);
	        }
	        if (isCalled && !timeoutId && !maxTimeoutId) {
	          args = thisArg = undefined;
	        }
	        return result;
	      }
	      debounced.cancel = cancel;
	      return debounced;
	    }

	    /**
	     * Defers invoking the `func` until the current call stack has cleared. Any
	     * additional arguments are provided to `func` when it is invoked.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to defer.
	     * @param {...*} [args] The arguments to invoke the function with.
	     * @returns {number} Returns the timer id.
	     * @example
	     *
	     * _.defer(function(text) {
	     *   console.log(text);
	     * }, 'deferred');
	     * // logs 'deferred' after one or more milliseconds
	     */
	    var defer = restParam(function(func, args) {
	      return baseDelay(func, 1, args);
	    });

	    /**
	     * Invokes `func` after `wait` milliseconds. Any additional arguments are
	     * provided to `func` when it is invoked.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to delay.
	     * @param {number} wait The number of milliseconds to delay invocation.
	     * @param {...*} [args] The arguments to invoke the function with.
	     * @returns {number} Returns the timer id.
	     * @example
	     *
	     * _.delay(function(text) {
	     *   console.log(text);
	     * }, 1000, 'later');
	     * // => logs 'later' after one second
	     */
	    var delay = restParam(function(func, wait, args) {
	      return baseDelay(func, wait, args);
	    });

	    /**
	     * Creates a function that returns the result of invoking the provided
	     * functions with the `this` binding of the created function, where each
	     * successive invocation is supplied the return value of the previous.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {...Function} [funcs] Functions to invoke.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var addSquare = _.flow(_.add, square);
	     * addSquare(1, 2);
	     * // => 9
	     */
	    var flow = createFlow();

	    /**
	     * This method is like `_.flow` except that it creates a function that
	     * invokes the provided functions from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @alias backflow, compose
	     * @category Function
	     * @param {...Function} [funcs] Functions to invoke.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var addSquare = _.flowRight(square, _.add);
	     * addSquare(1, 2);
	     * // => 9
	     */
	    var flowRight = createFlow(true);

	    /**
	     * Creates a function that memoizes the result of `func`. If `resolver` is
	     * provided it determines the cache key for storing the result based on the
	     * arguments provided to the memoized function. By default, the first argument
	     * provided to the memoized function is coerced to a string and used as the
	     * cache key. The `func` is invoked with the `this` binding of the memoized
	     * function.
	     *
	     * **Note:** The cache is exposed as the `cache` property on the memoized
	     * function. Its creation may be customized by replacing the `_.memoize.Cache`
	     * constructor with one whose instances implement the [`Map`](http://ecma-international.org/ecma-262/6.0/#sec-properties-of-the-map-prototype-object)
	     * method interface of `get`, `has`, and `set`.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to have its output memoized.
	     * @param {Function} [resolver] The function to resolve the cache key.
	     * @returns {Function} Returns the new memoizing function.
	     * @example
	     *
	     * var upperCase = _.memoize(function(string) {
	     *   return string.toUpperCase();
	     * });
	     *
	     * upperCase('fred');
	     * // => 'FRED'
	     *
	     * // modifying the result cache
	     * upperCase.cache.set('fred', 'BARNEY');
	     * upperCase('fred');
	     * // => 'BARNEY'
	     *
	     * // replacing `_.memoize.Cache`
	     * var object = { 'user': 'fred' };
	     * var other = { 'user': 'barney' };
	     * var identity = _.memoize(_.identity);
	     *
	     * identity(object);
	     * // => { 'user': 'fred' }
	     * identity(other);
	     * // => { 'user': 'fred' }
	     *
	     * _.memoize.Cache = WeakMap;
	     * var identity = _.memoize(_.identity);
	     *
	     * identity(object);
	     * // => { 'user': 'fred' }
	     * identity(other);
	     * // => { 'user': 'barney' }
	     */
	    function memoize(func, resolver) {
	      if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      var memoized = function() {
	        var args = arguments,
	            key = resolver ? resolver.apply(this, args) : args[0],
	            cache = memoized.cache;

	        if (cache.has(key)) {
	          return cache.get(key);
	        }
	        var result = func.apply(this, args);
	        memoized.cache = cache.set(key, result);
	        return result;
	      };
	      memoized.cache = new memoize.Cache;
	      return memoized;
	    }

	    /**
	     * Creates a function that runs each argument through a corresponding
	     * transform function.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to wrap.
	     * @param {...(Function|Function[])} [transforms] The functions to transform
	     * arguments, specified as individual functions or arrays of functions.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * function doubled(n) {
	     *   return n * 2;
	     * }
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var modded = _.modArgs(function(x, y) {
	     *   return [x, y];
	     * }, square, doubled);
	     *
	     * modded(1, 2);
	     * // => [1, 4]
	     *
	     * modded(5, 10);
	     * // => [25, 20]
	     */
	    var modArgs = restParam(function(func, transforms) {
	      transforms = baseFlatten(transforms);
	      if (typeof func != 'function' || !arrayEvery(transforms, baseIsFunction)) {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      var length = transforms.length;
	      return restParam(function(args) {
	        var index = nativeMin(args.length, length);
	        while (index--) {
	          args[index] = transforms[index](args[index]);
	        }
	        return func.apply(this, args);
	      });
	    });

	    /**
	     * Creates a function that negates the result of the predicate `func`. The
	     * `func` predicate is invoked with the `this` binding and arguments of the
	     * created function.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} predicate The predicate to negate.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * function isEven(n) {
	     *   return n % 2 == 0;
	     * }
	     *
	     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
	     * // => [1, 3, 5]
	     */
	    function negate(predicate) {
	      if (typeof predicate != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      return function() {
	        return !predicate.apply(this, arguments);
	      };
	    }

	    /**
	     * Creates a function that is restricted to invoking `func` once. Repeat calls
	     * to the function return the value of the first call. The `func` is invoked
	     * with the `this` binding and arguments of the created function.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new restricted function.
	     * @example
	     *
	     * var initialize = _.once(createApplication);
	     * initialize();
	     * initialize();
	     * // `initialize` invokes `createApplication` once
	     */
	    function once(func) {
	      return before(2, func);
	    }

	    /**
	     * Creates a function that invokes `func` with `partial` arguments prepended
	     * to those provided to the new function. This method is like `_.bind` except
	     * it does **not** alter the `this` binding.
	     *
	     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for partially applied arguments.
	     *
	     * **Note:** This method does not set the "length" property of partially
	     * applied functions.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to partially apply arguments to.
	     * @param {...*} [partials] The arguments to be partially applied.
	     * @returns {Function} Returns the new partially applied function.
	     * @example
	     *
	     * var greet = function(greeting, name) {
	     *   return greeting + ' ' + name;
	     * };
	     *
	     * var sayHelloTo = _.partial(greet, 'hello');
	     * sayHelloTo('fred');
	     * // => 'hello fred'
	     *
	     * // using placeholders
	     * var greetFred = _.partial(greet, _, 'fred');
	     * greetFred('hi');
	     * // => 'hi fred'
	     */
	    var partial = createPartial(PARTIAL_FLAG);

	    /**
	     * This method is like `_.partial` except that partially applied arguments
	     * are appended to those provided to the new function.
	     *
	     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for partially applied arguments.
	     *
	     * **Note:** This method does not set the "length" property of partially
	     * applied functions.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to partially apply arguments to.
	     * @param {...*} [partials] The arguments to be partially applied.
	     * @returns {Function} Returns the new partially applied function.
	     * @example
	     *
	     * var greet = function(greeting, name) {
	     *   return greeting + ' ' + name;
	     * };
	     *
	     * var greetFred = _.partialRight(greet, 'fred');
	     * greetFred('hi');
	     * // => 'hi fred'
	     *
	     * // using placeholders
	     * var sayHelloTo = _.partialRight(greet, 'hello', _);
	     * sayHelloTo('fred');
	     * // => 'hello fred'
	     */
	    var partialRight = createPartial(PARTIAL_RIGHT_FLAG);

	    /**
	     * Creates a function that invokes `func` with arguments arranged according
	     * to the specified indexes where the argument value at the first index is
	     * provided as the first argument, the argument value at the second index is
	     * provided as the second argument, and so on.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to rearrange arguments for.
	     * @param {...(number|number[])} indexes The arranged argument indexes,
	     *  specified as individual indexes or arrays of indexes.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var rearged = _.rearg(function(a, b, c) {
	     *   return [a, b, c];
	     * }, 2, 0, 1);
	     *
	     * rearged('b', 'c', 'a')
	     * // => ['a', 'b', 'c']
	     *
	     * var map = _.rearg(_.map, [1, 0]);
	     * map(function(n) {
	     *   return n * 3;
	     * }, [1, 2, 3]);
	     * // => [3, 6, 9]
	     */
	    var rearg = restParam(function(func, indexes) {
	      return createWrapper(func, REARG_FLAG, undefined, undefined, undefined, baseFlatten(indexes));
	    });

	    /**
	     * Creates a function that invokes `func` with the `this` binding of the
	     * created function and arguments from `start` and beyond provided as an array.
	     *
	     * **Note:** This method is based on the [rest parameter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters).
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to apply a rest parameter to.
	     * @param {number} [start=func.length-1] The start position of the rest parameter.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var say = _.restParam(function(what, names) {
	     *   return what + ' ' + _.initial(names).join(', ') +
	     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
	     * });
	     *
	     * say('hello', 'fred', 'barney', 'pebbles');
	     * // => 'hello fred, barney, & pebbles'
	     */
	    function restParam(func, start) {
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      start = nativeMax(start === undefined ? (func.length - 1) : (+start || 0), 0);
	      return function() {
	        var args = arguments,
	            index = -1,
	            length = nativeMax(args.length - start, 0),
	            rest = Array(length);

	        while (++index < length) {
	          rest[index] = args[start + index];
	        }
	        switch (start) {
	          case 0: return func.call(this, rest);
	          case 1: return func.call(this, args[0], rest);
	          case 2: return func.call(this, args[0], args[1], rest);
	        }
	        var otherArgs = Array(start + 1);
	        index = -1;
	        while (++index < start) {
	          otherArgs[index] = args[index];
	        }
	        otherArgs[start] = rest;
	        return func.apply(this, otherArgs);
	      };
	    }

	    /**
	     * Creates a function that invokes `func` with the `this` binding of the created
	     * function and an array of arguments much like [`Function#apply`](https://es5.github.io/#x15.3.4.3).
	     *
	     * **Note:** This method is based on the [spread operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator).
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to spread arguments over.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var say = _.spread(function(who, what) {
	     *   return who + ' says ' + what;
	     * });
	     *
	     * say(['fred', 'hello']);
	     * // => 'fred says hello'
	     *
	     * // with a Promise
	     * var numbers = Promise.all([
	     *   Promise.resolve(40),
	     *   Promise.resolve(36)
	     * ]);
	     *
	     * numbers.then(_.spread(function(x, y) {
	     *   return x + y;
	     * }));
	     * // => a Promise of 76
	     */
	    function spread(func) {
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      return function(array) {
	        return func.apply(this, array);
	      };
	    }

	    /**
	     * Creates a throttled function that only invokes `func` at most once per
	     * every `wait` milliseconds. The throttled function comes with a `cancel`
	     * method to cancel delayed invocations. Provide an options object to indicate
	     * that `func` should be invoked on the leading and/or trailing edge of the
	     * `wait` timeout. Subsequent calls to the throttled function return the
	     * result of the last `func` call.
	     *
	     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
	     * on the trailing edge of the timeout only if the the throttled function is
	     * invoked more than once during the `wait` timeout.
	     *
	     * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
	     * for details over the differences between `_.throttle` and `_.debounce`.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to throttle.
	     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
	     * @param {Object} [options] The options object.
	     * @param {boolean} [options.leading=true] Specify invoking on the leading
	     *  edge of the timeout.
	     * @param {boolean} [options.trailing=true] Specify invoking on the trailing
	     *  edge of the timeout.
	     * @returns {Function} Returns the new throttled function.
	     * @example
	     *
	     * // avoid excessively updating the position while scrolling
	     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
	     *
	     * // invoke `renewToken` when the click event is fired, but not more than once every 5 minutes
	     * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
	     *   'trailing': false
	     * }));
	     *
	     * // cancel a trailing throttled call
	     * jQuery(window).on('popstate', throttled.cancel);
	     */
	    function throttle(func, wait, options) {
	      var leading = true,
	          trailing = true;

	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      if (options === false) {
	        leading = false;
	      } else if (isObject(options)) {
	        leading = 'leading' in options ? !!options.leading : leading;
	        trailing = 'trailing' in options ? !!options.trailing : trailing;
	      }
	      return debounce(func, wait, { 'leading': leading, 'maxWait': +wait, 'trailing': trailing });
	    }

	    /**
	     * Creates a function that provides `value` to the wrapper function as its
	     * first argument. Any additional arguments provided to the function are
	     * appended to those provided to the wrapper function. The wrapper is invoked
	     * with the `this` binding of the created function.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {*} value The value to wrap.
	     * @param {Function} wrapper The wrapper function.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var p = _.wrap(_.escape, function(func, text) {
	     *   return '<p>' + func(text) + '</p>';
	     * });
	     *
	     * p('fred, barney, & pebbles');
	     * // => '<p>fred, barney, &amp; pebbles</p>'
	     */
	    function wrap(value, wrapper) {
	      wrapper = wrapper == null ? identity : wrapper;
	      return createWrapper(wrapper, PARTIAL_FLAG, undefined, [value], []);
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates a clone of `value`. If `isDeep` is `true` nested objects are cloned,
	     * otherwise they are assigned by reference. If `customizer` is provided it is
	     * invoked to produce the cloned values. If `customizer` returns `undefined`
	     * cloning is handled by the method instead. The `customizer` is bound to
	     * `thisArg` and invoked with two argument; (value [, index|key, object]).
	     *
	     * **Note:** This method is loosely based on the
	     * [structured clone algorithm](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm).
	     * The enumerable properties of `arguments` objects and objects created by
	     * constructors other than `Object` are cloned to plain `Object` objects. An
	     * empty object is returned for uncloneable values such as functions, DOM nodes,
	     * Maps, Sets, and WeakMaps.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to clone.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @param {Function} [customizer] The function to customize cloning values.
	     * @param {*} [thisArg] The `this` binding of `customizer`.
	     * @returns {*} Returns the cloned value.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney' },
	     *   { 'user': 'fred' }
	     * ];
	     *
	     * var shallow = _.clone(users);
	     * shallow[0] === users[0];
	     * // => true
	     *
	     * var deep = _.clone(users, true);
	     * deep[0] === users[0];
	     * // => false
	     *
	     * // using a customizer callback
	     * var el = _.clone(document.body, function(value) {
	     *   if (_.isElement(value)) {
	     *     return value.cloneNode(false);
	     *   }
	     * });
	     *
	     * el === document.body
	     * // => false
	     * el.nodeName
	     * // => BODY
	     * el.childNodes.length;
	     * // => 0
	     */
	    function clone(value, isDeep, customizer, thisArg) {
	      if (isDeep && typeof isDeep != 'boolean' && isIterateeCall(value, isDeep, customizer)) {
	        isDeep = false;
	      }
	      else if (typeof isDeep == 'function') {
	        thisArg = customizer;
	        customizer = isDeep;
	        isDeep = false;
	      }
	      return typeof customizer == 'function'
	        ? baseClone(value, isDeep, bindCallback(customizer, thisArg, 1))
	        : baseClone(value, isDeep);
	    }

	    /**
	     * Creates a deep clone of `value`. If `customizer` is provided it is invoked
	     * to produce the cloned values. If `customizer` returns `undefined` cloning
	     * is handled by the method instead. The `customizer` is bound to `thisArg`
	     * and invoked with two argument; (value [, index|key, object]).
	     *
	     * **Note:** This method is loosely based on the
	     * [structured clone algorithm](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm).
	     * The enumerable properties of `arguments` objects and objects created by
	     * constructors other than `Object` are cloned to plain `Object` objects. An
	     * empty object is returned for uncloneable values such as functions, DOM nodes,
	     * Maps, Sets, and WeakMaps.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to deep clone.
	     * @param {Function} [customizer] The function to customize cloning values.
	     * @param {*} [thisArg] The `this` binding of `customizer`.
	     * @returns {*} Returns the deep cloned value.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney' },
	     *   { 'user': 'fred' }
	     * ];
	     *
	     * var deep = _.cloneDeep(users);
	     * deep[0] === users[0];
	     * // => false
	     *
	     * // using a customizer callback
	     * var el = _.cloneDeep(document.body, function(value) {
	     *   if (_.isElement(value)) {
	     *     return value.cloneNode(true);
	     *   }
	     * });
	     *
	     * el === document.body
	     * // => false
	     * el.nodeName
	     * // => BODY
	     * el.childNodes.length;
	     * // => 20
	     */
	    function cloneDeep(value, customizer, thisArg) {
	      return typeof customizer == 'function'
	        ? baseClone(value, true, bindCallback(customizer, thisArg, 1))
	        : baseClone(value, true);
	    }

	    /**
	     * Checks if `value` is greater than `other`.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is greater than `other`, else `false`.
	     * @example
	     *
	     * _.gt(3, 1);
	     * // => true
	     *
	     * _.gt(3, 3);
	     * // => false
	     *
	     * _.gt(1, 3);
	     * // => false
	     */
	    function gt(value, other) {
	      return value > other;
	    }

	    /**
	     * Checks if `value` is greater than or equal to `other`.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is greater than or equal to `other`, else `false`.
	     * @example
	     *
	     * _.gte(3, 1);
	     * // => true
	     *
	     * _.gte(3, 3);
	     * // => true
	     *
	     * _.gte(1, 3);
	     * // => false
	     */
	    function gte(value, other) {
	      return value >= other;
	    }

	    /**
	     * Checks if `value` is classified as an `arguments` object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isArguments(function() { return arguments; }());
	     * // => true
	     *
	     * _.isArguments([1, 2, 3]);
	     * // => false
	     */
	    function isArguments(value) {
	      return isObjectLike(value) && isArrayLike(value) &&
	        hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
	    }

	    /**
	     * Checks if `value` is classified as an `Array` object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isArray([1, 2, 3]);
	     * // => true
	     *
	     * _.isArray(function() { return arguments; }());
	     * // => false
	     */
	    var isArray = nativeIsArray || function(value) {
	      return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;
	    };

	    /**
	     * Checks if `value` is classified as a boolean primitive or object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isBoolean(false);
	     * // => true
	     *
	     * _.isBoolean(null);
	     * // => false
	     */
	    function isBoolean(value) {
	      return value === true || value === false || (isObjectLike(value) && objToString.call(value) == boolTag);
	    }

	    /**
	     * Checks if `value` is classified as a `Date` object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isDate(new Date);
	     * // => true
	     *
	     * _.isDate('Mon April 23 2012');
	     * // => false
	     */
	    function isDate(value) {
	      return isObjectLike(value) && objToString.call(value) == dateTag;
	    }

	    /**
	     * Checks if `value` is a DOM element.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
	     * @example
	     *
	     * _.isElement(document.body);
	     * // => true
	     *
	     * _.isElement('<body>');
	     * // => false
	     */
	    function isElement(value) {
	      return !!value && value.nodeType === 1 && isObjectLike(value) && !isPlainObject(value);
	    }

	    /**
	     * Checks if `value` is empty. A value is considered empty unless it is an
	     * `arguments` object, array, string, or jQuery-like collection with a length
	     * greater than `0` or an object with own enumerable properties.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {Array|Object|string} value The value to inspect.
	     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
	     * @example
	     *
	     * _.isEmpty(null);
	     * // => true
	     *
	     * _.isEmpty(true);
	     * // => true
	     *
	     * _.isEmpty(1);
	     * // => true
	     *
	     * _.isEmpty([1, 2, 3]);
	     * // => false
	     *
	     * _.isEmpty({ 'a': 1 });
	     * // => false
	     */
	    function isEmpty(value) {
	      if (value == null) {
	        return true;
	      }
	      if (isArrayLike(value) && (isArray(value) || isString(value) || isArguments(value) ||
	          (isObjectLike(value) && isFunction(value.splice)))) {
	        return !value.length;
	      }
	      return !keys(value).length;
	    }

	    /**
	     * Performs a deep comparison between two values to determine if they are
	     * equivalent. If `customizer` is provided it is invoked to compare values.
	     * If `customizer` returns `undefined` comparisons are handled by the method
	     * instead. The `customizer` is bound to `thisArg` and invoked with three
	     * arguments: (value, other [, index|key]).
	     *
	     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
	     * numbers, `Object` objects, regexes, and strings. Objects are compared by
	     * their own, not inherited, enumerable properties. Functions and DOM nodes
	     * are **not** supported. Provide a customizer function to extend support
	     * for comparing other values.
	     *
	     * @static
	     * @memberOf _
	     * @alias eq
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @param {Function} [customizer] The function to customize value comparisons.
	     * @param {*} [thisArg] The `this` binding of `customizer`.
	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	     * @example
	     *
	     * var object = { 'user': 'fred' };
	     * var other = { 'user': 'fred' };
	     *
	     * object == other;
	     * // => false
	     *
	     * _.isEqual(object, other);
	     * // => true
	     *
	     * // using a customizer callback
	     * var array = ['hello', 'goodbye'];
	     * var other = ['hi', 'goodbye'];
	     *
	     * _.isEqual(array, other, function(value, other) {
	     *   if (_.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/)) {
	     *     return true;
	     *   }
	     * });
	     * // => true
	     */
	    function isEqual(value, other, customizer, thisArg) {
	      customizer = typeof customizer == 'function' ? bindCallback(customizer, thisArg, 3) : undefined;
	      var result = customizer ? customizer(value, other) : undefined;
	      return  result === undefined ? baseIsEqual(value, other, customizer) : !!result;
	    }

	    /**
	     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
	     * `SyntaxError`, `TypeError`, or `URIError` object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
	     * @example
	     *
	     * _.isError(new Error);
	     * // => true
	     *
	     * _.isError(Error);
	     * // => false
	     */
	    function isError(value) {
	      return isObjectLike(value) && typeof value.message == 'string' && objToString.call(value) == errorTag;
	    }

	    /**
	     * Checks if `value` is a finite primitive number.
	     *
	     * **Note:** This method is based on [`Number.isFinite`](http://ecma-international.org/ecma-262/6.0/#sec-number.isfinite).
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
	     * @example
	     *
	     * _.isFinite(10);
	     * // => true
	     *
	     * _.isFinite('10');
	     * // => false
	     *
	     * _.isFinite(true);
	     * // => false
	     *
	     * _.isFinite(Object(10));
	     * // => false
	     *
	     * _.isFinite(Infinity);
	     * // => false
	     */
	    function isFinite(value) {
	      return typeof value == 'number' && nativeIsFinite(value);
	    }

	    /**
	     * Checks if `value` is classified as a `Function` object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isFunction(_);
	     * // => true
	     *
	     * _.isFunction(/abc/);
	     * // => false
	     */
	    function isFunction(value) {
	      // The use of `Object#toString` avoids issues with the `typeof` operator
	      // in older versions of Chrome and Safari which return 'function' for regexes
	      // and Safari 8 equivalents which return 'object' for typed array constructors.
	      return isObject(value) && objToString.call(value) == funcTag;
	    }

	    /**
	     * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
	     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	     * @example
	     *
	     * _.isObject({});
	     * // => true
	     *
	     * _.isObject([1, 2, 3]);
	     * // => true
	     *
	     * _.isObject(1);
	     * // => false
	     */
	    function isObject(value) {
	      // Avoid a V8 JIT bug in Chrome 19-20.
	      // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
	      var type = typeof value;
	      return !!value && (type == 'object' || type == 'function');
	    }

	    /**
	     * Performs a deep comparison between `object` and `source` to determine if
	     * `object` contains equivalent property values. If `customizer` is provided
	     * it is invoked to compare values. If `customizer` returns `undefined`
	     * comparisons are handled by the method instead. The `customizer` is bound
	     * to `thisArg` and invoked with three arguments: (value, other, index|key).
	     *
	     * **Note:** This method supports comparing properties of arrays, booleans,
	     * `Date` objects, numbers, `Object` objects, regexes, and strings. Functions
	     * and DOM nodes are **not** supported. Provide a customizer function to extend
	     * support for comparing other values.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {Object} object The object to inspect.
	     * @param {Object} source The object of property values to match.
	     * @param {Function} [customizer] The function to customize value comparisons.
	     * @param {*} [thisArg] The `this` binding of `customizer`.
	     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	     * @example
	     *
	     * var object = { 'user': 'fred', 'age': 40 };
	     *
	     * _.isMatch(object, { 'age': 40 });
	     * // => true
	     *
	     * _.isMatch(object, { 'age': 36 });
	     * // => false
	     *
	     * // using a customizer callback
	     * var object = { 'greeting': 'hello' };
	     * var source = { 'greeting': 'hi' };
	     *
	     * _.isMatch(object, source, function(value, other) {
	     *   return _.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/) || undefined;
	     * });
	     * // => true
	     */
	    function isMatch(object, source, customizer, thisArg) {
	      customizer = typeof customizer == 'function' ? bindCallback(customizer, thisArg, 3) : undefined;
	      return baseIsMatch(object, getMatchData(source), customizer);
	    }

	    /**
	     * Checks if `value` is `NaN`.
	     *
	     * **Note:** This method is not the same as [`isNaN`](https://es5.github.io/#x15.1.2.4)
	     * which returns `true` for `undefined` and other non-numeric values.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
	     * @example
	     *
	     * _.isNaN(NaN);
	     * // => true
	     *
	     * _.isNaN(new Number(NaN));
	     * // => true
	     *
	     * isNaN(undefined);
	     * // => true
	     *
	     * _.isNaN(undefined);
	     * // => false
	     */
	    function isNaN(value) {
	      // An `NaN` primitive is the only value that is not equal to itself.
	      // Perform the `toStringTag` check first to avoid errors with some host objects in IE.
	      return isNumber(value) && value != +value;
	    }

	    /**
	     * Checks if `value` is a native function.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
	     * @example
	     *
	     * _.isNative(Array.prototype.push);
	     * // => true
	     *
	     * _.isNative(_);
	     * // => false
	     */
	    function isNative(value) {
	      if (value == null) {
	        return false;
	      }
	      if (isFunction(value)) {
	        return reIsNative.test(fnToString.call(value));
	      }
	      return isObjectLike(value) && reIsHostCtor.test(value);
	    }

	    /**
	     * Checks if `value` is `null`.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
	     * @example
	     *
	     * _.isNull(null);
	     * // => true
	     *
	     * _.isNull(void 0);
	     * // => false
	     */
	    function isNull(value) {
	      return value === null;
	    }

	    /**
	     * Checks if `value` is classified as a `Number` primitive or object.
	     *
	     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are classified
	     * as numbers, use the `_.isFinite` method.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isNumber(8.4);
	     * // => true
	     *
	     * _.isNumber(NaN);
	     * // => true
	     *
	     * _.isNumber('8.4');
	     * // => false
	     */
	    function isNumber(value) {
	      return typeof value == 'number' || (isObjectLike(value) && objToString.call(value) == numberTag);
	    }

	    /**
	     * Checks if `value` is a plain object, that is, an object created by the
	     * `Object` constructor or one with a `[[Prototype]]` of `null`.
	     *
	     * **Note:** This method assumes objects created by the `Object` constructor
	     * have no inherited enumerable properties.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     * }
	     *
	     * _.isPlainObject(new Foo);
	     * // => false
	     *
	     * _.isPlainObject([1, 2, 3]);
	     * // => false
	     *
	     * _.isPlainObject({ 'x': 0, 'y': 0 });
	     * // => true
	     *
	     * _.isPlainObject(Object.create(null));
	     * // => true
	     */
	    function isPlainObject(value) {
	      var Ctor;

	      // Exit early for non `Object` objects.
	      if (!(isObjectLike(value) && objToString.call(value) == objectTag && !isArguments(value)) ||
	          (!hasOwnProperty.call(value, 'constructor') && (Ctor = value.constructor, typeof Ctor == 'function' && !(Ctor instanceof Ctor)))) {
	        return false;
	      }
	      // IE < 9 iterates inherited properties before own properties. If the first
	      // iterated property is an object's own property then there are no inherited
	      // enumerable properties.
	      var result;
	      // In most environments an object's own properties are iterated before
	      // its inherited properties. If the last iterated property is an object's
	      // own property then there are no inherited enumerable properties.
	      baseForIn(value, function(subValue, key) {
	        result = key;
	      });
	      return result === undefined || hasOwnProperty.call(value, result);
	    }

	    /**
	     * Checks if `value` is classified as a `RegExp` object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isRegExp(/abc/);
	     * // => true
	     *
	     * _.isRegExp('/abc/');
	     * // => false
	     */
	    function isRegExp(value) {
	      return isObject(value) && objToString.call(value) == regexpTag;
	    }

	    /**
	     * Checks if `value` is classified as a `String` primitive or object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isString('abc');
	     * // => true
	     *
	     * _.isString(1);
	     * // => false
	     */
	    function isString(value) {
	      return typeof value == 'string' || (isObjectLike(value) && objToString.call(value) == stringTag);
	    }

	    /**
	     * Checks if `value` is classified as a typed array.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isTypedArray(new Uint8Array);
	     * // => true
	     *
	     * _.isTypedArray([]);
	     * // => false
	     */
	    function isTypedArray(value) {
	      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];
	    }

	    /**
	     * Checks if `value` is `undefined`.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
	     * @example
	     *
	     * _.isUndefined(void 0);
	     * // => true
	     *
	     * _.isUndefined(null);
	     * // => false
	     */
	    function isUndefined(value) {
	      return value === undefined;
	    }

	    /**
	     * Checks if `value` is less than `other`.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is less than `other`, else `false`.
	     * @example
	     *
	     * _.lt(1, 3);
	     * // => true
	     *
	     * _.lt(3, 3);
	     * // => false
	     *
	     * _.lt(3, 1);
	     * // => false
	     */
	    function lt(value, other) {
	      return value < other;
	    }

	    /**
	     * Checks if `value` is less than or equal to `other`.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is less than or equal to `other`, else `false`.
	     * @example
	     *
	     * _.lte(1, 3);
	     * // => true
	     *
	     * _.lte(3, 3);
	     * // => true
	     *
	     * _.lte(3, 1);
	     * // => false
	     */
	    function lte(value, other) {
	      return value <= other;
	    }

	    /**
	     * Converts `value` to an array.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {Array} Returns the converted array.
	     * @example
	     *
	     * (function() {
	     *   return _.toArray(arguments).slice(1);
	     * }(1, 2, 3));
	     * // => [2, 3]
	     */
	    function toArray(value) {
	      var length = value ? getLength(value) : 0;
	      if (!isLength(length)) {
	        return values(value);
	      }
	      if (!length) {
	        return [];
	      }
	      return arrayCopy(value);
	    }

	    /**
	     * Converts `value` to a plain object flattening inherited enumerable
	     * properties of `value` to own properties of the plain object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {Object} Returns the converted plain object.
	     * @example
	     *
	     * function Foo() {
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.assign({ 'a': 1 }, new Foo);
	     * // => { 'a': 1, 'b': 2 }
	     *
	     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
	     * // => { 'a': 1, 'b': 2, 'c': 3 }
	     */
	    function toPlainObject(value) {
	      return baseCopy(value, keysIn(value));
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Recursively merges own enumerable properties of the source object(s), that
	     * don't resolve to `undefined` into the destination object. Subsequent sources
	     * overwrite property assignments of previous sources. If `customizer` is
	     * provided it is invoked to produce the merged values of the destination and
	     * source properties. If `customizer` returns `undefined` merging is handled
	     * by the method instead. The `customizer` is bound to `thisArg` and invoked
	     * with five arguments: (objectValue, sourceValue, key, object, source).
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @param {Function} [customizer] The function to customize assigned values.
	     * @param {*} [thisArg] The `this` binding of `customizer`.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var users = {
	     *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]
	     * };
	     *
	     * var ages = {
	     *   'data': [{ 'age': 36 }, { 'age': 40 }]
	     * };
	     *
	     * _.merge(users, ages);
	     * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }
	     *
	     * // using a customizer callback
	     * var object = {
	     *   'fruits': ['apple'],
	     *   'vegetables': ['beet']
	     * };
	     *
	     * var other = {
	     *   'fruits': ['banana'],
	     *   'vegetables': ['carrot']
	     * };
	     *
	     * _.merge(object, other, function(a, b) {
	     *   if (_.isArray(a)) {
	     *     return a.concat(b);
	     *   }
	     * });
	     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot'] }
	     */
	    var merge = createAssigner(baseMerge);

	    /**
	     * Assigns own enumerable properties of source object(s) to the destination
	     * object. Subsequent sources overwrite property assignments of previous sources.
	     * If `customizer` is provided it is invoked to produce the assigned values.
	     * The `customizer` is bound to `thisArg` and invoked with five arguments:
	     * (objectValue, sourceValue, key, object, source).
	     *
	     * **Note:** This method mutates `object` and is based on
	     * [`Object.assign`](http://ecma-international.org/ecma-262/6.0/#sec-object.assign).
	     *
	     * @static
	     * @memberOf _
	     * @alias extend
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @param {Function} [customizer] The function to customize assigned values.
	     * @param {*} [thisArg] The `this` binding of `customizer`.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * _.assign({ 'user': 'barney' }, { 'age': 40 }, { 'user': 'fred' });
	     * // => { 'user': 'fred', 'age': 40 }
	     *
	     * // using a customizer callback
	     * var defaults = _.partialRight(_.assign, function(value, other) {
	     *   return _.isUndefined(value) ? other : value;
	     * });
	     *
	     * defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
	     * // => { 'user': 'barney', 'age': 36 }
	     */
	    var assign = createAssigner(function(object, source, customizer) {
	      return customizer
	        ? assignWith(object, source, customizer)
	        : baseAssign(object, source);
	    });

	    /**
	     * Creates an object that inherits from the given `prototype` object. If a
	     * `properties` object is provided its own enumerable properties are assigned
	     * to the created object.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} prototype The object to inherit from.
	     * @param {Object} [properties] The properties to assign to the object.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * function Shape() {
	     *   this.x = 0;
	     *   this.y = 0;
	     * }
	     *
	     * function Circle() {
	     *   Shape.call(this);
	     * }
	     *
	     * Circle.prototype = _.create(Shape.prototype, {
	     *   'constructor': Circle
	     * });
	     *
	     * var circle = new Circle;
	     * circle instanceof Circle;
	     * // => true
	     *
	     * circle instanceof Shape;
	     * // => true
	     */
	    function create(prototype, properties, guard) {
	      var result = baseCreate(prototype);
	      if (guard && isIterateeCall(prototype, properties, guard)) {
	        properties = undefined;
	      }
	      return properties ? baseAssign(result, properties) : result;
	    }

	    /**
	     * Assigns own enumerable properties of source object(s) to the destination
	     * object for all destination properties that resolve to `undefined`. Once a
	     * property is set, additional values of the same property are ignored.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * _.defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
	     * // => { 'user': 'barney', 'age': 36 }
	     */
	    var defaults = createDefaults(assign, assignDefaults);

	    /**
	     * This method is like `_.defaults` except that it recursively assigns
	     * default properties.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * _.defaultsDeep({ 'user': { 'name': 'barney' } }, { 'user': { 'name': 'fred', 'age': 36 } });
	     * // => { 'user': { 'name': 'barney', 'age': 36 } }
	     *
	     */
	    var defaultsDeep = createDefaults(merge, mergeDefaults);

	    /**
	     * This method is like `_.find` except that it returns the key of the first
	     * element `predicate` returns truthy for instead of the element itself.
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to search.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {string|undefined} Returns the key of the matched element, else `undefined`.
	     * @example
	     *
	     * var users = {
	     *   'barney':  { 'age': 36, 'active': true },
	     *   'fred':    { 'age': 40, 'active': false },
	     *   'pebbles': { 'age': 1,  'active': true }
	     * };
	     *
	     * _.findKey(users, function(chr) {
	     *   return chr.age < 40;
	     * });
	     * // => 'barney' (iteration order is not guaranteed)
	     *
	     * // using the `_.matches` callback shorthand
	     * _.findKey(users, { 'age': 1, 'active': true });
	     * // => 'pebbles'
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.findKey(users, 'active', false);
	     * // => 'fred'
	     *
	     * // using the `_.property` callback shorthand
	     * _.findKey(users, 'active');
	     * // => 'barney'
	     */
	    var findKey = createFindKey(baseForOwn);

	    /**
	     * This method is like `_.findKey` except that it iterates over elements of
	     * a collection in the opposite order.
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to search.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {string|undefined} Returns the key of the matched element, else `undefined`.
	     * @example
	     *
	     * var users = {
	     *   'barney':  { 'age': 36, 'active': true },
	     *   'fred':    { 'age': 40, 'active': false },
	     *   'pebbles': { 'age': 1,  'active': true }
	     * };
	     *
	     * _.findLastKey(users, function(chr) {
	     *   return chr.age < 40;
	     * });
	     * // => returns `pebbles` assuming `_.findKey` returns `barney`
	     *
	     * // using the `_.matches` callback shorthand
	     * _.findLastKey(users, { 'age': 36, 'active': true });
	     * // => 'barney'
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.findLastKey(users, 'active', false);
	     * // => 'fred'
	     *
	     * // using the `_.property` callback shorthand
	     * _.findLastKey(users, 'active');
	     * // => 'pebbles'
	     */
	    var findLastKey = createFindKey(baseForOwnRight);

	    /**
	     * Iterates over own and inherited enumerable properties of an object invoking
	     * `iteratee` for each property. The `iteratee` is bound to `thisArg` and invoked
	     * with three arguments: (value, key, object). Iteratee functions may exit
	     * iteration early by explicitly returning `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forIn(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => logs 'a', 'b', and 'c' (iteration order is not guaranteed)
	     */
	    var forIn = createForIn(baseFor);

	    /**
	     * This method is like `_.forIn` except that it iterates over properties of
	     * `object` in the opposite order.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forInRight(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => logs 'c', 'b', and 'a' assuming `_.forIn ` logs 'a', 'b', and 'c'
	     */
	    var forInRight = createForIn(baseForRight);

	    /**
	     * Iterates over own enumerable properties of an object invoking `iteratee`
	     * for each property. The `iteratee` is bound to `thisArg` and invoked with
	     * three arguments: (value, key, object). Iteratee functions may exit iteration
	     * early by explicitly returning `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forOwn(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => logs 'a' and 'b' (iteration order is not guaranteed)
	     */
	    var forOwn = createForOwn(baseForOwn);

	    /**
	     * This method is like `_.forOwn` except that it iterates over properties of
	     * `object` in the opposite order.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forOwnRight(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => logs 'b' and 'a' assuming `_.forOwn` logs 'a' and 'b'
	     */
	    var forOwnRight = createForOwn(baseForOwnRight);

	    /**
	     * Creates an array of function property names from all enumerable properties,
	     * own and inherited, of `object`.
	     *
	     * @static
	     * @memberOf _
	     * @alias methods
	     * @category Object
	     * @param {Object} object The object to inspect.
	     * @returns {Array} Returns the new array of property names.
	     * @example
	     *
	     * _.functions(_);
	     * // => ['after', 'ary', 'assign', ...]
	     */
	    function functions(object) {
	      return baseFunctions(object, keysIn(object));
	    }

	    /**
	     * Gets the property value at `path` of `object`. If the resolved value is
	     * `undefined` the `defaultValue` is used in its place.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the property to get.
	     * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.
	     * @returns {*} Returns the resolved value.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	     *
	     * _.get(object, 'a[0].b.c');
	     * // => 3
	     *
	     * _.get(object, ['a', '0', 'b', 'c']);
	     * // => 3
	     *
	     * _.get(object, 'a.b.c', 'default');
	     * // => 'default'
	     */
	    function get(object, path, defaultValue) {
	      var result = object == null ? undefined : baseGet(object, toPath(path), path + '');
	      return result === undefined ? defaultValue : result;
	    }

	    /**
	     * Checks if `path` is a direct property.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path to check.
	     * @returns {boolean} Returns `true` if `path` is a direct property, else `false`.
	     * @example
	     *
	     * var object = { 'a': { 'b': { 'c': 3 } } };
	     *
	     * _.has(object, 'a');
	     * // => true
	     *
	     * _.has(object, 'a.b.c');
	     * // => true
	     *
	     * _.has(object, ['a', 'b', 'c']);
	     * // => true
	     */
	    function has(object, path) {
	      if (object == null) {
	        return false;
	      }
	      var result = hasOwnProperty.call(object, path);
	      if (!result && !isKey(path)) {
	        path = toPath(path);
	        object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
	        if (object == null) {
	          return false;
	        }
	        path = last(path);
	        result = hasOwnProperty.call(object, path);
	      }
	      return result || (isLength(object.length) && isIndex(path, object.length) &&
	        (isArray(object) || isArguments(object)));
	    }

	    /**
	     * Creates an object composed of the inverted keys and values of `object`.
	     * If `object` contains duplicate values, subsequent values overwrite property
	     * assignments of previous values unless `multiValue` is `true`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to invert.
	     * @param {boolean} [multiValue] Allow multiple values per key.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Object} Returns the new inverted object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': 2, 'c': 1 };
	     *
	     * _.invert(object);
	     * // => { '1': 'c', '2': 'b' }
	     *
	     * // with `multiValue`
	     * _.invert(object, true);
	     * // => { '1': ['a', 'c'], '2': ['b'] }
	     */
	    function invert(object, multiValue, guard) {
	      if (guard && isIterateeCall(object, multiValue, guard)) {
	        multiValue = undefined;
	      }
	      var index = -1,
	          props = keys(object),
	          length = props.length,
	          result = {};

	      while (++index < length) {
	        var key = props[index],
	            value = object[key];

	        if (multiValue) {
	          if (hasOwnProperty.call(result, value)) {
	            result[value].push(key);
	          } else {
	            result[value] = [key];
	          }
	        }
	        else {
	          result[value] = key;
	        }
	      }
	      return result;
	    }

	    /**
	     * Creates an array of the own enumerable property names of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects. See the
	     * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)
	     * for more details.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.keys(new Foo);
	     * // => ['a', 'b'] (iteration order is not guaranteed)
	     *
	     * _.keys('hi');
	     * // => ['0', '1']
	     */
	    var keys = !nativeKeys ? shimKeys : function(object) {
	      var Ctor = object == null ? undefined : object.constructor;
	      if ((typeof Ctor == 'function' && Ctor.prototype === object) ||
	          (typeof object != 'function' && isArrayLike(object))) {
	        return shimKeys(object);
	      }
	      return isObject(object) ? nativeKeys(object) : [];
	    };

	    /**
	     * Creates an array of the own and inherited enumerable property names of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.keysIn(new Foo);
	     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
	     */
	    function keysIn(object) {
	      if (object == null) {
	        return [];
	      }
	      if (!isObject(object)) {
	        object = Object(object);
	      }
	      var length = object.length;
	      length = (length && isLength(length) &&
	        (isArray(object) || isArguments(object)) && length) || 0;

	      var Ctor = object.constructor,
	          index = -1,
	          isProto = typeof Ctor == 'function' && Ctor.prototype === object,
	          result = Array(length),
	          skipIndexes = length > 0;

	      while (++index < length) {
	        result[index] = (index + '');
	      }
	      for (var key in object) {
	        if (!(skipIndexes && isIndex(key, length)) &&
	            !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
	          result.push(key);
	        }
	      }
	      return result;
	    }

	    /**
	     * The opposite of `_.mapValues`; this method creates an object with the
	     * same values as `object` and keys generated by running each own enumerable
	     * property of `object` through `iteratee`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Object} Returns the new mapped object.
	     * @example
	     *
	     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
	     *   return key + value;
	     * });
	     * // => { 'a1': 1, 'b2': 2 }
	     */
	    var mapKeys = createObjectMapper(true);

	    /**
	     * Creates an object with the same keys as `object` and values generated by
	     * running each own enumerable property of `object` through `iteratee`. The
	     * iteratee function is bound to `thisArg` and invoked with three arguments:
	     * (value, key, object).
	     *
	     * If a property name is provided for `iteratee` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `iteratee` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Object} Returns the new mapped object.
	     * @example
	     *
	     * _.mapValues({ 'a': 1, 'b': 2 }, function(n) {
	     *   return n * 3;
	     * });
	     * // => { 'a': 3, 'b': 6 }
	     *
	     * var users = {
	     *   'fred':    { 'user': 'fred',    'age': 40 },
	     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
	     * };
	     *
	     * // using the `_.property` callback shorthand
	     * _.mapValues(users, 'age');
	     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
	     */
	    var mapValues = createObjectMapper();

	    /**
	     * The opposite of `_.pick`; this method creates an object composed of the
	     * own and inherited enumerable properties of `object` that are not omitted.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The source object.
	     * @param {Function|...(string|string[])} [predicate] The function invoked per
	     *  iteration or property names to omit, specified as individual property
	     *  names or arrays of property names.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * var object = { 'user': 'fred', 'age': 40 };
	     *
	     * _.omit(object, 'age');
	     * // => { 'user': 'fred' }
	     *
	     * _.omit(object, _.isNumber);
	     * // => { 'user': 'fred' }
	     */
	    var omit = restParam(function(object, props) {
	      if (object == null) {
	        return {};
	      }
	      if (typeof props[0] != 'function') {
	        var props = arrayMap(baseFlatten(props), String);
	        return pickByArray(object, baseDifference(keysIn(object), props));
	      }
	      var predicate = bindCallback(props[0], props[1], 3);
	      return pickByCallback(object, function(value, key, object) {
	        return !predicate(value, key, object);
	      });
	    });

	    /**
	     * Creates a two dimensional array of the key-value pairs for `object`,
	     * e.g. `[[key1, value1], [key2, value2]]`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the new array of key-value pairs.
	     * @example
	     *
	     * _.pairs({ 'barney': 36, 'fred': 40 });
	     * // => [['barney', 36], ['fred', 40]] (iteration order is not guaranteed)
	     */
	    function pairs(object) {
	      object = toObject(object);

	      var index = -1,
	          props = keys(object),
	          length = props.length,
	          result = Array(length);

	      while (++index < length) {
	        var key = props[index];
	        result[index] = [key, object[key]];
	      }
	      return result;
	    }

	    /**
	     * Creates an object composed of the picked `object` properties. Property
	     * names may be specified as individual arguments or as arrays of property
	     * names. If `predicate` is provided it is invoked for each property of `object`
	     * picking the properties `predicate` returns truthy for. The predicate is
	     * bound to `thisArg` and invoked with three arguments: (value, key, object).
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The source object.
	     * @param {Function|...(string|string[])} [predicate] The function invoked per
	     *  iteration or property names to pick, specified as individual property
	     *  names or arrays of property names.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * var object = { 'user': 'fred', 'age': 40 };
	     *
	     * _.pick(object, 'user');
	     * // => { 'user': 'fred' }
	     *
	     * _.pick(object, _.isString);
	     * // => { 'user': 'fred' }
	     */
	    var pick = restParam(function(object, props) {
	      if (object == null) {
	        return {};
	      }
	      return typeof props[0] == 'function'
	        ? pickByCallback(object, bindCallback(props[0], props[1], 3))
	        : pickByArray(object, baseFlatten(props));
	    });

	    /**
	     * This method is like `_.get` except that if the resolved value is a function
	     * it is invoked with the `this` binding of its parent object and its result
	     * is returned.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the property to resolve.
	     * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.
	     * @returns {*} Returns the resolved value.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
	     *
	     * _.result(object, 'a[0].b.c1');
	     * // => 3
	     *
	     * _.result(object, 'a[0].b.c2');
	     * // => 4
	     *
	     * _.result(object, 'a.b.c', 'default');
	     * // => 'default'
	     *
	     * _.result(object, 'a.b.c', _.constant('default'));
	     * // => 'default'
	     */
	    function result(object, path, defaultValue) {
	      var result = object == null ? undefined : object[path];
	      if (result === undefined) {
	        if (object != null && !isKey(path, object)) {
	          path = toPath(path);
	          object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
	          result = object == null ? undefined : object[last(path)];
	        }
	        result = result === undefined ? defaultValue : result;
	      }
	      return isFunction(result) ? result.call(object) : result;
	    }

	    /**
	     * Sets the property value of `path` on `object`. If a portion of `path`
	     * does not exist it is created.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to augment.
	     * @param {Array|string} path The path of the property to set.
	     * @param {*} value The value to set.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	     *
	     * _.set(object, 'a[0].b.c', 4);
	     * console.log(object.a[0].b.c);
	     * // => 4
	     *
	     * _.set(object, 'x[0].y.z', 5);
	     * console.log(object.x[0].y.z);
	     * // => 5
	     */
	    function set(object, path, value) {
	      if (object == null) {
	        return object;
	      }
	      var pathKey = (path + '');
	      path = (object[pathKey] != null || isKey(path, object)) ? [pathKey] : toPath(path);

	      var index = -1,
	          length = path.length,
	          lastIndex = length - 1,
	          nested = object;

	      while (nested != null && ++index < length) {
	        var key = path[index];
	        if (isObject(nested)) {
	          if (index == lastIndex) {
	            nested[key] = value;
	          } else if (nested[key] == null) {
	            nested[key] = isIndex(path[index + 1]) ? [] : {};
	          }
	        }
	        nested = nested[key];
	      }
	      return object;
	    }

	    /**
	     * An alternative to `_.reduce`; this method transforms `object` to a new
	     * `accumulator` object which is the result of running each of its own enumerable
	     * properties through `iteratee`, with each invocation potentially mutating
	     * the `accumulator` object. The `iteratee` is bound to `thisArg` and invoked
	     * with four arguments: (accumulator, value, key, object). Iteratee functions
	     * may exit iteration early by explicitly returning `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Array|Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [accumulator] The custom accumulator value.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {*} Returns the accumulated value.
	     * @example
	     *
	     * _.transform([2, 3, 4], function(result, n) {
	     *   result.push(n *= n);
	     *   return n % 2 == 0;
	     * });
	     * // => [4, 9]
	     *
	     * _.transform({ 'a': 1, 'b': 2 }, function(result, n, key) {
	     *   result[key] = n * 3;
	     * });
	     * // => { 'a': 3, 'b': 6 }
	     */
	    function transform(object, iteratee, accumulator, thisArg) {
	      var isArr = isArray(object) || isTypedArray(object);
	      iteratee = getCallback(iteratee, thisArg, 4);

	      if (accumulator == null) {
	        if (isArr || isObject(object)) {
	          var Ctor = object.constructor;
	          if (isArr) {
	            accumulator = isArray(object) ? new Ctor : [];
	          } else {
	            accumulator = baseCreate(isFunction(Ctor) ? Ctor.prototype : undefined);
	          }
	        } else {
	          accumulator = {};
	        }
	      }
	      (isArr ? arrayEach : baseForOwn)(object, function(value, index, object) {
	        return iteratee(accumulator, value, index, object);
	      });
	      return accumulator;
	    }

	    /**
	     * Creates an array of the own enumerable property values of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property values.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.values(new Foo);
	     * // => [1, 2] (iteration order is not guaranteed)
	     *
	     * _.values('hi');
	     * // => ['h', 'i']
	     */
	    function values(object) {
	      return baseValues(object, keys(object));
	    }

	    /**
	     * Creates an array of the own and inherited enumerable property values
	     * of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property values.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.valuesIn(new Foo);
	     * // => [1, 2, 3] (iteration order is not guaranteed)
	     */
	    function valuesIn(object) {
	      return baseValues(object, keysIn(object));
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Checks if `n` is between `start` and up to but not including, `end`. If
	     * `end` is not specified it is set to `start` with `start` then set to `0`.
	     *
	     * @static
	     * @memberOf _
	     * @category Number
	     * @param {number} n The number to check.
	     * @param {number} [start=0] The start of the range.
	     * @param {number} end The end of the range.
	     * @returns {boolean} Returns `true` if `n` is in the range, else `false`.
	     * @example
	     *
	     * _.inRange(3, 2, 4);
	     * // => true
	     *
	     * _.inRange(4, 8);
	     * // => true
	     *
	     * _.inRange(4, 2);
	     * // => false
	     *
	     * _.inRange(2, 2);
	     * // => false
	     *
	     * _.inRange(1.2, 2);
	     * // => true
	     *
	     * _.inRange(5.2, 4);
	     * // => false
	     */
	    function inRange(value, start, end) {
	      start = +start || 0;
	      if (end === undefined) {
	        end = start;
	        start = 0;
	      } else {
	        end = +end || 0;
	      }
	      return value >= nativeMin(start, end) && value < nativeMax(start, end);
	    }

	    /**
	     * Produces a random number between `min` and `max` (inclusive). If only one
	     * argument is provided a number between `0` and the given number is returned.
	     * If `floating` is `true`, or either `min` or `max` are floats, a floating-point
	     * number is returned instead of an integer.
	     *
	     * @static
	     * @memberOf _
	     * @category Number
	     * @param {number} [min=0] The minimum possible value.
	     * @param {number} [max=1] The maximum possible value.
	     * @param {boolean} [floating] Specify returning a floating-point number.
	     * @returns {number} Returns the random number.
	     * @example
	     *
	     * _.random(0, 5);
	     * // => an integer between 0 and 5
	     *
	     * _.random(5);
	     * // => also an integer between 0 and 5
	     *
	     * _.random(5, true);
	     * // => a floating-point number between 0 and 5
	     *
	     * _.random(1.2, 5.2);
	     * // => a floating-point number between 1.2 and 5.2
	     */
	    function random(min, max, floating) {
	      if (floating && isIterateeCall(min, max, floating)) {
	        max = floating = undefined;
	      }
	      var noMin = min == null,
	          noMax = max == null;

	      if (floating == null) {
	        if (noMax && typeof min == 'boolean') {
	          floating = min;
	          min = 1;
	        }
	        else if (typeof max == 'boolean') {
	          floating = max;
	          noMax = true;
	        }
	      }
	      if (noMin && noMax) {
	        max = 1;
	        noMax = false;
	      }
	      min = +min || 0;
	      if (noMax) {
	        max = min;
	        min = 0;
	      } else {
	        max = +max || 0;
	      }
	      if (floating || min % 1 || max % 1) {
	        var rand = nativeRandom();
	        return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand + '').length - 1)))), max);
	      }
	      return baseRandom(min, max);
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the camel cased string.
	     * @example
	     *
	     * _.camelCase('Foo Bar');
	     * // => 'fooBar'
	     *
	     * _.camelCase('--foo-bar');
	     * // => 'fooBar'
	     *
	     * _.camelCase('__foo_bar__');
	     * // => 'fooBar'
	     */
	    var camelCase = createCompounder(function(result, word, index) {
	      word = word.toLowerCase();
	      return result + (index ? (word.charAt(0).toUpperCase() + word.slice(1)) : word);
	    });

	    /**
	     * Capitalizes the first character of `string`.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to capitalize.
	     * @returns {string} Returns the capitalized string.
	     * @example
	     *
	     * _.capitalize('fred');
	     * // => 'Fred'
	     */
	    function capitalize(string) {
	      string = baseToString(string);
	      return string && (string.charAt(0).toUpperCase() + string.slice(1));
	    }

	    /**
	     * Deburrs `string` by converting [latin-1 supplementary letters](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
	     * to basic latin letters and removing [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to deburr.
	     * @returns {string} Returns the deburred string.
	     * @example
	     *
	     * _.deburr('déjà vu');
	     * // => 'deja vu'
	     */
	    function deburr(string) {
	      string = baseToString(string);
	      return string && string.replace(reLatin1, deburrLetter).replace(reComboMark, '');
	    }

	    /**
	     * Checks if `string` ends with the given target string.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to search.
	     * @param {string} [target] The string to search for.
	     * @param {number} [position=string.length] The position to search from.
	     * @returns {boolean} Returns `true` if `string` ends with `target`, else `false`.
	     * @example
	     *
	     * _.endsWith('abc', 'c');
	     * // => true
	     *
	     * _.endsWith('abc', 'b');
	     * // => false
	     *
	     * _.endsWith('abc', 'b', 2);
	     * // => true
	     */
	    function endsWith(string, target, position) {
	      string = baseToString(string);
	      target = (target + '');

	      var length = string.length;
	      position = position === undefined
	        ? length
	        : nativeMin(position < 0 ? 0 : (+position || 0), length);

	      position -= target.length;
	      return position >= 0 && string.indexOf(target, position) == position;
	    }

	    /**
	     * Converts the characters "&", "<", ">", '"', "'", and "\`", in `string` to
	     * their corresponding HTML entities.
	     *
	     * **Note:** No other characters are escaped. To escape additional characters
	     * use a third-party library like [_he_](https://mths.be/he).
	     *
	     * Though the ">" character is escaped for symmetry, characters like
	     * ">" and "/" don't need escaping in HTML and have no special meaning
	     * unless they're part of a tag or unquoted attribute value.
	     * See [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
	     * (under "semi-related fun fact") for more details.
	     *
	     * Backticks are escaped because in Internet Explorer < 9, they can break out
	     * of attribute values or HTML comments. See [#59](https://html5sec.org/#59),
	     * [#102](https://html5sec.org/#102), [#108](https://html5sec.org/#108), and
	     * [#133](https://html5sec.org/#133) of the [HTML5 Security Cheatsheet](https://html5sec.org/)
	     * for more details.
	     *
	     * When working with HTML you should always [quote attribute values](http://wonko.com/post/html-escaping)
	     * to reduce XSS vectors.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to escape.
	     * @returns {string} Returns the escaped string.
	     * @example
	     *
	     * _.escape('fred, barney, & pebbles');
	     * // => 'fred, barney, &amp; pebbles'
	     */
	    function escape(string) {
	      // Reset `lastIndex` because in IE < 9 `String#replace` does not.
	      string = baseToString(string);
	      return (string && reHasUnescapedHtml.test(string))
	        ? string.replace(reUnescapedHtml, escapeHtmlChar)
	        : string;
	    }

	    /**
	     * Escapes the `RegExp` special characters "\", "/", "^", "$", ".", "|", "?",
	     * "*", "+", "(", ")", "[", "]", "{" and "}" in `string`.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to escape.
	     * @returns {string} Returns the escaped string.
	     * @example
	     *
	     * _.escapeRegExp('[lodash](https://lodash.com/)');
	     * // => '\[lodash\]\(https:\/\/lodash\.com\/\)'
	     */
	    function escapeRegExp(string) {
	      string = baseToString(string);
	      return (string && reHasRegExpChars.test(string))
	        ? string.replace(reRegExpChars, escapeRegExpChar)
	        : (string || '(?:)');
	    }

	    /**
	     * Converts `string` to [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the kebab cased string.
	     * @example
	     *
	     * _.kebabCase('Foo Bar');
	     * // => 'foo-bar'
	     *
	     * _.kebabCase('fooBar');
	     * // => 'foo-bar'
	     *
	     * _.kebabCase('__foo_bar__');
	     * // => 'foo-bar'
	     */
	    var kebabCase = createCompounder(function(result, word, index) {
	      return result + (index ? '-' : '') + word.toLowerCase();
	    });

	    /**
	     * Pads `string` on the left and right sides if it's shorter than `length`.
	     * Padding characters are truncated if they can't be evenly divided by `length`.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to pad.
	     * @param {number} [length=0] The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the padded string.
	     * @example
	     *
	     * _.pad('abc', 8);
	     * // => '  abc   '
	     *
	     * _.pad('abc', 8, '_-');
	     * // => '_-abc_-_'
	     *
	     * _.pad('abc', 3);
	     * // => 'abc'
	     */
	    function pad(string, length, chars) {
	      string = baseToString(string);
	      length = +length;

	      var strLength = string.length;
	      if (strLength >= length || !nativeIsFinite(length)) {
	        return string;
	      }
	      var mid = (length - strLength) / 2,
	          leftLength = nativeFloor(mid),
	          rightLength = nativeCeil(mid);

	      chars = createPadding('', rightLength, chars);
	      return chars.slice(0, leftLength) + string + chars;
	    }

	    /**
	     * Pads `string` on the left side if it's shorter than `length`. Padding
	     * characters are truncated if they exceed `length`.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to pad.
	     * @param {number} [length=0] The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the padded string.
	     * @example
	     *
	     * _.padLeft('abc', 6);
	     * // => '   abc'
	     *
	     * _.padLeft('abc', 6, '_-');
	     * // => '_-_abc'
	     *
	     * _.padLeft('abc', 3);
	     * // => 'abc'
	     */
	    var padLeft = createPadDir();

	    /**
	     * Pads `string` on the right side if it's shorter than `length`. Padding
	     * characters are truncated if they exceed `length`.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to pad.
	     * @param {number} [length=0] The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the padded string.
	     * @example
	     *
	     * _.padRight('abc', 6);
	     * // => 'abc   '
	     *
	     * _.padRight('abc', 6, '_-');
	     * // => 'abc_-_'
	     *
	     * _.padRight('abc', 3);
	     * // => 'abc'
	     */
	    var padRight = createPadDir(true);

	    /**
	     * Converts `string` to an integer of the specified radix. If `radix` is
	     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a hexadecimal,
	     * in which case a `radix` of `16` is used.
	     *
	     * **Note:** This method aligns with the [ES5 implementation](https://es5.github.io/#E)
	     * of `parseInt`.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} string The string to convert.
	     * @param {number} [radix] The radix to interpret `value` by.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {number} Returns the converted integer.
	     * @example
	     *
	     * _.parseInt('08');
	     * // => 8
	     *
	     * _.map(['6', '08', '10'], _.parseInt);
	     * // => [6, 8, 10]
	     */
	    function parseInt(string, radix, guard) {
	      // Firefox < 21 and Opera < 15 follow ES3 for `parseInt`.
	      // Chrome fails to trim leading <BOM> whitespace characters.
	      // See https://code.google.com/p/v8/issues/detail?id=3109 for more details.
	      if (guard ? isIterateeCall(string, radix, guard) : radix == null) {
	        radix = 0;
	      } else if (radix) {
	        radix = +radix;
	      }
	      string = trim(string);
	      return nativeParseInt(string, radix || (reHasHexPrefix.test(string) ? 16 : 10));
	    }

	    /**
	     * Repeats the given string `n` times.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to repeat.
	     * @param {number} [n=0] The number of times to repeat the string.
	     * @returns {string} Returns the repeated string.
	     * @example
	     *
	     * _.repeat('*', 3);
	     * // => '***'
	     *
	     * _.repeat('abc', 2);
	     * // => 'abcabc'
	     *
	     * _.repeat('abc', 0);
	     * // => ''
	     */
	    function repeat(string, n) {
	      var result = '';
	      string = baseToString(string);
	      n = +n;
	      if (n < 1 || !string || !nativeIsFinite(n)) {
	        return result;
	      }
	      // Leverage the exponentiation by squaring algorithm for a faster repeat.
	      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
	      do {
	        if (n % 2) {
	          result += string;
	        }
	        n = nativeFloor(n / 2);
	        string += string;
	      } while (n);

	      return result;
	    }

	    /**
	     * Converts `string` to [snake case](https://en.wikipedia.org/wiki/Snake_case).
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the snake cased string.
	     * @example
	     *
	     * _.snakeCase('Foo Bar');
	     * // => 'foo_bar'
	     *
	     * _.snakeCase('fooBar');
	     * // => 'foo_bar'
	     *
	     * _.snakeCase('--foo-bar');
	     * // => 'foo_bar'
	     */
	    var snakeCase = createCompounder(function(result, word, index) {
	      return result + (index ? '_' : '') + word.toLowerCase();
	    });

	    /**
	     * Converts `string` to [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the start cased string.
	     * @example
	     *
	     * _.startCase('--foo-bar');
	     * // => 'Foo Bar'
	     *
	     * _.startCase('fooBar');
	     * // => 'Foo Bar'
	     *
	     * _.startCase('__foo_bar__');
	     * // => 'Foo Bar'
	     */
	    var startCase = createCompounder(function(result, word, index) {
	      return result + (index ? ' ' : '') + (word.charAt(0).toUpperCase() + word.slice(1));
	    });

	    /**
	     * Checks if `string` starts with the given target string.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to search.
	     * @param {string} [target] The string to search for.
	     * @param {number} [position=0] The position to search from.
	     * @returns {boolean} Returns `true` if `string` starts with `target`, else `false`.
	     * @example
	     *
	     * _.startsWith('abc', 'a');
	     * // => true
	     *
	     * _.startsWith('abc', 'b');
	     * // => false
	     *
	     * _.startsWith('abc', 'b', 1);
	     * // => true
	     */
	    function startsWith(string, target, position) {
	      string = baseToString(string);
	      position = position == null
	        ? 0
	        : nativeMin(position < 0 ? 0 : (+position || 0), string.length);

	      return string.lastIndexOf(target, position) == position;
	    }

	    /**
	     * Creates a compiled template function that can interpolate data properties
	     * in "interpolate" delimiters, HTML-escape interpolated data properties in
	     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
	     * properties may be accessed as free variables in the template. If a setting
	     * object is provided it takes precedence over `_.templateSettings` values.
	     *
	     * **Note:** In the development build `_.template` utilizes
	     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
	     * for easier debugging.
	     *
	     * For more information on precompiling templates see
	     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
	     *
	     * For more information on Chrome extension sandboxes see
	     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The template string.
	     * @param {Object} [options] The options object.
	     * @param {RegExp} [options.escape] The HTML "escape" delimiter.
	     * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
	     * @param {Object} [options.imports] An object to import into the template as free variables.
	     * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
	     * @param {string} [options.sourceURL] The sourceURL of the template's compiled source.
	     * @param {string} [options.variable] The data object variable name.
	     * @param- {Object} [otherOptions] Enables the legacy `options` param signature.
	     * @returns {Function} Returns the compiled template function.
	     * @example
	     *
	     * // using the "interpolate" delimiter to create a compiled template
	     * var compiled = _.template('hello <%= user %>!');
	     * compiled({ 'user': 'fred' });
	     * // => 'hello fred!'
	     *
	     * // using the HTML "escape" delimiter to escape data property values
	     * var compiled = _.template('<b><%- value %></b>');
	     * compiled({ 'value': '<script>' });
	     * // => '<b>&lt;script&gt;</b>'
	     *
	     * // using the "evaluate" delimiter to execute JavaScript and generate HTML
	     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
	     * compiled({ 'users': ['fred', 'barney'] });
	     * // => '<li>fred</li><li>barney</li>'
	     *
	     * // using the internal `print` function in "evaluate" delimiters
	     * var compiled = _.template('<% print("hello " + user); %>!');
	     * compiled({ 'user': 'barney' });
	     * // => 'hello barney!'
	     *
	     * // using the ES delimiter as an alternative to the default "interpolate" delimiter
	     * var compiled = _.template('hello ${ user }!');
	     * compiled({ 'user': 'pebbles' });
	     * // => 'hello pebbles!'
	     *
	     * // using custom template delimiters
	     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
	     * var compiled = _.template('hello {{ user }}!');
	     * compiled({ 'user': 'mustache' });
	     * // => 'hello mustache!'
	     *
	     * // using backslashes to treat delimiters as plain text
	     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
	     * compiled({ 'value': 'ignored' });
	     * // => '<%- value %>'
	     *
	     * // using the `imports` option to import `jQuery` as `jq`
	     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
	     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
	     * compiled({ 'users': ['fred', 'barney'] });
	     * // => '<li>fred</li><li>barney</li>'
	     *
	     * // using the `sourceURL` option to specify a custom sourceURL for the template
	     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
	     * compiled(data);
	     * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
	     *
	     * // using the `variable` option to ensure a with-statement isn't used in the compiled template
	     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
	     * compiled.source;
	     * // => function(data) {
	     * //   var __t, __p = '';
	     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
	     * //   return __p;
	     * // }
	     *
	     * // using the `source` property to inline compiled templates for meaningful
	     * // line numbers in error messages and a stack trace
	     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
	     *   var JST = {\
	     *     "main": ' + _.template(mainText).source + '\
	     *   };\
	     * ');
	     */
	    function template(string, options, otherOptions) {
	      // Based on John Resig's `tmpl` implementation (http://ejohn.org/blog/javascript-micro-templating/)
	      // and Laura Doktorova's doT.js (https://github.com/olado/doT).
	      var settings = lodash.templateSettings;

	      if (otherOptions && isIterateeCall(string, options, otherOptions)) {
	        options = otherOptions = undefined;
	      }
	      string = baseToString(string);
	      options = assignWith(baseAssign({}, otherOptions || options), settings, assignOwnDefaults);

	      var imports = assignWith(baseAssign({}, options.imports), settings.imports, assignOwnDefaults),
	          importsKeys = keys(imports),
	          importsValues = baseValues(imports, importsKeys);

	      var isEscaping,
	          isEvaluating,
	          index = 0,
	          interpolate = options.interpolate || reNoMatch,
	          source = "__p += '";

	      // Compile the regexp to match each delimiter.
	      var reDelimiters = RegExp(
	        (options.escape || reNoMatch).source + '|' +
	        interpolate.source + '|' +
	        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
	        (options.evaluate || reNoMatch).source + '|$'
	      , 'g');

	      // Use a sourceURL for easier debugging.
	      var sourceURL = '//# sourceURL=' +
	        ('sourceURL' in options
	          ? options.sourceURL
	          : ('lodash.templateSources[' + (++templateCounter) + ']')
	        ) + '\n';

	      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
	        interpolateValue || (interpolateValue = esTemplateValue);

	        // Escape characters that can't be included in string literals.
	        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

	        // Replace delimiters with snippets.
	        if (escapeValue) {
	          isEscaping = true;
	          source += "' +\n__e(" + escapeValue + ") +\n'";
	        }
	        if (evaluateValue) {
	          isEvaluating = true;
	          source += "';\n" + evaluateValue + ";\n__p += '";
	        }
	        if (interpolateValue) {
	          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
	        }
	        index = offset + match.length;

	        // The JS engine embedded in Adobe products requires returning the `match`
	        // string in order to produce the correct `offset` value.
	        return match;
	      });

	      source += "';\n";

	      // If `variable` is not specified wrap a with-statement around the generated
	      // code to add the data object to the top of the scope chain.
	      var variable = options.variable;
	      if (!variable) {
	        source = 'with (obj) {\n' + source + '\n}\n';
	      }
	      // Cleanup code by stripping empty strings.
	      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
	        .replace(reEmptyStringMiddle, '$1')
	        .replace(reEmptyStringTrailing, '$1;');

	      // Frame code as the function body.
	      source = 'function(' + (variable || 'obj') + ') {\n' +
	        (variable
	          ? ''
	          : 'obj || (obj = {});\n'
	        ) +
	        "var __t, __p = ''" +
	        (isEscaping
	           ? ', __e = _.escape'
	           : ''
	        ) +
	        (isEvaluating
	          ? ', __j = Array.prototype.join;\n' +
	            "function print() { __p += __j.call(arguments, '') }\n"
	          : ';\n'
	        ) +
	        source +
	        'return __p\n}';

	      var result = attempt(function() {
	        return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);
	      });

	      // Provide the compiled function's source by its `toString` method or
	      // the `source` property as a convenience for inlining compiled templates.
	      result.source = source;
	      if (isError(result)) {
	        throw result;
	      }
	      return result;
	    }

	    /**
	     * Removes leading and trailing whitespace or specified characters from `string`.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to trim.
	     * @param {string} [chars=whitespace] The characters to trim.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {string} Returns the trimmed string.
	     * @example
	     *
	     * _.trim('  abc  ');
	     * // => 'abc'
	     *
	     * _.trim('-_-abc-_-', '_-');
	     * // => 'abc'
	     *
	     * _.map(['  foo  ', '  bar  '], _.trim);
	     * // => ['foo', 'bar']
	     */
	    function trim(string, chars, guard) {
	      var value = string;
	      string = baseToString(string);
	      if (!string) {
	        return string;
	      }
	      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
	        return string.slice(trimmedLeftIndex(string), trimmedRightIndex(string) + 1);
	      }
	      chars = (chars + '');
	      return string.slice(charsLeftIndex(string, chars), charsRightIndex(string, chars) + 1);
	    }

	    /**
	     * Removes leading whitespace or specified characters from `string`.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to trim.
	     * @param {string} [chars=whitespace] The characters to trim.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {string} Returns the trimmed string.
	     * @example
	     *
	     * _.trimLeft('  abc  ');
	     * // => 'abc  '
	     *
	     * _.trimLeft('-_-abc-_-', '_-');
	     * // => 'abc-_-'
	     */
	    function trimLeft(string, chars, guard) {
	      var value = string;
	      string = baseToString(string);
	      if (!string) {
	        return string;
	      }
	      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
	        return string.slice(trimmedLeftIndex(string));
	      }
	      return string.slice(charsLeftIndex(string, (chars + '')));
	    }

	    /**
	     * Removes trailing whitespace or specified characters from `string`.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to trim.
	     * @param {string} [chars=whitespace] The characters to trim.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {string} Returns the trimmed string.
	     * @example
	     *
	     * _.trimRight('  abc  ');
	     * // => '  abc'
	     *
	     * _.trimRight('-_-abc-_-', '_-');
	     * // => '-_-abc'
	     */
	    function trimRight(string, chars, guard) {
	      var value = string;
	      string = baseToString(string);
	      if (!string) {
	        return string;
	      }
	      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
	        return string.slice(0, trimmedRightIndex(string) + 1);
	      }
	      return string.slice(0, charsRightIndex(string, (chars + '')) + 1);
	    }

	    /**
	     * Truncates `string` if it's longer than the given maximum string length.
	     * The last characters of the truncated string are replaced with the omission
	     * string which defaults to "...".
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to truncate.
	     * @param {Object|number} [options] The options object or maximum string length.
	     * @param {number} [options.length=30] The maximum string length.
	     * @param {string} [options.omission='...'] The string to indicate text is omitted.
	     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {string} Returns the truncated string.
	     * @example
	     *
	     * _.trunc('hi-diddly-ho there, neighborino');
	     * // => 'hi-diddly-ho there, neighbo...'
	     *
	     * _.trunc('hi-diddly-ho there, neighborino', 24);
	     * // => 'hi-diddly-ho there, n...'
	     *
	     * _.trunc('hi-diddly-ho there, neighborino', {
	     *   'length': 24,
	     *   'separator': ' '
	     * });
	     * // => 'hi-diddly-ho there,...'
	     *
	     * _.trunc('hi-diddly-ho there, neighborino', {
	     *   'length': 24,
	     *   'separator': /,? +/
	     * });
	     * // => 'hi-diddly-ho there...'
	     *
	     * _.trunc('hi-diddly-ho there, neighborino', {
	     *   'omission': ' [...]'
	     * });
	     * // => 'hi-diddly-ho there, neig [...]'
	     */
	    function trunc(string, options, guard) {
	      if (guard && isIterateeCall(string, options, guard)) {
	        options = undefined;
	      }
	      var length = DEFAULT_TRUNC_LENGTH,
	          omission = DEFAULT_TRUNC_OMISSION;

	      if (options != null) {
	        if (isObject(options)) {
	          var separator = 'separator' in options ? options.separator : separator;
	          length = 'length' in options ? (+options.length || 0) : length;
	          omission = 'omission' in options ? baseToString(options.omission) : omission;
	        } else {
	          length = +options || 0;
	        }
	      }
	      string = baseToString(string);
	      if (length >= string.length) {
	        return string;
	      }
	      var end = length - omission.length;
	      if (end < 1) {
	        return omission;
	      }
	      var result = string.slice(0, end);
	      if (separator == null) {
	        return result + omission;
	      }
	      if (isRegExp(separator)) {
	        if (string.slice(end).search(separator)) {
	          var match,
	              newEnd,
	              substring = string.slice(0, end);

	          if (!separator.global) {
	            separator = RegExp(separator.source, (reFlags.exec(separator) || '') + 'g');
	          }
	          separator.lastIndex = 0;
	          while ((match = separator.exec(substring))) {
	            newEnd = match.index;
	          }
	          result = result.slice(0, newEnd == null ? end : newEnd);
	        }
	      } else if (string.indexOf(separator, end) != end) {
	        var index = result.lastIndexOf(separator);
	        if (index > -1) {
	          result = result.slice(0, index);
	        }
	      }
	      return result + omission;
	    }

	    /**
	     * The inverse of `_.escape`; this method converts the HTML entities
	     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, `&#39;`, and `&#96;` in `string` to their
	     * corresponding characters.
	     *
	     * **Note:** No other HTML entities are unescaped. To unescape additional HTML
	     * entities use a third-party library like [_he_](https://mths.be/he).
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to unescape.
	     * @returns {string} Returns the unescaped string.
	     * @example
	     *
	     * _.unescape('fred, barney, &amp; pebbles');
	     * // => 'fred, barney, & pebbles'
	     */
	    function unescape(string) {
	      string = baseToString(string);
	      return (string && reHasEscapedHtml.test(string))
	        ? string.replace(reEscapedHtml, unescapeHtmlChar)
	        : string;
	    }

	    /**
	     * Splits `string` into an array of its words.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to inspect.
	     * @param {RegExp|string} [pattern] The pattern to match words.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Array} Returns the words of `string`.
	     * @example
	     *
	     * _.words('fred, barney, & pebbles');
	     * // => ['fred', 'barney', 'pebbles']
	     *
	     * _.words('fred, barney, & pebbles', /[^, ]+/g);
	     * // => ['fred', 'barney', '&', 'pebbles']
	     */
	    function words(string, pattern, guard) {
	      if (guard && isIterateeCall(string, pattern, guard)) {
	        pattern = undefined;
	      }
	      string = baseToString(string);
	      return string.match(pattern || reWords) || [];
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Attempts to invoke `func`, returning either the result or the caught error
	     * object. Any additional arguments are provided to `func` when it is invoked.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {Function} func The function to attempt.
	     * @returns {*} Returns the `func` result or error object.
	     * @example
	     *
	     * // avoid throwing errors for invalid selectors
	     * var elements = _.attempt(function(selector) {
	     *   return document.querySelectorAll(selector);
	     * }, '>_>');
	     *
	     * if (_.isError(elements)) {
	     *   elements = [];
	     * }
	     */
	    var attempt = restParam(function(func, args) {
	      try {
	        return func.apply(undefined, args);
	      } catch(e) {
	        return isError(e) ? e : new Error(e);
	      }
	    });

	    /**
	     * Creates a function that invokes `func` with the `this` binding of `thisArg`
	     * and arguments of the created function. If `func` is a property name the
	     * created callback returns the property value for a given element. If `func`
	     * is an object the created callback returns `true` for elements that contain
	     * the equivalent object properties, otherwise it returns `false`.
	     *
	     * @static
	     * @memberOf _
	     * @alias iteratee
	     * @category Utility
	     * @param {*} [func=_.identity] The value to convert to a callback.
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Function} Returns the callback.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36 },
	     *   { 'user': 'fred',   'age': 40 }
	     * ];
	     *
	     * // wrap to create custom callback shorthands
	     * _.callback = _.wrap(_.callback, function(callback, func, thisArg) {
	     *   var match = /^(.+?)__([gl]t)(.+)$/.exec(func);
	     *   if (!match) {
	     *     return callback(func, thisArg);
	     *   }
	     *   return function(object) {
	     *     return match[2] == 'gt'
	     *       ? object[match[1]] > match[3]
	     *       : object[match[1]] < match[3];
	     *   };
	     * });
	     *
	     * _.filter(users, 'age__gt36');
	     * // => [{ 'user': 'fred', 'age': 40 }]
	     */
	    function callback(func, thisArg, guard) {
	      if (guard && isIterateeCall(func, thisArg, guard)) {
	        thisArg = undefined;
	      }
	      return isObjectLike(func)
	        ? matches(func)
	        : baseCallback(func, thisArg);
	    }

	    /**
	     * Creates a function that returns `value`.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {*} value The value to return from the new function.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var object = { 'user': 'fred' };
	     * var getter = _.constant(object);
	     *
	     * getter() === object;
	     * // => true
	     */
	    function constant(value) {
	      return function() {
	        return value;
	      };
	    }

	    /**
	     * This method returns the first argument provided to it.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {*} value Any value.
	     * @returns {*} Returns `value`.
	     * @example
	     *
	     * var object = { 'user': 'fred' };
	     *
	     * _.identity(object) === object;
	     * // => true
	     */
	    function identity(value) {
	      return value;
	    }

	    /**
	     * Creates a function that performs a deep comparison between a given object
	     * and `source`, returning `true` if the given object has equivalent property
	     * values, else `false`.
	     *
	     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
	     * numbers, `Object` objects, regexes, and strings. Objects are compared by
	     * their own, not inherited, enumerable properties. For comparing a single
	     * own or inherited property value see `_.matchesProperty`.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {Object} source The object of property values to match.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': true },
	     *   { 'user': 'fred',   'age': 40, 'active': false }
	     * ];
	     *
	     * _.filter(users, _.matches({ 'age': 40, 'active': false }));
	     * // => [{ 'user': 'fred', 'age': 40, 'active': false }]
	     */
	    function matches(source) {
	      return baseMatches(baseClone(source, true));
	    }

	    /**
	     * Creates a function that compares the property value of `path` on a given
	     * object to `value`.
	     *
	     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
	     * numbers, `Object` objects, regexes, and strings. Objects are compared by
	     * their own, not inherited, enumerable properties.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {Array|string} path The path of the property to get.
	     * @param {*} srcValue The value to match.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney' },
	     *   { 'user': 'fred' }
	     * ];
	     *
	     * _.find(users, _.matchesProperty('user', 'fred'));
	     * // => { 'user': 'fred' }
	     */
	    function matchesProperty(path, srcValue) {
	      return baseMatchesProperty(path, baseClone(srcValue, true));
	    }

	    /**
	     * Creates a function that invokes the method at `path` on a given object.
	     * Any additional arguments are provided to the invoked method.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {Array|string} path The path of the method to invoke.
	     * @param {...*} [args] The arguments to invoke the method with.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var objects = [
	     *   { 'a': { 'b': { 'c': _.constant(2) } } },
	     *   { 'a': { 'b': { 'c': _.constant(1) } } }
	     * ];
	     *
	     * _.map(objects, _.method('a.b.c'));
	     * // => [2, 1]
	     *
	     * _.invoke(_.sortBy(objects, _.method(['a', 'b', 'c'])), 'a.b.c');
	     * // => [1, 2]
	     */
	    var method = restParam(function(path, args) {
	      return function(object) {
	        return invokePath(object, path, args);
	      };
	    });

	    /**
	     * The opposite of `_.method`; this method creates a function that invokes
	     * the method at a given path on `object`. Any additional arguments are
	     * provided to the invoked method.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {Object} object The object to query.
	     * @param {...*} [args] The arguments to invoke the method with.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var array = _.times(3, _.constant),
	     *     object = { 'a': array, 'b': array, 'c': array };
	     *
	     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
	     * // => [2, 0]
	     *
	     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
	     * // => [2, 0]
	     */
	    var methodOf = restParam(function(object, args) {
	      return function(path) {
	        return invokePath(object, path, args);
	      };
	    });

	    /**
	     * Adds all own enumerable function properties of a source object to the
	     * destination object. If `object` is a function then methods are added to
	     * its prototype as well.
	     *
	     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
	     * avoid conflicts caused by modifying the original.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {Function|Object} [object=lodash] The destination object.
	     * @param {Object} source The object of functions to add.
	     * @param {Object} [options] The options object.
	     * @param {boolean} [options.chain=true] Specify whether the functions added
	     *  are chainable.
	     * @returns {Function|Object} Returns `object`.
	     * @example
	     *
	     * function vowels(string) {
	     *   return _.filter(string, function(v) {
	     *     return /[aeiou]/i.test(v);
	     *   });
	     * }
	     *
	     * _.mixin({ 'vowels': vowels });
	     * _.vowels('fred');
	     * // => ['e']
	     *
	     * _('fred').vowels().value();
	     * // => ['e']
	     *
	     * _.mixin({ 'vowels': vowels }, { 'chain': false });
	     * _('fred').vowels();
	     * // => ['e']
	     */
	    function mixin(object, source, options) {
	      if (options == null) {
	        var isObj = isObject(source),
	            props = isObj ? keys(source) : undefined,
	            methodNames = (props && props.length) ? baseFunctions(source, props) : undefined;

	        if (!(methodNames ? methodNames.length : isObj)) {
	          methodNames = false;
	          options = source;
	          source = object;
	          object = this;
	        }
	      }
	      if (!methodNames) {
	        methodNames = baseFunctions(source, keys(source));
	      }
	      var chain = true,
	          index = -1,
	          isFunc = isFunction(object),
	          length = methodNames.length;

	      if (options === false) {
	        chain = false;
	      } else if (isObject(options) && 'chain' in options) {
	        chain = options.chain;
	      }
	      while (++index < length) {
	        var methodName = methodNames[index],
	            func = source[methodName];

	        object[methodName] = func;
	        if (isFunc) {
	          object.prototype[methodName] = (function(func) {
	            return function() {
	              var chainAll = this.__chain__;
	              if (chain || chainAll) {
	                var result = object(this.__wrapped__),
	                    actions = result.__actions__ = arrayCopy(this.__actions__);

	                actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
	                result.__chain__ = chainAll;
	                return result;
	              }
	              return func.apply(object, arrayPush([this.value()], arguments));
	            };
	          }(func));
	        }
	      }
	      return object;
	    }

	    /**
	     * Reverts the `_` variable to its previous value and returns a reference to
	     * the `lodash` function.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @returns {Function} Returns the `lodash` function.
	     * @example
	     *
	     * var lodash = _.noConflict();
	     */
	    function noConflict() {
	      root._ = oldDash;
	      return this;
	    }

	    /**
	     * A no-operation function that returns `undefined` regardless of the
	     * arguments it receives.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @example
	     *
	     * var object = { 'user': 'fred' };
	     *
	     * _.noop(object) === undefined;
	     * // => true
	     */
	    function noop() {
	      // No operation performed.
	    }

	    /**
	     * Creates a function that returns the property value at `path` on a
	     * given object.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {Array|string} path The path of the property to get.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var objects = [
	     *   { 'a': { 'b': { 'c': 2 } } },
	     *   { 'a': { 'b': { 'c': 1 } } }
	     * ];
	     *
	     * _.map(objects, _.property('a.b.c'));
	     * // => [2, 1]
	     *
	     * _.pluck(_.sortBy(objects, _.property(['a', 'b', 'c'])), 'a.b.c');
	     * // => [1, 2]
	     */
	    function property(path) {
	      return isKey(path) ? baseProperty(path) : basePropertyDeep(path);
	    }

	    /**
	     * The opposite of `_.property`; this method creates a function that returns
	     * the property value at a given path on `object`.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {Object} object The object to query.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var array = [0, 1, 2],
	     *     object = { 'a': array, 'b': array, 'c': array };
	     *
	     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
	     * // => [2, 0]
	     *
	     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
	     * // => [2, 0]
	     */
	    function propertyOf(object) {
	      return function(path) {
	        return baseGet(object, toPath(path), path + '');
	      };
	    }

	    /**
	     * Creates an array of numbers (positive and/or negative) progressing from
	     * `start` up to, but not including, `end`. If `end` is not specified it is
	     * set to `start` with `start` then set to `0`. If `end` is less than `start`
	     * a zero-length range is created unless a negative `step` is specified.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {number} [start=0] The start of the range.
	     * @param {number} end The end of the range.
	     * @param {number} [step=1] The value to increment or decrement by.
	     * @returns {Array} Returns the new array of numbers.
	     * @example
	     *
	     * _.range(4);
	     * // => [0, 1, 2, 3]
	     *
	     * _.range(1, 5);
	     * // => [1, 2, 3, 4]
	     *
	     * _.range(0, 20, 5);
	     * // => [0, 5, 10, 15]
	     *
	     * _.range(0, -4, -1);
	     * // => [0, -1, -2, -3]
	     *
	     * _.range(1, 4, 0);
	     * // => [1, 1, 1]
	     *
	     * _.range(0);
	     * // => []
	     */
	    function range(start, end, step) {
	      if (step && isIterateeCall(start, end, step)) {
	        end = step = undefined;
	      }
	      start = +start || 0;
	      step = step == null ? 1 : (+step || 0);

	      if (end == null) {
	        end = start;
	        start = 0;
	      } else {
	        end = +end || 0;
	      }
	      // Use `Array(length)` so engines like Chakra and V8 avoid slower modes.
	      // See https://youtu.be/XAqIpGU8ZZk#t=17m25s for more details.
	      var index = -1,
	          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
	          result = Array(length);

	      while (++index < length) {
	        result[index] = start;
	        start += step;
	      }
	      return result;
	    }

	    /**
	     * Invokes the iteratee function `n` times, returning an array of the results
	     * of each invocation. The `iteratee` is bound to `thisArg` and invoked with
	     * one argument; (index).
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {number} n The number of times to invoke `iteratee`.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Array} Returns the array of results.
	     * @example
	     *
	     * var diceRolls = _.times(3, _.partial(_.random, 1, 6, false));
	     * // => [3, 6, 4]
	     *
	     * _.times(3, function(n) {
	     *   mage.castSpell(n);
	     * });
	     * // => invokes `mage.castSpell(n)` three times with `n` of `0`, `1`, and `2`
	     *
	     * _.times(3, function(n) {
	     *   this.cast(n);
	     * }, mage);
	     * // => also invokes `mage.castSpell(n)` three times
	     */
	    function times(n, iteratee, thisArg) {
	      n = nativeFloor(n);

	      // Exit early to avoid a JSC JIT bug in Safari 8
	      // where `Array(0)` is treated as `Array(1)`.
	      if (n < 1 || !nativeIsFinite(n)) {
	        return [];
	      }
	      var index = -1,
	          result = Array(nativeMin(n, MAX_ARRAY_LENGTH));

	      iteratee = bindCallback(iteratee, thisArg, 1);
	      while (++index < n) {
	        if (index < MAX_ARRAY_LENGTH) {
	          result[index] = iteratee(index);
	        } else {
	          iteratee(index);
	        }
	      }
	      return result;
	    }

	    /**
	     * Generates a unique ID. If `prefix` is provided the ID is appended to it.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {string} [prefix] The value to prefix the ID with.
	     * @returns {string} Returns the unique ID.
	     * @example
	     *
	     * _.uniqueId('contact_');
	     * // => 'contact_104'
	     *
	     * _.uniqueId();
	     * // => '105'
	     */
	    function uniqueId(prefix) {
	      var id = ++idCounter;
	      return baseToString(prefix) + id;
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Adds two numbers.
	     *
	     * @static
	     * @memberOf _
	     * @category Math
	     * @param {number} augend The first number to add.
	     * @param {number} addend The second number to add.
	     * @returns {number} Returns the sum.
	     * @example
	     *
	     * _.add(6, 4);
	     * // => 10
	     */
	    function add(augend, addend) {
	      return (+augend || 0) + (+addend || 0);
	    }

	    /**
	     * Calculates `n` rounded up to `precision`.
	     *
	     * @static
	     * @memberOf _
	     * @category Math
	     * @param {number} n The number to round up.
	     * @param {number} [precision=0] The precision to round up to.
	     * @returns {number} Returns the rounded up number.
	     * @example
	     *
	     * _.ceil(4.006);
	     * // => 5
	     *
	     * _.ceil(6.004, 2);
	     * // => 6.01
	     *
	     * _.ceil(6040, -2);
	     * // => 6100
	     */
	    var ceil = createRound('ceil');

	    /**
	     * Calculates `n` rounded down to `precision`.
	     *
	     * @static
	     * @memberOf _
	     * @category Math
	     * @param {number} n The number to round down.
	     * @param {number} [precision=0] The precision to round down to.
	     * @returns {number} Returns the rounded down number.
	     * @example
	     *
	     * _.floor(4.006);
	     * // => 4
	     *
	     * _.floor(0.046, 2);
	     * // => 0.04
	     *
	     * _.floor(4060, -2);
	     * // => 4000
	     */
	    var floor = createRound('floor');

	    /**
	     * Gets the maximum value of `collection`. If `collection` is empty or falsey
	     * `-Infinity` is returned. If an iteratee function is provided it is invoked
	     * for each value in `collection` to generate the criterion by which the value
	     * is ranked. The `iteratee` is bound to `thisArg` and invoked with three
	     * arguments: (value, index, collection).
	     *
	     * If a property name is provided for `iteratee` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `iteratee` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Math
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {*} Returns the maximum value.
	     * @example
	     *
	     * _.max([4, 2, 8, 6]);
	     * // => 8
	     *
	     * _.max([]);
	     * // => -Infinity
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36 },
	     *   { 'user': 'fred',   'age': 40 }
	     * ];
	     *
	     * _.max(users, function(chr) {
	     *   return chr.age;
	     * });
	     * // => { 'user': 'fred', 'age': 40 }
	     *
	     * // using the `_.property` callback shorthand
	     * _.max(users, 'age');
	     * // => { 'user': 'fred', 'age': 40 }
	     */
	    var max = createExtremum(gt, NEGATIVE_INFINITY);

	    /**
	     * Gets the minimum value of `collection`. If `collection` is empty or falsey
	     * `Infinity` is returned. If an iteratee function is provided it is invoked
	     * for each value in `collection` to generate the criterion by which the value
	     * is ranked. The `iteratee` is bound to `thisArg` and invoked with three
	     * arguments: (value, index, collection).
	     *
	     * If a property name is provided for `iteratee` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `iteratee` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Math
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {*} Returns the minimum value.
	     * @example
	     *
	     * _.min([4, 2, 8, 6]);
	     * // => 2
	     *
	     * _.min([]);
	     * // => Infinity
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36 },
	     *   { 'user': 'fred',   'age': 40 }
	     * ];
	     *
	     * _.min(users, function(chr) {
	     *   return chr.age;
	     * });
	     * // => { 'user': 'barney', 'age': 36 }
	     *
	     * // using the `_.property` callback shorthand
	     * _.min(users, 'age');
	     * // => { 'user': 'barney', 'age': 36 }
	     */
	    var min = createExtremum(lt, POSITIVE_INFINITY);

	    /**
	     * Calculates `n` rounded to `precision`.
	     *
	     * @static
	     * @memberOf _
	     * @category Math
	     * @param {number} n The number to round.
	     * @param {number} [precision=0] The precision to round to.
	     * @returns {number} Returns the rounded number.
	     * @example
	     *
	     * _.round(4.006);
	     * // => 4
	     *
	     * _.round(4.006, 2);
	     * // => 4.01
	     *
	     * _.round(4060, -2);
	     * // => 4100
	     */
	    var round = createRound('round');

	    /**
	     * Gets the sum of the values in `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @category Math
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {number} Returns the sum.
	     * @example
	     *
	     * _.sum([4, 6]);
	     * // => 10
	     *
	     * _.sum({ 'a': 4, 'b': 6 });
	     * // => 10
	     *
	     * var objects = [
	     *   { 'n': 4 },
	     *   { 'n': 6 }
	     * ];
	     *
	     * _.sum(objects, function(object) {
	     *   return object.n;
	     * });
	     * // => 10
	     *
	     * // using the `_.property` callback shorthand
	     * _.sum(objects, 'n');
	     * // => 10
	     */
	    function sum(collection, iteratee, thisArg) {
	      if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
	        iteratee = undefined;
	      }
	      iteratee = getCallback(iteratee, thisArg, 3);
	      return iteratee.length == 1
	        ? arraySum(isArray(collection) ? collection : toIterable(collection), iteratee)
	        : baseSum(collection, iteratee);
	    }

	    /*------------------------------------------------------------------------*/

	    // Ensure wrappers are instances of `baseLodash`.
	    lodash.prototype = baseLodash.prototype;

	    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
	    LodashWrapper.prototype.constructor = LodashWrapper;

	    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
	    LazyWrapper.prototype.constructor = LazyWrapper;

	    // Add functions to the `Map` cache.
	    MapCache.prototype['delete'] = mapDelete;
	    MapCache.prototype.get = mapGet;
	    MapCache.prototype.has = mapHas;
	    MapCache.prototype.set = mapSet;

	    // Add functions to the `Set` cache.
	    SetCache.prototype.push = cachePush;

	    // Assign cache to `_.memoize`.
	    memoize.Cache = MapCache;

	    // Add functions that return wrapped values when chaining.
	    lodash.after = after;
	    lodash.ary = ary;
	    lodash.assign = assign;
	    lodash.at = at;
	    lodash.before = before;
	    lodash.bind = bind;
	    lodash.bindAll = bindAll;
	    lodash.bindKey = bindKey;
	    lodash.callback = callback;
	    lodash.chain = chain;
	    lodash.chunk = chunk;
	    lodash.compact = compact;
	    lodash.constant = constant;
	    lodash.countBy = countBy;
	    lodash.create = create;
	    lodash.curry = curry;
	    lodash.curryRight = curryRight;
	    lodash.debounce = debounce;
	    lodash.defaults = defaults;
	    lodash.defaultsDeep = defaultsDeep;
	    lodash.defer = defer;
	    lodash.delay = delay;
	    lodash.difference = difference;
	    lodash.drop = drop;
	    lodash.dropRight = dropRight;
	    lodash.dropRightWhile = dropRightWhile;
	    lodash.dropWhile = dropWhile;
	    lodash.fill = fill;
	    lodash.filter = filter;
	    lodash.flatten = flatten;
	    lodash.flattenDeep = flattenDeep;
	    lodash.flow = flow;
	    lodash.flowRight = flowRight;
	    lodash.forEach = forEach;
	    lodash.forEachRight = forEachRight;
	    lodash.forIn = forIn;
	    lodash.forInRight = forInRight;
	    lodash.forOwn = forOwn;
	    lodash.forOwnRight = forOwnRight;
	    lodash.functions = functions;
	    lodash.groupBy = groupBy;
	    lodash.indexBy = indexBy;
	    lodash.initial = initial;
	    lodash.intersection = intersection;
	    lodash.invert = invert;
	    lodash.invoke = invoke;
	    lodash.keys = keys;
	    lodash.keysIn = keysIn;
	    lodash.map = map;
	    lodash.mapKeys = mapKeys;
	    lodash.mapValues = mapValues;
	    lodash.matches = matches;
	    lodash.matchesProperty = matchesProperty;
	    lodash.memoize = memoize;
	    lodash.merge = merge;
	    lodash.method = method;
	    lodash.methodOf = methodOf;
	    lodash.mixin = mixin;
	    lodash.modArgs = modArgs;
	    lodash.negate = negate;
	    lodash.omit = omit;
	    lodash.once = once;
	    lodash.pairs = pairs;
	    lodash.partial = partial;
	    lodash.partialRight = partialRight;
	    lodash.partition = partition;
	    lodash.pick = pick;
	    lodash.pluck = pluck;
	    lodash.property = property;
	    lodash.propertyOf = propertyOf;
	    lodash.pull = pull;
	    lodash.pullAt = pullAt;
	    lodash.range = range;
	    lodash.rearg = rearg;
	    lodash.reject = reject;
	    lodash.remove = remove;
	    lodash.rest = rest;
	    lodash.restParam = restParam;
	    lodash.set = set;
	    lodash.shuffle = shuffle;
	    lodash.slice = slice;
	    lodash.sortBy = sortBy;
	    lodash.sortByAll = sortByAll;
	    lodash.sortByOrder = sortByOrder;
	    lodash.spread = spread;
	    lodash.take = take;
	    lodash.takeRight = takeRight;
	    lodash.takeRightWhile = takeRightWhile;
	    lodash.takeWhile = takeWhile;
	    lodash.tap = tap;
	    lodash.throttle = throttle;
	    lodash.thru = thru;
	    lodash.times = times;
	    lodash.toArray = toArray;
	    lodash.toPlainObject = toPlainObject;
	    lodash.transform = transform;
	    lodash.union = union;
	    lodash.uniq = uniq;
	    lodash.unzip = unzip;
	    lodash.unzipWith = unzipWith;
	    lodash.values = values;
	    lodash.valuesIn = valuesIn;
	    lodash.where = where;
	    lodash.without = without;
	    lodash.wrap = wrap;
	    lodash.xor = xor;
	    lodash.zip = zip;
	    lodash.zipObject = zipObject;
	    lodash.zipWith = zipWith;

	    // Add aliases.
	    lodash.backflow = flowRight;
	    lodash.collect = map;
	    lodash.compose = flowRight;
	    lodash.each = forEach;
	    lodash.eachRight = forEachRight;
	    lodash.extend = assign;
	    lodash.iteratee = callback;
	    lodash.methods = functions;
	    lodash.object = zipObject;
	    lodash.select = filter;
	    lodash.tail = rest;
	    lodash.unique = uniq;

	    // Add functions to `lodash.prototype`.
	    mixin(lodash, lodash);

	    /*------------------------------------------------------------------------*/

	    // Add functions that return unwrapped values when chaining.
	    lodash.add = add;
	    lodash.attempt = attempt;
	    lodash.camelCase = camelCase;
	    lodash.capitalize = capitalize;
	    lodash.ceil = ceil;
	    lodash.clone = clone;
	    lodash.cloneDeep = cloneDeep;
	    lodash.deburr = deburr;
	    lodash.endsWith = endsWith;
	    lodash.escape = escape;
	    lodash.escapeRegExp = escapeRegExp;
	    lodash.every = every;
	    lodash.find = find;
	    lodash.findIndex = findIndex;
	    lodash.findKey = findKey;
	    lodash.findLast = findLast;
	    lodash.findLastIndex = findLastIndex;
	    lodash.findLastKey = findLastKey;
	    lodash.findWhere = findWhere;
	    lodash.first = first;
	    lodash.floor = floor;
	    lodash.get = get;
	    lodash.gt = gt;
	    lodash.gte = gte;
	    lodash.has = has;
	    lodash.identity = identity;
	    lodash.includes = includes;
	    lodash.indexOf = indexOf;
	    lodash.inRange = inRange;
	    lodash.isArguments = isArguments;
	    lodash.isArray = isArray;
	    lodash.isBoolean = isBoolean;
	    lodash.isDate = isDate;
	    lodash.isElement = isElement;
	    lodash.isEmpty = isEmpty;
	    lodash.isEqual = isEqual;
	    lodash.isError = isError;
	    lodash.isFinite = isFinite;
	    lodash.isFunction = isFunction;
	    lodash.isMatch = isMatch;
	    lodash.isNaN = isNaN;
	    lodash.isNative = isNative;
	    lodash.isNull = isNull;
	    lodash.isNumber = isNumber;
	    lodash.isObject = isObject;
	    lodash.isPlainObject = isPlainObject;
	    lodash.isRegExp = isRegExp;
	    lodash.isString = isString;
	    lodash.isTypedArray = isTypedArray;
	    lodash.isUndefined = isUndefined;
	    lodash.kebabCase = kebabCase;
	    lodash.last = last;
	    lodash.lastIndexOf = lastIndexOf;
	    lodash.lt = lt;
	    lodash.lte = lte;
	    lodash.max = max;
	    lodash.min = min;
	    lodash.noConflict = noConflict;
	    lodash.noop = noop;
	    lodash.now = now;
	    lodash.pad = pad;
	    lodash.padLeft = padLeft;
	    lodash.padRight = padRight;
	    lodash.parseInt = parseInt;
	    lodash.random = random;
	    lodash.reduce = reduce;
	    lodash.reduceRight = reduceRight;
	    lodash.repeat = repeat;
	    lodash.result = result;
	    lodash.round = round;
	    lodash.runInContext = runInContext;
	    lodash.size = size;
	    lodash.snakeCase = snakeCase;
	    lodash.some = some;
	    lodash.sortedIndex = sortedIndex;
	    lodash.sortedLastIndex = sortedLastIndex;
	    lodash.startCase = startCase;
	    lodash.startsWith = startsWith;
	    lodash.sum = sum;
	    lodash.template = template;
	    lodash.trim = trim;
	    lodash.trimLeft = trimLeft;
	    lodash.trimRight = trimRight;
	    lodash.trunc = trunc;
	    lodash.unescape = unescape;
	    lodash.uniqueId = uniqueId;
	    lodash.words = words;

	    // Add aliases.
	    lodash.all = every;
	    lodash.any = some;
	    lodash.contains = includes;
	    lodash.eq = isEqual;
	    lodash.detect = find;
	    lodash.foldl = reduce;
	    lodash.foldr = reduceRight;
	    lodash.head = first;
	    lodash.include = includes;
	    lodash.inject = reduce;

	    mixin(lodash, (function() {
	      var source = {};
	      baseForOwn(lodash, function(func, methodName) {
	        if (!lodash.prototype[methodName]) {
	          source[methodName] = func;
	        }
	      });
	      return source;
	    }()), false);

	    /*------------------------------------------------------------------------*/

	    // Add functions capable of returning wrapped and unwrapped values when chaining.
	    lodash.sample = sample;

	    lodash.prototype.sample = function(n) {
	      if (!this.__chain__ && n == null) {
	        return sample(this.value());
	      }
	      return this.thru(function(value) {
	        return sample(value, n);
	      });
	    };

	    /*------------------------------------------------------------------------*/

	    /**
	     * The semantic version number.
	     *
	     * @static
	     * @memberOf _
	     * @type string
	     */
	    lodash.VERSION = VERSION;

	    // Assign default placeholders.
	    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
	      lodash[methodName].placeholder = lodash;
	    });

	    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
	    arrayEach(['drop', 'take'], function(methodName, index) {
	      LazyWrapper.prototype[methodName] = function(n) {
	        var filtered = this.__filtered__;
	        if (filtered && !index) {
	          return new LazyWrapper(this);
	        }
	        n = n == null ? 1 : nativeMax(nativeFloor(n) || 0, 0);

	        var result = this.clone();
	        if (filtered) {
	          result.__takeCount__ = nativeMin(result.__takeCount__, n);
	        } else {
	          result.__views__.push({ 'size': n, 'type': methodName + (result.__dir__ < 0 ? 'Right' : '') });
	        }
	        return result;
	      };

	      LazyWrapper.prototype[methodName + 'Right'] = function(n) {
	        return this.reverse()[methodName](n).reverse();
	      };
	    });

	    // Add `LazyWrapper` methods that accept an `iteratee` value.
	    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
	      var type = index + 1,
	          isFilter = type != LAZY_MAP_FLAG;

	      LazyWrapper.prototype[methodName] = function(iteratee, thisArg) {
	        var result = this.clone();
	        result.__iteratees__.push({ 'iteratee': getCallback(iteratee, thisArg, 1), 'type': type });
	        result.__filtered__ = result.__filtered__ || isFilter;
	        return result;
	      };
	    });

	    // Add `LazyWrapper` methods for `_.first` and `_.last`.
	    arrayEach(['first', 'last'], function(methodName, index) {
	      var takeName = 'take' + (index ? 'Right' : '');

	      LazyWrapper.prototype[methodName] = function() {
	        return this[takeName](1).value()[0];
	      };
	    });

	    // Add `LazyWrapper` methods for `_.initial` and `_.rest`.
	    arrayEach(['initial', 'rest'], function(methodName, index) {
	      var dropName = 'drop' + (index ? '' : 'Right');

	      LazyWrapper.prototype[methodName] = function() {
	        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
	      };
	    });

	    // Add `LazyWrapper` methods for `_.pluck` and `_.where`.
	    arrayEach(['pluck', 'where'], function(methodName, index) {
	      var operationName = index ? 'filter' : 'map',
	          createCallback = index ? baseMatches : property;

	      LazyWrapper.prototype[methodName] = function(value) {
	        return this[operationName](createCallback(value));
	      };
	    });

	    LazyWrapper.prototype.compact = function() {
	      return this.filter(identity);
	    };

	    LazyWrapper.prototype.reject = function(predicate, thisArg) {
	      predicate = getCallback(predicate, thisArg, 1);
	      return this.filter(function(value) {
	        return !predicate(value);
	      });
	    };

	    LazyWrapper.prototype.slice = function(start, end) {
	      start = start == null ? 0 : (+start || 0);

	      var result = this;
	      if (result.__filtered__ && (start > 0 || end < 0)) {
	        return new LazyWrapper(result);
	      }
	      if (start < 0) {
	        result = result.takeRight(-start);
	      } else if (start) {
	        result = result.drop(start);
	      }
	      if (end !== undefined) {
	        end = (+end || 0);
	        result = end < 0 ? result.dropRight(-end) : result.take(end - start);
	      }
	      return result;
	    };

	    LazyWrapper.prototype.takeRightWhile = function(predicate, thisArg) {
	      return this.reverse().takeWhile(predicate, thisArg).reverse();
	    };

	    LazyWrapper.prototype.toArray = function() {
	      return this.take(POSITIVE_INFINITY);
	    };

	    // Add `LazyWrapper` methods to `lodash.prototype`.
	    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
	      var checkIteratee = /^(?:filter|map|reject)|While$/.test(methodName),
	          retUnwrapped = /^(?:first|last)$/.test(methodName),
	          lodashFunc = lodash[retUnwrapped ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName];

	      if (!lodashFunc) {
	        return;
	      }
	      lodash.prototype[methodName] = function() {
	        var args = retUnwrapped ? [1] : arguments,
	            chainAll = this.__chain__,
	            value = this.__wrapped__,
	            isHybrid = !!this.__actions__.length,
	            isLazy = value instanceof LazyWrapper,
	            iteratee = args[0],
	            useLazy = isLazy || isArray(value);

	        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
	          // Avoid lazy use if the iteratee has a "length" value other than `1`.
	          isLazy = useLazy = false;
	        }
	        var interceptor = function(value) {
	          return (retUnwrapped && chainAll)
	            ? lodashFunc(value, 1)[0]
	            : lodashFunc.apply(undefined, arrayPush([value], args));
	        };

	        var action = { 'func': thru, 'args': [interceptor], 'thisArg': undefined },
	            onlyLazy = isLazy && !isHybrid;

	        if (retUnwrapped && !chainAll) {
	          if (onlyLazy) {
	            value = value.clone();
	            value.__actions__.push(action);
	            return func.call(value);
	          }
	          return lodashFunc.call(undefined, this.value())[0];
	        }
	        if (!retUnwrapped && useLazy) {
	          value = onlyLazy ? value : new LazyWrapper(this);
	          var result = func.apply(value, args);
	          result.__actions__.push(action);
	          return new LodashWrapper(result, chainAll);
	        }
	        return this.thru(interceptor);
	      };
	    });

	    // Add `Array` and `String` methods to `lodash.prototype`.
	    arrayEach(['join', 'pop', 'push', 'replace', 'shift', 'sort', 'splice', 'split', 'unshift'], function(methodName) {
	      var func = (/^(?:replace|split)$/.test(methodName) ? stringProto : arrayProto)[methodName],
	          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
	          retUnwrapped = /^(?:join|pop|replace|shift)$/.test(methodName);

	      lodash.prototype[methodName] = function() {
	        var args = arguments;
	        if (retUnwrapped && !this.__chain__) {
	          return func.apply(this.value(), args);
	        }
	        return this[chainName](function(value) {
	          return func.apply(value, args);
	        });
	      };
	    });

	    // Map minified function names to their real names.
	    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
	      var lodashFunc = lodash[methodName];
	      if (lodashFunc) {
	        var key = lodashFunc.name,
	            names = realNames[key] || (realNames[key] = []);

	        names.push({ 'name': methodName, 'func': lodashFunc });
	      }
	    });

	    realNames[createHybridWrapper(undefined, BIND_KEY_FLAG).name] = [{ 'name': 'wrapper', 'func': undefined }];

	    // Add functions to the lazy wrapper.
	    LazyWrapper.prototype.clone = lazyClone;
	    LazyWrapper.prototype.reverse = lazyReverse;
	    LazyWrapper.prototype.value = lazyValue;

	    // Add chaining functions to the `lodash` wrapper.
	    lodash.prototype.chain = wrapperChain;
	    lodash.prototype.commit = wrapperCommit;
	    lodash.prototype.concat = wrapperConcat;
	    lodash.prototype.plant = wrapperPlant;
	    lodash.prototype.reverse = wrapperReverse;
	    lodash.prototype.toString = wrapperToString;
	    lodash.prototype.run = lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

	    // Add function aliases to the `lodash` wrapper.
	    lodash.prototype.collect = lodash.prototype.map;
	    lodash.prototype.head = lodash.prototype.first;
	    lodash.prototype.select = lodash.prototype.filter;
	    lodash.prototype.tail = lodash.prototype.rest;

	    return lodash;
	  }

	  /*--------------------------------------------------------------------------*/

	  // Export lodash.
	  var _ = runInContext();

	  // Some AMD build optimizers like r.js check for condition patterns like the following:
	  if (true) {
	    // Expose lodash to the global object when an AMD loader is present to avoid
	    // errors in cases where lodash is loaded by a script tag and not intended
	    // as an AMD module. See http://requirejs.org/docs/errors.html#mismatch for
	    // more details.
	    root._ = _;

	    // Define as an anonymous module so, through path mapping, it can be
	    // referenced as the "underscore" module.
	    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
	      return _;
	    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	  // Check for `exports` after `define` in case a build optimizer adds an `exports` object.
	  else if (freeExports && freeModule) {
	    // Export for Node.js or RingoJS.
	    if (moduleExports) {
	      (freeModule.exports = _)._ = _;
	    }
	    // Export for Rhino with CommonJS support.
	    else {
	      freeExports._ = _;
	    }
	  }
	  else {
	    // Export for a browser or Rhino.
	    root._ = _;
	  }
	}.call(this));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)(module), (function() { return this; }())))

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	var Highcharts = __webpack_require__(58);
	var dataService = __webpack_require__(17);
	var configService = __webpack_require__(61);
	var chart = function () {
	    var that = this;

	    that.load = function (element) {
	        element.innerHTML = '<div id="container" style="width:100%; height:400px;"></div>';
	        container = element.firstChild;
	        var config = {
	            chart: {
	                type: 'bar'
	            },
	            title: {
	                text: 'Fruit Consumption'
	            },
	            xAxis: {
	                categories: ['Apples', 'Bananas', 'Oranges']
	            },
	            yAxis: {
	                title: {
	                    text: 'Fruit eaten'
	                }
	            },
	            series: [{
	                name: 'Jane',
	                data: [1, 0, 4]
	            }, {
	                name: 'John',
	                data: [5, 7, 3]
	            }]
	        };

	        var chart = Highcharts.createChart(
	            container,
	            config,
	            function () {
	                console.log('Chart initialized');
	            }
	        );
	    };
	    return that;
	};


	module.exports = chart();

/***/ },
/* 20 */,
/* 21 */,
/* 22 */,
/* 23 */,
/* 24 */,
/* 25 */,
/* 26 */,
/* 27 */,
/* 28 */,
/* 29 */,
/* 30 */,
/* 31 */,
/* 32 */,
/* 33 */,
/* 34 */,
/* 35 */,
/* 36 */,
/* 37 */,
/* 38 */,
/* 39 */,
/* 40 */,
/* 41 */,
/* 42 */,
/* 43 */,
/* 44 */,
/* 45 */,
/* 46 */,
/* 47 */,
/* 48 */,
/* 49 */,
/* 50 */,
/* 51 */,
/* 52 */,
/* 53 */,
/* 54 */,
/* 55 */,
/* 56 */,
/* 57 */
/***/ function(module, exports) {

	

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Highcharts = __webpack_require__(59);

	module.exports = {
	  createChart: function(div, options, callback) {
	    options.chart = options.chart || {};
	    options.chart.renderTo = div;
	    return new Highcharts.Chart(options, callback);
	  },
	  destroy: function(chart) {
	    chart.destroy();
	  }
	};


/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	 /*eslint-disable*/
	 'use strict';
	 var jquery = __webpack_require__(60);
	 var Highcharts;
	 var HighchartsAdapter;
	 
	// ==ClosureCompiler==
	// @compilation_level SIMPLE_OPTIMIZATIONS

	/**
	 * @license Highcharts JS v4.1.7 (2015-06-26)
	 *
	 * (c) 2009-2014 Torstein Honsi
	 *
	 * License: www.highcharts.com/license
	 */

	// JSLint options:
	/*global Highcharts, HighchartsAdapter, document, window, navigator, setInterval, clearInterval, clearTimeout, setTimeout, location, jQuery, $, console, each, grep */
	/*jslint ass: true, sloppy: true, forin: true, plusplus: true, nomen: true, vars: true, regexp: true, newcap: true, browser: true, continue: true, white: true */
	// encapsulated variables
	var UNDEFINED,
		doc = document,
		win = window,
		math = Math,
		mathRound = math.round,
		mathFloor = math.floor,
		mathCeil = math.ceil,
		mathMax = math.max,
		mathMin = math.min,
		mathAbs = math.abs,
		mathCos = math.cos,
		mathSin = math.sin,
		mathPI = math.PI,
		deg2rad = mathPI * 2 / 360,


		// some variables
		userAgent = navigator.userAgent,
		isOpera = win.opera,
		isIE = /(msie|trident)/i.test(userAgent) && !isOpera,
		docMode8 = doc.documentMode === 8,
		isWebKit = /AppleWebKit/.test(userAgent),
		isFirefox = /Firefox/.test(userAgent),
		isTouchDevice = /(Mobile|Android|Windows Phone)/.test(userAgent),
		SVG_NS = 'http://www.w3.org/2000/svg',
		hasSVG = !!doc.createElementNS && !!doc.createElementNS(SVG_NS, 'svg').createSVGRect,
		hasBidiBug = isFirefox && parseInt(userAgent.split('Firefox/')[1], 10) < 4, // issue #38
		useCanVG = !hasSVG && !isIE && !!doc.createElement('canvas').getContext,
		Renderer,
		hasTouch,
		symbolSizes = {},
		idCounter = 0,
		garbageBin,
		defaultOptions,
		dateFormat, // function
		globalAnimation,
		pathAnim,
		timeUnits,
		noop = function () { return UNDEFINED; },
		charts = [],
		chartCount = 0,
		PRODUCT = 'Highcharts',
		VERSION = '4.1.7',

		// some constants for frequently used strings
		DIV = 'div',
		ABSOLUTE = 'absolute',
		RELATIVE = 'relative',
		HIDDEN = 'hidden',
		PREFIX = 'highcharts-',
		VISIBLE = 'visible',
		PX = 'px',
		NONE = 'none',
		M = 'M',
		L = 'L',
		numRegex = /^[0-9]+$/,
		NORMAL_STATE = '',
		HOVER_STATE = 'hover',
		SELECT_STATE = 'select',
		marginNames = ['plotTop', 'marginRight', 'marginBottom', 'plotLeft'],
		
		// Object for extending Axis
		AxisPlotLineOrBandExtension,

		// constants for attributes
		STROKE_WIDTH = 'stroke-width',

		// time methods, changed based on whether or not UTC is used
		Date,  // Allow using a different Date class
		makeTime,
		timezoneOffset,
		getTimezoneOffset,
		getMinutes,
		getHours,
		getDay,
		getDate,
		getMonth,
		getFullYear,
		setMilliseconds,
		setSeconds,
		setMinutes,
		setHours,
		setDate,
		setMonth,
		setFullYear,


		// lookup over the types and the associated classes
		seriesTypes = {},
		Highcharts;

	// The Highcharts namespace
	Highcharts = {};

	Highcharts.seriesTypes = seriesTypes;

	/**
	 * Extend an object with the members of another
	 * @param {Object} a The object to be extended
	 * @param {Object} b The object to add to the first one
	 */
	var extend = Highcharts.extend = function (a, b) {
		var n;
		if (!a) {
			a = {};
		}
		for (n in b) {
			a[n] = b[n];
		}
		return a;
	};
		
	/**
	 * Deep merge two or more objects and return a third object. If the first argument is
	 * true, the contents of the second object is copied into the first object.
	 * Previously this function redirected to jQuery.extend(true), but this had two limitations.
	 * First, it deep merged arrays, which lead to workarounds in Highcharts. Second,
	 * it copied properties from extended prototypes. 
	 */
	function merge() {
		var i,
			args = arguments,
			len,
			ret = {},
			doCopy = function (copy, original) {
				var value, key;

				// An object is replacing a primitive
				if (typeof copy !== 'object') {
					copy = {};
				}

				for (key in original) {
					if (original.hasOwnProperty(key)) {
						value = original[key];

						// Copy the contents of objects, but not arrays or DOM nodes
						if (value && typeof value === 'object' && Object.prototype.toString.call(value) !== '[object Array]' &&
								key !== 'renderTo' && typeof value.nodeType !== 'number') {
							copy[key] = doCopy(copy[key] || {}, value);
					
						// Primitives and arrays are copied over directly
						} else {
							copy[key] = original[key];
						}
					}
				}
				return copy;
			};

		// If first argument is true, copy into the existing object. Used in setOptions.
		if (args[0] === true) {
			ret = args[1];
			args = Array.prototype.slice.call(args, 2);
		}

		// For each argument, extend the return
		len = args.length;
		for (i = 0; i < len; i++) {
			ret = doCopy(ret, args[i]);
		}

		return ret;
	}

	/**
	 * Shortcut for parseInt
	 * @param {Object} s
	 * @param {Number} mag Magnitude
	 */
	function pInt(s, mag) {
		return parseInt(s, mag || 10);
	}

	/**
	 * Check for string
	 * @param {Object} s
	 */
	function isString(s) {
		return typeof s === 'string';
	}

	/**
	 * Check for object
	 * @param {Object} obj
	 */
	function isObject(obj) {
		return obj && typeof obj === 'object';
	}

	/**
	 * Check for array
	 * @param {Object} obj
	 */
	function isArray(obj) {
		return Object.prototype.toString.call(obj) === '[object Array]';
	}

	/**
	 * Check for number
	 * @param {Object} n
	 */
	function isNumber(n) {
		return typeof n === 'number';
	}

	function log2lin(num) {
		return math.log(num) / math.LN10;
	}
	function lin2log(num) {
		return math.pow(10, num);
	}

	/**
	 * Remove last occurence of an item from an array
	 * @param {Array} arr
	 * @param {Mixed} item
	 */
	function erase(arr, item) {
		var i = arr.length;
		while (i--) {
			if (arr[i] === item) {
				arr.splice(i, 1);
				break;
			}
		}
		//return arr;
	}

	/**
	 * Returns true if the object is not null or undefined. Like MooTools' $.defined.
	 * @param {Object} obj
	 */
	function defined(obj) {
		return obj !== UNDEFINED && obj !== null;
	}

	/**
	 * Set or get an attribute or an object of attributes. Can't use jQuery attr because
	 * it attempts to set expando properties on the SVG element, which is not allowed.
	 *
	 * @param {Object} elem The DOM element to receive the attribute(s)
	 * @param {String|Object} prop The property or an abject of key-value pairs
	 * @param {String} value The value if a single property is set
	 */
	function attr(elem, prop, value) {
		var key,
			ret;

		// if the prop is a string
		if (isString(prop)) {
			// set the value
			if (defined(value)) {
				elem.setAttribute(prop, value);

			// get the value
			} else if (elem && elem.getAttribute) { // elem not defined when printing pie demo...
				ret = elem.getAttribute(prop);
			}

		// else if prop is defined, it is a hash of key/value pairs
		} else if (defined(prop) && isObject(prop)) {
			for (key in prop) {
				elem.setAttribute(key, prop[key]);
			}
		}
		return ret;
	}
	/**
	 * Check if an element is an array, and if not, make it into an array. Like
	 * MooTools' $.splat.
	 */
	function splat(obj) {
		return isArray(obj) ? obj : [obj];
	}


	/**
	 * Return the first value that is defined. Like MooTools' $.pick.
	 */
	var pick = Highcharts.pick = function () {
		var args = arguments,
			i,
			arg,
			length = args.length;
		for (i = 0; i < length; i++) {
			arg = args[i];
			if (arg !== UNDEFINED && arg !== null) {
				return arg;
			}
		}
	};

	/**
	 * Set CSS on a given element
	 * @param {Object} el
	 * @param {Object} styles Style object with camel case property names
	 */
	function css(el, styles) {
		if (isIE && !hasSVG) { // #2686
			if (styles && styles.opacity !== UNDEFINED) {
				styles.filter = 'alpha(opacity=' + (styles.opacity * 100) + ')';
			}
		}
		extend(el.style, styles);
	}

	/**
	 * Utility function to create element with attributes and styles
	 * @param {Object} tag
	 * @param {Object} attribs
	 * @param {Object} styles
	 * @param {Object} parent
	 * @param {Object} nopad
	 */
	function createElement(tag, attribs, styles, parent, nopad) {
		var el = doc.createElement(tag);
		if (attribs) {
			extend(el, attribs);
		}
		if (nopad) {
			css(el, {padding: 0, border: NONE, margin: 0});
		}
		if (styles) {
			css(el, styles);
		}
		if (parent) {
			parent.appendChild(el);
		}
		return el;
	}

	/**
	 * Extend a prototyped class by new members
	 * @param {Object} parent
	 * @param {Object} members
	 */
	function extendClass(parent, members) {
		var object = function () { return UNDEFINED; };
		object.prototype = new parent();
		extend(object.prototype, members);
		return object;
	}

	/**
	 * Pad a string to a given length by adding 0 to the beginning
	 * @param {Number} number
	 * @param {Number} length
	 */
	function pad(number, length) {
		// Create an array of the remaining length +1 and join it with 0's
		return new Array((length || 2) + 1 - String(number).length).join(0) + number;
	}

	/**
	 * Return a length based on either the integer value, or a percentage of a base.
	 */
	function relativeLength (value, base) {
		return (/%$/).test(value) ? base * parseFloat(value) / 100 : parseFloat(value);
	}

	/**
	 * Wrap a method with extended functionality, preserving the original function
	 * @param {Object} obj The context object that the method belongs to 
	 * @param {String} method The name of the method to extend
	 * @param {Function} func A wrapper function callback. This function is called with the same arguments
	 * as the original function, except that the original function is unshifted and passed as the first 
	 * argument. 
	 */
	var wrap = Highcharts.wrap = function (obj, method, func) {
		var proceed = obj[method];
		obj[method] = function () {
			var args = Array.prototype.slice.call(arguments);
			args.unshift(proceed);
			return func.apply(this, args);
		};
	};


	function getTZOffset(timestamp) {
		return ((getTimezoneOffset && getTimezoneOffset(timestamp)) || timezoneOffset || 0) * 60000;
	}

	/**
	 * Based on http://www.php.net/manual/en/function.strftime.php
	 * @param {String} format
	 * @param {Number} timestamp
	 * @param {Boolean} capitalize
	 */
	dateFormat = function (format, timestamp, capitalize) {
		if (!defined(timestamp) || isNaN(timestamp)) {
			return 'Invalid date';
		}
		format = pick(format, '%Y-%m-%d %H:%M:%S');

		var date = new Date(timestamp - getTZOffset(timestamp)),
			key, // used in for constuct below
			// get the basic time values
			hours = date[getHours](),
			day = date[getDay](),
			dayOfMonth = date[getDate](),
			month = date[getMonth](),
			fullYear = date[getFullYear](),
			lang = defaultOptions.lang,
			langWeekdays = lang.weekdays,

			// List all format keys. Custom formats can be added from the outside. 
			replacements = extend({

				// Day
				'a': langWeekdays[day].substr(0, 3), // Short weekday, like 'Mon'
				'A': langWeekdays[day], // Long weekday, like 'Monday'
				'd': pad(dayOfMonth), // Two digit day of the month, 01 to 31
				'e': dayOfMonth, // Day of the month, 1 through 31
				'w': day,

				// Week (none implemented)
				//'W': weekNumber(),

				// Month
				'b': lang.shortMonths[month], // Short month, like 'Jan'
				'B': lang.months[month], // Long month, like 'January'
				'm': pad(month + 1), // Two digit month number, 01 through 12

				// Year
				'y': fullYear.toString().substr(2, 2), // Two digits year, like 09 for 2009
				'Y': fullYear, // Four digits year, like 2009

				// Time
				'H': pad(hours), // Two digits hours in 24h format, 00 through 23
				'I': pad((hours % 12) || 12), // Two digits hours in 12h format, 00 through 11
				'l': (hours % 12) || 12, // Hours in 12h format, 1 through 12
				'M': pad(date[getMinutes]()), // Two digits minutes, 00 through 59
				'p': hours < 12 ? 'AM' : 'PM', // Upper case AM or PM
				'P': hours < 12 ? 'am' : 'pm', // Lower case AM or PM
				'S': pad(date.getSeconds()), // Two digits seconds, 00 through  59
				'L': pad(mathRound(timestamp % 1000), 3) // Milliseconds (naming from Ruby)
			}, Highcharts.dateFormats);


		// do the replaces
		for (key in replacements) {
			while (format.indexOf('%' + key) !== -1) { // regex would do it in one line, but this is faster
				format = format.replace('%' + key, typeof replacements[key] === 'function' ? replacements[key](timestamp) : replacements[key]);
			}
		}

		// Optionally capitalize the string and return
		return capitalize ? format.substr(0, 1).toUpperCase() + format.substr(1) : format;
	};

	/** 
	 * Format a single variable. Similar to sprintf, without the % prefix.
	 */
	function formatSingle(format, val) {
		var floatRegex = /f$/,
			decRegex = /\.([0-9])/,
			lang = defaultOptions.lang,
			decimals;

		if (floatRegex.test(format)) { // float
			decimals = format.match(decRegex);
			decimals = decimals ? decimals[1] : -1;
			if (val !== null) {
				val = Highcharts.numberFormat(
					val,
					decimals,
					lang.decimalPoint,
					format.indexOf(',') > -1 ? lang.thousandsSep : ''
				);
			}
		} else {
			val = dateFormat(format, val);
		}
		return val;
	}

	/**
	 * Format a string according to a subset of the rules of Python's String.format method.
	 */
	function format(str, ctx) {
		var splitter = '{',
			isInside = false,
			segment,
			valueAndFormat,
			path,
			i,
			len,
			ret = [],
			val,
			index;
		
		while ((index = str.indexOf(splitter)) !== -1) {
			
			segment = str.slice(0, index);
			if (isInside) { // we're on the closing bracket looking back
				
				valueAndFormat = segment.split(':');
				path = valueAndFormat.shift().split('.'); // get first and leave format
				len = path.length;
				val = ctx;

				// Assign deeper paths
				for (i = 0; i < len; i++) {
					val = val[path[i]];
				}

				// Format the replacement
				if (valueAndFormat.length) {
					val = formatSingle(valueAndFormat.join(':'), val);
				}

				// Push the result and advance the cursor
				ret.push(val);
				
			} else {
				ret.push(segment);
				
			}
			str = str.slice(index + 1); // the rest
			isInside = !isInside; // toggle
			splitter = isInside ? '}' : '{'; // now look for next matching bracket
		}
		ret.push(str);
		return ret.join('');
	}

	/**
	 * Get the magnitude of a number
	 */
	function getMagnitude(num) {
		return math.pow(10, mathFloor(math.log(num) / math.LN10));
	}

	/**
	 * Take an interval and normalize it to multiples of 1, 2, 2.5 and 5
	 * @param {Number} interval
	 * @param {Array} multiples
	 * @param {Number} magnitude
	 * @param {Object} options
	 */
	function normalizeTickInterval(interval, multiples, magnitude, allowDecimals, preventExceed) {
		var normalized, 
			i,
			retInterval = interval;

		// round to a tenfold of 1, 2, 2.5 or 5
		magnitude = pick(magnitude, 1);
		normalized = interval / magnitude;

		// multiples for a linear scale
		if (!multiples) {
			multiples = [1, 2, 2.5, 5, 10];

			// the allowDecimals option
			if (allowDecimals === false) {
				if (magnitude === 1) {
					multiples = [1, 2, 5, 10];
				} else if (magnitude <= 0.1) {
					multiples = [1 / magnitude];
				}
			}
		}

		// normalize the interval to the nearest multiple
		for (i = 0; i < multiples.length; i++) {
			retInterval = multiples[i];
			if ((preventExceed && retInterval * magnitude >= interval) || // only allow tick amounts smaller than natural
				(!preventExceed && (normalized <= (multiples[i] + (multiples[i + 1] || multiples[i])) / 2))) {
				break;
			}
		}

		// multiply back to the correct magnitude
		retInterval *= magnitude;
		
		return retInterval;
	}


	/**
	 * Utility method that sorts an object array and keeping the order of equal items.
	 * ECMA script standard does not specify the behaviour when items are equal.
	 */
	function stableSort(arr, sortFunction) {
		var length = arr.length,
			sortValue,
			i;

		// Add index to each item
		for (i = 0; i < length; i++) {
			arr[i].ss_i = i; // stable sort index
		}

		arr.sort(function (a, b) {
			sortValue = sortFunction(a, b);
			return sortValue === 0 ? a.ss_i - b.ss_i : sortValue;
		});

		// Remove index from items
		for (i = 0; i < length; i++) {
			delete arr[i].ss_i; // stable sort index
		}
	}

	/**
	 * Non-recursive method to find the lowest member of an array. Math.min raises a maximum
	 * call stack size exceeded error in Chrome when trying to apply more than 150.000 points. This
	 * method is slightly slower, but safe.
	 */
	function arrayMin(data) {
		var i = data.length,
			min = data[0];

		while (i--) {
			if (data[i] < min) {
				min = data[i];
			}
		}
		return min;
	}

	/**
	 * Non-recursive method to find the lowest member of an array. Math.min raises a maximum
	 * call stack size exceeded error in Chrome when trying to apply more than 150.000 points. This
	 * method is slightly slower, but safe.
	 */
	function arrayMax(data) {
		var i = data.length,
			max = data[0];

		while (i--) {
			if (data[i] > max) {
				max = data[i];
			}
		}
		return max;
	}

	/**
	 * Utility method that destroys any SVGElement or VMLElement that are properties on the given object.
	 * It loops all properties and invokes destroy if there is a destroy method. The property is
	 * then delete'ed.
	 * @param {Object} The object to destroy properties on
	 * @param {Object} Exception, do not destroy this property, only delete it.
	 */
	function destroyObjectProperties(obj, except) {
		var n;
		for (n in obj) {
			// If the object is non-null and destroy is defined
			if (obj[n] && obj[n] !== except && obj[n].destroy) {
				// Invoke the destroy
				obj[n].destroy();
			}

			// Delete the property from the object.
			delete obj[n];
		}
	}


	/**
	 * Discard an element by moving it to the bin and delete
	 * @param {Object} The HTML node to discard
	 */
	function discardElement(element) {
		// create a garbage bin element, not part of the DOM
		if (!garbageBin) {
			garbageBin = createElement(DIV);
		}

		// move the node and empty bin
		if (element) {
			garbageBin.appendChild(element);
		}
		garbageBin.innerHTML = '';
	}

	/**
	 * Provide error messages for debugging, with links to online explanation 
	 */
	function error (code, stop) {
		var msg = 'Highcharts error #' + code + ': www.highcharts.com/errors/' + code;
		if (stop) {
			throw msg;
		}
		// else ...
		if (win.console) {
			console.log(msg);
		}
	}

	/**
	 * Fix JS round off float errors
	 * @param {Number} num
	 */
	function correctFloat(num) {
		return parseFloat(
			num.toPrecision(14)
		);
	}

	/**
	 * Set the global animation to either a given value, or fall back to the
	 * given chart's animation option
	 * @param {Object} animation
	 * @param {Object} chart
	 */
	function setAnimation(animation, chart) {
		globalAnimation = pick(animation, chart.animation);
	}

	/**
	 * The time unit lookup
	 */
	timeUnits = {
		millisecond: 1,
		second: 1000,
		minute: 60000,
		hour: 3600000,
		day: 24 * 3600000,
		week: 7 * 24 * 3600000,
		month: 28 * 24 * 3600000,
		year: 364 * 24 * 3600000
	};


	/**
	 * Format a number and return a string based on input settings
	 * @param {Number} number The input number to format
	 * @param {Number} decimals The amount of decimals
	 * @param {String} decPoint The decimal point, defaults to the one given in the lang options
	 * @param {String} thousandsSep The thousands separator, defaults to the one given in the lang options
	 */
	Highcharts.numberFormat = function (number, decimals, decPoint, thousandsSep) {
		var lang = defaultOptions.lang,
			// http://kevin.vanzonneveld.net/techblog/article/javascript_equivalent_for_phps_number_format/
			n = +number || 0,
			c = decimals === -1 ?
				mathMin((n.toString().split('.')[1] || '').length, 20) : // Preserve decimals. Not huge numbers (#3793).
				(isNaN(decimals = mathAbs(decimals)) ? 2 : decimals),
			d = decPoint === undefined ? lang.decimalPoint : decPoint,
			t = thousandsSep === undefined ? lang.thousandsSep : thousandsSep,
			s = n < 0 ? "-" : "",
			i = String(pInt(n = mathAbs(n).toFixed(c))),
			j = i.length > 3 ? i.length % 3 : 0;

		return (s + (j ? i.substr(0, j) + t : "") + i.substr(j).replace(/(\d{3})(?=\d)/g, "$1" + t) +
				(c ? d + mathAbs(n - i).toFixed(c).slice(2) : ""));
	};
	/**
	 * Path interpolation algorithm used across adapters
	 */
	pathAnim = {
		/**
		 * Prepare start and end values so that the path can be animated one to one
		 */
		init: function (elem, fromD, toD) {
			fromD = fromD || '';
			var shift = elem.shift,
				bezier = fromD.indexOf('C') > -1,
				numParams = bezier ? 7 : 3,
				endLength,
				slice,
				i,
				start = fromD.split(' '),
				end = [].concat(toD), // copy
				startBaseLine,
				endBaseLine,
				sixify = function (arr) { // in splines make move points have six parameters like bezier curves
					i = arr.length;
					while (i--) {
						if (arr[i] === M) {
							arr.splice(i + 1, 0, arr[i + 1], arr[i + 2], arr[i + 1], arr[i + 2]);
						}
					}
				};

			if (bezier) {
				sixify(start);
				sixify(end);
			}

			// pull out the base lines before padding
			if (elem.isArea) {
				startBaseLine = start.splice(start.length - 6, 6);
				endBaseLine = end.splice(end.length - 6, 6);
			}

			// if shifting points, prepend a dummy point to the end path
			if (shift <= end.length / numParams && start.length === end.length) {
				while (shift--) {
					end = [].concat(end).splice(0, numParams).concat(end);
				}
			}
			elem.shift = 0; // reset for following animations

			// copy and append last point until the length matches the end length
			if (start.length) {
				endLength = end.length;
				while (start.length < endLength) {

					//bezier && sixify(start);
					slice = [].concat(start).splice(start.length - numParams, numParams);
					if (bezier) { // disable first control point
						slice[numParams - 6] = slice[numParams - 2];
						slice[numParams - 5] = slice[numParams - 1];
					}
					start = start.concat(slice);
				}
			}

			if (startBaseLine) { // append the base lines for areas
				start = start.concat(startBaseLine);
				end = end.concat(endBaseLine);
			}
			return [start, end];
		},

		/**
		 * Interpolate each value of the path and return the array
		 */
		step: function (start, end, pos, complete) {
			var ret = [],
				i = start.length,
				startVal;

			if (pos === 1) { // land on the final path without adjustment points appended in the ends
				ret = complete;

			} else if (i === end.length && pos < 1) {
				while (i--) {
					startVal = parseFloat(start[i]);
					ret[i] =
						isNaN(startVal) ? // a letter instruction like M or L
							start[i] :
							pos * (parseFloat(end[i] - startVal)) + startVal;

				}
			} else { // if animation is finished or length not matching, land on right value
				ret = end;
			}
			return ret;
		}
	};

	(function ($) {
		/**
		 * The default HighchartsAdapter for jQuery
		 */
	 	HighchartsAdapter =  ($ && {
			
			/**
			 * Initialize the adapter by applying some extensions to jQuery
			 */
			init: function (pathAnim) {
				
				// extend the animate function to allow SVG animations
				var Fx = $.fx;
				
				/*jslint unparam: true*//* allow unused param x in this function */
				$.extend($.easing, {
					easeOutQuad: function (x, t, b, c, d) {
						return -c * (t /= d) * (t - 2) + b;
					}
				});
				/*jslint unparam: false*/
			
				// extend some methods to check for elem.attr, which means it is a Highcharts SVG object
				$.each(['cur', '_default', 'width', 'height', 'opacity'], function (i, fn) {
					var obj = Fx.step,
						base;
						
					// Handle different parent objects
					if (fn === 'cur') {
						obj = Fx.prototype; // 'cur', the getter, relates to Fx.prototype
					
					} else if (fn === '_default' && $.Tween) { // jQuery 1.8 model
						obj = $.Tween.propHooks[fn];
						fn = 'set';
					}
			
					// Overwrite the method
					base = obj[fn];
					if (base) { // step.width and step.height don't exist in jQuery < 1.7
			
						// create the extended function replacement
						obj[fn] = function (fx) {

							var elem;
							
							// Fx.prototype.cur does not use fx argument
							fx = i ? fx : this;

							// Don't run animations on textual properties like align (#1821)
							if (fx.prop === 'align') {
								return;
							}
			
							// shortcut
							elem = fx.elem;
			
							// Fx.prototype.cur returns the current value. The other ones are setters
							// and returning a value has no effect.
							return elem.attr ? // is SVG element wrapper
								elem.attr(fx.prop, fn === 'cur' ? UNDEFINED : fx.now) : // apply the SVG wrapper's method
								base.apply(this, arguments); // use jQuery's built-in method
						};
					}
				});

				// Extend the opacity getter, needed for fading opacity with IE9 and jQuery 1.10+
				wrap($.cssHooks.opacity, 'get', function (proceed, elem, computed) {
					return elem.attr ? (elem.opacity || 0) : proceed.call(this, elem, computed);
				});
				
				// Define the setter function for d (path definitions)
				this.addAnimSetter('d', function (fx) {
					var elem = fx.elem,
						ends;
			
					// Normally start and end should be set in state == 0, but sometimes,
					// for reasons unknown, this doesn't happen. Perhaps state == 0 is skipped
					// in these cases
					if (!fx.started) {
						ends = pathAnim.init(elem, elem.d, elem.toD);
						fx.start = ends[0];
						fx.end = ends[1];
						fx.started = true;
					}
			
					// Interpolate each value of the path
					elem.attr('d', pathAnim.step(fx.start, fx.end, fx.pos, elem.toD));
				});
				
				/**
				 * Utility for iterating over an array. Parameters are reversed compared to jQuery.
				 * @param {Array} arr
				 * @param {Function} fn
				 */
				this.each = Array.prototype.forEach ?
					function (arr, fn) { // modern browsers
						return Array.prototype.forEach.call(arr, fn);
						
					} : 
					function (arr, fn) { // legacy
						var i, 
							len = arr.length;
						for (i = 0; i < len; i++) {
							if (fn.call(arr[i], arr[i], i, arr) === false) {
								return i;
							}
						}
					};
			},

			/**
			 * Add an animation setter for a specific property
			 */
			addAnimSetter: function (prop, setter) {
				// jQuery 1.8 style
				if ($.Tween) {
					$.Tween.propHooks[prop] = {
						set: setter
					};
				// pre 1.8
				} else {
					$.fx.step[prop] = setter;
				}
			},
			
			/**
			 * Downloads a script and executes a callback when done.
			 * @param {String} scriptLocation
			 * @param {Function} callback
			 */
			getScript: $.getScript,
			
			/**
			 * Return the index of an item in an array, or -1 if not found
			 */
			inArray: $.inArray,
			
			/**
			 * A direct link to jQuery methods. MooTools and Prototype adapters must be implemented for each case of method.
			 * @param {Object} elem The HTML element
			 * @param {String} method Which method to run on the wrapped element
			 */
			adapterRun: function (elem, method) {
				return $(elem)[method]();
			},
		
			/**
			 * Filter an array
			 */
			grep: $.grep,
		
			/**
			 * Map an array
			 * @param {Array} arr
			 * @param {Function} fn
			 */
			map: function (arr, fn) {
				//return jQuery.map(arr, fn);
				var results = [],
					i = 0,
					len = arr.length;
				for (; i < len; i++) {
					results[i] = fn.call(arr[i], arr[i], i, arr);
				}
				return results;
		
			},
		
			/**
			 * Get the position of an element relative to the top left of the page
			 */
			offset: function (el) {
				return $(el).offset();
			},
		
			/**
			 * Add an event listener
			 * @param {Object} el A HTML element or custom object
			 * @param {String} event The event type
			 * @param {Function} fn The event handler
			 */
			addEvent: function (el, event, fn) {
				$(el).bind(event, fn);
			},
		
			/**
			 * Remove event added with addEvent
			 * @param {Object} el The object
			 * @param {String} eventType The event type. Leave blank to remove all events.
			 * @param {Function} handler The function to remove
			 */
			removeEvent: function (el, eventType, handler) {
				// workaround for jQuery issue with unbinding custom events:
				// http://forum.jQuery.com/topic/javascript-error-when-unbinding-a-custom-event-using-jQuery-1-4-2
				var func = doc.removeEventListener ? 'removeEventListener' : 'detachEvent';
				if (doc[func] && el && !el[func]) {
					el[func] = function () {};
				}
		
				$(el).unbind(eventType, handler);
			},
		
			/**
			 * Fire an event on a custom object
			 * @param {Object} el
			 * @param {String} type
			 * @param {Object} eventArguments
			 * @param {Function} defaultFunction
			 */
			fireEvent: function (el, type, eventArguments, defaultFunction) {
				var event = $.Event(type),
					detachedType = 'detached' + type,
					defaultPrevented;
		
				// Remove warnings in Chrome when accessing returnValue (#2790), layerX and layerY. Although Highcharts
				// never uses these properties, Chrome includes them in the default click event and
				// raises the warning when they are copied over in the extend statement below.
				//
				// To avoid problems in IE (see #1010) where we cannot delete the properties and avoid
				// testing if they are there (warning in chrome) the only option is to test if running IE.
				if (!isIE && eventArguments) {
					delete eventArguments.layerX;
					delete eventArguments.layerY;
					delete eventArguments.returnValue;
				}
		
				extend(event, eventArguments);
		
				// Prevent jQuery from triggering the object method that is named the
				// same as the event. For example, if the event is 'select', jQuery
				// attempts calling el.select and it goes into a loop.
				if (el[type]) {
					el[detachedType] = el[type];
					el[type] = null;
				}
		
				// Wrap preventDefault and stopPropagation in try/catch blocks in
				// order to prevent JS errors when cancelling events on non-DOM
				// objects. #615.
				/*jslint unparam: true*/
				$.each(['preventDefault', 'stopPropagation'], function (i, fn) {
					var base = event[fn];
					event[fn] = function () {
						try {
							base.call(event);
						} catch (e) {
							if (fn === 'preventDefault') {
								defaultPrevented = true;
							}
						}
					};
				});
				/*jslint unparam: false*/
		
				// trigger it
				$(el).trigger(event);
		
				// attach the method
				if (el[detachedType]) {
					el[type] = el[detachedType];
					el[detachedType] = null;
				}
		
				if (defaultFunction && !event.isDefaultPrevented() && !defaultPrevented) {
					defaultFunction(event);
				}
			},
			
			/**
			 * Extension method needed for MooTools
			 */
			washMouseEvent: function (e) {
				var ret = e.originalEvent || e;
				
				// computed by jQuery, needed by IE8
				if (ret.pageX === UNDEFINED) { // #1236
					ret.pageX = e.pageX;
					ret.pageY = e.pageY;
				}
				
				return ret;
			},
		
			/**
			 * Animate a HTML element or SVG element wrapper
			 * @param {Object} el
			 * @param {Object} params
			 * @param {Object} options jQuery-like animation options: duration, easing, callback
			 */
			animate: function (el, params, options) {
				var $el = $(el);
				if (!el.style) {
					el.style = {}; // #1881
				}
				if (params.d) {
					el.toD = params.d; // keep the array form for paths, used in $.fx.step.d
					params.d = 1; // because in jQuery, animating to an array has a different meaning
				}
		
				$el.stop();
				if (params.opacity !== UNDEFINED && el.attr) {
					params.opacity += 'px'; // force jQuery to use same logic as width and height (#2161)
				}
				el.hasAnim = 1; // #3342
				$el.animate(params, options);
		
			},
			/**
			 * Stop running animation
			 */
			stop: function (el) {
				if (el.hasAnim) { // #3342, memory leak on calling $(el) from destroy
					$(el).stop();
				}
			}
		});
	}(jquery));


	// check for a custom HighchartsAdapter defined prior to this file
	var globalAdapter = HighchartsAdapter,
		adapter = globalAdapter || {};
		
	// Initialize the adapter
	if (globalAdapter) {
		globalAdapter.init.call(globalAdapter, pathAnim);
	}


	// Utility functions. If the HighchartsAdapter is not defined, adapter is an empty object
	// and all the utility functions will be null. In that case they are populated by the
	// default adapters below.
	var adapterRun = adapter.adapterRun,
		getScript = adapter.getScript,
		inArray = adapter.inArray,
		each = Highcharts.each = adapter.each,
		grep = adapter.grep,
		offset = adapter.offset,
		map = adapter.map,
		addEvent = adapter.addEvent,
		removeEvent = adapter.removeEvent,
		fireEvent = adapter.fireEvent,
		washMouseEvent = adapter.washMouseEvent,
		animate = adapter.animate,
		stop = adapter.stop;



	/* ****************************************************************************
	 * Handle the options                                                         *
	 *****************************************************************************/
	defaultOptions = {
		colors: ['#7cb5ec', '#434348', '#90ed7d', '#f7a35c', 
			    '#8085e9', '#f15c80', '#e4d354', '#2b908f', '#f45b5b', '#91e8e1'],
		symbols: ['circle', 'diamond', 'square', 'triangle', 'triangle-down'],
		lang: {
			loading: 'Loading...',
			months: ['January', 'February', 'March', 'April', 'May', 'June', 'July',
					'August', 'September', 'October', 'November', 'December'],
			shortMonths: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
			weekdays: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
			decimalPoint: '.',
			numericSymbols: ['k', 'M', 'G', 'T', 'P', 'E'], // SI prefixes used in axis labels
			resetZoom: 'Reset zoom',
			resetZoomTitle: 'Reset zoom level 1:1',
			thousandsSep: ' '
		},
		global: {
			useUTC: true,
			//timezoneOffset: 0,
			canvasToolsURL: 'http://code.highcharts.com/4.1.7/modules/canvas-tools.js',
			VMLRadialGradientURL: 'http://code.highcharts.com/4.1.7/gfx/vml-radial-gradient.png'
		},
		chart: {
			//animation: true,
			//alignTicks: false,
			//reflow: true,
			//className: null,
			//events: { load, selection },
			//margin: [null],
			//marginTop: null,
			//marginRight: null,
			//marginBottom: null,
			//marginLeft: null,
			borderColor: '#4572A7',
			//borderWidth: 0,
			borderRadius: 0,
			defaultSeriesType: 'line',
			ignoreHiddenSeries: true,
			//inverted: false,
			//shadow: false,
			spacing: [10, 10, 15, 10],
			//spacingTop: 10,
			//spacingRight: 10,
			//spacingBottom: 15,
			//spacingLeft: 10,
			//style: {
			//	fontFamily: '"Lucida Grande", "Lucida Sans Unicode", Verdana, Arial, Helvetica, sans-serif', // default font
			//	fontSize: '12px'
			//},
			backgroundColor: '#FFFFFF',
			//plotBackgroundColor: null,
			plotBorderColor: '#C0C0C0',
			//plotBorderWidth: 0,
			//plotShadow: false,
			//zoomType: ''
			resetZoomButton: {
				theme: {
					zIndex: 20
				},
				position: {
					align: 'right',
					x: -10,
					//verticalAlign: 'top',
					y: 10
				}
				// relativeTo: 'plot'
			}
		},
		title: {
			text: 'Chart title',
			align: 'center',
			// floating: false,
			margin: 15,
			// x: 0,
			// verticalAlign: 'top',
			// y: null,
			style: {
				color: '#333333',
				fontSize: '18px'
			}

		},
		subtitle: {
			text: '',
			align: 'center',
			// floating: false
			// x: 0,
			// verticalAlign: 'top',
			// y: null,
			style: {
				color: '#555555'
			}
		},

		plotOptions: {
			line: { // base series options
				allowPointSelect: false,
				showCheckbox: false,
				animation: {
					duration: 1000
				},
				//connectNulls: false,
				//cursor: 'default',
				//clip: true,
				//dashStyle: null,
				//enableMouseTracking: true,
				events: {},
				//legendIndex: 0,
				//linecap: 'round',
				lineWidth: 2,
				//shadow: false,
				// stacking: null,
				marker: {
					//enabled: true,
					//symbol: null,
					lineWidth: 0,
					radius: 4,
					lineColor: '#FFFFFF',
					//fillColor: null,
					states: { // states for a single point
						hover: {
							enabled: true,
							lineWidthPlus: 1,
							radiusPlus: 2
						},
						select: {
							fillColor: '#FFFFFF',
							lineColor: '#000000',
							lineWidth: 2
						}
					}
				},
				point: {
					events: {}
				},
				dataLabels: {
					align: 'center',
					// defer: true,
					// enabled: false,
					formatter: function () {
						return this.y === null ? '' : Highcharts.numberFormat(this.y, -1);
					},
					style: {
						color: 'contrast',
						fontSize: '11px',
						fontWeight: 'bold',
						textShadow: '0 0 6px contrast, 0 0 3px contrast'
					},
					verticalAlign: 'bottom', // above singular point
					x: 0,
					y: 0,
					// backgroundColor: undefined,
					// borderColor: undefined,
					// borderRadius: undefined,
					// borderWidth: undefined,
					padding: 5
					// shadow: false
				},
				cropThreshold: 300, // draw points outside the plot area when the number of points is less than this
				pointRange: 0,
				//pointStart: 0,
				//pointInterval: 1,
				//showInLegend: null, // auto: true for standalone series, false for linked series
				states: { // states for the entire series
					hover: {
						//enabled: false,
						lineWidthPlus: 1,
						marker: {
							// lineWidth: base + 1,
							// radius: base + 1
						},
						halo: {
							size: 10,
							opacity: 0.25
						}
					},
					select: {
						marker: {}
					}
				},
				stickyTracking: true,
				//tooltip: {
					//pointFormat: '<span style="color:{point.color}">\u25CF</span> {series.name}: <b>{point.y}</b>'
					//valueDecimals: null,
					//xDateFormat: '%A, %b %e, %Y',
					//valuePrefix: '',
					//ySuffix: ''				
				//}
				turboThreshold: 1000
				// zIndex: null
			}
		},
		labels: {
			//items: [],
			style: {
				//font: defaultFont,
				position: ABSOLUTE,
				color: '#3E576F'
			}
		},
		legend: {
			enabled: true,
			align: 'center',
			//floating: false,
			layout: 'horizontal',
			labelFormatter: function () {
				return this.name;
			},
			//borderWidth: 0,
			borderColor: '#909090',
			borderRadius: 0,
			navigation: {
				// animation: true,
				activeColor: '#274b6d',
				// arrowSize: 12
				inactiveColor: '#CCC'
				// style: {} // text styles
			},
			// margin: 20,
			// reversed: false,
			shadow: false,
			// backgroundColor: null,
			/*style: {
				padding: '5px'
			},*/
			itemStyle: {			
				color: '#333333',
				fontSize: '12px',
				fontWeight: 'bold'
			},
			itemHoverStyle: {
				//cursor: 'pointer', removed as of #601
				color: '#000'
			},
			itemHiddenStyle: {
				color: '#CCC'
			},
			itemCheckboxStyle: {
				position: ABSOLUTE,
				width: '13px', // for IE precision
				height: '13px'
			},
			// itemWidth: undefined,
			// symbolRadius: 0,
			// symbolWidth: 16,
			symbolPadding: 5,
			verticalAlign: 'bottom',
			// width: undefined,
			x: 0,
			y: 0,
			title: {
				//text: null,
				style: {
					fontWeight: 'bold'
				}
			}			
		},

		loading: {
			// hideDuration: 100,
			labelStyle: {
				fontWeight: 'bold',
				position: RELATIVE,
				top: '45%'
			},
			// showDuration: 0,
			style: {
				position: ABSOLUTE,
				backgroundColor: 'white',
				opacity: 0.5,
				textAlign: 'center'
			}
		},

		tooltip: {
			enabled: true,
			animation: hasSVG,
			//crosshairs: null,
			backgroundColor: 'rgba(249, 249, 249, .85)',
			borderWidth: 1,
			borderRadius: 3,
			dateTimeLabelFormats: { 
				millisecond: '%A, %b %e, %H:%M:%S.%L',
				second: '%A, %b %e, %H:%M:%S',
				minute: '%A, %b %e, %H:%M',
				hour: '%A, %b %e, %H:%M',
				day: '%A, %b %e, %Y',
				week: 'Week from %A, %b %e, %Y',
				month: '%B %Y',
				year: '%Y'
			},
			footerFormat: '',
			//formatter: defaultFormatter,
			headerFormat: '<span style="font-size: 10px">{point.key}</span><br/>',
			pointFormat: '<span style="color:{point.color}">\u25CF</span> {series.name}: <b>{point.y}</b><br/>',
			shadow: true,
			//shape: 'callout',
			//shared: false,
			snap: isTouchDevice ? 25 : 10,
			style: {
				color: '#333333',
				cursor: 'default',
				fontSize: '12px',
				padding: '8px',
				whiteSpace: 'nowrap'
			}
			//xDateFormat: '%A, %b %e, %Y',
			//valueDecimals: null,
			//valuePrefix: '',
			//valueSuffix: ''
		},

		credits: {
			enabled: true,
			text: 'Highcharts.com',
			href: 'http://www.highcharts.com',
			position: {
				align: 'right',
				x: -10,
				verticalAlign: 'bottom',
				y: -5
			},
			style: {
				cursor: 'pointer',
				color: '#909090',
				fontSize: '9px'
			}
		}
	};




	// Series defaults
	var defaultPlotOptions = defaultOptions.plotOptions,
		defaultSeriesOptions = defaultPlotOptions.line;

	// set the default time methods
	setTimeMethods();



	/**
	 * Set the time methods globally based on the useUTC option. Time method can be either
	 * local time or UTC (default).
	 */
	function setTimeMethods() {
		var globalOptions = defaultOptions.global,
			useUTC = globalOptions.useUTC,
			GET = useUTC ? 'getUTC' : 'get',
			SET = useUTC ? 'setUTC' : 'set';


		Date = globalOptions.Date || window.Date;
		timezoneOffset = useUTC && globalOptions.timezoneOffset;
		getTimezoneOffset = useUTC && globalOptions.getTimezoneOffset;
		makeTime = function (year, month, date, hours, minutes, seconds) {
			var d;
			if (useUTC) {
				d = Date.UTC.apply(0, arguments);
				d += getTZOffset(d);
			} else {
				d = new Date(
					year,
					month,
					pick(date, 1),
					pick(hours, 0),
					pick(minutes, 0),
					pick(seconds, 0)
				).getTime();
			}
			return d;
		};
		getMinutes =      GET + 'Minutes';
		getHours =        GET + 'Hours';
		getDay =          GET + 'Day';
		getDate =         GET + 'Date';
		getMonth =        GET + 'Month';
		getFullYear =     GET + 'FullYear';
		setMilliseconds = SET + 'Milliseconds';
		setSeconds =      SET + 'Seconds';
		setMinutes =      SET + 'Minutes';
		setHours =        SET + 'Hours';
		setDate =         SET + 'Date';
		setMonth =        SET + 'Month';
		setFullYear =     SET + 'FullYear';

	}

	/**
	 * Merge the default options with custom options and return the new options structure
	 * @param {Object} options The new custom options
	 */
	function setOptions(options) {
		
		// Copy in the default options
		defaultOptions = merge(true, defaultOptions, options);
		
		// Apply UTC
		setTimeMethods();

		return defaultOptions;
	}

	/**
	 * Get the updated default options. Until 3.0.7, merely exposing defaultOptions for outside modules
	 * wasn't enough because the setOptions method created a new object.
	 */
	function getOptions() {
		return defaultOptions;
	}


	/**
	 * Handle color operations. The object methods are chainable.
	 * @param {String} input The input color in either rbga or hex format
	 */
	var rgbaRegEx = /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/,
		hexRegEx = /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/,
		rgbRegEx = /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/;

	var Color = function (input) {
		// declare variables
		var rgba = [], result, stops;

		/**
		 * Parse the input color to rgba array
		 * @param {String} input
		 */
		function init(input) {

			// Gradients
			if (input && input.stops) {
				stops = map(input.stops, function (stop) {
					return Color(stop[1]);
				});

			// Solid colors
			} else {
				// rgba
				result = rgbaRegEx.exec(input);
				if (result) {
					rgba = [pInt(result[1]), pInt(result[2]), pInt(result[3]), parseFloat(result[4], 10)];
				} else { 
					// hex
					result = hexRegEx.exec(input);
					if (result) {
						rgba = [pInt(result[1], 16), pInt(result[2], 16), pInt(result[3], 16), 1];
					} else {
						// rgb
						result = rgbRegEx.exec(input);
						if (result) {
							rgba = [pInt(result[1]), pInt(result[2]), pInt(result[3]), 1];
						}
					}
				}
			}		

		}
		/**
		 * Return the color a specified format
		 * @param {String} format
		 */
		function get(format) {
			var ret;

			if (stops) {
				ret = merge(input);
				ret.stops = [].concat(ret.stops);
				each(stops, function (stop, i) {
					ret.stops[i] = [ret.stops[i][0], stop.get(format)];
				});

			// it's NaN if gradient colors on a column chart
			} else if (rgba && !isNaN(rgba[0])) {
				if (format === 'rgb') {
					ret = 'rgb(' + rgba[0] + ',' + rgba[1] + ',' + rgba[2] + ')';
				} else if (format === 'a') {
					ret = rgba[3];
				} else {
					ret = 'rgba(' + rgba.join(',') + ')';
				}
			} else {
				ret = input;
			}
			return ret;
		}

		/**
		 * Brighten the color
		 * @param {Number} alpha
		 */
		function brighten(alpha) {
			if (stops) {
				each(stops, function (stop) {
					stop.brighten(alpha);
				});
			
			} else if (isNumber(alpha) && alpha !== 0) {
				var i;
				for (i = 0; i < 3; i++) {
					rgba[i] += pInt(alpha * 255);

					if (rgba[i] < 0) {
						rgba[i] = 0;
					}
					if (rgba[i] > 255) {
						rgba[i] = 255;
					}
				}
			}
			return this;
		}
		/**
		 * Set the color's opacity to a given alpha value
		 * @param {Number} alpha
		 */
		function setOpacity(alpha) {
			rgba[3] = alpha;
			return this;
		}

		// initialize: parse the input
		init(input);

		// public methods
		return {
			get: get,
			brighten: brighten,
			rgba: rgba,
			setOpacity: setOpacity,
			raw: input
		};
	};


	/**
	 * A wrapper object for SVG elements
	 */
	function SVGElement() {}

	SVGElement.prototype = {
		
		// Default base for animation
		opacity: 1,
		// For labels, these CSS properties are applied to the <text> node directly
		textProps: ['fontSize', 'fontWeight', 'fontFamily', 'fontStyle', 'color', 
			'lineHeight', 'width', 'textDecoration', 'textShadow'],
		
		/**
		 * Initialize the SVG renderer
		 * @param {Object} renderer
		 * @param {String} nodeName
		 */
		init: function (renderer, nodeName) {
			var wrapper = this;
			wrapper.element = nodeName === 'span' ?
				createElement(nodeName) :
				doc.createElementNS(SVG_NS, nodeName);
			wrapper.renderer = renderer;
		},
		
		/**
		 * Animate a given attribute
		 * @param {Object} params
		 * @param {Number} options The same options as in jQuery animation
		 * @param {Function} complete Function to perform at the end of animation
		 */
		animate: function (params, options, complete) {
			var animOptions = pick(options, globalAnimation, true);
			stop(this); // stop regardless of animation actually running, or reverting to .attr (#607)
			if (animOptions) {
				animOptions = merge(animOptions, {}); //#2625
				if (complete) { // allows using a callback with the global animation without overwriting it
					animOptions.complete = complete;
				}
				animate(this, params, animOptions);
			} else {
				this.attr(params);
				if (complete) {
					complete();
				}
			}
			return this;
		},

		/**
		 * Build an SVG gradient out of a common JavaScript configuration object
		 */
		colorGradient: function (color, prop, elem) {
			var renderer = this.renderer,
				colorObject,
				gradName,
				gradAttr,
				gradients,
				gradientObject,
				stops,
				stopColor,
				stopOpacity,
				radialReference,
				n,
				id,
				key = [];

			// Apply linear or radial gradients
			if (color.linearGradient) {
				gradName = 'linearGradient';
			} else if (color.radialGradient) {
				gradName = 'radialGradient';
			}

			if (gradName) {
				gradAttr = color[gradName];
				gradients = renderer.gradients;
				stops = color.stops;
				radialReference = elem.radialReference;

				// Keep < 2.2 kompatibility
				if (isArray(gradAttr)) {
					color[gradName] = gradAttr = {
						x1: gradAttr[0],
						y1: gradAttr[1],
						x2: gradAttr[2],
						y2: gradAttr[3],
						gradientUnits: 'userSpaceOnUse'
					};
				}

				// Correct the radial gradient for the radial reference system
				if (gradName === 'radialGradient' && radialReference && !defined(gradAttr.gradientUnits)) {
					gradAttr = merge(gradAttr, {
						cx: (radialReference[0] - radialReference[2] / 2) + gradAttr.cx * radialReference[2],
						cy: (radialReference[1] - radialReference[2] / 2) + gradAttr.cy * radialReference[2],
						r: gradAttr.r * radialReference[2],
						gradientUnits: 'userSpaceOnUse'
					});
				}

				// Build the unique key to detect whether we need to create a new element (#1282)
				for (n in gradAttr) {
					if (n !== 'id') {
						key.push(n, gradAttr[n]);
					}
				}
				for (n in stops) {
					key.push(stops[n]);
				}
				key = key.join(',');

				// Check if a gradient object with the same config object is created within this renderer
				if (gradients[key]) {
					id = gradients[key].attr('id');

				} else {

					// Set the id and create the element
					gradAttr.id = id = PREFIX + idCounter++;
					gradients[key] = gradientObject = renderer.createElement(gradName)
						.attr(gradAttr)
						.add(renderer.defs);


					// The gradient needs to keep a list of stops to be able to destroy them
					gradientObject.stops = [];
					each(stops, function (stop) {
						var stopObject;
						if (stop[1].indexOf('rgba') === 0) {
							colorObject = Color(stop[1]);
							stopColor = colorObject.get('rgb');
							stopOpacity = colorObject.get('a');
						} else {
							stopColor = stop[1];
							stopOpacity = 1;
						}
						stopObject = renderer.createElement('stop').attr({
							offset: stop[0],
							'stop-color': stopColor,
							'stop-opacity': stopOpacity
						}).add(gradientObject);

						// Add the stop element to the gradient
						gradientObject.stops.push(stopObject);
					});
				}

				// Set the reference to the gradient object
				elem.setAttribute(prop, 'url(' + renderer.url + '#' + id + ')');
			} 
		},

		/**
		 * Apply a polyfill to the text-stroke CSS property, by copying the text element
		 * and apply strokes to the copy.
		 *
		 * docs: update default, document the polyfill and the limitations on hex colors and pixel values, document contrast pseudo-color
		 * TODO: 
		 * - update defaults
		 */
		applyTextShadow: function (textShadow) {
			var elem = this.element,
				tspans,
				hasContrast = textShadow.indexOf('contrast') !== -1,
				styles = {},
				// IE10 and IE11 report textShadow in elem.style even though it doesn't work. Check
				// this again with new IE release. In exports, the rendering is passed to PhantomJS. 
				supports = this.renderer.forExport || (elem.style.textShadow !== UNDEFINED && !isIE);

			// When the text shadow is set to contrast, use dark stroke for light text and vice versa
			if (hasContrast) {
				styles.textShadow = textShadow = textShadow.replace(/contrast/g, this.renderer.getContrast(elem.style.fill));
			}

			// Safari with retina displays as well as PhantomJS bug (#3974). Firefox does not tolerate this,
			// it removes the text shadows.
			if (isWebKit) {
				styles.textRendering = 'geometricPrecision';
			}

			/* Selective side-by-side testing in supported browser (http://jsfiddle.net/highcharts/73L1ptrh/)
			if (elem.textContent.indexOf('2.') === 0) {
				elem.style['text-shadow'] = 'none';
				supports = false;
			}
			// */

			// No reason to polyfill, we've got native support
			if (supports) {
				css(elem, styles); // Apply altered textShadow or textRendering workaround
			} else {

				this.fakeTS = true; // Fake text shadow

				// In order to get the right y position of the clones, 
				// copy over the y setter
				this.ySetter = this.xSetter;

				tspans = [].slice.call(elem.getElementsByTagName('tspan'));
				each(textShadow.split(/\s?,\s?/g), function (textShadow) {
					var firstChild = elem.firstChild,
						color,
						strokeWidth;
					
					textShadow = textShadow.split(' ');
					color = textShadow[textShadow.length - 1];

					// Approximately tune the settings to the text-shadow behaviour
					strokeWidth = textShadow[textShadow.length - 2];

					if (strokeWidth) {
						each(tspans, function (tspan, y) {
							var clone;

							// Let the first line start at the correct X position
							if (y === 0) {
								tspan.setAttribute('x', elem.getAttribute('x'));
								y = elem.getAttribute('y');
								tspan.setAttribute('y', y || 0);
								if (y === null) {
									elem.setAttribute('y', 0);
								}
							}

							// Create the clone and apply shadow properties
							clone = tspan.cloneNode(1);
							attr(clone, {
								'class': PREFIX + 'text-shadow',
								'fill': color,
								'stroke': color,
								'stroke-opacity': 1 / mathMax(pInt(strokeWidth), 3),
								'stroke-width': strokeWidth,
								'stroke-linejoin': 'round'
							});
							elem.insertBefore(clone, firstChild);
						});
					}
				});
			}
		},

		/**
		 * Set or get a given attribute
		 * @param {Object|String} hash
		 * @param {Mixed|Undefined} val
		 */
		attr: function (hash, val) {
			var key,
				value,
				element = this.element,
				hasSetSymbolSize,
				ret = this,
				skipAttr;

			// single key-value pair
			if (typeof hash === 'string' && val !== UNDEFINED) {
				key = hash;
				hash = {};
				hash[key] = val;
			}

			// used as a getter: first argument is a string, second is undefined
			if (typeof hash === 'string') {
				ret = (this[hash + 'Getter'] || this._defaultGetter).call(this, hash, element);
			
			// setter
			} else {

				for (key in hash) {
					value = hash[key];
					skipAttr = false;



					if (this.symbolName && /^(x|y|width|height|r|start|end|innerR|anchorX|anchorY)/.test(key)) {
						if (!hasSetSymbolSize) {
							this.symbolAttr(hash);
							hasSetSymbolSize = true;
						}
						skipAttr = true;
					}

					if (this.rotation && (key === 'x' || key === 'y')) {
						this.doTransform = true;
					}
					
					if (!skipAttr) {
						(this[key + 'Setter'] || this._defaultSetter).call(this, value, key, element);
					}

					// Let the shadow follow the main element
					if (this.shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(key)) {
						this.updateShadows(key, value);
					}
				}

				// Update transform. Do this outside the loop to prevent redundant updating for batch setting
				// of attributes.
				if (this.doTransform) {
					this.updateTransform();
					this.doTransform = false;
				}

			}

			return ret;
		},

		updateShadows: function (key, value) {
			var shadows = this.shadows,
				i = shadows.length;
			while (i--) {
				shadows[i].setAttribute(
					key,
					key === 'height' ?
						mathMax(value - (shadows[i].cutHeight || 0), 0) :
						key === 'd' ? this.d : value
				);
			}
		},

		/**
		 * Add a class name to an element
		 */
		addClass: function (className) {
			var element = this.element,
				currentClassName = attr(element, 'class') || '';

			if (currentClassName.indexOf(className) === -1) {
				attr(element, 'class', currentClassName + ' ' + className);
			}
			return this;
		},
		/* hasClass and removeClass are not (yet) needed
		hasClass: function (className) {
			return attr(this.element, 'class').indexOf(className) !== -1;
		},
		removeClass: function (className) {
			attr(this.element, 'class', attr(this.element, 'class').replace(className, ''));
			return this;
		},
		*/

		/**
		 * If one of the symbol size affecting parameters are changed,
		 * check all the others only once for each call to an element's
		 * .attr() method
		 * @param {Object} hash
		 */
		symbolAttr: function (hash) {
			var wrapper = this;

			each(['x', 'y', 'r', 'start', 'end', 'width', 'height', 'innerR', 'anchorX', 'anchorY'], function (key) {
				wrapper[key] = pick(hash[key], wrapper[key]);
			});

			wrapper.attr({
				d: wrapper.renderer.symbols[wrapper.symbolName](
					wrapper.x,
					wrapper.y,
					wrapper.width,
					wrapper.height,
					wrapper
				)
			});
		},

		/**
		 * Apply a clipping path to this object
		 * @param {String} id
		 */
		clip: function (clipRect) {
			return this.attr('clip-path', clipRect ? 'url(' + this.renderer.url + '#' + clipRect.id + ')' : NONE);
		},

		/**
		 * Calculate the coordinates needed for drawing a rectangle crisply and return the
		 * calculated attributes
		 * @param {Number} strokeWidth
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Number} width
		 * @param {Number} height
		 */
		crisp: function (rect) {

			var wrapper = this,
				key,
				attribs = {},
				normalizer,
				strokeWidth = rect.strokeWidth || wrapper.strokeWidth || 0;

			normalizer = mathRound(strokeWidth) % 2 / 2; // mathRound because strokeWidth can sometimes have roundoff errors

			// normalize for crisp edges
			rect.x = mathFloor(rect.x || wrapper.x || 0) + normalizer;
			rect.y = mathFloor(rect.y || wrapper.y || 0) + normalizer;
			rect.width = mathFloor((rect.width || wrapper.width || 0) - 2 * normalizer);
			rect.height = mathFloor((rect.height || wrapper.height || 0) - 2 * normalizer);
			rect.strokeWidth = strokeWidth;

			for (key in rect) {
				if (wrapper[key] !== rect[key]) { // only set attribute if changed
					wrapper[key] = attribs[key] = rect[key];
				}
			}

			return attribs;
		},

		/**
		 * Set styles for the element
		 * @param {Object} styles
		 */
		css: function (styles) {
			var elemWrapper = this,
				oldStyles = elemWrapper.styles,
				newStyles = {},
				elem = elemWrapper.element,
				textWidth,
				n,
				serializedCss = '',
				hyphenate,
				hasNew = !oldStyles;

			// convert legacy
			if (styles && styles.color) {
				styles.fill = styles.color;
			}

			// Filter out existing styles to increase performance (#2640)
			if (oldStyles) {
				for (n in styles) {
					if (styles[n] !== oldStyles[n]) {
						newStyles[n] = styles[n];
						hasNew = true;
					}
				}
			}
			if (hasNew) {
				textWidth = elemWrapper.textWidth = 
					(styles && styles.width && elem.nodeName.toLowerCase() === 'text' && pInt(styles.width)) || 
					elemWrapper.textWidth; // #3501

				// Merge the new styles with the old ones
				if (oldStyles) {
					styles = extend(
						oldStyles,
						newStyles
					);
				}		

				// store object
				elemWrapper.styles = styles;

				if (textWidth && (useCanVG || (!hasSVG && elemWrapper.renderer.forExport))) {
					delete styles.width;
				}

				// serialize and set style attribute
				if (isIE && !hasSVG) {
					css(elemWrapper.element, styles);
				} else {
					/*jslint unparam: true*/
					hyphenate = function (a, b) { return '-' + b.toLowerCase(); };
					/*jslint unparam: false*/
					for (n in styles) {
						serializedCss += n.replace(/([A-Z])/g, hyphenate) + ':' + styles[n] + ';';
					}
					attr(elem, 'style', serializedCss); // #1881
				}


				// re-build text
				if (textWidth && elemWrapper.added) {
					elemWrapper.renderer.buildText(elemWrapper);
				}
			}

			return elemWrapper;
		},

		/**
		 * Add an event listener
		 * @param {String} eventType
		 * @param {Function} handler
		 */
		on: function (eventType, handler) {
			var svgElement = this,
				element = svgElement.element;
			
			// touch
			if (hasTouch && eventType === 'click') {
				element.ontouchstart = function (e) {			
					svgElement.touchEventFired = Date.now();				
					e.preventDefault();
					handler.call(element, e);
				};
				element.onclick = function (e) {												
					if (userAgent.indexOf('Android') === -1 || Date.now() - (svgElement.touchEventFired || 0) > 1100) { // #2269
						handler.call(element, e);
					}
				};			
			} else {
				// simplest possible event model for internal use
				element['on' + eventType] = handler;
			}
			return this;
		},

		/**
		 * Set the coordinates needed to draw a consistent radial gradient across
		 * pie slices regardless of positioning inside the chart. The format is
		 * [centerX, centerY, diameter] in pixels.
		 */
		setRadialReference: function (coordinates) {
			this.element.radialReference = coordinates;
			return this;
		},

		/**
		 * Move an object and its children by x and y values
		 * @param {Number} x
		 * @param {Number} y
		 */
		translate: function (x, y) {
			return this.attr({
				translateX: x,
				translateY: y
			});
		},

		/**
		 * Invert a group, rotate and flip
		 */
		invert: function () {
			var wrapper = this;
			wrapper.inverted = true;
			wrapper.updateTransform();
			return wrapper;
		},

		/**
		 * Private method to update the transform attribute based on internal
		 * properties
		 */
		updateTransform: function () {
			var wrapper = this,
				translateX = wrapper.translateX || 0,
				translateY = wrapper.translateY || 0,
				scaleX = wrapper.scaleX,
				scaleY = wrapper.scaleY,
				inverted = wrapper.inverted,
				rotation = wrapper.rotation,
				element = wrapper.element,
				transform;

			// flipping affects translate as adjustment for flipping around the group's axis
			if (inverted) {
				translateX += wrapper.attr('width');
				translateY += wrapper.attr('height');
			}

			// Apply translate. Nearly all transformed elements have translation, so instead
			// of checking for translate = 0, do it always (#1767, #1846).
			transform = ['translate(' + translateX + ',' + translateY + ')'];

			// apply rotation
			if (inverted) {
				transform.push('rotate(90) scale(-1,1)');
			} else if (rotation) { // text rotation
				transform.push('rotate(' + rotation + ' ' + (element.getAttribute('x') || 0) + ' ' + (element.getAttribute('y') || 0) + ')');
				
				// Delete bBox memo when the rotation changes
				//delete wrapper.bBox;
			}

			// apply scale
			if (defined(scaleX) || defined(scaleY)) {
				transform.push('scale(' + pick(scaleX, 1) + ' ' + pick(scaleY, 1) + ')');
			}

			if (transform.length) {
				element.setAttribute('transform', transform.join(' '));
			}
		},
		/**
		 * Bring the element to the front
		 */
		toFront: function () {
			var element = this.element;
			element.parentNode.appendChild(element);
			return this;
		},


		/**
		 * Break down alignment options like align, verticalAlign, x and y
		 * to x and y relative to the chart.
		 *
		 * @param {Object} alignOptions
		 * @param {Boolean} alignByTranslate
		 * @param {String[Object} box The box to align to, needs a width and height. When the
		 *		box is a string, it refers to an object in the Renderer. For example, when
		 *		box is 'spacingBox', it refers to Renderer.spacingBox which holds width, height
		 *		x and y properties.
		 *
		 */
		align: function (alignOptions, alignByTranslate, box) {
			var align,
				vAlign,
				x,
				y,
				attribs = {},
				alignTo,
				renderer = this.renderer,
				alignedObjects = renderer.alignedObjects;

			// First call on instanciate
			if (alignOptions) {
				this.alignOptions = alignOptions;
				this.alignByTranslate = alignByTranslate;
				if (!box || isString(box)) { // boxes other than renderer handle this internally
					this.alignTo = alignTo = box || 'renderer';
					erase(alignedObjects, this); // prevent duplicates, like legendGroup after resize
					alignedObjects.push(this);
					box = null; // reassign it below
				}

			// When called on resize, no arguments are supplied
			} else {
				alignOptions = this.alignOptions;
				alignByTranslate = this.alignByTranslate;
				alignTo = this.alignTo;
			}

			box = pick(box, renderer[alignTo], renderer);

			// Assign variables
			align = alignOptions.align;
			vAlign = alignOptions.verticalAlign;
			x = (box.x || 0) + (alignOptions.x || 0); // default: left align
			y = (box.y || 0) + (alignOptions.y || 0); // default: top align

			// Align
			if (align === 'right' || align === 'center') {
				x += (box.width - (alignOptions.width || 0)) /
						{ right: 1, center: 2 }[align];
			}
			attribs[alignByTranslate ? 'translateX' : 'x'] = mathRound(x);


			// Vertical align
			if (vAlign === 'bottom' || vAlign === 'middle') {
				y += (box.height - (alignOptions.height || 0)) /
						({ bottom: 1, middle: 2 }[vAlign] || 1);

			}
			attribs[alignByTranslate ? 'translateY' : 'y'] = mathRound(y);

			// Animate only if already placed
			this[this.placed ? 'animate' : 'attr'](attribs);
			this.placed = true;
			this.alignAttr = attribs;

			return this;
		},

		/**
		 * Get the bounding box (width, height, x and y) for the element
		 */
		getBBox: function (reload) {
			var wrapper = this,
				bBox,// = wrapper.bBox,
				renderer = wrapper.renderer,
				width,
				height,
				rotation = wrapper.rotation,
				element = wrapper.element,
				styles = wrapper.styles,
				rad = rotation * deg2rad,
				textStr = wrapper.textStr,
				textShadow,
				elemStyle = element.style,
				toggleTextShadowShim,
				cacheKey;

			if (textStr !== UNDEFINED) {

				// Properties that affect bounding box
				cacheKey = ['', rotation || 0, styles && styles.fontSize, element.style.width].join(',');

				// Since numbers are monospaced, and numerical labels appear a lot in a chart,
				// we assume that a label of n characters has the same bounding box as others 
				// of the same length.
				if (textStr === '' || numRegex.test(textStr)) {
					cacheKey = 'num:' + textStr.toString().length + cacheKey;

				// Caching all strings reduces rendering time by 4-5%.
				} else {
					cacheKey = textStr + cacheKey;
				}
			}

			if (cacheKey && !reload) {
				bBox = renderer.cache[cacheKey];
			}

			// No cache found
			if (!bBox) {

				// SVG elements
				if (element.namespaceURI === SVG_NS || renderer.forExport) {
					try { // Fails in Firefox if the container has display: none.

						// When the text shadow shim is used, we need to hide the fake shadows
						// to get the correct bounding box (#3872)
						toggleTextShadowShim = this.fakeTS && function (display) {
							each(element.querySelectorAll('.' + PREFIX + 'text-shadow'), function (tspan) {
								tspan.style.display = display;
							});
						};

						// Workaround for #3842, Firefox reporting wrong bounding box for shadows
						if (isFirefox && elemStyle.textShadow) {
							textShadow = elemStyle.textShadow;
							elemStyle.textShadow = '';
						} else if (toggleTextShadowShim) {
							toggleTextShadowShim(NONE);
						}

						bBox = element.getBBox ?
							// SVG: use extend because IE9 is not allowed to change width and height in case
							// of rotation (below)
							extend({}, element.getBBox()) :
							// Canvas renderer and legacy IE in export mode
							{
								width: element.offsetWidth,
								height: element.offsetHeight
							};

						// #3842
						if (textShadow) {
							elemStyle.textShadow = textShadow;
						} else if (toggleTextShadowShim) {
							toggleTextShadowShim('');
						}
					} catch (e) {}

					// If the bBox is not set, the try-catch block above failed. The other condition
					// is for Opera that returns a width of -Infinity on hidden elements.
					if (!bBox || bBox.width < 0) {
						bBox = { width: 0, height: 0 };
					}


				// VML Renderer or useHTML within SVG
				} else {

					bBox = wrapper.htmlGetBBox();

				}

				// True SVG elements as well as HTML elements in modern browsers using the .useHTML option
				// need to compensated for rotation
				if (renderer.isSVG) {
					width = bBox.width;
					height = bBox.height;

					// Workaround for wrong bounding box in IE9 and IE10 (#1101, #1505, #1669, #2568)
					if (isIE && styles && styles.fontSize === '11px' && height.toPrecision(3) === '16.9') {
						bBox.height = height = 14;
					}

					// Adjust for rotated text
					if (rotation) {
						bBox.width = mathAbs(height * mathSin(rad)) + mathAbs(width * mathCos(rad));
						bBox.height = mathAbs(height * mathCos(rad)) + mathAbs(width * mathSin(rad));
					}
				}

				// Cache it
				renderer.cache[cacheKey] = bBox;
			}
			return bBox;
		},

		/**
		 * Show the element
		 */
		show: function (inherit) {
			// IE9-11 doesn't handle visibilty:inherit well, so we remove the attribute instead (#2881)
			if (inherit && this.element.namespaceURI === SVG_NS) {
				this.element.removeAttribute('visibility');
			} else {
				this.attr({ visibility: inherit ? 'inherit' : VISIBLE });
			}
			return this;
		},

		/**
		 * Hide the element
		 */
		hide: function () {
			return this.attr({ visibility: HIDDEN });
		},

		fadeOut: function (duration) {
			var elemWrapper = this;
			elemWrapper.animate({
				opacity: 0
			}, {
				duration: duration || 150,
				complete: function () {
					elemWrapper.attr({ y: -9999 }); // #3088, assuming we're only using this for tooltips
				}
			});
		},

		/**
		 * Add the element
		 * @param {Object|Undefined} parent Can be an element, an element wrapper or undefined
		 *	to append the element to the renderer.box.
		 */
		add: function (parent) {

			var renderer = this.renderer,
				element = this.element,
				inserted;

			if (parent) {
				this.parentGroup = parent;
			}

			// mark as inverted
			this.parentInverted = parent && parent.inverted;

			// build formatted text
			if (this.textStr !== undefined) {
				renderer.buildText(this);
			}

			// Mark as added
			this.added = true;

			// If we're adding to renderer root, or other elements in the group 
			// have a z index, we need to handle it
			if (!parent || parent.handleZ || this.zIndex) {
				inserted = this.zIndexSetter();
			}

			// If zIndex is not handled, append at the end
			if (!inserted) {
				(parent ? parent.element : renderer.box).appendChild(element);
			}

			// fire an event for internal hooks
			if (this.onAdd) {
				this.onAdd();
			}

			return this;
		},

		/**
		 * Removes a child either by removeChild or move to garbageBin.
		 * Issue 490; in VML removeChild results in Orphaned nodes according to sIEve, discardElement does not.
		 */
		safeRemoveChild: function (element) {
			var parentNode = element.parentNode;
			if (parentNode) {
				parentNode.removeChild(element);
			}
		},

		/**
		 * Destroy the element and element wrapper
		 */
		destroy: function () {
			var wrapper = this,
				element = wrapper.element || {},
				shadows = wrapper.shadows,
				parentToClean = wrapper.renderer.isSVG && element.nodeName === 'SPAN' && wrapper.parentGroup,
				grandParent,
				key,
				i;

			// remove events
			element.onclick = element.onmouseout = element.onmouseover = element.onmousemove = element.point = null;
			stop(wrapper); // stop running animations

			if (wrapper.clipPath) {
				wrapper.clipPath = wrapper.clipPath.destroy();
			}

			// Destroy stops in case this is a gradient object
			if (wrapper.stops) {
				for (i = 0; i < wrapper.stops.length; i++) {
					wrapper.stops[i] = wrapper.stops[i].destroy();
				}
				wrapper.stops = null;
			}

			// remove element
			wrapper.safeRemoveChild(element);

			// destroy shadows
			if (shadows) {
				each(shadows, function (shadow) {
					wrapper.safeRemoveChild(shadow);
				});
			}

			// In case of useHTML, clean up empty containers emulating SVG groups (#1960, #2393, #2697).
			while (parentToClean && parentToClean.div && parentToClean.div.childNodes.length === 0) {
				grandParent = parentToClean.parentGroup;
				wrapper.safeRemoveChild(parentToClean.div);
				delete parentToClean.div;
				parentToClean = grandParent;
			}

			// remove from alignObjects
			if (wrapper.alignTo) {
				erase(wrapper.renderer.alignedObjects, wrapper);
			}

			for (key in wrapper) {
				delete wrapper[key];
			}

			return null;
		},

		/**
		 * Add a shadow to the element. Must be done after the element is added to the DOM
		 * @param {Boolean|Object} shadowOptions
		 */
		shadow: function (shadowOptions, group, cutOff) {
			var shadows = [],
				i,
				shadow,
				element = this.element,
				strokeWidth,
				shadowWidth,
				shadowElementOpacity,

				// compensate for inverted plot area
				transform;


			if (shadowOptions) {
				shadowWidth = pick(shadowOptions.width, 3);
				shadowElementOpacity = (shadowOptions.opacity || 0.15) / shadowWidth;
				transform = this.parentInverted ?
					'(-1,-1)' :
					'(' + pick(shadowOptions.offsetX, 1) + ', ' + pick(shadowOptions.offsetY, 1) + ')';
				for (i = 1; i <= shadowWidth; i++) {
					shadow = element.cloneNode(0);
					strokeWidth = (shadowWidth * 2) + 1 - (2 * i);
					attr(shadow, {
						'isShadow': 'true',
						'stroke': shadowOptions.color || 'black',
						'stroke-opacity': shadowElementOpacity * i,
						'stroke-width': strokeWidth,
						'transform': 'translate' + transform,
						'fill': NONE
					});
					if (cutOff) {
						attr(shadow, 'height', mathMax(attr(shadow, 'height') - strokeWidth, 0));
						shadow.cutHeight = strokeWidth;
					}

					if (group) {
						group.element.appendChild(shadow);
					} else {
						element.parentNode.insertBefore(shadow, element);
					}

					shadows.push(shadow);
				}

				this.shadows = shadows;
			}
			return this;

		},

		xGetter: function (key) {
			if (this.element.nodeName === 'circle') {
				key = { x: 'cx', y: 'cy' }[key] || key;
			}
			return this._defaultGetter(key);
		},

		/** 
		 * Get the current value of an attribute or pseudo attribute, used mainly
		 * for animation.
		 */
		_defaultGetter: function (key) {
			var ret = pick(this[key], this.element ? this.element.getAttribute(key) : null, 0);

			if (/^[\-0-9\.]+$/.test(ret)) { // is numerical
				ret = parseFloat(ret);
			}
			return ret;
		},


		dSetter: function (value, key, element) {
			if (value && value.join) { // join path
				value = value.join(' ');
			}
			if (/(NaN| {2}|^$)/.test(value)) {
				value = 'M 0 0';
			}
			element.setAttribute(key, value);

			this[key] = value;
		},
		dashstyleSetter: function (value) {
			var i;
			value = value && value.toLowerCase();
			if (value) {
				value = value
					.replace('shortdashdotdot', '3,1,1,1,1,1,')
					.replace('shortdashdot', '3,1,1,1')
					.replace('shortdot', '1,1,')
					.replace('shortdash', '3,1,')
					.replace('longdash', '8,3,')
					.replace(/dot/g, '1,3,')
					.replace('dash', '4,3,')
					.replace(/,$/, '')
					.split(','); // ending comma

				i = value.length;
				while (i--) {
					value[i] = pInt(value[i]) * this['stroke-width'];
				}
				value = value.join(',')
					.replace('NaN', 'none'); // #3226
				this.element.setAttribute('stroke-dasharray', value);
			}
		},
		alignSetter: function (value) {
			this.element.setAttribute('text-anchor', { left: 'start', center: 'middle', right: 'end' }[value]);
		},
		opacitySetter: function (value, key, element) {
			this[key] = value;
			element.setAttribute(key, value);
		},
		titleSetter: function (value) {
			var titleNode = this.element.getElementsByTagName('title')[0];
			if (!titleNode) {
				titleNode = doc.createElementNS(SVG_NS, 'title');
				this.element.appendChild(titleNode);
			}
			titleNode.appendChild(
				doc.createTextNode(
					(String(pick(value), '')).replace(/<[^>]*>/g, '') // #3276, #3895
				)
			);
		},
		textSetter: function (value) {
			if (value !== this.textStr) {
				// Delete bBox memo when the text changes
				delete this.bBox;
			
				this.textStr = value;
				if (this.added) {
					this.renderer.buildText(this);
				}
			}
		},
		fillSetter: function (value, key, element) {
			if (typeof value === 'string') {
				element.setAttribute(key, value);
			} else if (value) {
				this.colorGradient(value, key, element);
			}
		},
		zIndexSetter: function (value, key) {
			var renderer = this.renderer,
				parentGroup = this.parentGroup,
				parentWrapper = parentGroup || renderer,
				parentNode = parentWrapper.element || renderer.box,
				childNodes,
				otherElement,
				otherZIndex,
				element = this.element,
				inserted,
				run = this.added,
				i;
			
			if (defined(value)) {
				element.setAttribute(key, value); // So we can read it for other elements in the group
				value = +value;
				if (this[key] === value) { // Only update when needed (#3865)
					run = false;
				}
				this[key] = value;
			}

			// Insert according to this and other elements' zIndex. Before .add() is called,
			// nothing is done. Then on add, or by later calls to zIndexSetter, the node
			// is placed on the right place in the DOM.
			if (run) {
				value = this.zIndex;

				if (value && parentGroup) {
					parentGroup.handleZ = true;
				}
			
				childNodes = parentNode.childNodes;
				for (i = 0; i < childNodes.length && !inserted; i++) {
					otherElement = childNodes[i];
					otherZIndex = attr(otherElement, 'zIndex');
					if (otherElement !== element && (
							// Insert before the first element with a higher zIndex
							pInt(otherZIndex) > value ||
							// If no zIndex given, insert before the first element with a zIndex
							(!defined(value) && defined(otherZIndex))

							)) {
						parentNode.insertBefore(element, otherElement);
						inserted = true;
					}
				}
				if (!inserted) {
					parentNode.appendChild(element);
				}
			}
			return inserted;
		},
		_defaultSetter: function (value, key, element) {
			element.setAttribute(key, value);
		}
	};

	// Some shared setters and getters
	SVGElement.prototype.yGetter = SVGElement.prototype.xGetter;
	SVGElement.prototype.translateXSetter = SVGElement.prototype.translateYSetter = 
			SVGElement.prototype.rotationSetter = SVGElement.prototype.verticalAlignSetter = 
			SVGElement.prototype.scaleXSetter = SVGElement.prototype.scaleYSetter = function (value, key) {
		this[key] = value;
		this.doTransform = true;
	};

	// WebKit and Batik have problems with a stroke-width of zero, so in this case we remove the 
	// stroke attribute altogether. #1270, #1369, #3065, #3072.
	SVGElement.prototype['stroke-widthSetter'] = SVGElement.prototype.strokeSetter = function (value, key, element) {
		this[key] = value;
		// Only apply the stroke attribute if the stroke width is defined and larger than 0
		if (this.stroke && this['stroke-width']) {
			this.strokeWidth = this['stroke-width'];
			SVGElement.prototype.fillSetter.call(this, this.stroke, 'stroke', element); // use prototype as instance may be overridden
			element.setAttribute('stroke-width', this['stroke-width']);
			this.hasStroke = true;
		} else if (key === 'stroke-width' && value === 0 && this.hasStroke) {
			element.removeAttribute('stroke');
			this.hasStroke = false;
		}
	};


	/**
	 * The default SVG renderer
	 */
	var SVGRenderer = function () {
		this.init.apply(this, arguments);
	};
	SVGRenderer.prototype = {
		Element: SVGElement,

		/**
		 * Initialize the SVGRenderer
		 * @param {Object} container
		 * @param {Number} width
		 * @param {Number} height
		 * @param {Boolean} forExport
		 */
		init: function (container, width, height, style, forExport) {
			var renderer = this,
				loc = location,
				boxWrapper,
				element,
				desc;

			boxWrapper = renderer.createElement('svg')
				.attr({
					version: '1.1'
				})
				.css(this.getStyle(style));
			element = boxWrapper.element;
			container.appendChild(element);

			// For browsers other than IE, add the namespace attribute (#1978)
			if (container.innerHTML.indexOf('xmlns') === -1) {
				attr(element, 'xmlns', SVG_NS);
			}

			// object properties
			renderer.isSVG = true;
			renderer.box = element;
			renderer.boxWrapper = boxWrapper;
			renderer.alignedObjects = [];

			// Page url used for internal references. #24, #672, #1070
			renderer.url = (isFirefox || isWebKit) && doc.getElementsByTagName('base').length ?
				loc.href
					.replace(/#.*?$/, '') // remove the hash
					.replace(/([\('\)])/g, '\\$1') // escape parantheses and quotes
					.replace(/ /g, '%20') : // replace spaces (needed for Safari only)
				'';

			// Add description
			desc = this.createElement('desc').add();
			desc.element.appendChild(doc.createTextNode('Created with ' + PRODUCT + ' ' + VERSION));


			renderer.defs = this.createElement('defs').add();
			renderer.forExport = forExport;
			renderer.gradients = {}; // Object where gradient SvgElements are stored
			renderer.cache = {}; // Cache for numerical bounding boxes

			renderer.setSize(width, height, false);



			// Issue 110 workaround:
			// In Firefox, if a div is positioned by percentage, its pixel position may land
			// between pixels. The container itself doesn't display this, but an SVG element
			// inside this container will be drawn at subpixel precision. In order to draw
			// sharp lines, this must be compensated for. This doesn't seem to work inside
			// iframes though (like in jsFiddle).
			var subPixelFix, rect;
			if (isFirefox && container.getBoundingClientRect) {
				renderer.subPixelFix = subPixelFix = function () {
					css(container, { left: 0, top: 0 });
					rect = container.getBoundingClientRect();
					css(container, {
						left: (mathCeil(rect.left) - rect.left) + PX,
						top: (mathCeil(rect.top) - rect.top) + PX
					});
				};

				// run the fix now
				subPixelFix();

				// run it on resize
				addEvent(win, 'resize', subPixelFix);
			}
		},

		getStyle: function (style) {
			return (this.style = extend({
				fontFamily: '"Lucida Grande", "Lucida Sans Unicode", Arial, Helvetica, sans-serif', // default font
				fontSize: '12px'
			}, style));
		},

		/**
		 * Detect whether the renderer is hidden. This happens when one of the parent elements
		 * has display: none. #608.
		 */
		isHidden: function () {
			return !this.boxWrapper.getBBox().width;
		},

		/**
		 * Destroys the renderer and its allocated members.
		 */
		destroy: function () {
			var renderer = this,
				rendererDefs = renderer.defs;
			renderer.box = null;
			renderer.boxWrapper = renderer.boxWrapper.destroy();

			// Call destroy on all gradient elements
			destroyObjectProperties(renderer.gradients || {});
			renderer.gradients = null;

			// Defs are null in VMLRenderer
			// Otherwise, destroy them here.
			if (rendererDefs) {
				renderer.defs = rendererDefs.destroy();
			}

			// Remove sub pixel fix handler
			// We need to check that there is a handler, otherwise all functions that are registered for event 'resize' are removed
			// See issue #982
			if (renderer.subPixelFix) {
				removeEvent(win, 'resize', renderer.subPixelFix);
			}

			renderer.alignedObjects = null;

			return null;
		},

		/**
		 * Create a wrapper for an SVG element
		 * @param {Object} nodeName
		 */
		createElement: function (nodeName) {
			var wrapper = new this.Element();
			wrapper.init(this, nodeName);
			return wrapper;
		},

		/**
		 * Dummy function for use in canvas renderer
		 */
		draw: function () {},

		/**
		 * Parse a simple HTML string into SVG tspans
		 *
		 * @param {Object} textNode The parent text SVG node
		 */
		buildText: function (wrapper) {
			var textNode = wrapper.element,
				renderer = this,
				forExport = renderer.forExport,
				textStr = pick(wrapper.textStr, '').toString(),
				hasMarkup = textStr.indexOf('<') !== -1,
				lines,
				childNodes = textNode.childNodes,
				styleRegex,
				hrefRegex,
				parentX = attr(textNode, 'x'),
				textStyles = wrapper.styles,
				width = wrapper.textWidth,
				textLineHeight = textStyles && textStyles.lineHeight,
				textShadow = textStyles && textStyles.textShadow,
				ellipsis = textStyles && textStyles.textOverflow === 'ellipsis',
				i = childNodes.length,
				tempParent = width && !wrapper.added && this.box,
				getLineHeight = function (tspan) {
					return textLineHeight ? 
						pInt(textLineHeight) :
						renderer.fontMetrics(
							/(px|em)$/.test(tspan && tspan.style.fontSize) ?
								tspan.style.fontSize :
								((textStyles && textStyles.fontSize) || renderer.style.fontSize || 12),
							tspan
						).h;
				},
				unescapeAngleBrackets = function (inputStr) {
					return inputStr.replace(/&lt;/g, '<').replace(/&gt;/g, '>');
				};

			/// remove old text
			while (i--) {
				textNode.removeChild(childNodes[i]);
			}

			// Skip tspans, add text directly to text node. The forceTSpan is a hook 
			// used in text outline hack.
			if (!hasMarkup && !textShadow && !ellipsis && textStr.indexOf(' ') === -1) {
				textNode.appendChild(doc.createTextNode(unescapeAngleBrackets(textStr)));
				return;

			// Complex strings, add more logic
			} else {

				styleRegex = /<.*style="([^"]+)".*>/;
				hrefRegex = /<.*href="(http[^"]+)".*>/;

				if (tempParent) {
					tempParent.appendChild(textNode); // attach it to the DOM to read offset width
				}

				if (hasMarkup) {
					lines = textStr
						.replace(/<(b|strong)>/g, '<span style="font-weight:bold">')
						.replace(/<(i|em)>/g, '<span style="font-style:italic">')
						.replace(/<a/g, '<span')
						.replace(/<\/(b|strong|i|em|a)>/g, '</span>')
						.split(/<br.*?>/g);

				} else {
					lines = [textStr];
				}


				// remove empty line at end
				if (lines[lines.length - 1] === '') {
					lines.pop();
				}

				
				// build the lines
				each(lines, function (line, lineNo) {
					var spans, spanNo = 0;

					line = line.replace(/<span/g, '|||<span').replace(/<\/span>/g, '</span>|||');
					spans = line.split('|||');

					each(spans, function (span) {
						if (span !== '' || spans.length === 1) {
							var attributes = {},
								tspan = doc.createElementNS(SVG_NS, 'tspan'),
								spanStyle; // #390
							if (styleRegex.test(span)) {
								spanStyle = span.match(styleRegex)[1].replace(/(;| |^)color([ :])/, '$1fill$2');
								attr(tspan, 'style', spanStyle);
							}
							if (hrefRegex.test(span) && !forExport) { // Not for export - #1529
								attr(tspan, 'onclick', 'location.href=\"' + span.match(hrefRegex)[1] + '\"');
								css(tspan, { cursor: 'pointer' });
							}

							span = unescapeAngleBrackets(span.replace(/<(.|\n)*?>/g, '') || ' ');

							// Nested tags aren't supported, and cause crash in Safari (#1596)
							if (span !== ' ') {

								// add the text node
								tspan.appendChild(doc.createTextNode(span));

								if (!spanNo) { // first span in a line, align it to the left
									if (lineNo && parentX !== null) {
										attributes.x = parentX;
									}
								} else {
									attributes.dx = 0; // #16
								}

								// add attributes
								attr(tspan, attributes);

								// Append it
								textNode.appendChild(tspan);

								// first span on subsequent line, add the line height
								if (!spanNo && lineNo) {

									// allow getting the right offset height in exporting in IE
									if (!hasSVG && forExport) {
										css(tspan, { display: 'block' });
									}

									// Set the line height based on the font size of either
									// the text element or the tspan element
									attr(
										tspan,
										'dy',
										getLineHeight(tspan)
									);
								}

								/*if (width) {
									renderer.breakText(wrapper, width);
								}*/

								// Check width and apply soft breaks or ellipsis
								if (width) {
									var words = span.replace(/([^\^])-/g, '$1- ').split(' '), // #1273
										hasWhiteSpace = spans.length > 1 || lineNo || (words.length > 1 && textStyles.whiteSpace !== 'nowrap'),
										tooLong,
										wasTooLong,
										actualWidth,
										rest = [],
										dy = getLineHeight(tspan),
										softLineNo = 1,
										rotation = wrapper.rotation,
										wordStr = span, // for ellipsis
										cursor = wordStr.length, // binary search cursor
										bBox;

									while ((hasWhiteSpace || ellipsis) && (words.length || rest.length)) {
										wrapper.rotation = 0; // discard rotation when computing box
										bBox = wrapper.getBBox(true);
										actualWidth = bBox.width;

										// Old IE cannot measure the actualWidth for SVG elements (#2314)
										if (!hasSVG && renderer.forExport) {
											actualWidth = renderer.measureSpanWidth(tspan.firstChild.data, wrapper.styles);
										}

										tooLong = actualWidth > width;

										// For ellipsis, do a binary search for the correct string length
										if (wasTooLong === undefined) {
											wasTooLong = tooLong; // First time
										}
										if (ellipsis && wasTooLong) {
											cursor /= 2;

											if (wordStr === '' || (!tooLong && cursor < 0.5)) {
												words = []; // All ok, break out
											} else {
												if (tooLong) {
													wasTooLong = true;
												}
												wordStr = span.substring(0, wordStr.length + (tooLong ? -1 : 1) * mathCeil(cursor));
												words = [wordStr + (width > 3 ? '\u2026' : '')];
												tspan.removeChild(tspan.firstChild);
											}

										// Looping down, this is the first word sequence that is not too long,
										// so we can move on to build the next line.
										} else if (!tooLong || words.length === 1) {
											words = rest;
											rest = [];
													
											if (words.length) {
												softLineNo++;
												
												tspan = doc.createElementNS(SVG_NS, 'tspan');
												attr(tspan, {
													dy: dy,
													x: parentX
												});
												if (spanStyle) { // #390
													attr(tspan, 'style', spanStyle);
												}
												textNode.appendChild(tspan);
											}
											if (actualWidth > width) { // a single word is pressing it out
												width = actualWidth;
											}
										} else { // append to existing line tspan
											tspan.removeChild(tspan.firstChild);
											rest.unshift(words.pop());
										}
										if (words.length) {
											tspan.appendChild(doc.createTextNode(words.join(' ').replace(/- /g, '-')));
										}
									}
									if (wasTooLong) {
										wrapper.attr('title', wrapper.textStr);
									}
									wrapper.rotation = rotation;
								}

								spanNo++;
							}
						}
					});
				});
				if (tempParent) {
					tempParent.removeChild(textNode); // attach it to the DOM to read offset width
				}

				// Apply the text shadow
				if (textShadow && wrapper.applyTextShadow) {
					wrapper.applyTextShadow(textShadow);
				}
			}
		},

		

		/*
		breakText: function (wrapper, width) {
			var bBox = wrapper.getBBox(),
				node = wrapper.element,
				textLength = node.textContent.length,
				pos = mathRound(width * textLength / bBox.width), // try this position first, based on average character width
				increment = 0,
				finalPos;

			if (bBox.width > width) {
				while (finalPos === undefined) {
					textLength = node.getSubStringLength(0, pos);

					if (textLength <= width) {
						if (increment === -1) {
							finalPos = pos;
						} else {
							increment = 1;
						}
					} else {
						if (increment === 1) {
							finalPos = pos - 1;
						} else {
							increment = -1;
						}
					}
					pos += increment;
				}
			}
			console.log(finalPos, node.getSubStringLength(0, finalPos))
		},
		*/

		/** 
		 * Returns white for dark colors and black for bright colors
		 */
		getContrast: function (color) {
			color = Color(color).rgba;
			return color[0] + color[1] + color[2] > 384 ? '#000000' : '#FFFFFF';
		},

		/**
		 * Create a button with preset states
		 * @param {String} text
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Function} callback
		 * @param {Object} normalState
		 * @param {Object} hoverState
		 * @param {Object} pressedState
		 */
		button: function (text, x, y, callback, normalState, hoverState, pressedState, disabledState, shape) {
			var label = this.label(text, x, y, shape, null, null, null, null, 'button'),
				curState = 0,
				stateOptions,
				stateStyle,
				normalStyle,
				hoverStyle,
				pressedStyle,
				disabledStyle,
				verticalGradient = { x1: 0, y1: 0, x2: 0, y2: 1 };

			// Normal state - prepare the attributes
			normalState = merge({
				'stroke-width': 1,
				stroke: '#CCCCCC',
				fill: {
					linearGradient: verticalGradient,
					stops: [
						[0, '#FEFEFE'],
						[1, '#F6F6F6']
					]
				},
				r: 2,
				padding: 5,
				style: {
					color: 'black'
				}
			}, normalState);
			normalStyle = normalState.style;
			delete normalState.style;

			// Hover state
			hoverState = merge(normalState, {
				stroke: '#68A',
				fill: {
					linearGradient: verticalGradient,
					stops: [
						[0, '#FFF'],
						[1, '#ACF']
					]
				}
			}, hoverState);
			hoverStyle = hoverState.style;
			delete hoverState.style;

			// Pressed state
			pressedState = merge(normalState, {
				stroke: '#68A',
				fill: {
					linearGradient: verticalGradient,
					stops: [
						[0, '#9BD'],
						[1, '#CDF']
					]
				}
			}, pressedState);
			pressedStyle = pressedState.style;
			delete pressedState.style;

			// Disabled state
			disabledState = merge(normalState, {
				style: {
					color: '#CCC'
				}
			}, disabledState);
			disabledStyle = disabledState.style;
			delete disabledState.style;

			// Add the events. IE9 and IE10 need mouseover and mouseout to funciton (#667).
			addEvent(label.element, isIE ? 'mouseover' : 'mouseenter', function () {
				if (curState !== 3) {
					label.attr(hoverState)
						.css(hoverStyle);
				}
			});
			addEvent(label.element, isIE ? 'mouseout' : 'mouseleave', function () {
				if (curState !== 3) {
					stateOptions = [normalState, hoverState, pressedState][curState];
					stateStyle = [normalStyle, hoverStyle, pressedStyle][curState];
					label.attr(stateOptions)
						.css(stateStyle);
				}
			});

			label.setState = function (state) {
				label.state = curState = state;
				if (!state) {
					label.attr(normalState)
						.css(normalStyle);
				} else if (state === 2) {
					label.attr(pressedState)
						.css(pressedStyle);
				} else if (state === 3) {
					label.attr(disabledState)
						.css(disabledStyle);
				}
			};

			return label
				.on('click', function () {
					if (curState !== 3) {
						callback.call(label);
					}
				})
				.attr(normalState)
				.css(extend({ cursor: 'default' }, normalStyle));
		},

		/**
		 * Make a straight line crisper by not spilling out to neighbour pixels
		 * @param {Array} points
		 * @param {Number} width
		 */
		crispLine: function (points, width) {
			// points format: [M, 0, 0, L, 100, 0]
			// normalize to a crisp line
			if (points[1] === points[4]) {
				// Substract due to #1129. Now bottom and left axis gridlines behave the same.
				points[1] = points[4] = mathRound(points[1]) - (width % 2 / 2);
			}
			if (points[2] === points[5]) {
				points[2] = points[5] = mathRound(points[2]) + (width % 2 / 2);
			}
			return points;
		},


		/**
		 * Draw a path
		 * @param {Array} path An SVG path in array form
		 */
		path: function (path) {
			var attr = {
				fill: NONE
			};
			if (isArray(path)) {
				attr.d = path;
			} else if (isObject(path)) { // attributes
				extend(attr, path);
			}
			return this.createElement('path').attr(attr);
		},

		/**
		 * Draw and return an SVG circle
		 * @param {Number} x The x position
		 * @param {Number} y The y position
		 * @param {Number} r The radius
		 */
		circle: function (x, y, r) {
			var attr = isObject(x) ?
				x :
				{
					x: x,
					y: y,
					r: r
				},
				wrapper = this.createElement('circle');

			wrapper.xSetter = function (value) {
				this.element.setAttribute('cx', value);
			};
			wrapper.ySetter = function (value) {
				this.element.setAttribute('cy', value);
			};
			return wrapper.attr(attr);
		},

		/**
		 * Draw and return an arc
		 * @param {Number} x X position
		 * @param {Number} y Y position
		 * @param {Number} r Radius
		 * @param {Number} innerR Inner radius like used in donut charts
		 * @param {Number} start Starting angle
		 * @param {Number} end Ending angle
		 */
		arc: function (x, y, r, innerR, start, end) {
			var arc;

			if (isObject(x)) {
				y = x.y;
				r = x.r;
				innerR = x.innerR;
				start = x.start;
				end = x.end;
				x = x.x;
			}

			// Arcs are defined as symbols for the ability to set
			// attributes in attr and animate
			arc = this.symbol('arc', x || 0, y || 0, r || 0, r || 0, {
				innerR: innerR || 0,
				start: start || 0,
				end: end || 0
			});
			arc.r = r; // #959
			return arc;
		},

		/**
		 * Draw and return a rectangle
		 * @param {Number} x Left position
		 * @param {Number} y Top position
		 * @param {Number} width
		 * @param {Number} height
		 * @param {Number} r Border corner radius
		 * @param {Number} strokeWidth A stroke width can be supplied to allow crisp drawing
		 */
		rect: function (x, y, width, height, r, strokeWidth) {

			r = isObject(x) ? x.r : r;

			var wrapper = this.createElement('rect'),
				attribs = isObject(x) ? x : x === UNDEFINED ? {} : {
					x: x,
					y: y,
					width: mathMax(width, 0),
					height: mathMax(height, 0)
				};

			if (strokeWidth !== UNDEFINED) {
				attribs.strokeWidth = strokeWidth;
				attribs = wrapper.crisp(attribs);
			}

			if (r) {
				attribs.r = r;
			}

			wrapper.rSetter = function (value) {
				attr(this.element, {
					rx: value,
					ry: value
				});
			};
			
			return wrapper.attr(attribs);
		},

		/**
		 * Resize the box and re-align all aligned elements
		 * @param {Object} width
		 * @param {Object} height
		 * @param {Boolean} animate
		 *
		 */
		setSize: function (width, height, animate) {
			var renderer = this,
				alignedObjects = renderer.alignedObjects,
				i = alignedObjects.length;

			renderer.width = width;
			renderer.height = height;

			renderer.boxWrapper[pick(animate, true) ? 'animate' : 'attr']({
				width: width,
				height: height
			});

			while (i--) {
				alignedObjects[i].align();
			}
		},

		/**
		 * Create a group
		 * @param {String} name The group will be given a class name of 'highcharts-{name}'.
		 *	 This can be used for styling and scripting.
		 */
		g: function (name) {
			var elem = this.createElement('g');
			return defined(name) ? elem.attr({ 'class': PREFIX + name }) : elem;
		},

		/**
		 * Display an image
		 * @param {String} src
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Number} width
		 * @param {Number} height
		 */
		image: function (src, x, y, width, height) {
			var attribs = {
					preserveAspectRatio: NONE
				},
				elemWrapper;

			// optional properties
			if (arguments.length > 1) {
				extend(attribs, {
					x: x,
					y: y,
					width: width,
					height: height
				});
			}

			elemWrapper = this.createElement('image').attr(attribs);

			// set the href in the xlink namespace
			if (elemWrapper.element.setAttributeNS) {
				elemWrapper.element.setAttributeNS('http://www.w3.org/1999/xlink',
					'href', src);
			} else {
				// could be exporting in IE
				// using href throws "not supported" in ie7 and under, requries regex shim to fix later
				elemWrapper.element.setAttribute('hc-svg-href', src);
			}
			return elemWrapper;
		},

		/**
		 * Draw a symbol out of pre-defined shape paths from the namespace 'symbol' object.
		 *
		 * @param {Object} symbol
		 * @param {Object} x
		 * @param {Object} y
		 * @param {Object} radius
		 * @param {Object} options
		 */
		symbol: function (symbol, x, y, width, height, options) {

			var obj,

				// get the symbol definition function
				symbolFn = this.symbols[symbol],

				// check if there's a path defined for this symbol
				path = symbolFn && symbolFn(
					mathRound(x),
					mathRound(y),
					width,
					height,
					options
				),

				imageElement,
				imageRegex = /^url\((.*?)\)$/,
				imageSrc,
				imageSize,
				centerImage;

			if (path) {

				obj = this.path(path);
				// expando properties for use in animate and attr
				extend(obj, {
					symbolName: symbol,
					x: x,
					y: y,
					width: width,
					height: height
				});
				if (options) {
					extend(obj, options);
				}


			// image symbols
			} else if (imageRegex.test(symbol)) {

				// On image load, set the size and position
				centerImage = function (img, size) {
					if (img.element) { // it may be destroyed in the meantime (#1390)
						img.attr({
							width: size[0],
							height: size[1]
						});

						if (!img.alignByTranslate) { // #185
							img.translate(
								mathRound((width - size[0]) / 2), // #1378
								mathRound((height - size[1]) / 2)
							);
						}
					}
				};

				imageSrc = symbol.match(imageRegex)[1];
				imageSize = symbolSizes[imageSrc] || (options && options.width && options.height && [options.width, options.height]);

				// Ireate the image synchronously, add attribs async
				obj = this.image(imageSrc)
					.attr({
						x: x,
						y: y
					});
				obj.isImg = true;

				if (imageSize) {
					centerImage(obj, imageSize);
				} else {
					// Initialize image to be 0 size so export will still function if there's no cached sizes.
					obj.attr({ width: 0, height: 0 });

					// Create a dummy JavaScript image to get the width and height. Due to a bug in IE < 8,
					// the created element must be assigned to a variable in order to load (#292).
					imageElement = createElement('img', {
						onload: function () {
							centerImage(obj, symbolSizes[imageSrc] = [this.width, this.height]);
						},
						src: imageSrc
					});
				}
			}

			return obj;
		},

		/**
		 * An extendable collection of functions for defining symbol paths.
		 */
		symbols: {
			'circle': function (x, y, w, h) {
				var cpw = 0.166 * w;
				return [
					M, x + w / 2, y,
					'C', x + w + cpw, y, x + w + cpw, y + h, x + w / 2, y + h,
					'C', x - cpw, y + h, x - cpw, y, x + w / 2, y,
					'Z'
				];
			},

			'square': function (x, y, w, h) {
				return [
					M, x, y,
					L, x + w, y,
					x + w, y + h,
					x, y + h,
					'Z'
				];
			},

			'triangle': function (x, y, w, h) {
				return [
					M, x + w / 2, y,
					L, x + w, y + h,
					x, y + h,
					'Z'
				];
			},

			'triangle-down': function (x, y, w, h) {
				return [
					M, x, y,
					L, x + w, y,
					x + w / 2, y + h,
					'Z'
				];
			},
			'diamond': function (x, y, w, h) {
				return [
					M, x + w / 2, y,
					L, x + w, y + h / 2,
					x + w / 2, y + h,
					x, y + h / 2,
					'Z'
				];
			},
			'arc': function (x, y, w, h, options) {
				var start = options.start,
					radius = options.r || w || h,
					end = options.end - 0.001, // to prevent cos and sin of start and end from becoming equal on 360 arcs (related: #1561)
					innerRadius = options.innerR,
					open = options.open,
					cosStart = mathCos(start),
					sinStart = mathSin(start),
					cosEnd = mathCos(end),
					sinEnd = mathSin(end),
					longArc = options.end - start < mathPI ? 0 : 1;

				return [
					M,
					x + radius * cosStart,
					y + radius * sinStart,
					'A', // arcTo
					radius, // x radius
					radius, // y radius
					0, // slanting
					longArc, // long or short arc
					1, // clockwise
					x + radius * cosEnd,
					y + radius * sinEnd,
					open ? M : L,
					x + innerRadius * cosEnd,
					y + innerRadius * sinEnd,
					'A', // arcTo
					innerRadius, // x radius
					innerRadius, // y radius
					0, // slanting
					longArc, // long or short arc
					0, // clockwise
					x + innerRadius * cosStart,
					y + innerRadius * sinStart,

					open ? '' : 'Z' // close
				];
			},

			/**
			 * Callout shape used for default tooltips, also used for rounded rectangles in VML
			 */
			callout: function (x, y, w, h, options) {
				var arrowLength = 6,
					halfDistance = 6,
					r = mathMin((options && options.r) || 0, w, h),
					safeDistance = r + halfDistance,
					anchorX = options && options.anchorX,
					anchorY = options && options.anchorY,
					path;

				path = [
					'M', x + r, y, 
					'L', x + w - r, y, // top side
					'C', x + w, y, x + w, y, x + w, y + r, // top-right corner
					'L', x + w, y + h - r, // right side
					'C', x + w, y + h, x + w, y + h, x + w - r, y + h, // bottom-right corner
					'L', x + r, y + h, // bottom side
					'C', x, y + h, x, y + h, x, y + h - r, // bottom-left corner
					'L', x, y + r, // left side
					'C', x, y, x, y, x + r, y // top-right corner
				];
				
				if (anchorX && anchorX > w && anchorY > y + safeDistance && anchorY < y + h - safeDistance) { // replace right side
					path.splice(13, 3,
						'L', x + w, anchorY - halfDistance, 
						x + w + arrowLength, anchorY,
						x + w, anchorY + halfDistance,
						x + w, y + h - r
					);
				} else if (anchorX && anchorX < 0 && anchorY > y + safeDistance && anchorY < y + h - safeDistance) { // replace left side
					path.splice(33, 3, 
						'L', x, anchorY + halfDistance, 
						x - arrowLength, anchorY,
						x, anchorY - halfDistance,
						x, y + r
					);
				} else if (anchorY && anchorY > h && anchorX > x + safeDistance && anchorX < x + w - safeDistance) { // replace bottom
					path.splice(23, 3,
						'L', anchorX + halfDistance, y + h,
						anchorX, y + h + arrowLength,
						anchorX - halfDistance, y + h,
						x + r, y + h
					);
				} else if (anchorY && anchorY < 0 && anchorX > x + safeDistance && anchorX < x + w - safeDistance) { // replace top
					path.splice(3, 3,
						'L', anchorX - halfDistance, y,
						anchorX, y - arrowLength,
						anchorX + halfDistance, y,
						w - r, y
					);
				}
				return path;
			}
		},

		/**
		 * Define a clipping rectangle
		 * @param {String} id
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Number} width
		 * @param {Number} height
		 */
		clipRect: function (x, y, width, height) {
			var wrapper,
				id = PREFIX + idCounter++,

				clipPath = this.createElement('clipPath').attr({
					id: id
				}).add(this.defs);

			wrapper = this.rect(x, y, width, height, 0).add(clipPath);
			wrapper.id = id;
			wrapper.clipPath = clipPath;
			wrapper.count = 0;

			return wrapper;
		},


		


		/**
		 * Add text to the SVG object
		 * @param {String} str
		 * @param {Number} x Left position
		 * @param {Number} y Top position
		 * @param {Boolean} useHTML Use HTML to render the text
		 */
		text: function (str, x, y, useHTML) {

			// declare variables
			var renderer = this,
				fakeSVG = useCanVG || (!hasSVG && renderer.forExport),
				wrapper,
				attr = {};

			if (useHTML && !renderer.forExport) {
				return renderer.html(str, x, y);
			}

			attr.x = Math.round(x || 0); // X is always needed for line-wrap logic
			if (y) {
				attr.y = Math.round(y);
			}
			if (str || str === 0) {
				attr.text = str;
			}

			wrapper = renderer.createElement('text')
				.attr(attr);

			// Prevent wrapping from creating false offsetWidths in export in legacy IE (#1079, #1063)
			if (fakeSVG) {
				wrapper.css({
					position: ABSOLUTE
				});
			}

			if (!useHTML) {
				wrapper.xSetter = function (value, key, element) {
					var tspans = element.getElementsByTagName('tspan'),
						tspan,
						parentVal = element.getAttribute(key),
						i;
					for (i = 0; i < tspans.length; i++) {
						tspan = tspans[i];
						// If the x values are equal, the tspan represents a linebreak
						if (tspan.getAttribute(key) === parentVal) {
							tspan.setAttribute(key, value);
						}
					}
					element.setAttribute(key, value);
				};
			}
			
			return wrapper;
		},

		/**
		 * Utility to return the baseline offset and total line height from the font size
		 */
		fontMetrics: function (fontSize, elem) {
			var lineHeight,
				baseline,
				style;

			fontSize = fontSize || this.style.fontSize;
			if (elem && win.getComputedStyle) {
				elem = elem.element || elem; // SVGElement
				style = win.getComputedStyle(elem, "");
				fontSize = style && style.fontSize; // #4309, the style doesn't exist inside a hidden iframe in Firefox
			}
			fontSize = /px/.test(fontSize) ? pInt(fontSize) : /em/.test(fontSize) ? parseFloat(fontSize) * 12 : 12;

			// Empirical values found by comparing font size and bounding box height.
			// Applies to the default font family. http://jsfiddle.net/highcharts/7xvn7/
			lineHeight = fontSize < 24 ? fontSize + 3 : mathRound(fontSize * 1.2);
			baseline = mathRound(lineHeight * 0.8);

			return {
				h: lineHeight,
				b: baseline,
				f: fontSize
			};
		},

		/**
		 * Correct X and Y positioning of a label for rotation (#1764)
		 */
		rotCorr: function (baseline, rotation, alterY) {
			var y = baseline;
			if (rotation && alterY) {
				y = mathMax(y * mathCos(rotation * deg2rad), 4);
			}
			return {
				x: (-baseline / 3) * mathSin(rotation * deg2rad),
				y: y
			};
		},

		/**
		 * Add a label, a text item that can hold a colored or gradient background
		 * as well as a border and shadow.
		 * @param {string} str
		 * @param {Number} x
		 * @param {Number} y
		 * @param {String} shape
		 * @param {Number} anchorX In case the shape has a pointer, like a flag, this is the
		 *	coordinates it should be pinned to
		 * @param {Number} anchorY
		 * @param {Boolean} baseline Whether to position the label relative to the text baseline,
		 *	like renderer.text, or to the upper border of the rectangle.
		 * @param {String} className Class name for the group
		 */
		label: function (str, x, y, shape, anchorX, anchorY, useHTML, baseline, className) {

			var renderer = this,
				wrapper = renderer.g(className),
				text = renderer.text('', 0, 0, useHTML)
					.attr({
						zIndex: 1
					}),
					//.add(wrapper),
				box,
				bBox,
				alignFactor = 0,
				padding = 3,
				paddingLeft = 0,
				width,
				height,
				wrapperX,
				wrapperY,
				crispAdjust = 0,
				deferredAttr = {},
				baselineOffset,
				needsBox;

			/**
			 * This function runs after the label is added to the DOM (when the bounding box is
			 * available), and after the text of the label is updated to detect the new bounding
			 * box and reflect it in the border box.
			 */
			function updateBoxSize() {
				var boxX,
					boxY,
					style = text.element.style;

				bBox = (width === undefined || height === undefined || wrapper.styles.textAlign) && defined(text.textStr) && 
					text.getBBox(); //#3295 && 3514 box failure when string equals 0
				wrapper.width = (width || bBox.width || 0) + 2 * padding + paddingLeft;
				wrapper.height = (height || bBox.height || 0) + 2 * padding;

				// update the label-scoped y offset
				baselineOffset = padding + renderer.fontMetrics(style && style.fontSize, text).b;

				
				if (needsBox) {

					// create the border box if it is not already present
					if (!box) {
						boxX = mathRound(-alignFactor * padding) + crispAdjust;
						boxY = (baseline ? -baselineOffset : 0) + crispAdjust;

						wrapper.box = box = shape ?
							renderer.symbol(shape, boxX, boxY, wrapper.width, wrapper.height, deferredAttr) :
							renderer.rect(boxX, boxY, wrapper.width, wrapper.height, 0, deferredAttr[STROKE_WIDTH]);
						box.attr('fill', NONE).add(wrapper);
					}

					// apply the box attributes
					if (!box.isImg) { // #1630
						box.attr(extend({
							width: mathRound(wrapper.width),
							height: mathRound(wrapper.height)
						}, deferredAttr));
					}
					deferredAttr = null;
				}
			}

			/**
			 * This function runs after setting text or padding, but only if padding is changed
			 */
			function updateTextPadding() {
				var styles = wrapper.styles,
					textAlign = styles && styles.textAlign,
					x = paddingLeft + padding * (1 - alignFactor),
					y;

				// determin y based on the baseline
				y = baseline ? 0 : baselineOffset;

				// compensate for alignment
				if (defined(width) && bBox && (textAlign === 'center' || textAlign === 'right')) {
					x += { center: 0.5, right: 1 }[textAlign] * (width - bBox.width);
				}

				// update if anything changed
				if (x !== text.x || y !== text.y) {
					text.attr('x', x);
					if (y !== UNDEFINED) {
						text.attr('y', y);
					}
				}

				// record current values
				text.x = x;
				text.y = y;
			}

			/**
			 * Set a box attribute, or defer it if the box is not yet created
			 * @param {Object} key
			 * @param {Object} value
			 */
			function boxAttr(key, value) {
				if (box) {
					box.attr(key, value);
				} else {
					deferredAttr[key] = value;
				}
			}

			/**
			 * After the text element is added, get the desired size of the border box
			 * and add it before the text in the DOM.
			 */
			wrapper.onAdd = function () {
				text.add(wrapper);
				wrapper.attr({
					text: (str || str === 0) ? str : '', // alignment is available now // #3295: 0 not rendered if given as a value
					x: x,
					y: y
				});

				if (box && defined(anchorX)) {
					wrapper.attr({
						anchorX: anchorX,
						anchorY: anchorY
					});
				}
			};

			/*
			 * Add specific attribute setters.
			 */

			// only change local variables
			wrapper.widthSetter = function (value) {
				width = value;
			};
			wrapper.heightSetter = function (value) {
				height = value;
			};
			wrapper.paddingSetter =  function (value) {
				if (defined(value) && value !== padding) {
					padding = wrapper.padding = value;
					updateTextPadding();
				}
			};
			wrapper.paddingLeftSetter =  function (value) {
				if (defined(value) && value !== paddingLeft) {
					paddingLeft = value;
					updateTextPadding();
				}
			};


			// change local variable and prevent setting attribute on the group
			wrapper.alignSetter = function (value) {
				alignFactor = { left: 0, center: 0.5, right: 1 }[value];
			};

			// apply these to the box and the text alike
			wrapper.textSetter = function (value) {
				if (value !== UNDEFINED) {
					text.textSetter(value);
				}
				updateBoxSize();
				updateTextPadding();
			};

			// apply these to the box but not to the text
			wrapper['stroke-widthSetter'] = function (value, key) {
				if (value) {
					needsBox = true;
				}
				crispAdjust = value % 2 / 2;
				boxAttr(key, value);
			};
			wrapper.strokeSetter = wrapper.fillSetter = wrapper.rSetter = function (value, key) {
				if (key === 'fill' && value) {
					needsBox = true;
				}
				boxAttr(key, value);
			};
			wrapper.anchorXSetter = function (value, key) {
				anchorX = value;
				boxAttr(key, mathRound(value) - crispAdjust - wrapperX);
			};
			wrapper.anchorYSetter = function (value, key) {
				anchorY = value;
				boxAttr(key, value - wrapperY);
			};

			// rename attributes
			wrapper.xSetter = function (value) {
				wrapper.x = value; // for animation getter
				if (alignFactor) {
					value -= alignFactor * ((width || bBox.width) + padding);
				}
				wrapperX = mathRound(value);
				wrapper.attr('translateX', wrapperX);
			};
			wrapper.ySetter = function (value) {
				wrapperY = wrapper.y = mathRound(value);
				wrapper.attr('translateY', wrapperY);
			};

			// Redirect certain methods to either the box or the text
			var baseCss = wrapper.css;
			return extend(wrapper, {
				/**
				 * Pick up some properties and apply them to the text instead of the wrapper
				 */
				css: function (styles) {
					if (styles) {
						var textStyles = {};
						styles = merge(styles); // create a copy to avoid altering the original object (#537)
						each(wrapper.textProps, function (prop) {
							if (styles[prop] !== UNDEFINED) {
								textStyles[prop] = styles[prop];
								delete styles[prop];
							}
						});
						text.css(textStyles);
					}
					return baseCss.call(wrapper, styles);
				},
				/**
				 * Return the bounding box of the box, not the group
				 */
				getBBox: function () {
					return {
						width: bBox.width + 2 * padding,
						height: bBox.height + 2 * padding,
						x: bBox.x - padding,
						y: bBox.y - padding
					};
				},
				/**
				 * Apply the shadow to the box
				 */
				shadow: function (b) {
					if (box) {
						box.shadow(b);
					}
					return wrapper;
				},
				/**
				 * Destroy and release memory.
				 */
				destroy: function () {

					// Added by button implementation
					removeEvent(wrapper.element, 'mouseenter');
					removeEvent(wrapper.element, 'mouseleave');

					if (text) {
						text = text.destroy();
					}
					if (box) {
						box = box.destroy();
					}
					// Call base implementation to destroy the rest
					SVGElement.prototype.destroy.call(wrapper);

					// Release local pointers (#1298)
					wrapper = renderer = updateBoxSize = updateTextPadding = boxAttr = null;
				}
			});
		}
	}; // end SVGRenderer


	// general renderer
	Renderer = SVGRenderer;
	// extend SvgElement for useHTML option
	extend(SVGElement.prototype, {
		/**
		 * Apply CSS to HTML elements. This is used in text within SVG rendering and
		 * by the VML renderer
		 */
		htmlCss: function (styles) {
			var wrapper = this,
				element = wrapper.element,
				textWidth = styles && element.tagName === 'SPAN' && styles.width;

			if (textWidth) {
				delete styles.width;
				wrapper.textWidth = textWidth;
				wrapper.updateTransform();
			}
			if (styles && styles.textOverflow === 'ellipsis') {
				styles.whiteSpace = 'nowrap';
				styles.overflow = 'hidden';
			}
			wrapper.styles = extend(wrapper.styles, styles);
			css(wrapper.element, styles);

			return wrapper;
		},

		/**
		 * VML and useHTML method for calculating the bounding box based on offsets
		 * @param {Boolean} refresh Whether to force a fresh value from the DOM or to
		 * use the cached value
		 *
		 * @return {Object} A hash containing values for x, y, width and height
		 */

		htmlGetBBox: function () {
			var wrapper = this,
				element = wrapper.element;

			// faking getBBox in exported SVG in legacy IE
			// faking getBBox in exported SVG in legacy IE (is this a duplicate of the fix for #1079?)
			if (element.nodeName === 'text') {
				element.style.position = ABSOLUTE;
			}

			return {
				x: element.offsetLeft,
				y: element.offsetTop,
				width: element.offsetWidth,
				height: element.offsetHeight
			};
		},

		/**
		 * VML override private method to update elements based on internal
		 * properties based on SVG transform
		 */
		htmlUpdateTransform: function () {
			// aligning non added elements is expensive
			if (!this.added) {
				this.alignOnAdd = true;
				return;
			}

			var wrapper = this,
				renderer = wrapper.renderer,
				elem = wrapper.element,
				translateX = wrapper.translateX || 0,
				translateY = wrapper.translateY || 0,
				x = wrapper.x || 0,
				y = wrapper.y || 0,
				align = wrapper.textAlign || 'left',
				alignCorrection = { left: 0, center: 0.5, right: 1 }[align],
				shadows = wrapper.shadows,
				styles = wrapper.styles;

			// apply translate
			css(elem, {
				marginLeft: translateX,
				marginTop: translateY
			});
			if (shadows) { // used in labels/tooltip
				each(shadows, function (shadow) {
					css(shadow, {
						marginLeft: translateX + 1,
						marginTop: translateY + 1
					});
				});
			}

			// apply inversion
			if (wrapper.inverted) { // wrapper is a group
				each(elem.childNodes, function (child) {
					renderer.invertChild(child, elem);
				});
			}

			if (elem.tagName === 'SPAN') {

				var width,
					rotation = wrapper.rotation,
					baseline,
					textWidth = pInt(wrapper.textWidth),
					currentTextTransform = [rotation, align, elem.innerHTML, wrapper.textWidth].join(',');

				if (currentTextTransform !== wrapper.cTT) { // do the calculations and DOM access only if properties changed


					baseline = renderer.fontMetrics(elem.style.fontSize).b;

					// Renderer specific handling of span rotation
					if (defined(rotation)) {
						wrapper.setSpanRotation(rotation, alignCorrection, baseline);
					}

					width = pick(wrapper.elemWidth, elem.offsetWidth);

					// Update textWidth
					if (width > textWidth && /[ \-]/.test(elem.textContent || elem.innerText)) { // #983, #1254
						css(elem, {
							width: textWidth + PX,
							display: 'block',
							whiteSpace: (styles && styles.whiteSpace) || 'normal' // #3331
						});
						width = textWidth;
					}

					wrapper.getSpanCorrection(width, baseline, alignCorrection, rotation, align);
				}

				// apply position with correction
				css(elem, {
					left: (x + (wrapper.xCorr || 0)) + PX,
					top: (y + (wrapper.yCorr || 0)) + PX
				});

				// force reflow in webkit to apply the left and top on useHTML element (#1249)
				if (isWebKit) {
					baseline = elem.offsetHeight; // assigned to baseline for JSLint purpose
				}

				// record current text transform
				wrapper.cTT = currentTextTransform;
			}
		},

		/**
		 * Set the rotation of an individual HTML span
		 */
		setSpanRotation: function (rotation, alignCorrection, baseline) {
			var rotationStyle = {},
				cssTransformKey = isIE ? '-ms-transform' : isWebKit ? '-webkit-transform' : isFirefox ? 'MozTransform' : isOpera ? '-o-transform' : '';

			rotationStyle[cssTransformKey] = rotationStyle.transform = 'rotate(' + rotation + 'deg)';
			rotationStyle[cssTransformKey + (isFirefox ? 'Origin' : '-origin')] = rotationStyle.transformOrigin = (alignCorrection * 100) + '% ' + baseline + 'px';
			css(this.element, rotationStyle);
		},

		/**
		 * Get the correction in X and Y positioning as the element is rotated.
		 */
		getSpanCorrection: function (width, baseline, alignCorrection) {
			this.xCorr = -width * alignCorrection;
			this.yCorr = -baseline;
		}
	});

	// Extend SvgRenderer for useHTML option.
	extend(SVGRenderer.prototype, {
		/**
		 * Create HTML text node. This is used by the VML renderer as well as the SVG
		 * renderer through the useHTML option.
		 *
		 * @param {String} str
		 * @param {Number} x
		 * @param {Number} y
		 */
		html: function (str, x, y) {
			var wrapper = this.createElement('span'),
				element = wrapper.element,
				renderer = wrapper.renderer;

			// Text setter
			wrapper.textSetter = function (value) {
				if (value !== element.innerHTML) {
					delete this.bBox;
				}
				element.innerHTML = this.textStr = value;
			};

			// Various setters which rely on update transform
			wrapper.xSetter = wrapper.ySetter = wrapper.alignSetter = wrapper.rotationSetter = function (value, key) {
				if (key === 'align') {
					key = 'textAlign'; // Do not overwrite the SVGElement.align method. Same as VML.
				}
				wrapper[key] = value;
				wrapper.htmlUpdateTransform();
			};

			// Set the default attributes
			wrapper.attr({
					text: str,
					x: mathRound(x),
					y: mathRound(y)
				})
				.css({
					position: ABSOLUTE,
					fontFamily: this.style.fontFamily,
					fontSize: this.style.fontSize
				});

			// Keep the whiteSpace style outside the wrapper.styles collection
			element.style.whiteSpace = 'nowrap';

			// Use the HTML specific .css method
			wrapper.css = wrapper.htmlCss;

			// This is specific for HTML within SVG
			if (renderer.isSVG) {
				wrapper.add = function (svgGroupWrapper) {

					var htmlGroup,
						container = renderer.box.parentNode,
						parentGroup,
						parents = [];

					this.parentGroup = svgGroupWrapper;

					// Create a mock group to hold the HTML elements
					if (svgGroupWrapper) {
						htmlGroup = svgGroupWrapper.div;
						if (!htmlGroup) {

							// Read the parent chain into an array and read from top down
							parentGroup = svgGroupWrapper;
							while (parentGroup) {

								parents.push(parentGroup);

								// Move up to the next parent group
								parentGroup = parentGroup.parentGroup;
							}

							// Ensure dynamically updating position when any parent is translated
							each(parents.reverse(), function (parentGroup) {
								var htmlGroupStyle,
									cls = attr(parentGroup.element, 'class');

								if (cls) {
									cls = { className: cls };
								} // else null

								// Create a HTML div and append it to the parent div to emulate
								// the SVG group structure
								htmlGroup = parentGroup.div = parentGroup.div || createElement(DIV, cls, {
									position: ABSOLUTE,
									left: (parentGroup.translateX || 0) + PX,
									top: (parentGroup.translateY || 0) + PX
								}, htmlGroup || container); // the top group is appended to container

								// Shortcut
								htmlGroupStyle = htmlGroup.style;

								// Set listeners to update the HTML div's position whenever the SVG group
								// position is changed
								extend(parentGroup, {
									translateXSetter: function (value, key) {
										htmlGroupStyle.left = value + PX;
										parentGroup[key] = value;
										parentGroup.doTransform = true;
									},
									translateYSetter: function (value, key) {
										htmlGroupStyle.top = value + PX;
										parentGroup[key] = value;
										parentGroup.doTransform = true;
									},
									visibilitySetter: function (value, key) {
										htmlGroupStyle[key] = value;
									}
								});
							});

						}
					} else {
						htmlGroup = container;
					}

					htmlGroup.appendChild(element);

					// Shared with VML:
					wrapper.added = true;
					if (wrapper.alignOnAdd) {
						wrapper.htmlUpdateTransform();
					}

					return wrapper;
				};
			}
			return wrapper;
		}
	});

	/* ****************************************************************************
	 *                                                                            *
	 * START OF INTERNET EXPLORER <= 8 SPECIFIC CODE                              *
	 *                                                                            *
	 * For applications and websites that don't need IE support, like platform    *
	 * targeted mobile apps and web apps, this code can be removed.               *
	 *                                                                            *
	 *****************************************************************************/

	/**
	 * @constructor
	 */
	var VMLRenderer, VMLElement;
	if (!hasSVG && !useCanVG) {

	/**
	 * The VML element wrapper.
	 */
	VMLElement = {

		/**
		 * Initialize a new VML element wrapper. It builds the markup as a string
		 * to minimize DOM traffic.
		 * @param {Object} renderer
		 * @param {Object} nodeName
		 */
		init: function (renderer, nodeName) {
			var wrapper = this,
				markup =  ['<', nodeName, ' filled="f" stroked="f"'],
				style = ['position: ', ABSOLUTE, ';'],
				isDiv = nodeName === DIV;

			// divs and shapes need size
			if (nodeName === 'shape' || isDiv) {
				style.push('left:0;top:0;width:1px;height:1px;');
			}
			style.push('visibility: ', isDiv ? HIDDEN : VISIBLE);

			markup.push(' style="', style.join(''), '"/>');

			// create element with default attributes and style
			if (nodeName) {
				markup = isDiv || nodeName === 'span' || nodeName === 'img' ?
					markup.join('')
					: renderer.prepVML(markup);
				wrapper.element = createElement(markup);
			}

			wrapper.renderer = renderer;
		},

		/**
		 * Add the node to the given parent
		 * @param {Object} parent
		 */
		add: function (parent) {
			var wrapper = this,
				renderer = wrapper.renderer,
				element = wrapper.element,
				box = renderer.box,
				inverted = parent && parent.inverted,

				// get the parent node
				parentNode = parent ?
					parent.element || parent :
					box;


			// if the parent group is inverted, apply inversion on all children
			if (inverted) { // only on groups
				renderer.invertChild(element, parentNode);
			}

			// append it
			parentNode.appendChild(element);

			// align text after adding to be able to read offset
			wrapper.added = true;
			if (wrapper.alignOnAdd && !wrapper.deferUpdateTransform) {
				wrapper.updateTransform();
			}

			// fire an event for internal hooks
			if (wrapper.onAdd) {
				wrapper.onAdd();
			}

			return wrapper;
		},

		/**
		 * VML always uses htmlUpdateTransform
		 */
		updateTransform: SVGElement.prototype.htmlUpdateTransform,

		/**
		 * Set the rotation of a span with oldIE's filter
		 */
		setSpanRotation: function () {
			// Adjust for alignment and rotation. Rotation of useHTML content is not yet implemented
			// but it can probably be implemented for Firefox 3.5+ on user request. FF3.5+
			// has support for CSS3 transform. The getBBox method also needs to be updated
			// to compensate for the rotation, like it currently does for SVG.
			// Test case: http://jsfiddle.net/highcharts/Ybt44/

			var rotation = this.rotation,
				costheta = mathCos(rotation * deg2rad),
				sintheta = mathSin(rotation * deg2rad);
						
			css(this.element, {
				filter: rotation ? ['progid:DXImageTransform.Microsoft.Matrix(M11=', costheta,
					', M12=', -sintheta, ', M21=', sintheta, ', M22=', costheta,
					', sizingMethod=\'auto expand\')'].join('') : NONE
			});
		},

		/**
		 * Get the positioning correction for the span after rotating. 
		 */
		getSpanCorrection: function (width, baseline, alignCorrection, rotation, align) {

			var costheta = rotation ? mathCos(rotation * deg2rad) : 1,
				sintheta = rotation ? mathSin(rotation * deg2rad) : 0,
				height = pick(this.elemHeight, this.element.offsetHeight),
				quad,
				nonLeft = align && align !== 'left';

			// correct x and y
			this.xCorr = costheta < 0 && -width;
			this.yCorr = sintheta < 0 && -height;

			// correct for baseline and corners spilling out after rotation
			quad = costheta * sintheta < 0;
			this.xCorr += sintheta * baseline * (quad ? 1 - alignCorrection : alignCorrection);
			this.yCorr -= costheta * baseline * (rotation ? (quad ? alignCorrection : 1 - alignCorrection) : 1);
			// correct for the length/height of the text
			if (nonLeft) {
				this.xCorr -= width * alignCorrection * (costheta < 0 ? -1 : 1);
				if (rotation) {
					this.yCorr -= height * alignCorrection * (sintheta < 0 ? -1 : 1);
				}
				css(this.element, {
					textAlign: align
				});
			}
		},

		/**
		 * Converts a subset of an SVG path definition to its VML counterpart. Takes an array
		 * as the parameter and returns a string.
		 */
		pathToVML: function (value) {
			// convert paths
			var i = value.length,
				path = [];

			while (i--) {

				// Multiply by 10 to allow subpixel precision.
				// Substracting half a pixel seems to make the coordinates
				// align with SVG, but this hasn't been tested thoroughly
				if (isNumber(value[i])) {
					path[i] = mathRound(value[i] * 10) - 5;
				} else if (value[i] === 'Z') { // close the path
					path[i] = 'x';
				} else {
					path[i] = value[i];

					// When the start X and end X coordinates of an arc are too close,
					// they are rounded to the same value above. In this case, substract or 
					// add 1 from the end X and Y positions. #186, #760, #1371, #1410.
					if (value.isArc && (value[i] === 'wa' || value[i] === 'at')) {
						// Start and end X
						if (path[i + 5] === path[i + 7]) {
							path[i + 7] += value[i + 7] > value[i + 5] ? 1 : -1;
						}
						// Start and end Y
						if (path[i + 6] === path[i + 8]) {
							path[i + 8] += value[i + 8] > value[i + 6] ? 1 : -1;
						}
					}
				}
			}

			
			// Loop up again to handle path shortcuts (#2132)
			/*while (i++ < path.length) {
				if (path[i] === 'H') { // horizontal line to
					path[i] = 'L';
					path.splice(i + 2, 0, path[i - 1]);
				} else if (path[i] === 'V') { // vertical line to
					path[i] = 'L';
					path.splice(i + 1, 0, path[i - 2]);
				}
			}*/
			return path.join(' ') || 'x';
		},

		/**
		 * Set the element's clipping to a predefined rectangle
		 *
		 * @param {String} id The id of the clip rectangle
		 */
		clip: function (clipRect) {
			var wrapper = this,
				clipMembers,
				cssRet;

			if (clipRect) {
				clipMembers = clipRect.members;
				erase(clipMembers, wrapper); // Ensure unique list of elements (#1258)
				clipMembers.push(wrapper);
				wrapper.destroyClip = function () {
					erase(clipMembers, wrapper);
				};
				cssRet = clipRect.getCSS(wrapper);

			} else {
				if (wrapper.destroyClip) {
					wrapper.destroyClip();
				}
				cssRet = { clip: docMode8 ? 'inherit' : 'rect(auto)' }; // #1214
			}

			return wrapper.css(cssRet);

		},

		/**
		 * Set styles for the element
		 * @param {Object} styles
		 */
		css: SVGElement.prototype.htmlCss,

		/**
		 * Removes a child either by removeChild or move to garbageBin.
		 * Issue 490; in VML removeChild results in Orphaned nodes according to sIEve, discardElement does not.
		 */
		safeRemoveChild: function (element) {
			// discardElement will detach the node from its parent before attaching it
			// to the garbage bin. Therefore it is important that the node is attached and have parent.
			if (element.parentNode) {
				discardElement(element);
			}
		},

		/**
		 * Extend element.destroy by removing it from the clip members array
		 */
		destroy: function () {
			if (this.destroyClip) {
				this.destroyClip();
			}

			return SVGElement.prototype.destroy.apply(this);
		},

		/**
		 * Add an event listener. VML override for normalizing event parameters.
		 * @param {String} eventType
		 * @param {Function} handler
		 */
		on: function (eventType, handler) {
			// simplest possible event model for internal use
			this.element['on' + eventType] = function () {
				var evt = win.event;
				evt.target = evt.srcElement;
				handler(evt);
			};
			return this;
		},

		/**
		 * In stacked columns, cut off the shadows so that they don't overlap
		 */
		cutOffPath: function (path, length) {

			var len;

			path = path.split(/[ ,]/);
			len = path.length;

			if (len === 9 || len === 11) {
				path[len - 4] = path[len - 2] = pInt(path[len - 2]) - 10 * length;
			}
			return path.join(' ');
		},

		/**
		 * Apply a drop shadow by copying elements and giving them different strokes
		 * @param {Boolean|Object} shadowOptions
		 */
		shadow: function (shadowOptions, group, cutOff) {
			var shadows = [],
				i,
				element = this.element,
				renderer = this.renderer,
				shadow,
				elemStyle = element.style,
				markup,
				path = element.path,
				strokeWidth,
				modifiedPath,
				shadowWidth,
				shadowElementOpacity;

			// some times empty paths are not strings
			if (path && typeof path.value !== 'string') {
				path = 'x';
			}
			modifiedPath = path;

			if (shadowOptions) {
				shadowWidth = pick(shadowOptions.width, 3);
				shadowElementOpacity = (shadowOptions.opacity || 0.15) / shadowWidth;
				for (i = 1; i <= 3; i++) {

					strokeWidth = (shadowWidth * 2) + 1 - (2 * i);

					// Cut off shadows for stacked column items
					if (cutOff) {
						modifiedPath = this.cutOffPath(path.value, strokeWidth + 0.5);
					}

					markup = ['<shape isShadow="true" strokeweight="', strokeWidth,
						'" filled="false" path="', modifiedPath,
						'" coordsize="10 10" style="', element.style.cssText, '" />'];

					shadow = createElement(renderer.prepVML(markup),
						null, {
							left: pInt(elemStyle.left) + pick(shadowOptions.offsetX, 1),
							top: pInt(elemStyle.top) + pick(shadowOptions.offsetY, 1)
						}
					);
					if (cutOff) {
						shadow.cutOff = strokeWidth + 1;
					}

					// apply the opacity
					markup = ['<stroke color="', shadowOptions.color || 'black', '" opacity="', shadowElementOpacity * i, '"/>'];
					createElement(renderer.prepVML(markup), null, null, shadow);


					// insert it
					if (group) {
						group.element.appendChild(shadow);
					} else {
						element.parentNode.insertBefore(shadow, element);
					}

					// record it
					shadows.push(shadow);

				}

				this.shadows = shadows;
			}
			return this;
		},
		updateShadows: noop, // Used in SVG only

		setAttr: function (key, value) {
			if (docMode8) { // IE8 setAttribute bug
				this.element[key] = value;
			} else {
				this.element.setAttribute(key, value);
			}
		},
		classSetter: function (value) {
			// IE8 Standards mode has problems retrieving the className unless set like this
			this.element.className = value;
		},
		dashstyleSetter: function (value, key, element) {
			var strokeElem = element.getElementsByTagName('stroke')[0] ||
				createElement(this.renderer.prepVML(['<stroke/>']), null, null, element);
			strokeElem[key] = value || 'solid';
			this[key] = value; /* because changing stroke-width will change the dash length
				and cause an epileptic effect */
		},
		dSetter: function (value, key, element) {
			var i,
				shadows = this.shadows;
			value = value || [];
			this.d = value.join && value.join(' '); // used in getter for animation

			element.path = value = this.pathToVML(value);

			// update shadows
			if (shadows) {
				i = shadows.length;
				while (i--) {
					shadows[i].path = shadows[i].cutOff ? this.cutOffPath(value, shadows[i].cutOff) : value;
				}
			}
			this.setAttr(key, value);
		},
		fillSetter: function (value, key, element) {
			var nodeName = element.nodeName;
			if (nodeName === 'SPAN') { // text color
				element.style.color = value;
			} else if (nodeName !== 'IMG') { // #1336
				element.filled = value !== NONE;
				this.setAttr('fillcolor', this.renderer.color(value, element, key, this));
			}
		},
		opacitySetter: noop, // Don't bother - animation is too slow and filters introduce artifacts
		rotationSetter: function (value, key, element) {
			var style = element.style;
			this[key] = style[key] = value; // style is for #1873

			// Correction for the 1x1 size of the shape container. Used in gauge needles.
			style.left = -mathRound(mathSin(value * deg2rad) + 1) + PX;
			style.top = mathRound(mathCos(value * deg2rad)) + PX;
		},
		strokeSetter: function (value, key, element) {
			this.setAttr('strokecolor', this.renderer.color(value, element, key));
		},
		'stroke-widthSetter': function (value, key, element) {
			element.stroked = !!value; // VML "stroked" attribute
			this[key] = value; // used in getter, issue #113
			if (isNumber(value)) {
				value += PX;
			}
			this.setAttr('strokeweight', value);
		},
		titleSetter: function (value, key) {
			this.setAttr(key, value);
		},
		visibilitySetter: function (value, key, element) {

			// Handle inherited visibility
			if (value === 'inherit') {
				value = VISIBLE;
			}
			
			// Let the shadow follow the main element
			if (this.shadows) {
				each(this.shadows, function (shadow) {
					shadow.style[key] = value;
				});
			}

			// Instead of toggling the visibility CSS property, move the div out of the viewport.
			// This works around #61 and #586
			if (element.nodeName === 'DIV') {
				value = value === HIDDEN ? '-999em' : 0;

				// In order to redraw, IE7 needs the div to be visible when tucked away
				// outside the viewport. So the visibility is actually opposite of
				// the expected value. This applies to the tooltip only.
				if (!docMode8) {
					element.style[key] = value ? VISIBLE : HIDDEN;
				}
				key = 'top';
			}
			element.style[key] = value;
		},
		xSetter: function (value, key, element) {
			this[key] = value; // used in getter

			if (key === 'x') {
				key = 'left';
			} else if (key === 'y') {
				key = 'top';
			}/* else {
				value = mathMax(0, value); // don't set width or height below zero (#311)
			}*/

			// clipping rectangle special
			if (this.updateClipping) {
				this[key] = value; // the key is now 'left' or 'top' for 'x' and 'y'
				this.updateClipping();
			} else {
				// normal
				element.style[key] = value;
			}
		},
		zIndexSetter: function (value, key, element) {
			element.style[key] = value;
		}
	};
	Highcharts.VMLElement = VMLElement = extendClass(SVGElement, VMLElement);

	// Some shared setters
	VMLElement.prototype.ySetter =
		VMLElement.prototype.widthSetter = 
		VMLElement.prototype.heightSetter = 
		VMLElement.prototype.xSetter;


	/**
	 * The VML renderer
	 */
	var VMLRendererExtension = { // inherit SVGRenderer

		Element: VMLElement,
		isIE8: userAgent.indexOf('MSIE 8.0') > -1,


		/**
		 * Initialize the VMLRenderer
		 * @param {Object} container
		 * @param {Number} width
		 * @param {Number} height
		 */
		init: function (container, width, height, style) {
			var renderer = this,
				boxWrapper,
				box,
				css;

			renderer.alignedObjects = [];

			boxWrapper = renderer.createElement(DIV)
				.css(extend(this.getStyle(style), { position: RELATIVE}));
			box = boxWrapper.element;
			container.appendChild(boxWrapper.element);


			// generate the containing box
			renderer.isVML = true;
			renderer.box = box;
			renderer.boxWrapper = boxWrapper;
			renderer.cache = {};


			renderer.setSize(width, height, false);

			// The only way to make IE6 and IE7 print is to use a global namespace. However,
			// with IE8 the only way to make the dynamic shapes visible in screen and print mode
			// seems to be to add the xmlns attribute and the behaviour style inline.
			if (!doc.namespaces.hcv) {

				doc.namespaces.add('hcv', 'urn:schemas-microsoft-com:vml');

				// Setup default CSS (#2153, #2368, #2384)
				css = 'hcv\\:fill, hcv\\:path, hcv\\:shape, hcv\\:stroke' +
					'{ behavior:url(#default#VML); display: inline-block; } ';
				try {
					doc.createStyleSheet().cssText = css;
				} catch (e) {
					doc.styleSheets[0].cssText += css;
				}

			}
		},


		/**
		 * Detect whether the renderer is hidden. This happens when one of the parent elements
		 * has display: none
		 */
		isHidden: function () {
			return !this.box.offsetWidth;
		},

		/**
		 * Define a clipping rectangle. In VML it is accomplished by storing the values
		 * for setting the CSS style to all associated members.
		 *
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Number} width
		 * @param {Number} height
		 */
		clipRect: function (x, y, width, height) {

			// create a dummy element
			var clipRect = this.createElement(),
				isObj = isObject(x);

			// mimic a rectangle with its style object for automatic updating in attr
			return extend(clipRect, {
				members: [],
				count: 0,
				left: (isObj ? x.x : x) + 1,
				top: (isObj ? x.y : y) + 1,
				width: (isObj ? x.width : width) - 1,
				height: (isObj ? x.height : height) - 1,
				getCSS: function (wrapper) {
					var element = wrapper.element,
						nodeName = element.nodeName,
						isShape = nodeName === 'shape',
						inverted = wrapper.inverted,
						rect = this,
						top = rect.top - (isShape ? element.offsetTop : 0),
						left = rect.left,
						right = left + rect.width,
						bottom = top + rect.height,
						ret = {
							clip: 'rect(' +
								mathRound(inverted ? left : top) + 'px,' +
								mathRound(inverted ? bottom : right) + 'px,' +
								mathRound(inverted ? right : bottom) + 'px,' +
								mathRound(inverted ? top : left) + 'px)'
						};

					// issue 74 workaround
					if (!inverted && docMode8 && nodeName === 'DIV') {
						extend(ret, {
							width: right + PX,
							height: bottom + PX
						});
					}
					return ret;
				},

				// used in attr and animation to update the clipping of all members
				updateClipping: function () {
					each(clipRect.members, function (member) {
						if (member.element) { // Deleted series, like in stock/members/series-remove demo. Should be removed from members, but this will do.
							member.css(clipRect.getCSS(member));
						}
					});
				}
			});

		},


		/**
		 * Take a color and return it if it's a string, make it a gradient if it's a
		 * gradient configuration object, and apply opacity.
		 *
		 * @param {Object} color The color or config object
		 */
		color: function (color, elem, prop, wrapper) {
			var renderer = this,
				colorObject,
				regexRgba = /^rgba/,
				markup,
				fillType,
				ret = NONE;

			// Check for linear or radial gradient
			if (color && color.linearGradient) {
				fillType = 'gradient';
			} else if (color && color.radialGradient) {
				fillType = 'pattern';
			}


			if (fillType) {

				var stopColor,
					stopOpacity,
					gradient = color.linearGradient || color.radialGradient,
					x1,
					y1,
					x2,
					y2,
					opacity1,
					opacity2,
					color1,
					color2,
					fillAttr = '',
					stops = color.stops,
					firstStop,
					lastStop,
					colors = [],
					addFillNode = function () {
						// Add the fill subnode. When colors attribute is used, the meanings of opacity and o:opacity2
						// are reversed.
						markup = ['<fill colors="' + colors.join(',') + '" opacity="', opacity2, '" o:opacity2="', opacity1,
							'" type="', fillType, '" ', fillAttr, 'focus="100%" method="any" />'];
						createElement(renderer.prepVML(markup), null, null, elem);
					};

				// Extend from 0 to 1
				firstStop = stops[0];
				lastStop = stops[stops.length - 1];
				if (firstStop[0] > 0) {
					stops.unshift([
						0,
						firstStop[1]
					]);
				}
				if (lastStop[0] < 1) {
					stops.push([
						1,
						lastStop[1]
					]);
				}

				// Compute the stops
				each(stops, function (stop, i) {
					if (regexRgba.test(stop[1])) {
						colorObject = Color(stop[1]);
						stopColor = colorObject.get('rgb');
						stopOpacity = colorObject.get('a');
					} else {
						stopColor = stop[1];
						stopOpacity = 1;
					}

					// Build the color attribute
					colors.push((stop[0] * 100) + '% ' + stopColor);

					// Only start and end opacities are allowed, so we use the first and the last
					if (!i) {
						opacity1 = stopOpacity;
						color2 = stopColor;
					} else {
						opacity2 = stopOpacity;
						color1 = stopColor;
					}
				});

				// Apply the gradient to fills only.
				if (prop === 'fill') {

					// Handle linear gradient angle
					if (fillType === 'gradient') {
						x1 = gradient.x1 || gradient[0] || 0;
						y1 = gradient.y1 || gradient[1] || 0;
						x2 = gradient.x2 || gradient[2] || 0;
						y2 = gradient.y2 || gradient[3] || 0;
						fillAttr = 'angle="' + (90  - math.atan(
							(y2 - y1) / // y vector
							(x2 - x1) // x vector
							) * 180 / mathPI) + '"';

						addFillNode();

					// Radial (circular) gradient
					} else {

						var r = gradient.r,
							sizex = r * 2,
							sizey = r * 2,
							cx = gradient.cx,
							cy = gradient.cy,
							radialReference = elem.radialReference,
							bBox,
							applyRadialGradient = function () {
								if (radialReference) {
									bBox = wrapper.getBBox();
									cx += (radialReference[0] - bBox.x) / bBox.width - 0.5;
									cy += (radialReference[1] - bBox.y) / bBox.height - 0.5;
									sizex *= radialReference[2] / bBox.width;
									sizey *= radialReference[2] / bBox.height;
								}
								fillAttr = 'src="' + defaultOptions.global.VMLRadialGradientURL + '" ' +
									'size="' + sizex + ',' + sizey + '" ' +
									'origin="0.5,0.5" ' +
									'position="' + cx + ',' + cy + '" ' +
									'color2="' + color2 + '" ';

								addFillNode();
							};

						// Apply radial gradient
						if (wrapper.added) {
							applyRadialGradient();
						} else {
							// We need to know the bounding box to get the size and position right
							wrapper.onAdd = applyRadialGradient;
						}

						// The fill element's color attribute is broken in IE8 standards mode, so we
						// need to set the parent shape's fillcolor attribute instead.
						ret = color1;
					}

				// Gradients are not supported for VML stroke, return the first color. #722.
				} else {
					ret = stopColor;
				}

			// if the color is an rgba color, split it and add a fill node
			// to hold the opacity component
			} else if (regexRgba.test(color) && elem.tagName !== 'IMG') {

				colorObject = Color(color);

				markup = ['<', prop, ' opacity="', colorObject.get('a'), '"/>'];
				createElement(this.prepVML(markup), null, null, elem);

				ret = colorObject.get('rgb');


			} else {
				var propNodes = elem.getElementsByTagName(prop); // 'stroke' or 'fill' node
				if (propNodes.length) {
					propNodes[0].opacity = 1;
					propNodes[0].type = 'solid';
				}
				ret = color;
			}

			return ret;
		},

		/**
		 * Take a VML string and prepare it for either IE8 or IE6/IE7.
		 * @param {Array} markup A string array of the VML markup to prepare
		 */
		prepVML: function (markup) {
			var vmlStyle = 'display:inline-block;behavior:url(#default#VML);',
				isIE8 = this.isIE8;

			markup = markup.join('');

			if (isIE8) { // add xmlns and style inline
				markup = markup.replace('/>', ' xmlns="urn:schemas-microsoft-com:vml" />');
				if (markup.indexOf('style="') === -1) {
					markup = markup.replace('/>', ' style="' + vmlStyle + '" />');
				} else {
					markup = markup.replace('style="', 'style="' + vmlStyle);
				}

			} else { // add namespace
				markup = markup.replace('<', '<hcv:');
			}

			return markup;
		},

		/**
		 * Create rotated and aligned text
		 * @param {String} str
		 * @param {Number} x
		 * @param {Number} y
		 */
		text: SVGRenderer.prototype.html,

		/**
		 * Create and return a path element
		 * @param {Array} path
		 */
		path: function (path) {
			var attr = {
				// subpixel precision down to 0.1 (width and height = 1px)
				coordsize: '10 10'
			};
			if (isArray(path)) {
				attr.d = path;
			} else if (isObject(path)) { // attributes
				extend(attr, path);
			}
			// create the shape
			return this.createElement('shape').attr(attr);
		},

		/**
		 * Create and return a circle element. In VML circles are implemented as
		 * shapes, which is faster than v:oval
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Number} r
		 */
		circle: function (x, y, r) {
			var circle = this.symbol('circle');
			if (isObject(x)) {
				r = x.r;
				y = x.y;
				x = x.x;
			}
			circle.isCircle = true; // Causes x and y to mean center (#1682)
			circle.r = r;
			return circle.attr({ x: x, y: y });
		},

		/**
		 * Create a group using an outer div and an inner v:group to allow rotating
		 * and flipping. A simple v:group would have problems with positioning
		 * child HTML elements and CSS clip.
		 *
		 * @param {String} name The name of the group
		 */
		g: function (name) {
			var wrapper,
				attribs;

			// set the class name
			if (name) {
				attribs = { 'className': PREFIX + name, 'class': PREFIX + name };
			}

			// the div to hold HTML and clipping
			wrapper = this.createElement(DIV).attr(attribs);

			return wrapper;
		},

		/**
		 * VML override to create a regular HTML image
		 * @param {String} src
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Number} width
		 * @param {Number} height
		 */
		image: function (src, x, y, width, height) {
			var obj = this.createElement('img')
				.attr({ src: src });

			if (arguments.length > 1) {
				obj.attr({
					x: x,
					y: y,
					width: width,
					height: height
				});
			}
			return obj;
		},

		/**
		 * For rectangles, VML uses a shape for rect to overcome bugs and rotation problems
		 */
		createElement: function (nodeName) {
			return nodeName === 'rect' ? this.symbol(nodeName) : SVGRenderer.prototype.createElement.call(this, nodeName);	
		},

		/**
		 * In the VML renderer, each child of an inverted div (group) is inverted
		 * @param {Object} element
		 * @param {Object} parentNode
		 */
		invertChild: function (element, parentNode) {
			var ren = this,
				parentStyle = parentNode.style,
				imgStyle = element.tagName === 'IMG' && element.style; // #1111

			css(element, {
				flip: 'x',
				left: pInt(parentStyle.width) - (imgStyle ? pInt(imgStyle.top) : 1),
				top: pInt(parentStyle.height) - (imgStyle ? pInt(imgStyle.left) : 1),
				rotation: -90
			});

			// Recursively invert child elements, needed for nested composite shapes like box plots and error bars. #1680, #1806.
			each(element.childNodes, function (child) {
				ren.invertChild(child, element);
			});
		},

		/**
		 * Symbol definitions that override the parent SVG renderer's symbols
		 *
		 */
		symbols: {
			// VML specific arc function
			arc: function (x, y, w, h, options) {
				var start = options.start,
					end = options.end,
					radius = options.r || w || h,
					innerRadius = options.innerR,
					cosStart = mathCos(start),
					sinStart = mathSin(start),
					cosEnd = mathCos(end),
					sinEnd = mathSin(end),
					ret;

				if (end - start === 0) { // no angle, don't show it.
					return ['x'];
				}

				ret = [
					'wa', // clockwise arc to
					x - radius, // left
					y - radius, // top
					x + radius, // right
					y + radius, // bottom
					x + radius * cosStart, // start x
					y + radius * sinStart, // start y
					x + radius * cosEnd, // end x
					y + radius * sinEnd  // end y
				];

				if (options.open && !innerRadius) {
					ret.push(
						'e',
						M,
						x,// - innerRadius,
						y// - innerRadius
					);
				}

				ret.push(
					'at', // anti clockwise arc to
					x - innerRadius, // left
					y - innerRadius, // top
					x + innerRadius, // right
					y + innerRadius, // bottom
					x + innerRadius * cosEnd, // start x
					y + innerRadius * sinEnd, // start y
					x + innerRadius * cosStart, // end x
					y + innerRadius * sinStart, // end y
					'x', // finish path
					'e' // close
				);

				ret.isArc = true;
				return ret;

			},
			// Add circle symbol path. This performs significantly faster than v:oval.
			circle: function (x, y, w, h, wrapper) {

				if (wrapper) {
					w = h = 2 * wrapper.r;
				}

				// Center correction, #1682
				if (wrapper && wrapper.isCircle) {
					x -= w / 2;
					y -= h / 2;
				}

				// Return the path
				return [
					'wa', // clockwisearcto
					x, // left
					y, // top
					x + w, // right
					y + h, // bottom
					x + w, // start x
					y + h / 2,     // start y
					x + w, // end x
					y + h / 2,     // end y
					//'x', // finish path
					'e' // close
				];
			},
			/**
			 * Add rectangle symbol path which eases rotation and omits arcsize problems
			 * compared to the built-in VML roundrect shape. When borders are not rounded,
			 * use the simpler square path, else use the callout path without the arrow.
			 */
			rect: function (x, y, w, h, options) {
				return SVGRenderer.prototype.symbols[
					!defined(options) || !options.r ? 'square' : 'callout'
				].call(0, x, y, w, h, options);
			}
		}
	};
	Highcharts.VMLRenderer = VMLRenderer = function () {
		this.init.apply(this, arguments);
	};
	VMLRenderer.prototype = merge(SVGRenderer.prototype, VMLRendererExtension);

		// general renderer
		Renderer = VMLRenderer;
	}

	// This method is used with exporting in old IE, when emulating SVG (see #2314)
	SVGRenderer.prototype.measureSpanWidth = function (text, styles) {
		var measuringSpan = doc.createElement('span'),
			offsetWidth,
		textNode = doc.createTextNode(text);

		measuringSpan.appendChild(textNode);
		css(measuringSpan, styles);
		this.box.appendChild(measuringSpan);
		offsetWidth = measuringSpan.offsetWidth;
		discardElement(measuringSpan); // #2463
		return offsetWidth;
	};


	/* ****************************************************************************
	 *                                                                            *
	 * END OF INTERNET EXPLORER <= 8 SPECIFIC CODE                                *
	 *                                                                            *
	 *****************************************************************************/
	/* ****************************************************************************
	 *                                                                            *
	 * START OF ANDROID < 3 SPECIFIC CODE. THIS CAN BE REMOVED IF YOU'RE NOT      *
	 * TARGETING THAT SYSTEM.                                                     *
	 *                                                                            *
	 *****************************************************************************/
	var CanVGRenderer,
		CanVGController;

	if (useCanVG) {
		/**
		 * The CanVGRenderer is empty from start to keep the source footprint small.
		 * When requested, the CanVGController downloads the rest of the source packaged
		 * together with the canvg library.
		 */
		Highcharts.CanVGRenderer = CanVGRenderer = function () {
			// Override the global SVG namespace to fake SVG/HTML that accepts CSS
			SVG_NS = 'http://www.w3.org/1999/xhtml';
		};

		/**
		 * Start with an empty symbols object. This is needed when exporting is used (exporting.src.js will add a few symbols), but 
		 * the implementation from SvgRenderer will not be merged in until first render.
		 */
		CanVGRenderer.prototype.symbols = {};

		/**
		 * Handles on demand download of canvg rendering support.
		 */
		CanVGController = (function () {
			// List of renderering calls
			var deferredRenderCalls = [];

			/**
			 * When downloaded, we are ready to draw deferred charts.
			 */
			function drawDeferred() {
				var callLength = deferredRenderCalls.length,
					callIndex;

				// Draw all pending render calls
				for (callIndex = 0; callIndex < callLength; callIndex++) {
					deferredRenderCalls[callIndex]();
				}
				// Clear the list
				deferredRenderCalls = [];
			}

			return {
				push: function (func, scriptLocation) {
					// Only get the script once
					if (deferredRenderCalls.length === 0) {
						getScript(scriptLocation, drawDeferred);
					}
					// Register render call
					deferredRenderCalls.push(func);
				}
			};
		}());

		Renderer = CanVGRenderer;
	} // end CanVGRenderer

	/* ****************************************************************************
	 *                                                                            *
	 * END OF ANDROID < 3 SPECIFIC CODE                                           *
	 *                                                                            *
	 *****************************************************************************/

	/**
	 * The Tick class
	 */
	function Tick(axis, pos, type, noLabel) {
		this.axis = axis;
		this.pos = pos;
		this.type = type || '';
		this.isNew = true;

		if (!type && !noLabel) {
			this.addLabel();
		}
	}

	Tick.prototype = {
		/**
		 * Write the tick label
		 */
		addLabel: function () {
			var tick = this,
				axis = tick.axis,
				options = axis.options,
				chart = axis.chart,
				categories = axis.categories,
				names = axis.names,
				pos = tick.pos,
				labelOptions = options.labels,
				str,
				tickPositions = axis.tickPositions,
				isFirst = pos === tickPositions[0],
				isLast = pos === tickPositions[tickPositions.length - 1],
				value = categories ?
					pick(categories[pos], names[pos], pos) :
					pos,
				label = tick.label,
				tickPositionInfo = tickPositions.info,
				dateTimeLabelFormat;

			// Set the datetime label format. If a higher rank is set for this position, use that. If not,
			// use the general format.
			if (axis.isDatetimeAxis && tickPositionInfo) {
				dateTimeLabelFormat = options.dateTimeLabelFormats[tickPositionInfo.higherRanks[pos] || tickPositionInfo.unitName];
			}
			// set properties for access in render method
			tick.isFirst = isFirst;
			tick.isLast = isLast;

			// get the string
			str = axis.labelFormatter.call({
				axis: axis,
				chart: chart,
				isFirst: isFirst,
				isLast: isLast,
				dateTimeLabelFormat: dateTimeLabelFormat,
				value: axis.isLog ? correctFloat(lin2log(value)) : value
			});

			// prepare CSS
			//css = width && { width: mathMax(1, mathRound(width - 2 * (labelOptions.padding || 10))) + PX };
			
			// first call
			if (!defined(label)) {

				tick.label = label =
					defined(str) && labelOptions.enabled ?
						chart.renderer.text(
								str,
								0,
								0,
								labelOptions.useHTML
							)
							//.attr(attr)
							// without position absolute, IE export sometimes is wrong
							.css(merge(labelOptions.style))
							.add(axis.labelGroup) :
						null;
				tick.labelLength = label && label.getBBox().width; // Un-rotated length
				tick.rotation = 0; // Base value to detect change for new calls to getBBox

			// update
			} else if (label) {
				label.attr({ text: str });
			}
		},

		/**
		 * Get the offset height or width of the label
		 */
		getLabelSize: function () {
			return this.label ?
				this.label.getBBox()[this.axis.horiz ? 'height' : 'width'] :
				0;
		},

		/**
		 * Handle the label overflow by adjusting the labels to the left and right edge, or
		 * hide them if they collide into the neighbour label.
		 */
		handleOverflow: function (xy) {
			var axis = this.axis,
				pxPos = xy.x,
				chartWidth = axis.chart.chartWidth,
				spacing = axis.chart.spacing,
				leftBound = pick(axis.labelLeft, mathMin(axis.pos, spacing[3])),
				rightBound = pick(axis.labelRight, mathMax(axis.pos + axis.len, chartWidth - spacing[1])),
				label = this.label,
				rotation = this.rotation,
				factor = { left: 0, center: 0.5, right: 1 }[axis.labelAlign],
				labelWidth = label.getBBox().width,
				slotWidth = axis.slotWidth,
				xCorrection = factor,
				goRight = 1,
				leftPos,
				rightPos,
				textWidth,
				css = {};

			// Check if the label overshoots the chart spacing box. If it does, move it.
			// If it now overshoots the slotWidth, add ellipsis.
			if (!rotation) {
				leftPos = pxPos - factor * labelWidth;
				rightPos = pxPos + (1 - factor) * labelWidth;

				if (leftPos < leftBound) {
					slotWidth = xy.x + slotWidth * (1 - factor) - leftBound;
				} else if (rightPos > rightBound) {
					slotWidth = rightBound - xy.x + slotWidth * factor;
					goRight = -1;
				}

				slotWidth = mathMin(axis.slotWidth, slotWidth); // #4177
				if (slotWidth < axis.slotWidth && axis.labelAlign === 'center') {
					xy.x += goRight * (axis.slotWidth - slotWidth - xCorrection * (axis.slotWidth - mathMin(labelWidth, slotWidth)));				
				}
				// If the label width exceeds the available space, set a text width to be 
				// picked up below. Also, if a width has been set before, we need to set a new
				// one because the reported labelWidth will be limited by the box (#3938).
				if (labelWidth > slotWidth || (axis.autoRotation && label.styles.width)) {
					textWidth = slotWidth;
				}

			// Add ellipsis to prevent rotated labels to be clipped against the edge of the chart
			} else if (rotation < 0 && pxPos - factor * labelWidth < leftBound) {
				textWidth = mathRound(pxPos / mathCos(rotation * deg2rad) - leftBound);
			} else if (rotation > 0 && pxPos + factor * labelWidth > rightBound) {
				textWidth = mathRound((chartWidth - pxPos) / mathCos(rotation * deg2rad));
			}

			if (textWidth) {
				css.width = textWidth;
				if (!axis.options.labels.style.textOverflow) {
					css.textOverflow = 'ellipsis';
				}
				label.css(css);
			}
		},

		/**
		 * Get the x and y position for ticks and labels
		 */
		getPosition: function (horiz, pos, tickmarkOffset, old) {
			var axis = this.axis,
				chart = axis.chart,
				cHeight = (old && chart.oldChartHeight) || chart.chartHeight;

			return {
				x: horiz ?
					axis.translate(pos + tickmarkOffset, null, null, old) + axis.transB :
					axis.left + axis.offset + (axis.opposite ? ((old && chart.oldChartWidth) || chart.chartWidth) - axis.right - axis.left : 0),

				y: horiz ?
					cHeight - axis.bottom + axis.offset - (axis.opposite ? axis.height : 0) :
					cHeight - axis.translate(pos + tickmarkOffset, null, null, old) - axis.transB
			};

		},

		/**
		 * Get the x, y position of the tick label
		 */
		getLabelPosition: function (x, y, label, horiz, labelOptions, tickmarkOffset, index, step) {
			var axis = this.axis,
				transA = axis.transA,
				reversed = axis.reversed,
				staggerLines = axis.staggerLines,
				rotCorr = axis.tickRotCorr || { x: 0, y: 0 },
				yOffset = pick(labelOptions.y, rotCorr.y + (axis.side === 2 ? 8 : -(label.getBBox().height / 2))),
				line;

			x = x + labelOptions.x + rotCorr.x - (tickmarkOffset && horiz ?
				tickmarkOffset * transA * (reversed ? -1 : 1) : 0);
			y = y + yOffset - (tickmarkOffset && !horiz ?
				tickmarkOffset * transA * (reversed ? 1 : -1) : 0);

			// Correct for staggered labels
			if (staggerLines) {
				line = (index / (step || 1) % staggerLines);
				y += line * (axis.labelOffset / staggerLines);
			}

			return {
				x: x,
				y: mathRound(y)
			};
		},

		/**
		 * Extendible method to return the path of the marker
		 */
		getMarkPath: function (x, y, tickLength, tickWidth, horiz, renderer) {
			return renderer.crispLine([
					M,
					x,
					y,
					L,
					x + (horiz ? 0 : -tickLength),
					y + (horiz ? tickLength : 0)
				], tickWidth);
		},

		/**
		 * Put everything in place
		 *
		 * @param index {Number}
		 * @param old {Boolean} Use old coordinates to prepare an animation into new position
		 */
		render: function (index, old, opacity) {
			var tick = this,
				axis = tick.axis,
				options = axis.options,
				chart = axis.chart,
				renderer = chart.renderer,
				horiz = axis.horiz,
				type = tick.type,
				label = tick.label,
				pos = tick.pos,
				labelOptions = options.labels,
				gridLine = tick.gridLine,
				gridPrefix = type ? type + 'Grid' : 'grid',
				tickPrefix = type ? type + 'Tick' : 'tick',
				gridLineWidth = options[gridPrefix + 'LineWidth'],
				gridLineColor = options[gridPrefix + 'LineColor'],
				dashStyle = options[gridPrefix + 'LineDashStyle'],
				tickLength = options[tickPrefix + 'Length'],
				tickWidth = options[tickPrefix + 'Width'] || 0,
				tickColor = options[tickPrefix + 'Color'],
				tickPosition = options[tickPrefix + 'Position'],
				gridLinePath,
				mark = tick.mark,
				markPath,
				step = /*axis.labelStep || */labelOptions.step,
				attribs,
				show = true,
				tickmarkOffset = axis.tickmarkOffset,
				xy = tick.getPosition(horiz, pos, tickmarkOffset, old),
				x = xy.x,
				y = xy.y,
				reverseCrisp = ((horiz && x === axis.pos + axis.len) || (!horiz && y === axis.pos)) ? -1 : 1; // #1480, #1687

			opacity = pick(opacity, 1);
			this.isActive = true;

			// create the grid line
			if (gridLineWidth) {
				gridLinePath = axis.getPlotLinePath(pos + tickmarkOffset, gridLineWidth * reverseCrisp, old, true);

				if (gridLine === UNDEFINED) {
					attribs = {
						stroke: gridLineColor,
						'stroke-width': gridLineWidth
					};
					if (dashStyle) {
						attribs.dashstyle = dashStyle;
					}
					if (!type) {
						attribs.zIndex = 1;
					}
					if (old) {
						attribs.opacity = 0;
					}
					tick.gridLine = gridLine =
						gridLineWidth ?
							renderer.path(gridLinePath)
								.attr(attribs).add(axis.gridGroup) :
							null;
				}

				// If the parameter 'old' is set, the current call will be followed
				// by another call, therefore do not do any animations this time
				if (!old && gridLine && gridLinePath) {
					gridLine[tick.isNew ? 'attr' : 'animate']({
						d: gridLinePath,
						opacity: opacity
					});
				}
			}

			// create the tick mark
			if (tickWidth && tickLength) {

				// negate the length
				if (tickPosition === 'inside') {
					tickLength = -tickLength;
				}
				if (axis.opposite) {
					tickLength = -tickLength;
				}

				markPath = tick.getMarkPath(x, y, tickLength, tickWidth * reverseCrisp, horiz, renderer);
				if (mark) { // updating
					mark.animate({
						d: markPath,
						opacity: opacity
					});
				} else { // first time
					tick.mark = renderer.path(
						markPath
					).attr({
						stroke: tickColor,
						'stroke-width': tickWidth,
						opacity: opacity
					}).add(axis.axisGroup);
				}
			}

			// the label is created on init - now move it into place
			if (label && !isNaN(x)) {
				label.xy = xy = tick.getLabelPosition(x, y, label, horiz, labelOptions, tickmarkOffset, index, step);

				// Apply show first and show last. If the tick is both first and last, it is
				// a single centered tick, in which case we show the label anyway (#2100).
				if ((tick.isFirst && !tick.isLast && !pick(options.showFirstLabel, 1)) ||
						(tick.isLast && !tick.isFirst && !pick(options.showLastLabel, 1))) {
					show = false;

				// Handle label overflow and show or hide accordingly
				} else if (horiz && !axis.isRadial && !labelOptions.step && !labelOptions.rotation && !old && opacity !== 0) {
					tick.handleOverflow(xy);
				}

				// apply step
				if (step && index % step) {
					// show those indices dividable by step
					show = false;
				}

				// Set the new position, and show or hide
				if (show && !isNaN(xy.y)) {
					xy.opacity = opacity;
					label[tick.isNew ? 'attr' : 'animate'](xy);
					tick.isNew = false;
				} else {
					label.attr('y', -9999); // #1338
				}
			}
		},

		/**
		 * Destructor for the tick prototype
		 */
		destroy: function () {
			destroyObjectProperties(this, this.axis);
		}
	};

	/**
	 * The object wrapper for plot lines and plot bands
	 * @param {Object} options
	 */
	Highcharts.PlotLineOrBand = function (axis, options) {
		this.axis = axis;

		if (options) {
			this.options = options;
			this.id = options.id;
		}
	};

	Highcharts.PlotLineOrBand.prototype = {
		
		/**
		 * Render the plot line or plot band. If it is already existing,
		 * move it.
		 */
		render: function () {
			var plotLine = this,
				axis = plotLine.axis,
				horiz = axis.horiz,
				options = plotLine.options,
				optionsLabel = options.label,
				label = plotLine.label,
				width = options.width,
				to = options.to,
				from = options.from,
				isBand = defined(from) && defined(to),
				value = options.value,
				dashStyle = options.dashStyle,
				svgElem = plotLine.svgElem,
				path = [],
				addEvent,
				eventType,
				xs,
				ys,
				x,
				y,
				color = options.color,
				zIndex = options.zIndex,
				events = options.events,
				attribs = {},
				renderer = axis.chart.renderer;

			// logarithmic conversion
			if (axis.isLog) {
				from = log2lin(from);
				to = log2lin(to);
				value = log2lin(value);
			}

			// plot line
			if (width) {
				path = axis.getPlotLinePath(value, width);
				attribs = {
					stroke: color,
					'stroke-width': width
				};
				if (dashStyle) {
					attribs.dashstyle = dashStyle;
				}
			} else if (isBand) { // plot band

				path = axis.getPlotBandPath(from, to, options);
				if (color) {
					attribs.fill = color;
				}
				if (options.borderWidth) {
					attribs.stroke = options.borderColor;
					attribs['stroke-width'] = options.borderWidth;
				}
			} else {
				return;
			}
			// zIndex
			if (defined(zIndex)) {
				attribs.zIndex = zIndex;
			}

			// common for lines and bands
			if (svgElem) {
				if (path) {
					svgElem.animate({
						d: path
					}, null, svgElem.onGetPath);
				} else {
					svgElem.hide();
					svgElem.onGetPath = function () {
						svgElem.show();
					};
					if (label) {
						plotLine.label = label = label.destroy();
					}
				}
			} else if (path && path.length) {
				plotLine.svgElem = svgElem = renderer.path(path)
					.attr(attribs).add();

				// events
				if (events) {
					addEvent = function (eventType) {
						svgElem.on(eventType, function (e) {
							events[eventType].apply(plotLine, [e]);
						});
					};
					for (eventType in events) {
						addEvent(eventType);
					}
				}
			}

			// the plot band/line label
			if (optionsLabel && defined(optionsLabel.text) && path && path.length && axis.width > 0 && axis.height > 0) {
				// apply defaults
				optionsLabel = merge({
					align: horiz && isBand && 'center',
					x: horiz ? !isBand && 4 : 10,
					verticalAlign : !horiz && isBand && 'middle',
					y: horiz ? isBand ? 16 : 10 : isBand ? 6 : -4,
					rotation: horiz && !isBand && 90
				}, optionsLabel);

				// add the SVG element
				if (!label) {
					attribs = {
						align: optionsLabel.textAlign || optionsLabel.align,
						rotation: optionsLabel.rotation
					};
					if (defined(zIndex)) {
						attribs.zIndex = zIndex;
					}
					plotLine.label = label = renderer.text(
							optionsLabel.text,
							0,
							0,
							optionsLabel.useHTML
						)
						.attr(attribs)
						.css(optionsLabel.style)
						.add();
				}

				// get the bounding box and align the label
				// #3000 changed to better handle choice between plotband or plotline
				xs = [path[1], path[4], (isBand ? path[6] : path[1])];
				ys = [path[2], path[5], (isBand ? path[7] : path[2])];
				x = arrayMin(xs);
				y = arrayMin(ys);

				label.align(optionsLabel, false, {
					x: x,
					y: y,
					width: arrayMax(xs) - x,
					height: arrayMax(ys) - y
				});
				label.show();

			} else if (label) { // move out of sight
				label.hide();
			}

			// chainable
			return plotLine;
		},

		/**
		 * Remove the plot line or band
		 */
		destroy: function () {
			// remove it from the lookup
			erase(this.axis.plotLinesAndBands, this);
			
			delete this.axis;
			destroyObjectProperties(this);
		}
	};

	/**
	 * Object with members for extending the Axis prototype
	 */

	AxisPlotLineOrBandExtension = {

		/**
		 * Create the path for a plot band
		 */ 
		getPlotBandPath: function (from, to) {
			var toPath = this.getPlotLinePath(to, null, null, true),
				path = this.getPlotLinePath(from, null, null, true);

			if (path && toPath && path.toString() !== toPath.toString()) { // #3836
				path.push(
					toPath[4],
					toPath[5],
					toPath[1],
					toPath[2]
				);
			} else { // outside the axis area
				path = null;
			}
			
			return path;
		},

		addPlotBand: function (options) {
			return this.addPlotBandOrLine(options, 'plotBands');
		},
		
		addPlotLine: function (options) {
			return this.addPlotBandOrLine(options, 'plotLines');
		},

		/**
		 * Add a plot band or plot line after render time
		 *
		 * @param options {Object} The plotBand or plotLine configuration object
		 */
		addPlotBandOrLine: function (options, coll) {
			var obj = new Highcharts.PlotLineOrBand(this, options).render(),
				userOptions = this.userOptions;

			if (obj) { // #2189
				// Add it to the user options for exporting and Axis.update
				if (coll) {
					userOptions[coll] = userOptions[coll] || [];
					userOptions[coll].push(options); 
				}
				this.plotLinesAndBands.push(obj); 
			}
			
			return obj;
		},

		/**
		 * Remove a plot band or plot line from the chart by id
		 * @param {Object} id
		 */
		removePlotBandOrLine: function (id) {
			var plotLinesAndBands = this.plotLinesAndBands,
				options = this.options,
				userOptions = this.userOptions,
				i = plotLinesAndBands.length;
			while (i--) {
				if (plotLinesAndBands[i].id === id) {
					plotLinesAndBands[i].destroy();
				}
			}
			each([options.plotLines || [], userOptions.plotLines || [], options.plotBands || [], userOptions.plotBands || []], function (arr) {
				i = arr.length;
				while (i--) {
					if (arr[i].id === id) {
						erase(arr, arr[i]);
					}
				}
			});
		}
	};

	/**
	 * Create a new axis object
	 * @param {Object} chart
	 * @param {Object} options
	 */
	var Axis = Highcharts.Axis = function () {
		this.init.apply(this, arguments);
	};

	Axis.prototype = {

		/**
		 * Default options for the X axis - the Y axis has extended defaults
		 */
		defaultOptions: {
			// allowDecimals: null,
			// alternateGridColor: null,
			// categories: [],
			dateTimeLabelFormats: {
				millisecond: '%H:%M:%S.%L',
				second: '%H:%M:%S',
				minute: '%H:%M',
				hour: '%H:%M',
				day: '%e. %b',
				week: '%e. %b',
				month: '%b \'%y',
				year: '%Y'
			},
			endOnTick: false,
			gridLineColor: '#D8D8D8',
			// gridLineDashStyle: 'solid',
			// gridLineWidth: 0,
			// reversed: false,

			labels: {
				enabled: true,
				// rotation: 0,
				// align: 'center',
				// step: null,
				style: {
					color: '#606060',
					cursor: 'default',
					fontSize: '11px'
				},
				x: 0,
				y: 15
				/*formatter: function () {
					return this.value;
				},*/
			},
			lineColor: '#C0D0E0',
			lineWidth: 1,
			//linkedTo: null,
			//max: undefined,
			//min: undefined,
			minPadding: 0.01,
			maxPadding: 0.01,
			//minRange: null,
			minorGridLineColor: '#E0E0E0',
			// minorGridLineDashStyle: null,
			minorGridLineWidth: 1,
			minorTickColor: '#A0A0A0',
			//minorTickInterval: null,
			minorTickLength: 2,
			minorTickPosition: 'outside', // inside or outside
			//minorTickWidth: 0,
			//opposite: false,
			//offset: 0,
			//plotBands: [{
			//	events: {},
			//	zIndex: 1,
			//	labels: { align, x, verticalAlign, y, style, rotation, textAlign }
			//}],
			//plotLines: [{
			//	events: {}
			//  dashStyle: {}
			//	zIndex:
			//	labels: { align, x, verticalAlign, y, style, rotation, textAlign }
			//}],
			//reversed: false,
			// showFirstLabel: true,
			// showLastLabel: true,
			startOfWeek: 1,
			startOnTick: false,
			tickColor: '#C0D0E0',
			//tickInterval: null,
			tickLength: 10,
			tickmarkPlacement: 'between', // on or between
			tickPixelInterval: 100,
			tickPosition: 'outside',
			tickWidth: 1,
			title: {
				//text: null,
				align: 'middle', // low, middle or high
				//margin: 0 for horizontal, 10 for vertical axes,
				//rotation: 0,
				//side: 'outside',
				style: {
					color: '#707070'
				}
				//x: 0,
				//y: 0
			},
			type: 'linear' // linear, logarithmic or datetime
		},

		/**
		 * This options set extends the defaultOptions for Y axes
		 */
		defaultYAxisOptions: {
			endOnTick: true,
			gridLineWidth: 1,
			tickPixelInterval: 72,
			showLastLabel: true,
			labels: {
				x: -8,
				y: 3
			},
			lineWidth: 0,
			maxPadding: 0.05,
			minPadding: 0.05,
			startOnTick: true,
			tickWidth: 0,
			title: {
				rotation: 270,
				text: 'Values'
			},
			stackLabels: {
				enabled: false,
				//align: dynamic,
				//y: dynamic,
				//x: dynamic,
				//verticalAlign: dynamic,
				//textAlign: dynamic,
				//rotation: 0,
				formatter: function () {
					return Highcharts.numberFormat(this.total, -1);
				},
				style: merge(defaultPlotOptions.line.dataLabels.style, { color: '#000000' })
			}
		},

		/**
		 * These options extend the defaultOptions for left axes
		 */
		defaultLeftAxisOptions: {
			labels: {
				x: -15,
				y: null
			},
			title: {
				rotation: 270
			}
		},

		/**
		 * These options extend the defaultOptions for right axes
		 */
		defaultRightAxisOptions: {
			labels: {
				x: 15,
				y: null
			},
			title: {
				rotation: 90
			}
		},

		/**
		 * These options extend the defaultOptions for bottom axes
		 */
		defaultBottomAxisOptions: {
			labels: {
				autoRotation: [-45],
				x: 0,
				y: null // based on font size
				// overflow: undefined,
				// staggerLines: null
			},
			title: {
				rotation: 0
			}
		},
		/**
		 * These options extend the defaultOptions for top axes
		 */
		defaultTopAxisOptions: {
			labels: {
				autoRotation: [-45],
				x: 0,
				y: -15
				// overflow: undefined
				// staggerLines: null
			},
			title: {
				rotation: 0
			}
		},

		/**
		 * Initialize the axis
		 */
		init: function (chart, userOptions) {


			var isXAxis = userOptions.isX,
				axis = this;

			// Flag, is the axis horizontal
			axis.horiz = chart.inverted ? !isXAxis : isXAxis;

			// Flag, isXAxis
			axis.isXAxis = isXAxis;
			axis.coll = isXAxis ? 'xAxis' : 'yAxis';

			axis.opposite = userOptions.opposite; // needed in setOptions
			axis.side = userOptions.side || (axis.horiz ?
					(axis.opposite ? 0 : 2) : // top : bottom
					(axis.opposite ? 1 : 3));  // right : left

			axis.setOptions(userOptions);


			var options = this.options,
				type = options.type,
				isDatetimeAxis = type === 'datetime';

			axis.labelFormatter = options.labels.formatter || axis.defaultLabelFormatter; // can be overwritten by dynamic format


			// Flag, stagger lines or not
			axis.userOptions = userOptions;

			//axis.axisTitleMargin = UNDEFINED,// = options.title.margin,
			axis.minPixelPadding = 0;
			//axis.ignoreMinPadding = UNDEFINED; // can be set to true by a column or bar series
			//axis.ignoreMaxPadding = UNDEFINED;

			axis.chart = chart;
			axis.reversed = options.reversed;
			axis.zoomEnabled = options.zoomEnabled !== false;

			// Initial categories
			axis.categories = options.categories || type === 'category';
			axis.names = axis.names || []; // Preserve on update (#3830)

			// Elements
			//axis.axisGroup = UNDEFINED;
			//axis.gridGroup = UNDEFINED;
			//axis.axisTitle = UNDEFINED;
			//axis.axisLine = UNDEFINED;

			// Shorthand types
			axis.isLog = type === 'logarithmic';
			axis.isDatetimeAxis = isDatetimeAxis;

			// Flag, if axis is linked to another axis
			axis.isLinked = defined(options.linkedTo);
			// Linked axis.
			//axis.linkedParent = UNDEFINED;

			// Tick positions
			//axis.tickPositions = UNDEFINED; // array containing predefined positions
			// Tick intervals
			//axis.tickInterval = UNDEFINED;
			//axis.minorTickInterval = UNDEFINED;

			
			// Major ticks
			axis.ticks = {};
			axis.labelEdge = [];
			// Minor ticks
			axis.minorTicks = {};

			// List of plotLines/Bands
			axis.plotLinesAndBands = [];

			// Alternate bands
			axis.alternateBands = {};

			// Axis metrics
			//axis.left = UNDEFINED;
			//axis.top = UNDEFINED;
			//axis.width = UNDEFINED;
			//axis.height = UNDEFINED;
			//axis.bottom = UNDEFINED;
			//axis.right = UNDEFINED;
			//axis.transA = UNDEFINED;
			//axis.transB = UNDEFINED;
			//axis.oldTransA = UNDEFINED;
			axis.len = 0;
			//axis.oldMin = UNDEFINED;
			//axis.oldMax = UNDEFINED;
			//axis.oldUserMin = UNDEFINED;
			//axis.oldUserMax = UNDEFINED;
			//axis.oldAxisLength = UNDEFINED;
			axis.minRange = axis.userMinRange = options.minRange || options.maxZoom;
			axis.range = options.range;
			axis.offset = options.offset || 0;


			// Dictionary for stacks
			axis.stacks = {};
			axis.oldStacks = {};
			
			// Min and max in the data
			//axis.dataMin = UNDEFINED,
			//axis.dataMax = UNDEFINED,

			// The axis range
			axis.max = null;
			axis.min = null;

			// User set min and max
			//axis.userMin = UNDEFINED,
			//axis.userMax = UNDEFINED,

			// Crosshair options
			axis.crosshair = pick(options.crosshair, splat(chart.options.tooltip.crosshairs)[isXAxis ? 0 : 1], false);
			// Run Axis

			var eventType,
				events = axis.options.events;

			// Register
			if (inArray(axis, chart.axes) === -1) { // don't add it again on Axis.update()
				if (isXAxis && !this.isColorAxis) { // #2713
					chart.axes.splice(chart.xAxis.length, 0, axis);
				} else {
					chart.axes.push(axis);
				}

				chart[axis.coll].push(axis);
			}

			axis.series = axis.series || []; // populated by Series

			// inverted charts have reversed xAxes as default
			if (chart.inverted && isXAxis && axis.reversed === UNDEFINED) {
				axis.reversed = true;
			}

			axis.removePlotBand = axis.removePlotBandOrLine;
			axis.removePlotLine = axis.removePlotBandOrLine;


			// register event listeners
			for (eventType in events) {
				addEvent(axis, eventType, events[eventType]);
			}

			// extend logarithmic axis
			if (axis.isLog) {
				axis.val2lin = log2lin;
				axis.lin2val = lin2log;
			}
		},

		/**
		 * Merge and set options
		 */
		setOptions: function (userOptions) {
			this.options = merge(
				this.defaultOptions,
				this.isXAxis ? {} : this.defaultYAxisOptions,
				[this.defaultTopAxisOptions, this.defaultRightAxisOptions,
					this.defaultBottomAxisOptions, this.defaultLeftAxisOptions][this.side],
				merge(
					defaultOptions[this.coll], // if set in setOptions (#1053)
					userOptions
				)
			);
		},

		/**
		 * The default label formatter. The context is a special config object for the label.
		 */
		defaultLabelFormatter: function () {
			var axis = this.axis,
				value = this.value,
				categories = axis.categories,
				dateTimeLabelFormat = this.dateTimeLabelFormat,
				numericSymbols = defaultOptions.lang.numericSymbols,
				i = numericSymbols && numericSymbols.length,
				multi,
				ret,
				formatOption = axis.options.labels.format,

				// make sure the same symbol is added for all labels on a linear axis
				numericSymbolDetector = axis.isLog ? value : axis.tickInterval;

			if (formatOption) {
				ret = format(formatOption, this);

			} else if (categories) {
				ret = value;

			} else if (dateTimeLabelFormat) { // datetime axis
				ret = dateFormat(dateTimeLabelFormat, value);

			} else if (i && numericSymbolDetector >= 1000) {
				// Decide whether we should add a numeric symbol like k (thousands) or M (millions).
				// If we are to enable this in tooltip or other places as well, we can move this
				// logic to the numberFormatter and enable it by a parameter.
				while (i-- && ret === UNDEFINED) {
					multi = Math.pow(1000, i + 1);
					if (numericSymbolDetector >= multi && (value * 10) % multi === 0 && numericSymbols[i] !== null) {
						ret = Highcharts.numberFormat(value / multi, -1) + numericSymbols[i];
					}
				}
			}

			if (ret === UNDEFINED) {
				if (mathAbs(value) >= 10000) { // add thousands separators
					ret = Highcharts.numberFormat(value, -1);

				} else { // small numbers
					ret = Highcharts.numberFormat(value, -1, UNDEFINED, ''); // #2466
				}
			}

			return ret;
		},

		/**
		 * Get the minimum and maximum for the series of each axis
		 */
		getSeriesExtremes: function () {
			var axis = this,
				chart = axis.chart;

			axis.hasVisibleSeries = false;

			// Reset properties in case we're redrawing (#3353)
			axis.dataMin = axis.dataMax = axis.ignoreMinPadding = axis.ignoreMaxPadding = null;
			
			if (axis.buildStacks) {
				axis.buildStacks();
			}

			// loop through this axis' series
			each(axis.series, function (series) {

				if (series.visible || !chart.options.chart.ignoreHiddenSeries) {

					var seriesOptions = series.options,
						xData,
						threshold = seriesOptions.threshold,
						seriesDataMin,
						seriesDataMax;

					axis.hasVisibleSeries = true;

					// Validate threshold in logarithmic axes
					if (axis.isLog && threshold <= 0) {
						threshold = null;
					}

					// Get dataMin and dataMax for X axes
					if (axis.isXAxis) {
						xData = series.xData;
						if (xData.length) {
							axis.dataMin = mathMin(pick(axis.dataMin, xData[0]), arrayMin(xData));
							axis.dataMax = mathMax(pick(axis.dataMax, xData[0]), arrayMax(xData));
						}

					// Get dataMin and dataMax for Y axes, as well as handle stacking and processed data
					} else {

						// Get this particular series extremes
						series.getExtremes();
						seriesDataMax = series.dataMax;
						seriesDataMin = series.dataMin;

						// Get the dataMin and dataMax so far. If percentage is used, the min and max are
						// always 0 and 100. If seriesDataMin and seriesDataMax is null, then series
						// doesn't have active y data, we continue with nulls
						if (defined(seriesDataMin) && defined(seriesDataMax)) {
							axis.dataMin = mathMin(pick(axis.dataMin, seriesDataMin), seriesDataMin);
							axis.dataMax = mathMax(pick(axis.dataMax, seriesDataMax), seriesDataMax);
						}

						// Adjust to threshold
						if (defined(threshold)) {
							if (axis.dataMin >= threshold) {
								axis.dataMin = threshold;
								axis.ignoreMinPadding = true;
							} else if (axis.dataMax < threshold) {
								axis.dataMax = threshold;
								axis.ignoreMaxPadding = true;
							}
						}
					}
				}
			});
		},

		/**
		 * Translate from axis value to pixel position on the chart, or back
		 *
		 */
		translate: function (val, backwards, cvsCoord, old, handleLog, pointPlacement) {
			var axis = this.linkedParent || this, // #1417
				sign = 1,
				cvsOffset = 0,
				localA = old ? axis.oldTransA : axis.transA,
				localMin = old ? axis.oldMin : axis.min,
				returnValue,
				minPixelPadding = axis.minPixelPadding,
				doPostTranslate = (axis.doPostTranslate || (axis.isLog && handleLog)) && axis.lin2val;

			if (!localA) {
				localA = axis.transA;
			}

			// In vertical axes, the canvas coordinates start from 0 at the top like in
			// SVG.
			if (cvsCoord) {
				sign *= -1; // canvas coordinates inverts the value
				cvsOffset = axis.len;
			}

			// Handle reversed axis
			if (axis.reversed) {
				sign *= -1;
				cvsOffset -= sign * (axis.sector || axis.len);
			}

			// From pixels to value
			if (backwards) { // reverse translation

				val = val * sign + cvsOffset;
				val -= minPixelPadding;
				returnValue = val / localA + localMin; // from chart pixel to value
				if (doPostTranslate) { // log and ordinal axes
					returnValue = axis.lin2val(returnValue);
				}

			// From value to pixels
			} else {
				if (doPostTranslate) { // log and ordinal axes
					val = axis.val2lin(val);
				}
				if (pointPlacement === 'between') {
					pointPlacement = 0.5;
				}
				returnValue = sign * (val - localMin) * localA + cvsOffset + (sign * minPixelPadding) +
					(isNumber(pointPlacement) ? localA * pointPlacement * axis.pointRange : 0);
			}

			return returnValue;
		},

		/**
		 * Utility method to translate an axis value to pixel position.
		 * @param {Number} value A value in terms of axis units
		 * @param {Boolean} paneCoordinates Whether to return the pixel coordinate relative to the chart
		 *        or just the axis/pane itself.
		 */
		toPixels: function (value, paneCoordinates) {
			return this.translate(value, false, !this.horiz, null, true) + (paneCoordinates ? 0 : this.pos);
		},

		/*
		 * Utility method to translate a pixel position in to an axis value
		 * @param {Number} pixel The pixel value coordinate
		 * @param {Boolean} paneCoordiantes Whether the input pixel is relative to the chart or just the
		 *        axis/pane itself.
		 */
		toValue: function (pixel, paneCoordinates) {
			return this.translate(pixel - (paneCoordinates ? 0 : this.pos), true, !this.horiz, null, true);
		},

		/**
		 * Create the path for a plot line that goes from the given value on
		 * this axis, across the plot to the opposite side
		 * @param {Number} value
		 * @param {Number} lineWidth Used for calculation crisp line
		 * @param {Number] old Use old coordinates (for resizing and rescaling)
		 */
		getPlotLinePath: function (value, lineWidth, old, force, translatedValue) {
			var axis = this,
				chart = axis.chart,
				axisLeft = axis.left,
				axisTop = axis.top,
				x1,
				y1,
				x2,
				y2,
				cHeight = (old && chart.oldChartHeight) || chart.chartHeight,
				cWidth = (old && chart.oldChartWidth) || chart.chartWidth,
				skip,
				transB = axis.transB,
				/**
				 * Check if x is between a and b. If not, either move to a/b or skip, 
				 * depending on the force parameter.
				 */
				between = function (x, a, b) {
					if (x < a || x > b) {
						if (force) {
							x = mathMin(mathMax(a, x), b);
						} else {
							skip = true;
						}
					}
					return x;
				};

			translatedValue = pick(translatedValue, axis.translate(value, null, null, old));
			x1 = x2 = mathRound(translatedValue + transB);
			y1 = y2 = mathRound(cHeight - translatedValue - transB);

			if (isNaN(translatedValue)) { // no min or max
				skip = true;

			} else if (axis.horiz) {
				y1 = axisTop;
				y2 = cHeight - axis.bottom;
				x1 = x2 = between(x1, axisLeft, axisLeft + axis.width);
			} else {
				x1 = axisLeft;
				x2 = cWidth - axis.right;
				y1 = y2 = between(y1, axisTop, axisTop + axis.height);
			}
			return skip && !force ?
				null :
				chart.renderer.crispLine([M, x1, y1, L, x2, y2], lineWidth || 1);
		},

		/**
		 * Set the tick positions of a linear axis to round values like whole tens or every five.
		 */
		getLinearTickPositions: function (tickInterval, min, max) {
			var pos,
				lastPos,
				roundedMin = correctFloat(mathFloor(min / tickInterval) * tickInterval),
				roundedMax = correctFloat(mathCeil(max / tickInterval) * tickInterval),
				tickPositions = [];

			// For single points, add a tick regardless of the relative position (#2662)
			if (min === max && isNumber(min)) {
				return [min];
			}

			// Populate the intermediate values
			pos = roundedMin;
			while (pos <= roundedMax) {

				// Place the tick on the rounded value
				tickPositions.push(pos);

				// Always add the raw tickInterval, not the corrected one.
				pos = correctFloat(pos + tickInterval);

				// If the interval is not big enough in the current min - max range to actually increase
				// the loop variable, we need to break out to prevent endless loop. Issue #619
				if (pos === lastPos) {
					break;
				}

				// Record the last value
				lastPos = pos;
			}
			return tickPositions;
		},

		/**
		 * Return the minor tick positions. For logarithmic axes, reuse the same logic
		 * as for major ticks.
		 */
		getMinorTickPositions: function () {
			var axis = this,
				options = axis.options,
				tickPositions = axis.tickPositions,
				minorTickInterval = axis.minorTickInterval,
				minorTickPositions = [],
				pos,
				i,
				min = axis.min,
				max = axis.max,
				range = max - min,
				len;

			// If minor ticks get too dense, they are hard to read, and may cause long running script. So we don't draw them.
			if (range && range / minorTickInterval < axis.len / 3) { // #3875

				if (axis.isLog) {
					len = tickPositions.length;
					for (i = 1; i < len; i++) {
						minorTickPositions = minorTickPositions.concat(
							axis.getLogTickPositions(minorTickInterval, tickPositions[i - 1], tickPositions[i], true)
						);
					}
				} else if (axis.isDatetimeAxis && options.minorTickInterval === 'auto') { // #1314
					minorTickPositions = minorTickPositions.concat(
						axis.getTimeTicks(
							axis.normalizeTimeTickInterval(minorTickInterval),
							min,
							max,
							options.startOfWeek
						)
					);
				} else {
					for (pos = min + (tickPositions[0] - min) % minorTickInterval; pos <= max; pos += minorTickInterval) {
						minorTickPositions.push(pos);
					}
				}
			}

			axis.trimTicks(minorTickPositions); // #3652 #3743
			return minorTickPositions;
		},

		/**
		 * Adjust the min and max for the minimum range. Keep in mind that the series data is
		 * not yet processed, so we don't have information on data cropping and grouping, or
		 * updated axis.pointRange or series.pointRange. The data can't be processed until
		 * we have finally established min and max.
		 */
		adjustForMinRange: function () {
			var axis = this,
				options = axis.options,
				min = axis.min,
				max = axis.max,
				zoomOffset,
				spaceAvailable = axis.dataMax - axis.dataMin >= axis.minRange,
				closestDataRange,
				i,
				distance,
				xData,
				loopLength,
				minArgs,
				maxArgs;

			// Set the automatic minimum range based on the closest point distance
			if (axis.isXAxis && axis.minRange === UNDEFINED && !axis.isLog) {

				if (defined(options.min) || defined(options.max)) {
					axis.minRange = null; // don't do this again

				} else {

					// Find the closest distance between raw data points, as opposed to
					// closestPointRange that applies to processed points (cropped and grouped)
					each(axis.series, function (series) {
						xData = series.xData;
						loopLength = series.xIncrement ? 1 : xData.length - 1;
						for (i = loopLength; i > 0; i--) {
							distance = xData[i] - xData[i - 1];
							if (closestDataRange === UNDEFINED || distance < closestDataRange) {
								closestDataRange = distance;
							}
						}
					});
					axis.minRange = mathMin(closestDataRange * 5, axis.dataMax - axis.dataMin);
				}
			}

			// if minRange is exceeded, adjust
			if (max - min < axis.minRange) {
				var minRange = axis.minRange;
				zoomOffset = (minRange - max + min) / 2;

				// if min and max options have been set, don't go beyond it
				minArgs = [min - zoomOffset, pick(options.min, min - zoomOffset)];
				if (spaceAvailable) { // if space is available, stay within the data range
					minArgs[2] = axis.dataMin;
				}
				min = arrayMax(minArgs);

				maxArgs = [min + minRange, pick(options.max, min + minRange)];
				if (spaceAvailable) { // if space is availabe, stay within the data range
					maxArgs[2] = axis.dataMax;
				}

				max = arrayMin(maxArgs);

				// now if the max is adjusted, adjust the min back
				if (max - min < minRange) {
					minArgs[0] = max - minRange;
					minArgs[1] = pick(options.min, max - minRange);
					min = arrayMax(minArgs);
				}
			}

			// Record modified extremes
			axis.min = min;
			axis.max = max;
		},

		/**
		 * Update translation information
		 */
		setAxisTranslation: function (saveOld) {
			var axis = this,
				range = axis.max - axis.min,
				pointRange = axis.axisPointRange || 0,
				closestPointRange,
				minPointOffset = 0,
				pointRangePadding = 0,
				linkedParent = axis.linkedParent,
				ordinalCorrection,
				hasCategories = !!axis.categories,
				transA = axis.transA,
				isXAxis = axis.isXAxis;

			// Adjust translation for padding. Y axis with categories need to go through the same (#1784).
			if (isXAxis || hasCategories || pointRange) {
				if (linkedParent) {
					minPointOffset = linkedParent.minPointOffset;
					pointRangePadding = linkedParent.pointRangePadding;

				} else {
					each(axis.series, function (series) {
						var seriesPointRange = hasCategories ? 1 : (isXAxis ? series.pointRange : (axis.axisPointRange || 0)), // #2806
							pointPlacement = series.options.pointPlacement,
							seriesClosestPointRange = series.closestPointRange;

						if (seriesPointRange > range) { // #1446
							seriesPointRange = 0;
						}
						pointRange = mathMax(pointRange, seriesPointRange);

						if (!axis.single) {
							// minPointOffset is the value padding to the left of the axis in order to make
							// room for points with a pointRange, typically columns. When the pointPlacement option
							// is 'between' or 'on', this padding does not apply.
							minPointOffset = mathMax(
								minPointOffset,
								isString(pointPlacement) ? 0 : seriesPointRange / 2
							);

							// Determine the total padding needed to the length of the axis to make room for the
							// pointRange. If the series' pointPlacement is 'on', no padding is added.
							pointRangePadding = mathMax(
								pointRangePadding,
								pointPlacement === 'on' ? 0 : seriesPointRange
							);
						}

						// Set the closestPointRange
						if (!series.noSharedTooltip && defined(seriesClosestPointRange)) {
							closestPointRange = defined(closestPointRange) ?
								mathMin(closestPointRange, seriesClosestPointRange) :
								seriesClosestPointRange;
						}
					});
				}

				// Record minPointOffset and pointRangePadding
				ordinalCorrection = axis.ordinalSlope && closestPointRange ? axis.ordinalSlope / closestPointRange : 1; // #988, #1853
				axis.minPointOffset = minPointOffset = minPointOffset * ordinalCorrection;
				axis.pointRangePadding = pointRangePadding = pointRangePadding * ordinalCorrection;

				// pointRange means the width reserved for each point, like in a column chart
				axis.pointRange = mathMin(pointRange, range);

				// closestPointRange means the closest distance between points. In columns
				// it is mostly equal to pointRange, but in lines pointRange is 0 while closestPointRange
				// is some other value
				if (isXAxis) {
					axis.closestPointRange = closestPointRange;
				}
			}

			// Secondary values
			if (saveOld) {
				axis.oldTransA = transA;
			}
			axis.translationSlope = axis.transA = transA = axis.len / ((range + pointRangePadding) || 1);
			axis.transB = axis.horiz ? axis.left : axis.bottom; // translation addend
			axis.minPixelPadding = transA * minPointOffset;
		},

		/**
		 * Set the tick positions to round values and optionally extend the extremes
		 * to the nearest tick
		 */
		setTickInterval: function (secondPass) {
			var axis = this,
				chart = axis.chart,
				options = axis.options,
				isLog = axis.isLog,
				isDatetimeAxis = axis.isDatetimeAxis,
				isXAxis = axis.isXAxis,
				isLinked = axis.isLinked,
				maxPadding = options.maxPadding,
				minPadding = options.minPadding,
				length,
				linkedParentExtremes,
				tickIntervalOption = options.tickInterval,
				minTickInterval,
				tickPixelIntervalOption = options.tickPixelInterval,
				categories = axis.categories;

			if (!isDatetimeAxis && !categories && !isLinked) {
				this.getTickAmount();
			}

			// linked axis gets the extremes from the parent axis
			if (isLinked) {
				axis.linkedParent = chart[axis.coll][options.linkedTo];
				linkedParentExtremes = axis.linkedParent.getExtremes();
				axis.min = pick(linkedParentExtremes.min, linkedParentExtremes.dataMin);
				axis.max = pick(linkedParentExtremes.max, linkedParentExtremes.dataMax);
				if (options.type !== axis.linkedParent.options.type) {
					error(11, 1); // Can't link axes of different type
				}
			} else { // initial min and max from the extreme data values
				axis.min = pick(axis.userMin, options.min, axis.dataMin);
				axis.max = pick(axis.userMax, options.max, axis.dataMax);
			}

			if (isLog) {
				if (!secondPass && mathMin(axis.min, pick(axis.dataMin, axis.min)) <= 0) { // #978
					error(10, 1); // Can't plot negative values on log axis
				}
				axis.min = correctFloat(log2lin(axis.min)); // correctFloat cures #934
				axis.max = correctFloat(log2lin(axis.max));
			}

			// handle zoomed range
			if (axis.range && defined(axis.max)) {
				axis.userMin = axis.min = mathMax(axis.min, axis.max - axis.range); // #618
				axis.userMax = axis.max;

				axis.range = null;  // don't use it when running setExtremes
			}

			// Hook for adjusting this.min and this.max. Used by bubble series.
			if (axis.beforePadding) {
				axis.beforePadding();
			}

			// adjust min and max for the minimum range
			axis.adjustForMinRange();

			// Pad the values to get clear of the chart's edges. To avoid tickInterval taking the padding
			// into account, we do this after computing tick interval (#1337).
			if (!categories && !axis.axisPointRange && !axis.usePercentage && !isLinked && defined(axis.min) && defined(axis.max)) {
				length = axis.max - axis.min;
				if (length) {
					if (!defined(options.min) && !defined(axis.userMin) && minPadding && (axis.dataMin < 0 || !axis.ignoreMinPadding)) {
						axis.min -= length * minPadding;
					}
					if (!defined(options.max) && !defined(axis.userMax)  && maxPadding && (axis.dataMax > 0 || !axis.ignoreMaxPadding)) {
						axis.max += length * maxPadding;
					}
				}
			}

			// Stay within floor and ceiling
			if (isNumber(options.floor)) {
				axis.min = mathMax(axis.min, options.floor);
			}
			if (isNumber(options.ceiling)) {
				axis.max = mathMin(axis.max, options.ceiling);
			}

			// get tickInterval
			if (axis.min === axis.max || axis.min === undefined || axis.max === undefined) {
				axis.tickInterval = 1;
			} else if (isLinked && !tickIntervalOption &&
					tickPixelIntervalOption === axis.linkedParent.options.tickPixelInterval) {
				axis.tickInterval = tickIntervalOption = axis.linkedParent.tickInterval;
			} else {
				axis.tickInterval = pick(
					tickIntervalOption,
					this.tickAmount ? ((axis.max - axis.min) / mathMax(this.tickAmount - 1, 1)) : undefined,
					categories ? // for categoried axis, 1 is default, for linear axis use tickPix
						1 :
						// don't let it be more than the data range
						(axis.max - axis.min) * tickPixelIntervalOption / mathMax(axis.len, tickPixelIntervalOption)
				);
			}

			// Now we're finished detecting min and max, crop and group series data. This
			// is in turn needed in order to find tick positions in ordinal axes.
			if (isXAxis && !secondPass) {
				each(axis.series, function (series) {
					series.processData(axis.min !== axis.oldMin || axis.max !== axis.oldMax);
				});
			}

			// set the translation factor used in translate function
			axis.setAxisTranslation(true);

			// hook for ordinal axes and radial axes
			if (axis.beforeSetTickPositions) {
				axis.beforeSetTickPositions();
			}

			// hook for extensions, used in Highstock ordinal axes
			if (axis.postProcessTickInterval) {
				axis.tickInterval = axis.postProcessTickInterval(axis.tickInterval);
			}

			// In column-like charts, don't cramp in more ticks than there are points (#1943)
			if (axis.pointRange) {
				axis.tickInterval = mathMax(axis.pointRange, axis.tickInterval);
			}

			// Before normalizing the tick interval, handle minimum tick interval. This applies only if tickInterval is not defined.
			minTickInterval = pick(options.minTickInterval, axis.isDatetimeAxis && axis.closestPointRange);
			if (!tickIntervalOption && axis.tickInterval < minTickInterval) {
				axis.tickInterval = minTickInterval;
			}

			// for linear axes, get magnitude and normalize the interval
			if (!isDatetimeAxis && !isLog && !tickIntervalOption) {
				axis.tickInterval = normalizeTickInterval(
					axis.tickInterval, 
					null, 
					getMagnitude(axis.tickInterval), 
					// If the tick interval is between 0.5 and 5 and the axis max is in the order of
					// thousands, chances are we are dealing with years. Don't allow decimals. #3363.
					pick(options.allowDecimals, !(axis.tickInterval > 0.5 && axis.tickInterval < 5 && axis.max > 1000 && axis.max < 9999)),
					!!this.tickAmount
				);
			}
			
			// Prevent ticks from getting so close that we can't draw the labels
			if (!this.tickAmount && this.len) { // Color axis with disabled legend has no length
				axis.tickInterval = axis.unsquish();
			}

			this.setTickPositions();
		},

		/**
		 * Now we have computed the normalized tickInterval, get the tick positions
		 */
		setTickPositions: function () {

			var options = this.options,
				tickPositions,
				tickPositionsOption = options.tickPositions,
				tickPositioner = options.tickPositioner,
				startOnTick = options.startOnTick,
				endOnTick = options.endOnTick,
				single;

			// Set the tickmarkOffset
			this.tickmarkOffset = (this.categories && options.tickmarkPlacement === 'between' && 
				this.tickInterval === 1) ? 0.5 : 0; // #3202


			// get minorTickInterval
			this.minorTickInterval = options.minorTickInterval === 'auto' && this.tickInterval ?
				this.tickInterval / 5 : options.minorTickInterval;

			// Find the tick positions
			this.tickPositions = tickPositions = tickPositionsOption && tickPositionsOption.slice(); // Work on a copy (#1565)
			if (!tickPositions) {

				if (this.isDatetimeAxis) {
					tickPositions = this.getTimeTicks(
						this.normalizeTimeTickInterval(this.tickInterval, options.units),
						this.min,
						this.max,
						options.startOfWeek,
						this.ordinalPositions,
						this.closestPointRange,
						true
					);
				} else if (this.isLog) {
					tickPositions = this.getLogTickPositions(this.tickInterval, this.min, this.max);
				} else {
					tickPositions = this.getLinearTickPositions(this.tickInterval, this.min, this.max);
				}

				this.tickPositions = tickPositions;

				// Run the tick positioner callback, that allows modifying auto tick positions.
				if (tickPositioner) {
					tickPositioner = tickPositioner.apply(this, [this.min, this.max]);
					if (tickPositioner) {
						this.tickPositions = tickPositions = tickPositioner;
					}
				}

			}

			if (!this.isLinked) {

				// reset min/max or remove extremes based on start/end on tick
				this.trimTicks(tickPositions, startOnTick, endOnTick);

				// When there is only one point, or all points have the same value on this axis, then min
				// and max are equal and tickPositions.length is 0 or 1. In this case, add some padding
				// in order to center the point, but leave it with one tick. #1337.
				if (this.min === this.max && defined(this.min) && !this.tickAmount) {
					// Substract half a unit (#2619, #2846, #2515, #3390)
					single = true;
					this.min -= 0.5;
					this.max += 0.5;
				}
				this.single = single;

				if (!tickPositionsOption && !tickPositioner) {
					this.adjustTickAmount();
				}
			}
		},

		/**
		 * Handle startOnTick and endOnTick by either adapting to padding min/max or rounded min/max
		 */
		trimTicks: function (tickPositions, startOnTick, endOnTick) {
			var roundedMin = tickPositions[0],
				roundedMax = tickPositions[tickPositions.length - 1],
				minPointOffset = this.minPointOffset || 0;
				
			if (startOnTick) {
				this.min = roundedMin;
			} else if (this.min - minPointOffset > roundedMin) {
				tickPositions.shift();
			}

			if (endOnTick) {
				this.max = roundedMax;
			} else if (this.max + minPointOffset < roundedMax) {
				tickPositions.pop();
			}

			// If no tick are left, set one tick in the middle (#3195) 
			if (tickPositions.length === 0 && defined(roundedMin)) {
				tickPositions.push((roundedMax + roundedMin) / 2);
			}		
		},

		/**
		 * Set the max ticks of either the x and y axis collection
		 */
		getTickAmount: function () {
			var others = {}, // Whether there is another axis to pair with this one
				hasOther,
				options = this.options,
				tickAmount = options.tickAmount,
				tickPixelInterval = options.tickPixelInterval;

			if (!defined(options.tickInterval) && this.len < tickPixelInterval && !this.isRadial &&
					!this.isLog && options.startOnTick && options.endOnTick) {
				tickAmount = 2;
			}

			if (!tickAmount && this.chart.options.chart.alignTicks !== false && options.alignTicks !== false) {
				// Check if there are multiple axes in the same pane
				each(this.chart[this.coll], function (axis) {
					var options = axis.options,
						horiz = axis.horiz,
						key = [horiz ? options.left : options.top, horiz ? options.width : options.height, options.pane].join(',');
					
					if (others[key]) {
						if (axis.series.length) {
							hasOther = true; // #4201
						}
					} else {
						others[key] = 1;
					}
				});

				if (hasOther) {
					// Add 1 because 4 tick intervals require 5 ticks (including first and last)
					tickAmount = mathCeil(this.len / tickPixelInterval) + 1;
				}
			}

			// For tick amounts of 2 and 3, compute five ticks and remove the intermediate ones. This
			// prevents the axis from adding ticks that are too far away from the data extremes.
			if (tickAmount < 4) {
				this.finalTickAmt = tickAmount;
				tickAmount = 5;
			}
			
			this.tickAmount = tickAmount;
		},

		/**
		 * When using multiple axes, adjust the number of ticks to match the highest
		 * number of ticks in that group
		 */
		adjustTickAmount: function () {
			var tickInterval = this.tickInterval,
				tickPositions = this.tickPositions,
				tickAmount = this.tickAmount,
				finalTickAmt = this.finalTickAmt,
				currentTickAmount = tickPositions && tickPositions.length,
				i,
				len;

			if (currentTickAmount < tickAmount) { // TODO: Check #3411
				while (tickPositions.length < tickAmount) {
					tickPositions.push(correctFloat(
						tickPositions[tickPositions.length - 1] + tickInterval
					));
				}
				this.transA *= (currentTickAmount - 1) / (tickAmount - 1);
				this.max = tickPositions[tickPositions.length - 1];

			// We have too many ticks, run second pass to try to reduce ticks
			} else if (currentTickAmount > tickAmount) {
				this.tickInterval *= 2;
				this.setTickPositions();
			}

			// The finalTickAmt property is set in getTickAmount
			if (defined(finalTickAmt)) {
				i = len = tickPositions.length;
				while (i--) {
					if (
						(finalTickAmt === 3 && i % 2 === 1) || // Remove every other tick
						(finalTickAmt <= 2 && i > 0 && i < len - 1) // Remove all but first and last
					) {
						tickPositions.splice(i, 1);
					}	
				}
				this.finalTickAmt = UNDEFINED;
			}
		},

		/**
		 * Set the scale based on data min and max, user set min and max or options
		 *
		 */
		setScale: function () {
			var axis = this,
				stacks = axis.stacks,
				type,
				i,
				isDirtyData,
				isDirtyAxisLength;

			axis.oldMin = axis.min;
			axis.oldMax = axis.max;
			axis.oldAxisLength = axis.len;

			// set the new axisLength
			axis.setAxisSize();
			//axisLength = horiz ? axisWidth : axisHeight;
			isDirtyAxisLength = axis.len !== axis.oldAxisLength;

			// is there new data?
			each(axis.series, function (series) {
				if (series.isDirtyData || series.isDirty ||
						series.xAxis.isDirty) { // when x axis is dirty, we need new data extremes for y as well
					isDirtyData = true;
				}
			});

			// do we really need to go through all this?
			if (isDirtyAxisLength || isDirtyData || axis.isLinked || axis.forceRedraw ||
				axis.userMin !== axis.oldUserMin || axis.userMax !== axis.oldUserMax) {

				// reset stacks
				if (!axis.isXAxis) {
					for (type in stacks) {
						for (i in stacks[type]) {
							stacks[type][i].total = null;
							stacks[type][i].cum = 0;
						}
					}
				}

				axis.forceRedraw = false;

				// get data extremes if needed
				axis.getSeriesExtremes();

				// get fixed positions based on tickInterval
				axis.setTickInterval();

				// record old values to decide whether a rescale is necessary later on (#540)
				axis.oldUserMin = axis.userMin;
				axis.oldUserMax = axis.userMax;

				// Mark as dirty if it is not already set to dirty and extremes have changed. #595.
				if (!axis.isDirty) {
					axis.isDirty = isDirtyAxisLength || axis.min !== axis.oldMin || axis.max !== axis.oldMax;
				}
			} else if (!axis.isXAxis) {
				if (axis.oldStacks) {
					stacks = axis.stacks = axis.oldStacks;
				}

				// reset stacks
				for (type in stacks) {
					for (i in stacks[type]) {
						stacks[type][i].cum = stacks[type][i].total;
					}
				}
			}
		},

		/**
		 * Set the extremes and optionally redraw
		 * @param {Number} newMin
		 * @param {Number} newMax
		 * @param {Boolean} redraw
		 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
		 *    configuration
		 * @param {Object} eventArguments
		 *
		 */
		setExtremes: function (newMin, newMax, redraw, animation, eventArguments) {
			var axis = this,
				chart = axis.chart;

			redraw = pick(redraw, true); // defaults to true

			each(axis.series, function (serie) {
				delete serie.kdTree;
			});

			// Extend the arguments with min and max
			eventArguments = extend(eventArguments, {
				min: newMin,
				max: newMax
			});

			// Fire the event
			fireEvent(axis, 'setExtremes', eventArguments, function () { // the default event handler

				axis.userMin = newMin;
				axis.userMax = newMax;
				axis.eventArgs = eventArguments;

				// Mark for running afterSetExtremes
				axis.isDirtyExtremes = true;

				// redraw
				if (redraw) {
					chart.redraw(animation);
				}
			});
		},

		/**
		 * Overridable method for zooming chart. Pulled out in a separate method to allow overriding
		 * in stock charts.
		 */
		zoom: function (newMin, newMax) {
			var dataMin = this.dataMin,
				dataMax = this.dataMax,
				options = this.options;

			// Prevent pinch zooming out of range. Check for defined is for #1946. #1734.
			if (!this.allowZoomOutside) {
				if (defined(dataMin) && newMin <= mathMin(dataMin, pick(options.min, dataMin))) {
					newMin = UNDEFINED;
				}
				if (defined(dataMax) && newMax >= mathMax(dataMax, pick(options.max, dataMax))) {
					newMax = UNDEFINED;
				}
			}

			// In full view, displaying the reset zoom button is not required
			this.displayBtn = newMin !== UNDEFINED || newMax !== UNDEFINED;

			// Do it
			this.setExtremes(
				newMin,
				newMax,
				false,
				UNDEFINED,
				{ trigger: 'zoom' }
			);
			return true;
		},

		/**
		 * Update the axis metrics
		 */
		setAxisSize: function () {
			var chart = this.chart,
				options = this.options,
				offsetLeft = options.offsetLeft || 0,
				offsetRight = options.offsetRight || 0,
				horiz = this.horiz,
				width = pick(options.width, chart.plotWidth - offsetLeft + offsetRight),
				height = pick(options.height, chart.plotHeight),
				top = pick(options.top, chart.plotTop),
				left = pick(options.left, chart.plotLeft + offsetLeft),
				percentRegex = /%$/;

			// Check for percentage based input values
			if (percentRegex.test(height)) {
				height = parseFloat(height) / 100 * chart.plotHeight;
			}
			if (percentRegex.test(top)) {
				top = parseFloat(top) / 100 * chart.plotHeight + chart.plotTop;
			}

			// Expose basic values to use in Series object and navigator
			this.left = left;
			this.top = top;
			this.width = width;
			this.height = height;
			this.bottom = chart.chartHeight - height - top;
			this.right = chart.chartWidth - width - left;

			// Direction agnostic properties
			this.len = mathMax(horiz ? width : height, 0); // mathMax fixes #905
			this.pos = horiz ? left : top; // distance from SVG origin
		},

		/**
		 * Get the actual axis extremes
		 */
		getExtremes: function () {
			var axis = this,
				isLog = axis.isLog;

			return {
				min: isLog ? correctFloat(lin2log(axis.min)) : axis.min,
				max: isLog ? correctFloat(lin2log(axis.max)) : axis.max,
				dataMin: axis.dataMin,
				dataMax: axis.dataMax,
				userMin: axis.userMin,
				userMax: axis.userMax
			};
		},

		/**
		 * Get the zero plane either based on zero or on the min or max value.
		 * Used in bar and area plots
		 */
		getThreshold: function (threshold) {
			var axis = this,
				isLog = axis.isLog,
				realMin = isLog ? lin2log(axis.min) : axis.min,
				realMax = isLog ? lin2log(axis.max) : axis.max;

			// With a threshold of null, make the columns/areas rise from the top or bottom 
			// depending on the value, assuming an actual threshold of 0 (#4233).
			if (threshold === null) {
				threshold = realMax < 0 ? realMax : realMin;
			} else if (realMin > threshold) {
				threshold = realMin;
			} else if (realMax < threshold) {
				threshold = realMax;
			}

			return axis.translate(threshold, 0, 1, 0, 1);
		},

		/**
		 * Compute auto alignment for the axis label based on which side the axis is on
		 * and the given rotation for the label
		 */
		autoLabelAlign: function (rotation) {
			var ret,
				angle = (pick(rotation, 0) - (this.side * 90) + 720) % 360;

			if (angle > 15 && angle < 165) {
				ret = 'right';
			} else if (angle > 195 && angle < 345) {
				ret = 'left';
			} else {
				ret = 'center';
			}
			return ret;
		},

		/**
		 * Prevent the ticks from getting so close we can't draw the labels. On a horizontal
		 * axis, this is handled by rotating the labels, removing ticks and adding ellipsis. 
		 * On a vertical axis remove ticks and add ellipsis.
		 */
		unsquish: function () {
			var chart = this.chart,
				ticks = this.ticks,
				labelOptions = this.options.labels,
				horiz = this.horiz,
				tickInterval = this.tickInterval,
				newTickInterval = tickInterval,
				slotSize = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / tickInterval),
				rotation,
				rotationOption = labelOptions.rotation,
				labelMetrics = chart.renderer.fontMetrics(labelOptions.style.fontSize, ticks[0] && ticks[0].label),
				step,
				bestScore = Number.MAX_VALUE,
				autoRotation,
				// Return the multiple of tickInterval that is needed to avoid collision
				getStep = function (spaceNeeded) {
					var step = spaceNeeded / (slotSize || 1);
					step = step > 1 ? mathCeil(step) : 1;
					return step * tickInterval;
				};
			
			if (horiz) {
				autoRotation = defined(rotationOption) ? 
					[rotationOption] :
					slotSize < pick(labelOptions.autoRotationLimit, 80) && !labelOptions.staggerLines && !labelOptions.step && labelOptions.autoRotation;

				if (autoRotation) {

					// Loop over the given autoRotation options, and determine which gives the best score. The 
					// best score is that with the lowest number of steps and a rotation closest to horizontal.
					each(autoRotation, function (rot) {
						var score;

						if (rot === rotationOption || (rot && rot >= -90 && rot <= 90)) { // #3891
						
							step = getStep(mathAbs(labelMetrics.h / mathSin(deg2rad * rot)));

							score = step + mathAbs(rot / 360);

							if (score < bestScore) {
								bestScore = score;
								rotation = rot;
								newTickInterval = step;
							}
						}
					});
				}

			} else {
				newTickInterval = getStep(labelMetrics.h);
			}

			this.autoRotation = autoRotation;
			this.labelRotation = rotation;

			return newTickInterval;
		},

		renderUnsquish: function () {
			var chart = this.chart,
				renderer = chart.renderer,
				tickPositions = this.tickPositions,
				ticks = this.ticks,
				labelOptions = this.options.labels,
				horiz = this.horiz,
				margin = chart.margin,
				slotCount = this.categories ? tickPositions.length : tickPositions.length - 1,
				slotWidth = this.slotWidth = (horiz && !labelOptions.step && !labelOptions.rotation &&
					((this.staggerLines || 1) * chart.plotWidth) / slotCount) ||
					(!horiz && ((margin[3] && (margin[3] - chart.spacing[3])) || chart.chartWidth * 0.33)), // #1580, #1931,
				innerWidth = mathMax(1, mathRound(slotWidth - 2 * (labelOptions.padding || 5))),
				attr = {},
				labelMetrics = renderer.fontMetrics(labelOptions.style.fontSize, ticks[0] && ticks[0].label),
				textOverflowOption = labelOptions.style.textOverflow,
				css,
				labelLength = 0,
				label,
				i,
				pos;

			// Set rotation option unless it is "auto", like in gauges
			if (!isString(labelOptions.rotation)) {
				attr.rotation = labelOptions.rotation;
			}
			
			// Handle auto rotation on horizontal axis
			if (this.autoRotation) {

				// Get the longest label length
				each(tickPositions, function (tick) {
					tick = ticks[tick];
					if (tick && tick.labelLength > labelLength) {
						labelLength = tick.labelLength;
					}
				});
				
				// Apply rotation only if the label is too wide for the slot, and
				// the label is wider than its height.
				if (labelLength > innerWidth && labelLength > labelMetrics.h) {
					attr.rotation = this.labelRotation;
				} else {
					this.labelRotation = 0;
				}

			// Handle word-wrap or ellipsis on vertical axis
			} else if (slotWidth) {
				// For word-wrap or ellipsis
				css = { width: innerWidth + PX };

				if (!textOverflowOption) {
					css.textOverflow = 'clip';

					// On vertical axis, only allow word wrap if there is room for more lines.
					i = tickPositions.length;
					while (!horiz && i--) {
						pos = tickPositions[i];
						label = ticks[pos].label;
						if (label) {
							// Reset ellipsis in order to get the correct bounding box (#4070)
							if (label.styles.textOverflow === 'ellipsis') {
								label.css({ textOverflow: 'clip' });
							}
							if (label.getBBox().height > this.len / tickPositions.length - (labelMetrics.h - labelMetrics.f)) {
								label.specCss = { textOverflow: 'ellipsis' };
							}
						}
					}
				}
			}


			// Add ellipsis if the label length is significantly longer than ideal
			if (attr.rotation) {
				css = { 
					width: (labelLength > chart.chartHeight * 0.5 ? chart.chartHeight * 0.33 : chart.chartHeight) + PX
				};
				if (!textOverflowOption) {
					css.textOverflow = 'ellipsis';
				}
			}

			// Set the explicit or automatic label alignment
			this.labelAlign = attr.align = labelOptions.align || this.autoLabelAlign(this.labelRotation);

			// Apply general and specific CSS
			each(tickPositions, function (pos) {
				var tick = ticks[pos],
					label = tick && tick.label;
				if (label) {
					if (css) {
						label.css(merge(css, label.specCss));
					}
					delete label.specCss;
					label.attr(attr);
					tick.rotation = attr.rotation;
				}
			});

			// TODO: Why not part of getLabelPosition?
			this.tickRotCorr = renderer.rotCorr(labelMetrics.b, this.labelRotation || 0, this.side === 2);
		},

		/**
		 * Return true if the axis has associated data
		 */
		hasData: function () {
			return this.hasVisibleSeries || (defined(this.min) && defined(this.max) && !!this.tickPositions);
		},

		/**
		 * Render the tick labels to a preliminary position to get their sizes
		 */
		getOffset: function () {
			var axis = this,
				chart = axis.chart,
				renderer = chart.renderer,
				options = axis.options,
				tickPositions = axis.tickPositions,
				ticks = axis.ticks,
				horiz = axis.horiz,
				side = axis.side,
				invertedSide = chart.inverted ? [1, 0, 3, 2][side] : side,
				hasData,
				showAxis,
				titleOffset = 0,
				titleOffsetOption,
				titleMargin = 0,
				axisTitleOptions = options.title,
				labelOptions = options.labels,
				labelOffset = 0, // reset
				labelOffsetPadded,
				axisOffset = chart.axisOffset,
				clipOffset = chart.clipOffset,
				clip,
				directionFactor = [-1, 1, 1, -1][side],
				n,
				lineHeightCorrection;

			// For reuse in Axis.render
			hasData = axis.hasData();
			axis.showAxis = showAxis = hasData || pick(options.showEmpty, true);

			// Set/reset staggerLines
			axis.staggerLines = axis.horiz && labelOptions.staggerLines;

			// Create the axisGroup and gridGroup elements on first iteration
			if (!axis.axisGroup) {
				axis.gridGroup = renderer.g('grid')
					.attr({ zIndex: options.gridZIndex || 1 })
					.add();
				axis.axisGroup = renderer.g('axis')
					.attr({ zIndex: options.zIndex || 2 })
					.add();
				axis.labelGroup = renderer.g('axis-labels')
					.attr({ zIndex: labelOptions.zIndex || 7 })
					.addClass(PREFIX + axis.coll.toLowerCase() + '-labels')
					.add();
			}

			if (hasData || axis.isLinked) {
				
				// Generate ticks
				each(tickPositions, function (pos) {
					if (!ticks[pos]) {
						ticks[pos] = new Tick(axis, pos);
					} else {
						ticks[pos].addLabel(); // update labels depending on tick interval
					}
				});

				axis.renderUnsquish();

				each(tickPositions, function (pos) {
					// left side must be align: right and right side must have align: left for labels
					if (side === 0 || side === 2 || { 1: 'left', 3: 'right' }[side] === axis.labelAlign) {

						// get the highest offset
						labelOffset = mathMax(
							ticks[pos].getLabelSize(),
							labelOffset
						);
					}
				});

				if (axis.staggerLines) {
					labelOffset *= axis.staggerLines;
					axis.labelOffset = labelOffset;
				}


			} else { // doesn't have data
				for (n in ticks) {
					ticks[n].destroy();
					delete ticks[n];
				}
			}

			if (axisTitleOptions && axisTitleOptions.text && axisTitleOptions.enabled !== false) {
				if (!axis.axisTitle) {
					axis.axisTitle = renderer.text(
						axisTitleOptions.text,
						0,
						0,
						axisTitleOptions.useHTML
					)
					.attr({
						zIndex: 7,
						rotation: axisTitleOptions.rotation || 0,
						align:
							axisTitleOptions.textAlign ||
							{ low: 'left', middle: 'center', high: 'right' }[axisTitleOptions.align]
					})
					.addClass(PREFIX + this.coll.toLowerCase() + '-title')
					.css(axisTitleOptions.style)
					.add(axis.axisGroup);
					axis.axisTitle.isNew = true;
				}

				if (showAxis) {
					titleOffset = axis.axisTitle.getBBox()[horiz ? 'height' : 'width'];
					titleOffsetOption = axisTitleOptions.offset;
					titleMargin = defined(titleOffsetOption) ? 0 : pick(axisTitleOptions.margin, horiz ? 5 : 10);
				}

				// hide or show the title depending on whether showEmpty is set
				axis.axisTitle[showAxis ? 'show' : 'hide']();
			}

			// handle automatic or user set offset
			axis.offset = directionFactor * pick(options.offset, axisOffset[side]);

			axis.tickRotCorr = axis.tickRotCorr || { x: 0, y: 0 }; // polar
			lineHeightCorrection = side === 2 ? axis.tickRotCorr.y : 0;
			labelOffsetPadded = labelOffset + titleMargin +
				(labelOffset && (directionFactor * (horiz ? pick(labelOptions.y, axis.tickRotCorr.y + 8) : labelOptions.x) - lineHeightCorrection));
			axis.axisTitleMargin = pick(titleOffsetOption, labelOffsetPadded);

			axisOffset[side] = mathMax(
				axisOffset[side],
				axis.axisTitleMargin + titleOffset + directionFactor * axis.offset,
				labelOffsetPadded // #3027
			);

			// Decide the clipping needed to keep the graph inside the plot area and axis lines
			clip = mathFloor(options.lineWidth / 2) * 2;
			if (options.offset) {
				clip = mathMax(0, clip - options.offset);		
			}
			clipOffset[invertedSide] = mathMax(clipOffset[invertedSide], clip);
		},

		/**
		 * Get the path for the axis line
		 */
		getLinePath: function (lineWidth) {
			var chart = this.chart,
				opposite = this.opposite,
				offset = this.offset,
				horiz = this.horiz,
				lineLeft = this.left + (opposite ? this.width : 0) + offset,
				lineTop = chart.chartHeight - this.bottom - (opposite ? this.height : 0) + offset;

			if (opposite) {
				lineWidth *= -1; // crispify the other way - #1480, #1687
			}

			return chart.renderer.crispLine([
					M,
					horiz ?
						this.left :
						lineLeft,
					horiz ?
						lineTop :
						this.top,
					L,
					horiz ?
						chart.chartWidth - this.right :
						lineLeft,
					horiz ?
						lineTop :
						chart.chartHeight - this.bottom
				], lineWidth);
		},

		/**
		 * Position the title
		 */
		getTitlePosition: function () {
			// compute anchor points for each of the title align options
			var horiz = this.horiz,
				axisLeft = this.left,
				axisTop = this.top,
				axisLength = this.len,
				axisTitleOptions = this.options.title,
				margin = horiz ? axisLeft : axisTop,
				opposite = this.opposite,
				offset = this.offset,
				xOption = axisTitleOptions.x || 0,
				yOption = axisTitleOptions.y || 0,
				fontSize = pInt(axisTitleOptions.style.fontSize || 12),

				// the position in the length direction of the axis
				alongAxis = {
					low: margin + (horiz ? 0 : axisLength),
					middle: margin + axisLength / 2,
					high: margin + (horiz ? axisLength : 0)
				}[axisTitleOptions.align],

				// the position in the perpendicular direction of the axis
				offAxis = (horiz ? axisTop + this.height : axisLeft) +
					(horiz ? 1 : -1) * // horizontal axis reverses the margin
					(opposite ? -1 : 1) * // so does opposite axes
					this.axisTitleMargin +
					(this.side === 2 ? fontSize : 0);

			return {
				x: horiz ?
					alongAxis + xOption :
					offAxis + (opposite ? this.width : 0) + offset + xOption,
				y: horiz ?
					offAxis + yOption - (opposite ? this.height : 0) + offset :
					alongAxis + yOption
			};
		},

		/**
		 * Render the axis
		 */
		render: function () {
			var axis = this,
				chart = axis.chart,
				renderer = chart.renderer,
				options = axis.options,
				isLog = axis.isLog,
				isLinked = axis.isLinked,
				tickPositions = axis.tickPositions,
				axisTitle = axis.axisTitle,			
				ticks = axis.ticks,
				minorTicks = axis.minorTicks,
				alternateBands = axis.alternateBands,
				stackLabelOptions = options.stackLabels,
				alternateGridColor = options.alternateGridColor,
				tickmarkOffset = axis.tickmarkOffset,
				lineWidth = options.lineWidth,
				linePath,
				hasRendered = chart.hasRendered,
				slideInTicks = hasRendered && defined(axis.oldMin) && !isNaN(axis.oldMin),
				showAxis = axis.showAxis,
				from,
				to;

			// Reset
			axis.labelEdge.length = 0;
			//axis.justifyToPlot = overflow === 'justify';
			axis.overlap = false;

			// Mark all elements inActive before we go over and mark the active ones
			each([ticks, minorTicks, alternateBands], function (coll) {
				var pos;
				for (pos in coll) {
					coll[pos].isActive = false;
				}
			});

			// If the series has data draw the ticks. Else only the line and title
			if (axis.hasData() || isLinked) {

				// minor ticks
				if (axis.minorTickInterval && !axis.categories) {
					each(axis.getMinorTickPositions(), function (pos) {
						if (!minorTicks[pos]) {
							minorTicks[pos] = new Tick(axis, pos, 'minor');
						}

						// render new ticks in old position
						if (slideInTicks && minorTicks[pos].isNew) {
							minorTicks[pos].render(null, true);
						}

						minorTicks[pos].render(null, false, 1);
					});
				}

				// Major ticks. Pull out the first item and render it last so that
				// we can get the position of the neighbour label. #808.
				if (tickPositions.length) { // #1300
					each(tickPositions, function (pos, i) {

						// linked axes need an extra check to find out if
						if (!isLinked || (pos >= axis.min && pos <= axis.max)) {

							if (!ticks[pos]) {
								ticks[pos] = new Tick(axis, pos);
							}

							// render new ticks in old position
							if (slideInTicks && ticks[pos].isNew) {
								ticks[pos].render(i, true, 0.1);
							}

							ticks[pos].render(i);
						}

					});
					// In a categorized axis, the tick marks are displayed between labels. So
					// we need to add a tick mark and grid line at the left edge of the X axis.
					if (tickmarkOffset && (axis.min === 0 || axis.single)) {
						if (!ticks[-1]) {
							ticks[-1] = new Tick(axis, -1, null, true);
						}
						ticks[-1].render(-1);
					}

				}

				// alternate grid color
				if (alternateGridColor) {
					each(tickPositions, function (pos, i) {
						if (i % 2 === 0 && pos < axis.max) {
							if (!alternateBands[pos]) {
								alternateBands[pos] = new Highcharts.PlotLineOrBand(axis);
							}
							from = pos + tickmarkOffset; // #949
							to = tickPositions[i + 1] !== UNDEFINED ? tickPositions[i + 1] + tickmarkOffset : axis.max;
							alternateBands[pos].options = {
								from: isLog ? lin2log(from) : from,
								to: isLog ? lin2log(to) : to,
								color: alternateGridColor
							};
							alternateBands[pos].render();
							alternateBands[pos].isActive = true;
						}
					});
				}

				// custom plot lines and bands
				if (!axis._addedPlotLB) { // only first time
					each((options.plotLines || []).concat(options.plotBands || []), function (plotLineOptions) {
						axis.addPlotBandOrLine(plotLineOptions);
					});
					axis._addedPlotLB = true;
				}

			} // end if hasData

			// Remove inactive ticks
			each([ticks, minorTicks, alternateBands], function (coll) {
				var pos,
					i,
					forDestruction = [],
					delay = globalAnimation ? globalAnimation.duration || 500 : 0,
					destroyInactiveItems = function () {
						i = forDestruction.length;
						while (i--) {
							// When resizing rapidly, the same items may be destroyed in different timeouts,
							// or the may be reactivated
							if (coll[forDestruction[i]] && !coll[forDestruction[i]].isActive) {
								coll[forDestruction[i]].destroy();
								delete coll[forDestruction[i]];
							}
						}

					};

				for (pos in coll) {

					if (!coll[pos].isActive) {
						// Render to zero opacity
						coll[pos].render(pos, false, 0);
						coll[pos].isActive = false;
						forDestruction.push(pos);
					}
				}

				// When the objects are finished fading out, destroy them
				if (coll === alternateBands || !chart.hasRendered || !delay) {
					destroyInactiveItems();
				} else if (delay) {
					setTimeout(destroyInactiveItems, delay);
				}
			});

			// Static items. As the axis group is cleared on subsequent calls
			// to render, these items are added outside the group.
			// axis line
			if (lineWidth) {
				linePath = axis.getLinePath(lineWidth);
				if (!axis.axisLine) {
					axis.axisLine = renderer.path(linePath)
						.attr({
							stroke: options.lineColor,
							'stroke-width': lineWidth,
							zIndex: 7
						})
						.add(axis.axisGroup);
				} else {
					axis.axisLine.animate({ d: linePath });
				}

				// show or hide the line depending on options.showEmpty
				axis.axisLine[showAxis ? 'show' : 'hide']();
			}

			if (axisTitle && showAxis) {

				axisTitle[axisTitle.isNew ? 'attr' : 'animate'](
					axis.getTitlePosition()
				);
				axisTitle.isNew = false;
			}

			// Stacked totals:
			if (stackLabelOptions && stackLabelOptions.enabled) {
				axis.renderStackTotals();
			}
			// End stacked totals

			axis.isDirty = false;
		},

		/**
		 * Redraw the axis to reflect changes in the data or axis extremes
		 */
		redraw: function () {
			
			// render the axis
			this.render();

			// move plot lines and bands
			each(this.plotLinesAndBands, function (plotLine) {
				plotLine.render();
			});

			// mark associated series as dirty and ready for redraw
			each(this.series, function (series) {
				series.isDirty = true;
			});

		},

		/**
		 * Destroys an Axis instance.
		 */
		destroy: function (keepEvents) {
			var axis = this,
				stacks = axis.stacks,
				stackKey,
				plotLinesAndBands = axis.plotLinesAndBands,
				i;

			// Remove the events
			if (!keepEvents) {
				removeEvent(axis);
			}

			// Destroy each stack total
			for (stackKey in stacks) {
				destroyObjectProperties(stacks[stackKey]);

				stacks[stackKey] = null;
			}

			// Destroy collections
			each([axis.ticks, axis.minorTicks, axis.alternateBands], function (coll) {
				destroyObjectProperties(coll);
			});
			i = plotLinesAndBands.length;
			while (i--) { // #1975
				plotLinesAndBands[i].destroy();
			}

			// Destroy local variables
			each(['stackTotalGroup', 'axisLine', 'axisTitle', 'axisGroup', 'cross', 'gridGroup', 'labelGroup'], function (prop) {
				if (axis[prop]) {
					axis[prop] = axis[prop].destroy();
				}
			});

			// Destroy crosshair
			if (this.cross) {
				this.cross.destroy();
			}
		},

		/**
		 * Draw the crosshair
		 */
		drawCrosshair: function (e, point) { // docs: Missing docs for Axis.crosshair. Also for properties.

			var path,
				options = this.crosshair,
				animation = options.animation,
				pos,
				attribs,
				categorized;
			
			if (
				// Disabled in options
				!this.crosshair || 
				// Snap
				((defined(point) || !pick(this.crosshair.snap, true)) === false) || 
				// Not on this axis (#4095, #2888)
				(point && point.series && point.series[this.coll] !== this)
			) {
				this.hideCrosshair();
			
			} else {			

				// Get the path
				if (!pick(options.snap, true)) {
					pos = (this.horiz ? e.chartX - this.pos : this.len - e.chartY + this.pos);
				} else if (defined(point)) {
					/*jslint eqeq: true*/
					pos = this.isXAxis ? point.plotX : this.len - point.plotY; // #3834
					/*jslint eqeq: false*/
				}

				if (this.isRadial) {
					path = this.getPlotLinePath(this.isXAxis ? point.x : pick(point.stackY, point.y)) || null; // #3189
				} else {
					path = this.getPlotLinePath(null, null, null, null, pos) || null; // #3189
				}

				if (path === null) {
					this.hideCrosshair();
					return;
				}

				// Draw the cross
				if (this.cross) {
					this.cross
						.attr({ visibility: VISIBLE })[animation ? 'animate' : 'attr']({ d: path }, animation);
				} else {
					categorized = this.categories && !this.isRadial;
					attribs = {
						'stroke-width': options.width || (categorized ? this.transA : 1),
						stroke: options.color || (categorized ? 'rgba(155,200,255,0.2)' : '#C0C0C0'),
						zIndex: options.zIndex || 2
					};
					if (options.dashStyle) {
						attribs.dashstyle = options.dashStyle;
					}
					this.cross = this.chart.renderer.path(path).attr(attribs).add();
				}

			}

		},

		/**
		 *	Hide the crosshair.
		 */
		hideCrosshair: function () {
			if (this.cross) {
				this.cross.hide();
			}
		}
	}; // end Axis

	extend(Axis.prototype, AxisPlotLineOrBandExtension);

	/**
	 * Set the tick positions to a time unit that makes sense, for example
	 * on the first of each month or on every Monday. Return an array
	 * with the time positions. Used in datetime axes as well as for grouping
	 * data on a datetime axis.
	 *
	 * @param {Object} normalizedInterval The interval in axis values (ms) and the count
	 * @param {Number} min The minimum in axis values
	 * @param {Number} max The maximum in axis values
	 * @param {Number} startOfWeek
	 */
	Axis.prototype.getTimeTicks = function (normalizedInterval, min, max, startOfWeek) {
		var tickPositions = [],
			i,
			higherRanks = {},
			useUTC = defaultOptions.global.useUTC,
			minYear, // used in months and years as a basis for Date.UTC()
			minDate = new Date(min - getTZOffset(min)),
			interval = normalizedInterval.unitRange,
			count = normalizedInterval.count;

		if (defined(min)) { // #1300
			minDate[setMilliseconds](interval >= timeUnits.second ? 0 : // #3935
				count * mathFloor(minDate.getMilliseconds() / count)); // #3652, #3654

			if (interval >= timeUnits.second) { // second
				minDate[setSeconds](interval >= timeUnits.minute ? 0 : // #3935
					count * mathFloor(minDate.getSeconds() / count));
			}
		
			if (interval >= timeUnits.minute) { // minute
				minDate[setMinutes](interval >= timeUnits.hour ? 0 :
					count * mathFloor(minDate[getMinutes]() / count));
			}
		
			if (interval >= timeUnits.hour) { // hour
				minDate[setHours](interval >= timeUnits.day ? 0 :
					count * mathFloor(minDate[getHours]() / count));
			}
		
			if (interval >= timeUnits.day) { // day
				minDate[setDate](interval >= timeUnits.month ? 1 :
					count * mathFloor(minDate[getDate]() / count));
			}
		
			if (interval >= timeUnits.month) { // month
				minDate[setMonth](interval >= timeUnits.year ? 0 :
					count * mathFloor(minDate[getMonth]() / count));
				minYear = minDate[getFullYear]();
			}
		
			if (interval >= timeUnits.year) { // year
				minYear -= minYear % count;
				minDate[setFullYear](minYear);
			}
		
			// week is a special case that runs outside the hierarchy
			if (interval === timeUnits.week) {
				// get start of current week, independent of count
				minDate[setDate](minDate[getDate]() - minDate[getDay]() +
					pick(startOfWeek, 1));
			}
		
		
			// get tick positions
			i = 1;
			if (timezoneOffset || getTimezoneOffset) {
				minDate = minDate.getTime();
				minDate = new Date(minDate + getTZOffset(minDate));
			}
			minYear = minDate[getFullYear]();
			var time = minDate.getTime(),
				minMonth = minDate[getMonth](),
				minDateDate = minDate[getDate](),
				localTimezoneOffset = (timeUnits.day + 
						(useUTC ? getTZOffset(minDate) : minDate.getTimezoneOffset() * 60 * 1000)
					) % timeUnits.day; // #950, #3359
		
			// iterate and add tick positions at appropriate values
			while (time < max) {
				tickPositions.push(time);
		
				// if the interval is years, use Date.UTC to increase years
				if (interval === timeUnits.year) {
					time = makeTime(minYear + i * count, 0);
		
				// if the interval is months, use Date.UTC to increase months
				} else if (interval === timeUnits.month) {
					time = makeTime(minYear, minMonth + i * count);
		
				// if we're using global time, the interval is not fixed as it jumps
				// one hour at the DST crossover
				} else if (!useUTC && (interval === timeUnits.day || interval === timeUnits.week)) {
					time = makeTime(minYear, minMonth, minDateDate +
						i * count * (interval === timeUnits.day ? 1 : 7));
		
				// else, the interval is fixed and we use simple addition
				} else {
					time += interval * count;
				}
		
				i++;
			}
		
			// push the last time
			tickPositions.push(time);


			// mark new days if the time is dividible by day (#1649, #1760)
			each(grep(tickPositions, function (time) {
				return interval <= timeUnits.hour && time % timeUnits.day === localTimezoneOffset;
			}), function (time) {
				higherRanks[time] = 'day';
			});
		}


		// record information on the chosen unit - for dynamic label formatter
		tickPositions.info = extend(normalizedInterval, {
			higherRanks: higherRanks,
			totalRange: interval * count
		});

		return tickPositions;
	};

	/**
	 * Get a normalized tick interval for dates. Returns a configuration object with
	 * unit range (interval), count and name. Used to prepare data for getTimeTicks. 
	 * Previously this logic was part of getTimeTicks, but as getTimeTicks now runs
	 * of segments in stock charts, the normalizing logic was extracted in order to 
	 * prevent it for running over again for each segment having the same interval. 
	 * #662, #697.
	 */
	Axis.prototype.normalizeTimeTickInterval = function (tickInterval, unitsOption) {
		var units = unitsOption || [[
					'millisecond', // unit name
					[1, 2, 5, 10, 20, 25, 50, 100, 200, 500] // allowed multiples
				], [
					'second',
					[1, 2, 5, 10, 15, 30]
				], [
					'minute',
					[1, 2, 5, 10, 15, 30]
				], [
					'hour',
					[1, 2, 3, 4, 6, 8, 12]
				], [
					'day',
					[1, 2]
				], [
					'week',
					[1, 2]
				], [
					'month',
					[1, 2, 3, 4, 6]
				], [
					'year',
					null
				]],
			unit = units[units.length - 1], // default unit is years
			interval = timeUnits[unit[0]],
			multiples = unit[1],
			count,
			i;
			
		// loop through the units to find the one that best fits the tickInterval
		for (i = 0; i < units.length; i++) {
			unit = units[i];
			interval = timeUnits[unit[0]];
			multiples = unit[1];


			if (units[i + 1]) {
				// lessThan is in the middle between the highest multiple and the next unit.
				var lessThan = (interval * multiples[multiples.length - 1] +
							timeUnits[units[i + 1][0]]) / 2;

				// break and keep the current unit
				if (tickInterval <= lessThan) {
					break;
				}
			}
		}

		// prevent 2.5 years intervals, though 25, 250 etc. are allowed
		if (interval === timeUnits.year && tickInterval < 5 * interval) {
			multiples = [1, 2, 5];
		}

		// get the count
		count = normalizeTickInterval(
			tickInterval / interval, 
			multiples,
			unit[0] === 'year' ? mathMax(getMagnitude(tickInterval / interval), 1) : 1 // #1913, #2360
		);
		
		return {
			unitRange: interval,
			count: count,
			unitName: unit[0]
		};
	};/**
	 * Methods defined on the Axis prototype
	 */

	/**
	 * Set the tick positions of a logarithmic axis
	 */
	Axis.prototype.getLogTickPositions = function (interval, min, max, minor) {
		var axis = this,
			options = axis.options,
			axisLength = axis.len,
			// Since we use this method for both major and minor ticks,
			// use a local variable and return the result
			positions = []; 
		
		// Reset
		if (!minor) {
			axis._minorAutoInterval = null;
		}
		
		// First case: All ticks fall on whole logarithms: 1, 10, 100 etc.
		if (interval >= 0.5) {
			interval = mathRound(interval);
			positions = axis.getLinearTickPositions(interval, min, max);
			
		// Second case: We need intermediary ticks. For example 
		// 1, 2, 4, 6, 8, 10, 20, 40 etc. 
		} else if (interval >= 0.08) {
			var roundedMin = mathFloor(min),
				intermediate,
				i,
				j,
				len,
				pos,
				lastPos,
				break2;
				
			if (interval > 0.3) {
				intermediate = [1, 2, 4];
			} else if (interval > 0.15) { // 0.2 equals five minor ticks per 1, 10, 100 etc
				intermediate = [1, 2, 4, 6, 8];
			} else { // 0.1 equals ten minor ticks per 1, 10, 100 etc
				intermediate = [1, 2, 3, 4, 5, 6, 7, 8, 9];
			}
			
			for (i = roundedMin; i < max + 1 && !break2; i++) {
				len = intermediate.length;
				for (j = 0; j < len && !break2; j++) {
					pos = log2lin(lin2log(i) * intermediate[j]);
					if (pos > min && (!minor || lastPos <= max) && lastPos !== UNDEFINED) { // #1670, lastPos is #3113
						positions.push(lastPos);
					}
					
					if (lastPos > max) {
						break2 = true;
					}
					lastPos = pos;
				}
			}
			
		// Third case: We are so deep in between whole logarithmic values that
		// we might as well handle the tick positions like a linear axis. For
		// example 1.01, 1.02, 1.03, 1.04.
		} else {
			var realMin = lin2log(min),
				realMax = lin2log(max),
				tickIntervalOption = options[minor ? 'minorTickInterval' : 'tickInterval'],
				filteredTickIntervalOption = tickIntervalOption === 'auto' ? null : tickIntervalOption,
				tickPixelIntervalOption = options.tickPixelInterval / (minor ? 5 : 1),
				totalPixelLength = minor ? axisLength / axis.tickPositions.length : axisLength;
			
			interval = pick(
				filteredTickIntervalOption,
				axis._minorAutoInterval,
				(realMax - realMin) * tickPixelIntervalOption / (totalPixelLength || 1)
			);
			
			interval = normalizeTickInterval(
				interval, 
				null, 
				getMagnitude(interval)
			);
			
			positions = map(axis.getLinearTickPositions(
				interval, 
				realMin,
				realMax	
			), log2lin);
			
			if (!minor) {
				axis._minorAutoInterval = interval / 5;
			}
		}
		
		// Set the axis-level tickInterval variable 
		if (!minor) {
			axis.tickInterval = interval;
		}
		return positions;
	};/**
	 * The tooltip object
	 * @param {Object} chart The chart instance
	 * @param {Object} options Tooltip options
	 */
	var Tooltip = Highcharts.Tooltip = function () {
		this.init.apply(this, arguments);
	};

	Tooltip.prototype = {

		init: function (chart, options) {

			var borderWidth = options.borderWidth,
				style = options.style,
				padding = pInt(style.padding);

			// Save the chart and options
			this.chart = chart;
			this.options = options;

			// Keep track of the current series
			//this.currentSeries = UNDEFINED;

			// List of crosshairs
			this.crosshairs = [];

			// Current values of x and y when animating
			this.now = { x: 0, y: 0 };

			// The tooltip is initially hidden
			this.isHidden = true;


			// create the label		
			this.label = chart.renderer.label('', 0, 0, options.shape || 'callout', null, null, options.useHTML, null, 'tooltip')
				.attr({
					padding: padding,
					fill: options.backgroundColor,
					'stroke-width': borderWidth,
					r: options.borderRadius,
					zIndex: 8
				})
				.css(style)
				.css({ padding: 0 }) // Remove it from VML, the padding is applied as an attribute instead (#1117)
				.add()
				.attr({ y: -9999 }); // #2301, #2657

			// When using canVG the shadow shows up as a gray circle
			// even if the tooltip is hidden.
			if (!useCanVG) {
				this.label.shadow(options.shadow);
			}

			// Public property for getting the shared state.
			this.shared = options.shared;
		},

		/**
		 * Destroy the tooltip and its elements.
		 */
		destroy: function () {
			// Destroy and clear local variables
			if (this.label) {
				this.label = this.label.destroy();
			}
			clearTimeout(this.hideTimer);
			clearTimeout(this.tooltipTimeout);
		},

		/**
		 * Provide a soft movement for the tooltip
		 *
		 * @param {Number} x
		 * @param {Number} y
		 * @private
		 */
		move: function (x, y, anchorX, anchorY) {
			var tooltip = this,
				now = tooltip.now,
				animate = tooltip.options.animation !== false && !tooltip.isHidden && 
					// When we get close to the target position, abort animation and land on the right place (#3056)
					(mathAbs(x - now.x) > 1 || mathAbs(y - now.y) > 1),
				skipAnchor = tooltip.followPointer || tooltip.len > 1;

			// Get intermediate values for animation
			extend(now, {
				x: animate ? (2 * now.x + x) / 3 : x,
				y: animate ? (now.y + y) / 2 : y,
				anchorX: skipAnchor ? UNDEFINED : animate ? (2 * now.anchorX + anchorX) / 3 : anchorX,
				anchorY: skipAnchor ? UNDEFINED : animate ? (now.anchorY + anchorY) / 2 : anchorY
			});

			// Move to the intermediate value
			tooltip.label.attr(now);

			
			// Run on next tick of the mouse tracker
			if (animate) {
			
				// Never allow two timeouts
				clearTimeout(this.tooltipTimeout);
				
				// Set the fixed interval ticking for the smooth tooltip
				this.tooltipTimeout = setTimeout(function () {
					// The interval function may still be running during destroy, so check that the chart is really there before calling.
					if (tooltip) {
						tooltip.move(x, y, anchorX, anchorY);
					}
				}, 32);
				
			}
		},

		/**
		 * Hide the tooltip
		 */
		hide: function (delay) {
			var tooltip = this,
				hoverPoints;
			
			clearTimeout(this.hideTimer); // disallow duplicate timers (#1728, #1766)
			if (!this.isHidden) {
				hoverPoints = this.chart.hoverPoints;

				this.hideTimer = setTimeout(function () {
					tooltip.label.fadeOut();
					tooltip.isHidden = true;
				}, pick(delay, this.options.hideDelay, 500));
			}
		},
		
		/** 
		 * Extendable method to get the anchor position of the tooltip
		 * from a point or set of points
		 */
		getAnchor: function (points, mouseEvent) {
			var ret,
				chart = this.chart,
				inverted = chart.inverted,
				plotTop = chart.plotTop,
				plotLeft = chart.plotLeft,
				plotX = 0,
				plotY = 0,
				yAxis,
				xAxis;
			
			points = splat(points);
			
			// Pie uses a special tooltipPos
			ret = points[0].tooltipPos;
			
			// When tooltip follows mouse, relate the position to the mouse
			if (this.followPointer && mouseEvent) {
				if (mouseEvent.chartX === UNDEFINED) {
					mouseEvent = chart.pointer.normalize(mouseEvent);
				}
				ret = [
					mouseEvent.chartX - chart.plotLeft,
					mouseEvent.chartY - plotTop
				];
			}
			// When shared, use the average position
			if (!ret) {
				each(points, function (point) {
					yAxis = point.series.yAxis;
					xAxis = point.series.xAxis;
					plotX += point.plotX  + (!inverted && xAxis ? xAxis.left - plotLeft : 0); 
					plotY += (point.plotLow ? (point.plotLow + point.plotHigh) / 2 : point.plotY) +
						(!inverted && yAxis ? yAxis.top - plotTop : 0); // #1151
				});
				
				plotX /= points.length;
				plotY /= points.length;
				
				ret = [
					inverted ? chart.plotWidth - plotY : plotX,
					this.shared && !inverted && points.length > 1 && mouseEvent ? 
						mouseEvent.chartY - plotTop : // place shared tooltip next to the mouse (#424)
						inverted ? chart.plotHeight - plotX : plotY
				];
			}

			return map(ret, mathRound);
		},
		
		/**
		 * Place the tooltip in a chart without spilling over
		 * and not covering the point it self.
		 */
		getPosition: function (boxWidth, boxHeight, point) {
			
			var chart = this.chart,
				distance = this.distance,
				ret = {},
				h = point.h || 0, // #4117
				swapped,
				first = ['y', chart.chartHeight, boxHeight, point.plotY + chart.plotTop],
				second = ['x', chart.chartWidth, boxWidth, point.plotX + chart.plotLeft],
				// The far side is right or bottom
				preferFarSide = pick(point.ttBelow, (chart.inverted && !point.negative) || (!chart.inverted && point.negative)),
				/**
				 * Handle the preferred dimension. When the preferred dimension is tooltip
				 * on top or bottom of the point, it will look for space there.
				 */
				firstDimension = function (dim, outerSize, innerSize, point) {
					var roomLeft = innerSize < point - distance,
						roomRight = point + distance + innerSize < outerSize,
						alignedLeft = point - distance - innerSize,
						alignedRight = point + distance;

					if (preferFarSide && roomRight) {
						ret[dim] = alignedRight;
					} else if (!preferFarSide && roomLeft) {
						ret[dim] = alignedLeft;
					} else if (roomLeft) {
						ret[dim] = alignedLeft - h < 0 ? alignedLeft : alignedLeft - h;
					} else if (roomRight) {
						ret[dim] = alignedRight + h + innerSize > outerSize ? alignedRight : alignedRight + h;
					} else {
						return false;
					}
				},
				/**
				 * Handle the secondary dimension. If the preferred dimension is tooltip
				 * on top or bottom of the point, the second dimension is to align the tooltip
				 * above the point, trying to align center but allowing left or right
				 * align within the chart box.
				 */
				secondDimension = function (dim, outerSize, innerSize, point) {
					// Too close to the edge, return false and swap dimensions
					if (point < distance || point > outerSize - distance) {
						return false;
					
					// Align left/top
					} else if (point < innerSize / 2) {
						ret[dim] = 1;
					// Align right/bottom
					} else if (point > outerSize - innerSize / 2) {
						ret[dim] = outerSize - innerSize - 2;
					// Align center
					} else {
						ret[dim] = point - innerSize / 2;
					}
				},
				/**
				 * Swap the dimensions 
				 */
				swap = function (count) {
					var temp = first;
					first = second;
					second = temp;
					swapped = count;
				},
				run = function () {
					if (firstDimension.apply(0, first) !== false) {
						if (secondDimension.apply(0, second) === false && !swapped) {
							swap(true);
							run();
						}
					} else if (!swapped) {
						swap(true);
						run();
					} else {
						ret.x = ret.y = 0;
					}
				};

			// Under these conditions, prefer the tooltip on the side of the point
			if (chart.inverted || this.len > 1) {
				swap();
			}
			run();

			return ret;
		
		},

		/**
		 * In case no user defined formatter is given, this will be used. Note that the context
		 * here is an object holding point, series, x, y etc.
		 */
		defaultFormatter: function (tooltip) {
			var items = this.points || splat(this),
				s;

			// build the header
			s = [tooltip.tooltipFooterHeaderFormatter(items[0])]; //#3397: abstraction to enable formatting of footer and header

			// build the values
			s = s.concat(tooltip.bodyFormatter(items));

			// footer
			s.push(tooltip.tooltipFooterHeaderFormatter(items[0], true)); //#3397: abstraction to enable formatting of footer and header

			return s.join('');
		},

		/**
		 * Refresh the tooltip's text and position.
		 * @param {Object} point
		 */
		refresh: function (point, mouseEvent) {
			var tooltip = this,
				chart = tooltip.chart,
				label = tooltip.label,
				options = tooltip.options,
				x,
				y,
				anchor,
				textConfig = {},
				text,
				pointConfig = [],
				formatter = options.formatter || tooltip.defaultFormatter,
				hoverPoints = chart.hoverPoints,
				borderColor,
				shared = tooltip.shared,
				currentSeries;
				
			clearTimeout(this.hideTimer);
			
			// get the reference point coordinates (pie charts use tooltipPos)
			tooltip.followPointer = splat(point)[0].series.tooltipOptions.followPointer;
			anchor = tooltip.getAnchor(point, mouseEvent);
			x = anchor[0];
			y = anchor[1];

			// shared tooltip, array is sent over
			if (shared && !(point.series && point.series.noSharedTooltip)) {
				
				// hide previous hoverPoints and set new
				
				chart.hoverPoints = point;
				if (hoverPoints) {
					each(hoverPoints, function (point) {
						point.setState();
					});
				}

				each(point, function (item) {
					item.setState(HOVER_STATE);

					pointConfig.push(item.getLabelConfig());
				});

				textConfig = {
					x: point[0].category,
					y: point[0].y
				};
				textConfig.points = pointConfig;
				this.len = pointConfig.length;
				point = point[0];

			// single point tooltip
			} else {
				textConfig = point.getLabelConfig();
			}
			text = formatter.call(textConfig, tooltip);

			// register the current series
			currentSeries = point.series;
			this.distance = pick(currentSeries.tooltipOptions.distance, 16);

			// update the inner HTML
			if (text === false) {
				this.hide();
			} else {

				// show it
				if (tooltip.isHidden) {
					stop(label);
					label.attr('opacity', 1).show();
				}

				// update text
				label.attr({
					text: text
				});

				// set the stroke color of the box
				borderColor = options.borderColor || point.color || currentSeries.color || '#606060';
				label.attr({
					stroke: borderColor
				});
				tooltip.updatePosition({ 
					plotX: x, 
					plotY: y, 
					negative: point.negative, 
					ttBelow: point.ttBelow, 
					h: anchor[2] || 0
				});
			
				this.isHidden = false;
			}
			fireEvent(chart, 'tooltipRefresh', {
					text: text,
					x: x + chart.plotLeft,
					y: y + chart.plotTop,
					borderColor: borderColor
				});
		},
		
		/**
		 * Find the new position and perform the move
		 */
		updatePosition: function (point) {
			var chart = this.chart,
				label = this.label, 
				pos = (this.options.positioner || this.getPosition).call(
					this,
					label.width,
					label.height,
					point
				);

			// do the move
			this.move(
				mathRound(pos.x), 
				mathRound(pos.y || 0), // can be undefined (#3977) 
				point.plotX + chart.plotLeft, 
				point.plotY + chart.plotTop
			);
		},

		/** 
		 * Get the best X date format based on the closest point range on the axis.
		 */
		getXDateFormat: function (point, options, xAxis) {
			var xDateFormat,
				dateTimeLabelFormats = options.dateTimeLabelFormats,
				closestPointRange = xAxis && xAxis.closestPointRange,
				n,
				blank = '01-01 00:00:00.000',
				strpos = {
					millisecond: 15,
					second: 12,
					minute: 9,
					hour: 6,
					day: 3
				},
				date,
				lastN = 'millisecond'; // for sub-millisecond data, #4223

			if (closestPointRange) {
				date = dateFormat('%m-%d %H:%M:%S.%L', point.x);
				for (n in timeUnits) {

					// If the range is exactly one week and we're looking at a Sunday/Monday, go for the week format
					if (closestPointRange === timeUnits.week && +dateFormat('%w', point.x) === xAxis.options.startOfWeek && 
							date.substr(6) === blank.substr(6)) {
						n = 'week';
						break;

					// The first format that is too great for the range
					} else if (timeUnits[n] > closestPointRange) {
						n = lastN;
						break;
					
					// If the point is placed every day at 23:59, we need to show
					// the minutes as well. #2637.
					} else if (strpos[n] && date.substr(strpos[n]) !== blank.substr(strpos[n])) {
						break;
					}

					// Weeks are outside the hierarchy, only apply them on Mondays/Sundays like in the first condition
					if (n !== 'week') {
						lastN = n;
					}
				}
				
				if (n) {
					xDateFormat = dateTimeLabelFormats[n];
				}
			} else {
				xDateFormat = dateTimeLabelFormats.day;
			}

			return xDateFormat || dateTimeLabelFormats.year; // #2546, 2581
		},

		/**
		 * Format the footer/header of the tooltip
		 * #3397: abstraction to enable formatting of footer and header
		 */
		tooltipFooterHeaderFormatter: function (point, isFooter) {
			var footOrHead = isFooter ? 'footer' : 'header',
				series = point.series,
				tooltipOptions = series.tooltipOptions,
				xDateFormat = tooltipOptions.xDateFormat,
				xAxis = series.xAxis,
				isDateTime = xAxis && xAxis.options.type === 'datetime' && isNumber(point.key),
				formatString = tooltipOptions[footOrHead+'Format'];

			// Guess the best date format based on the closest point distance (#568, #3418)
			if (isDateTime && !xDateFormat) {
				xDateFormat = this.getXDateFormat(point, tooltipOptions, xAxis);
			}

			// Insert the footer date format if any
			if (isDateTime && xDateFormat) {
				formatString = formatString.replace('{point.key}', '{point.key:' + xDateFormat + '}');
			}

			return format(formatString, {
				point: point,
				series: series
			});
		},

		/**
	     * Build the body (lines) of the tooltip by iterating over the items and returning one entry for each item,
	     * abstracting this functionality allows to easily overwrite and extend it. 
		 */
		bodyFormatter: function (items) {
	        return map(items, function (item) {
	            var tooltipOptions = item.series.tooltipOptions;
	            return (tooltipOptions.pointFormatter || item.point.tooltipFormatter).call(item.point, tooltipOptions.pointFormat);
	        });
	    }
	    
	};

	var hoverChartIndex;

	// Global flag for touch support
	hasTouch = doc.documentElement.ontouchstart !== UNDEFINED;

	/**
	 * The mouse tracker object. All methods starting with "on" are primary DOM event handlers. 
	 * Subsequent methods should be named differently from what they are doing.
	 * @param {Object} chart The Chart instance
	 * @param {Object} options The root options object
	 */
	var Pointer = Highcharts.Pointer = function (chart, options) {
		this.init(chart, options);
	};

	Pointer.prototype = {
		/**
		 * Initialize Pointer
		 */
		init: function (chart, options) {
			
			var chartOptions = options.chart,
				chartEvents = chartOptions.events,
				zoomType = useCanVG ? '' : chartOptions.zoomType,
				inverted = chart.inverted,
				zoomX,
				zoomY;

			// Store references
			this.options = options;
			this.chart = chart;
			
			// Zoom status
			this.zoomX = zoomX = /x/.test(zoomType);
			this.zoomY = zoomY = /y/.test(zoomType);
			this.zoomHor = (zoomX && !inverted) || (zoomY && inverted);
			this.zoomVert = (zoomY && !inverted) || (zoomX && inverted);
			this.hasZoom = zoomX || zoomY;

			// Do we need to handle click on a touch device?
			this.runChartClick = chartEvents && !!chartEvents.click;

			this.pinchDown = [];
			this.lastValidTouch = {};

			if (Highcharts.Tooltip && options.tooltip.enabled) {
				chart.tooltip = new Tooltip(chart, options.tooltip);
				this.followTouchMove = pick(options.tooltip.followTouchMove, true);
			}

			this.setDOMEvents();
		}, 

		/**
		 * Add crossbrowser support for chartX and chartY
		 * @param {Object} e The event object in standard browsers
		 */
		normalize: function (e, chartPosition) {
			var chartX,
				chartY,
				ePos;

			// common IE normalizing
			e = e || window.event;

			// Framework specific normalizing (#1165)
			e = washMouseEvent(e);

			// More IE normalizing, needs to go after washMouseEvent
			if (!e.target) {
				e.target = e.srcElement;
			}
			
			// iOS (#2757)
			ePos = e.touches ?  (e.touches.length ? e.touches.item(0) : e.changedTouches[0]) : e;

			// Get mouse position
			if (!chartPosition) {
				this.chartPosition = chartPosition = offset(this.chart.container);
			}

			// chartX and chartY
			if (ePos.pageX === UNDEFINED) { // IE < 9. #886.
				chartX = mathMax(e.x, e.clientX - chartPosition.left); // #2005, #2129: the second case is 
					// for IE10 quirks mode within framesets
				chartY = e.y;
			} else {
				chartX = ePos.pageX - chartPosition.left;
				chartY = ePos.pageY - chartPosition.top;
			}

			return extend(e, {
				chartX: mathRound(chartX),
				chartY: mathRound(chartY)
			});
		},

		/**
		 * Get the click position in terms of axis values.
		 *
		 * @param {Object} e A pointer event
		 */
		getCoordinates: function (e) {
			var coordinates = {
					xAxis: [],
					yAxis: []
				};

			each(this.chart.axes, function (axis) {
				coordinates[axis.isXAxis ? 'xAxis' : 'yAxis'].push({
					axis: axis,
					value: axis.toValue(e[axis.horiz ? 'chartX' : 'chartY'])
				});
			});
			return coordinates;
		},
		
		/**
		 * With line type charts with a single tracker, get the point closest to the mouse.
		 * Run Point.onMouseOver and display tooltip for the point or points.
		 */
		runPointActions: function (e) {

			var pointer = this,
				chart = pointer.chart,
				series = chart.series,
				tooltip = chart.tooltip,
				shared = tooltip ? tooltip.shared : false,
				followPointer,
				hoverPoint = chart.hoverPoint,
				hoverSeries = chart.hoverSeries,
				i,
				distance = chart.chartWidth,
				anchor,
				noSharedTooltip,
				directTouch,
				kdpoints = [],
				kdpoint,
				kdpointT;

			// For hovering over the empty parts of the plot area (hoverSeries is undefined). 
			// If there is one series with point tracking (combo chart), don't go to nearest neighbour.
			if (!shared && !hoverSeries) {
				for (i = 0; i < series.length; i++) {
					if (series[i].directTouch || !series[i].options.stickyTracking) {
						series = [];
					}
				}
			}

			// If it has a hoverPoint and that series requires direct touch (like columns), 
			// use the hoverPoint (#3899). Otherwise, search the k-d tree.
			if (!shared && hoverSeries && hoverSeries.directTouch && hoverPoint) {
				kdpoint = hoverPoint;

			// Handle shared tooltip or cases where a series is not yet hovered
			} else {
				// Find nearest points on all series
				each(series, function (s) {
					// Skip hidden series
					noSharedTooltip = s.noSharedTooltip && shared;
					directTouch = !shared && s.directTouch;
					if (s.visible && !noSharedTooltip && !directTouch && pick(s.options.enableMouseTracking, true)) { // #3821
						kdpointT = s.searchPoint(e, !noSharedTooltip && s.kdDimensions === 1); // #3828
						if (kdpointT) {
							kdpoints.push(kdpointT);
						}
					}
				});
				// Find absolute nearest point
				each(kdpoints, function (p) {
					if (p && typeof p.dist === 'number' && p.dist < distance) {
						distance = p.dist;
						kdpoint = p;
					}
				});
			}

			// Refresh tooltip for kdpoint if new hover point or tooltip was hidden // #3926, #4200
			if (kdpoint && (kdpoint !== this.prevKDPoint || (tooltip && tooltip.isHidden))) {
				// Draw tooltip if necessary
				if (shared && !kdpoint.series.noSharedTooltip) {
					i = kdpoints.length;
					while (i--) {
						if (kdpoints[i].clientX !== kdpoint.clientX || kdpoints[i].series.noSharedTooltip) {
							kdpoints.splice(i, 1);
						}
					}
					if (kdpoints.length && tooltip) {
						tooltip.refresh(kdpoints, e);
					}

					// do mouseover on all points except the closest
					each(kdpoints, function (point) {
						if (point !== kdpoint) { 
							point.onMouseOver(e);
						}
					});	
					// #3919, #3985 do mouseover on the closest point last to ensure it is the hoverpoint
					((hoverSeries && hoverSeries.directTouch && hoverPoint) || kdpoint).onMouseOver(e); 
				} else {
					if (tooltip) { 
						tooltip.refresh(kdpoint, e);
					}
					kdpoint.onMouseOver(e); 
				}
				this.prevKDPoint = kdpoint;
			
			// Update positions (regardless of kdpoint or hoverPoint)
			} else {
				followPointer = hoverSeries && hoverSeries.tooltipOptions.followPointer;
				if (tooltip && followPointer && !tooltip.isHidden) {
					anchor = tooltip.getAnchor([{}], e);
					tooltip.updatePosition({ plotX: anchor[0], plotY: anchor[1] });			
				}
			}

			// Start the event listener to pick up the tooltip 
			if (tooltip && !pointer._onDocumentMouseMove) {
				pointer._onDocumentMouseMove = function (e) {
					if (charts[hoverChartIndex]) {
						charts[hoverChartIndex].pointer.onDocumentMouseMove(e);
					}
				};
				addEvent(doc, 'mousemove', pointer._onDocumentMouseMove);
			}
			
			// Crosshair
			each(chart.axes, function (axis) {
				axis.drawCrosshair(e, pick(kdpoint, hoverPoint));
			});	
			

		},



		/**
		 * Reset the tracking by hiding the tooltip, the hover series state and the hover point
		 * 
		 * @param allowMove {Boolean} Instead of destroying the tooltip altogether, allow moving it if possible
		 */
		reset: function (allowMove, delay) {
			var pointer = this,
				chart = pointer.chart,
				hoverSeries = chart.hoverSeries,
				hoverPoint = chart.hoverPoint,
				hoverPoints = chart.hoverPoints,
				tooltip = chart.tooltip,
				tooltipPoints = tooltip && tooltip.shared ? hoverPoints : hoverPoint;
				
			// Narrow in allowMove
			allowMove = allowMove && tooltip && tooltipPoints;
				
			// Check if the points have moved outside the plot area, #1003		
			if (allowMove  && splat(tooltipPoints)[0].plotX === UNDEFINED) {
				allowMove = false;
			}	
			// Just move the tooltip, #349
			if (allowMove) {
				tooltip.refresh(tooltipPoints);
				if (hoverPoint) { // #2500
					hoverPoint.setState(hoverPoint.state, true);
					each(chart.axes, function (axis) {
						if (pick(axis.options.crosshair && axis.options.crosshair.snap, true)) {
							axis.drawCrosshair(null, hoverPoint);
						}  else {
							axis.hideCrosshair();
						}
					});
					
				}

			// Full reset
			} else {

				if (hoverPoint) {
					hoverPoint.onMouseOut();
				}

				if (hoverPoints) {
					each(hoverPoints, function (point) {
						point.setState();
					});
				}

				if (hoverSeries) {
					hoverSeries.onMouseOut();
				}

				if (tooltip) {
					tooltip.hide(delay);
				}

				if (pointer._onDocumentMouseMove) {
					removeEvent(doc, 'mousemove', pointer._onDocumentMouseMove);
					pointer._onDocumentMouseMove = null;
				}

				// Remove crosshairs
				each(chart.axes, function (axis) {
					axis.hideCrosshair();
				});
				
				pointer.hoverX = chart.hoverPoints = chart.hoverPoint = null;

			}
		},

		/**
		 * Scale series groups to a certain scale and translation
		 */
		scaleGroups: function (attribs, clip) {

			var chart = this.chart,
				seriesAttribs;

			// Scale each series
			each(chart.series, function (series) {
				seriesAttribs = attribs || series.getPlotBox(); // #1701
				if (series.xAxis && series.xAxis.zoomEnabled) {
					series.group.attr(seriesAttribs);
					if (series.markerGroup) {
						series.markerGroup.attr(seriesAttribs);
						series.markerGroup.clip(clip ? chart.clipRect : null);
					}
					if (series.dataLabelsGroup) {
						series.dataLabelsGroup.attr(seriesAttribs);
					}
				}
			});
			
			// Clip
			chart.clipRect.attr(clip || chart.clipBox);
		},

		/**
		 * Start a drag operation
		 */
		dragStart: function (e) {
			var chart = this.chart;

			// Record the start position
			chart.mouseIsDown = e.type;
			chart.cancelClick = false;
			chart.mouseDownX = this.mouseDownX = e.chartX;
			chart.mouseDownY = this.mouseDownY = e.chartY;
		},

		/**
		 * Perform a drag operation in response to a mousemove event while the mouse is down
		 */
		drag: function (e) {

			var chart = this.chart,
				chartOptions = chart.options.chart,
				chartX = e.chartX,
				chartY = e.chartY,
				zoomHor = this.zoomHor,
				zoomVert = this.zoomVert,
				plotLeft = chart.plotLeft,
				plotTop = chart.plotTop,
				plotWidth = chart.plotWidth,
				plotHeight = chart.plotHeight,
				clickedInside,
				size,
				mouseDownX = this.mouseDownX,
				mouseDownY = this.mouseDownY,
				panKey = chartOptions.panKey && e[chartOptions.panKey + 'Key'];

			// If the mouse is outside the plot area, adjust to cooordinates
			// inside to prevent the selection marker from going outside
			if (chartX < plotLeft) {
				chartX = plotLeft;
			} else if (chartX > plotLeft + plotWidth) {
				chartX = plotLeft + plotWidth;
			}

			if (chartY < plotTop) {
				chartY = plotTop;
			} else if (chartY > plotTop + plotHeight) {
				chartY = plotTop + plotHeight;
			}
			
			// determine if the mouse has moved more than 10px
			this.hasDragged = Math.sqrt(
				Math.pow(mouseDownX - chartX, 2) +
				Math.pow(mouseDownY - chartY, 2)
			);
			
			if (this.hasDragged > 10) {
				clickedInside = chart.isInsidePlot(mouseDownX - plotLeft, mouseDownY - plotTop);

				// make a selection
				if (chart.hasCartesianSeries && (this.zoomX || this.zoomY) && clickedInside && !panKey) {
					if (!this.selectionMarker) {
						this.selectionMarker = chart.renderer.rect(
							plotLeft,
							plotTop,
							zoomHor ? 1 : plotWidth,
							zoomVert ? 1 : plotHeight,
							0
						)
						.attr({
							fill: chartOptions.selectionMarkerFill || 'rgba(69,114,167,0.25)',
							zIndex: 7
						})
						.add();
					}
				}

				// adjust the width of the selection marker
				if (this.selectionMarker && zoomHor) {
					size = chartX - mouseDownX;
					this.selectionMarker.attr({
						width: mathAbs(size),
						x: (size > 0 ? 0 : size) + mouseDownX
					});
				}
				// adjust the height of the selection marker
				if (this.selectionMarker && zoomVert) {
					size = chartY - mouseDownY;
					this.selectionMarker.attr({
						height: mathAbs(size),
						y: (size > 0 ? 0 : size) + mouseDownY
					});
				}

				// panning
				if (clickedInside && !this.selectionMarker && chartOptions.panning) {
					chart.pan(e, chartOptions.panning);
				}
			}
		},

		/**
		 * On mouse up or touch end across the entire document, drop the selection.
		 */
		drop: function (e) {
			var pointer = this,
				chart = this.chart,
				hasPinched = this.hasPinched;

			if (this.selectionMarker) {
				var selectionData = {
						xAxis: [],
						yAxis: [],
						originalEvent: e.originalEvent || e
					},
					selectionBox = this.selectionMarker,
					selectionLeft = selectionBox.attr ? selectionBox.attr('x') : selectionBox.x,
					selectionTop = selectionBox.attr ? selectionBox.attr('y') : selectionBox.y,
					selectionWidth = selectionBox.attr ? selectionBox.attr('width') : selectionBox.width,
					selectionHeight = selectionBox.attr ? selectionBox.attr('height') : selectionBox.height,
					runZoom;

				// a selection has been made
				if (this.hasDragged || hasPinched) {

					// record each axis' min and max
					each(chart.axes, function (axis) {
						if (axis.zoomEnabled && defined(axis.min) && (hasPinched || pointer[{ xAxis: 'zoomX', yAxis: 'zoomY' }[axis.coll]])) { // #859, #3569
							var horiz = axis.horiz,
								minPixelPadding = e.type === 'touchend' ? axis.minPixelPadding: 0, // #1207, #3075
								selectionMin = axis.toValue((horiz ? selectionLeft : selectionTop) + minPixelPadding),
								selectionMax = axis.toValue((horiz ? selectionLeft + selectionWidth : selectionTop + selectionHeight) - minPixelPadding);

							selectionData[axis.coll].push({
								axis: axis,
								min: mathMin(selectionMin, selectionMax), // for reversed axes
								max: mathMax(selectionMin, selectionMax)
							});
							runZoom = true;
						}
					});
					if (runZoom) {
						fireEvent(chart, 'selection', selectionData, function (args) { 
							chart.zoom(extend(args, hasPinched ? { animation: false } : null)); 
						});
					}

				}
				this.selectionMarker = this.selectionMarker.destroy();

				// Reset scaling preview
				if (hasPinched) {
					this.scaleGroups();
				}
			}

			// Reset all
			if (chart) { // it may be destroyed on mouse up - #877
				css(chart.container, { cursor: chart._cursor });
				chart.cancelClick = this.hasDragged > 10; // #370
				chart.mouseIsDown = this.hasDragged = this.hasPinched = false;
				this.pinchDown = [];
			}
		},

		onContainerMouseDown: function (e) {

			e = this.normalize(e);

			// issue #295, dragging not always working in Firefox
			if (e.preventDefault) {
				e.preventDefault();
			}
			
			this.dragStart(e);
		},

		

		onDocumentMouseUp: function (e) {
			if (charts[hoverChartIndex]) {
				charts[hoverChartIndex].pointer.drop(e);
			}
		},

		/**
		 * Special handler for mouse move that will hide the tooltip when the mouse leaves the plotarea.
		 * Issue #149 workaround. The mouseleave event does not always fire. 
		 */
		onDocumentMouseMove: function (e) {
			var chart = this.chart,
				chartPosition = this.chartPosition;

			e = this.normalize(e, chartPosition);

			// If we're outside, hide the tooltip
			if (chartPosition && !this.inClass(e.target, 'highcharts-tracker') &&
					!chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop)) {
				this.reset();
			}
		},

		/**
		 * When mouse leaves the container, hide the tooltip.
		 */
		onContainerMouseLeave: function () {
			var chart = charts[hoverChartIndex];
			if (chart) {
				chart.pointer.reset();
				chart.pointer.chartPosition = null; // also reset the chart position, used in #149 fix
			}
		},

		// The mousemove, touchmove and touchstart event handler
		onContainerMouseMove: function (e) {

			var chart = this.chart;

			hoverChartIndex = chart.index;

			e = this.normalize(e);		
			e.returnValue = false; // #2251, #3224
			
			if (chart.mouseIsDown === 'mousedown') {
				this.drag(e);
			} 
			
			// Show the tooltip and run mouse over events (#977)
			if ((this.inClass(e.target, 'highcharts-tracker') || 
					chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop)) && !chart.openMenu) {
				this.runPointActions(e);
			}
		},

		/**
		 * Utility to detect whether an element has, or has a parent with, a specific
		 * class name. Used on detection of tracker objects and on deciding whether
		 * hovering the tooltip should cause the active series to mouse out.
		 */
		inClass: function (element, className) {
			var elemClassName;
			while (element) {
				elemClassName = attr(element, 'class');
				if (elemClassName) {
					if (elemClassName.indexOf(className) !== -1) {
						return true;
					} else if (elemClassName.indexOf(PREFIX + 'container') !== -1) {
						return false;
					}
				}
				element = element.parentNode;
			}		
		},

		onTrackerMouseOut: function (e) {
			var series = this.chart.hoverSeries,
				relatedTarget = e.relatedTarget || e.toElement,
				relatedSeries = relatedTarget && relatedTarget.point && relatedTarget.point.series; // #2499
			
			if (series && !series.options.stickyTracking && !this.inClass(relatedTarget, PREFIX + 'tooltip') &&
					relatedSeries !== series) {
				series.onMouseOut();
			}
		},

		onContainerClick: function (e) {
			var chart = this.chart,
				hoverPoint = chart.hoverPoint, 
				plotLeft = chart.plotLeft,
				plotTop = chart.plotTop;
			
			e = this.normalize(e);
			e.originalEvent = e; // #3913

			if (!chart.cancelClick) {
				
				// On tracker click, fire the series and point events. #783, #1583
				if (hoverPoint && this.inClass(e.target, PREFIX + 'tracker')) {

					// the series click event
					fireEvent(hoverPoint.series, 'click', extend(e, {
						point: hoverPoint
					}));

					// the point click event
					if (chart.hoverPoint) { // it may be destroyed (#1844)
						hoverPoint.firePointEvent('click', e);
					}

				// When clicking outside a tracker, fire a chart event
				} else {
					extend(e, this.getCoordinates(e));

					// fire a click event in the chart
					if (chart.isInsidePlot(e.chartX - plotLeft, e.chartY - plotTop)) {
						fireEvent(chart, 'click', e);
					}
				}


			}
		},

		/**
		 * Set the JS DOM events on the container and document. This method should contain
		 * a one-to-one assignment between methods and their handlers. Any advanced logic should
		 * be moved to the handler reflecting the event's name.
		 */
		setDOMEvents: function () {

			var pointer = this,
				container = pointer.chart.container;

			container.onmousedown = function (e) {
				pointer.onContainerMouseDown(e);
			};
			container.onmousemove = function (e) {
				pointer.onContainerMouseMove(e);
			};
			container.onclick = function (e) {
				pointer.onContainerClick(e);
			};
			addEvent(container, 'mouseleave', pointer.onContainerMouseLeave);
			if (chartCount === 1) {
				addEvent(doc, 'mouseup', pointer.onDocumentMouseUp);
			}
			if (hasTouch) {
				container.ontouchstart = function (e) {
					pointer.onContainerTouchStart(e);
				};
				container.ontouchmove = function (e) {
					pointer.onContainerTouchMove(e);
				};
				if (chartCount === 1) {
					addEvent(doc, 'touchend', pointer.onDocumentTouchEnd);
				}
			}
			
		},

		/**
		 * Destroys the Pointer object and disconnects DOM events.
		 */
		destroy: function () {
			var prop;

			removeEvent(this.chart.container, 'mouseleave', this.onContainerMouseLeave);
			if (!chartCount) {
				removeEvent(doc, 'mouseup', this.onDocumentMouseUp);
				removeEvent(doc, 'touchend', this.onDocumentTouchEnd);
			}

			// memory and CPU leak
			clearInterval(this.tooltipTimeout);

			for (prop in this) {
				this[prop] = null;
			}
		}
	};


	/* Support for touch devices */
	extend(Highcharts.Pointer.prototype, {

		/**
		 * Run translation operations
		 */
		pinchTranslate: function (pinchDown, touches, transform, selectionMarker, clip, lastValidTouch) {
			if (this.zoomHor || this.pinchHor) {
				this.pinchTranslateDirection(true, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);
			}
			if (this.zoomVert || this.pinchVert) {
				this.pinchTranslateDirection(false, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);
			}
		},

		/**
		 * Run translation operations for each direction (horizontal and vertical) independently
		 */
		pinchTranslateDirection: function (horiz, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch, forcedScale) {
			var chart = this.chart,
				xy = horiz ? 'x' : 'y',
				XY = horiz ? 'X' : 'Y',
				sChartXY = 'chart' + XY,
				wh = horiz ? 'width' : 'height',
				plotLeftTop = chart['plot' + (horiz ? 'Left' : 'Top')],
				selectionWH,
				selectionXY,
				clipXY,
				scale = forcedScale || 1,
				inverted = chart.inverted,
				bounds = chart.bounds[horiz ? 'h' : 'v'],
				singleTouch = pinchDown.length === 1,
				touch0Start = pinchDown[0][sChartXY],
				touch0Now = touches[0][sChartXY],
				touch1Start = !singleTouch && pinchDown[1][sChartXY],
				touch1Now = !singleTouch && touches[1][sChartXY],
				outOfBounds,
				transformScale,
				scaleKey,
				setScale = function () {
					if (!singleTouch && mathAbs(touch0Start - touch1Start) > 20) { // Don't zoom if fingers are too close on this axis
						scale = forcedScale || mathAbs(touch0Now - touch1Now) / mathAbs(touch0Start - touch1Start); 
					}
					
					clipXY = ((plotLeftTop - touch0Now) / scale) + touch0Start;
					selectionWH = chart['plot' + (horiz ? 'Width' : 'Height')] / scale;
				};

			// Set the scale, first pass
			setScale();

			selectionXY = clipXY; // the clip position (x or y) is altered if out of bounds, the selection position is not

			// Out of bounds
			if (selectionXY < bounds.min) {
				selectionXY = bounds.min;
				outOfBounds = true;
			} else if (selectionXY + selectionWH > bounds.max) {
				selectionXY = bounds.max - selectionWH;
				outOfBounds = true;
			}
			
			// Is the chart dragged off its bounds, determined by dataMin and dataMax?
			if (outOfBounds) {

				// Modify the touchNow position in order to create an elastic drag movement. This indicates
				// to the user that the chart is responsive but can't be dragged further.
				touch0Now -= 0.8 * (touch0Now - lastValidTouch[xy][0]);
				if (!singleTouch) {
					touch1Now -= 0.8 * (touch1Now - lastValidTouch[xy][1]);
				}

				// Set the scale, second pass to adapt to the modified touchNow positions
				setScale();

			} else {
				lastValidTouch[xy] = [touch0Now, touch1Now];
			}

			// Set geometry for clipping, selection and transformation
			if (!inverted) { // TODO: implement clipping for inverted charts
				clip[xy] = clipXY - plotLeftTop;
				clip[wh] = selectionWH;
			}
			scaleKey = inverted ? (horiz ? 'scaleY' : 'scaleX') : 'scale' + XY;
			transformScale = inverted ? 1 / scale : scale;

			selectionMarker[wh] = selectionWH;
			selectionMarker[xy] = selectionXY;
			transform[scaleKey] = scale;
			transform['translate' + XY] = (transformScale * plotLeftTop) + (touch0Now - (transformScale * touch0Start));
		},
		
		/**
		 * Handle touch events with two touches
		 */
		pinch: function (e) {

			var self = this,
				chart = self.chart,
				pinchDown = self.pinchDown,
				touches = e.touches,
				touchesLength = touches.length,
				lastValidTouch = self.lastValidTouch,
				hasZoom = self.hasZoom,
				selectionMarker = self.selectionMarker,
				transform = {},
				fireClickEvent = touchesLength === 1 && ((self.inClass(e.target, PREFIX + 'tracker') && 
					chart.runTrackerClick) || self.runChartClick),
				clip = {};

			// Don't initiate panning until the user has pinched. This prevents us from 
			// blocking page scrolling as users scroll down a long page (#4210).
			if (touchesLength > 1) {
				self.initiated = true;
			}

			// On touch devices, only proceed to trigger click if a handler is defined
			if (hasZoom && self.initiated && !fireClickEvent) {
				e.preventDefault();
			}
			
			// Normalize each touch
			map(touches, function (e) {
				return self.normalize(e);
			});
			
			// Register the touch start position
			if (e.type === 'touchstart') {
				each(touches, function (e, i) {
					pinchDown[i] = { chartX: e.chartX, chartY: e.chartY };
				});
				lastValidTouch.x = [pinchDown[0].chartX, pinchDown[1] && pinchDown[1].chartX];
				lastValidTouch.y = [pinchDown[0].chartY, pinchDown[1] && pinchDown[1].chartY];

				// Identify the data bounds in pixels
				each(chart.axes, function (axis) {
					if (axis.zoomEnabled) {
						var bounds = chart.bounds[axis.horiz ? 'h' : 'v'],
							minPixelPadding = axis.minPixelPadding,
							min = axis.toPixels(pick(axis.options.min, axis.dataMin)),
							max = axis.toPixels(pick(axis.options.max, axis.dataMax)),
							absMin = mathMin(min, max),
							absMax = mathMax(min, max);

						// Store the bounds for use in the touchmove handler
						bounds.min = mathMin(axis.pos, absMin - minPixelPadding);
						bounds.max = mathMax(axis.pos + axis.len, absMax + minPixelPadding);
					}
				});
				self.res = true; // reset on next move
			
			// Event type is touchmove, handle panning and pinching
			} else if (pinchDown.length) { // can be 0 when releasing, if touchend fires first
				

				// Set the marker
				if (!selectionMarker) {
					self.selectionMarker = selectionMarker = extend({
						destroy: noop
					}, chart.plotBox);
				}
				
				self.pinchTranslate(pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);

				self.hasPinched = hasZoom;

				// Scale and translate the groups to provide visual feedback during pinching
				self.scaleGroups(transform, clip);
				
				// Optionally move the tooltip on touchmove
				if (!hasZoom && self.followTouchMove && touchesLength === 1) {
					this.runPointActions(self.normalize(e));
				} else if (self.res) {
					self.res = false;
					this.reset(false, 0);
				}
			}
		},

		/**
		 * General touch handler shared by touchstart and touchmove.
		 */
		touch: function (e, start) {
			var chart = this.chart;

			hoverChartIndex = chart.index;

			if (e.touches.length === 1) {

				e = this.normalize(e);

				if (chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop) && !chart.openMenu) {

					// Run mouse events and display tooltip etc
					if (start) {
						this.runPointActions(e);
					}

					this.pinch(e);

				} else if (start) {
					// Hide the tooltip on touching outside the plot area (#1203)
					this.reset();
				}

			} else if (e.touches.length === 2) {
				this.pinch(e);
			}
		},

		onContainerTouchStart: function (e) {
			this.touch(e, true);
		},

		onContainerTouchMove: function (e) {
			this.touch(e);
		},

		onDocumentTouchEnd: function (e) {
			if (charts[hoverChartIndex]) {
				charts[hoverChartIndex].pointer.drop(e);
			}
		}

	});
	if (win.PointerEvent || win.MSPointerEvent) {
		
		// The touches object keeps track of the points being touched at all times
		var touches = {},
			hasPointerEvent = !!win.PointerEvent,
			getWebkitTouches = function () {
				var key, fake = [];
				fake.item = function (i) { return this[i]; };
				for (key in touches) {
					if (touches.hasOwnProperty(key)) {
						fake.push({
							pageX: touches[key].pageX,
							pageY: touches[key].pageY,
							target: touches[key].target
						});
					}
				}
				return fake;
			},
			translateMSPointer = function (e, method, wktype, callback) {
				var p;
				e = e.originalEvent || e;
				if ((e.pointerType === 'touch' || e.pointerType === e.MSPOINTER_TYPE_TOUCH) && charts[hoverChartIndex]) {
					callback(e);
					p = charts[hoverChartIndex].pointer;
					p[method]({
						type: wktype,
						target: e.currentTarget,
						preventDefault: noop,
						touches: getWebkitTouches()
					});				
				}
			};

		/**
		 * Extend the Pointer prototype with methods for each event handler and more
		 */
		extend(Pointer.prototype, {
			onContainerPointerDown: function (e) {
				translateMSPointer(e, 'onContainerTouchStart', 'touchstart', function (e) {
					touches[e.pointerId] = { pageX: e.pageX, pageY: e.pageY, target: e.currentTarget };
				});
			},
			onContainerPointerMove: function (e) {
				translateMSPointer(e, 'onContainerTouchMove', 'touchmove', function (e) {
					touches[e.pointerId] = { pageX: e.pageX, pageY: e.pageY };
					if (!touches[e.pointerId].target) {
						touches[e.pointerId].target = e.currentTarget;
					}
				});
			},
			onDocumentPointerUp: function (e) {
				translateMSPointer(e, 'onDocumentTouchEnd', 'touchend', function (e) {
					delete touches[e.pointerId];
				});
			},

			/**
			 * Add or remove the MS Pointer specific events
			 */
			batchMSEvents: function (fn) {
				fn(this.chart.container, hasPointerEvent ? 'pointerdown' : 'MSPointerDown', this.onContainerPointerDown);
				fn(this.chart.container, hasPointerEvent ? 'pointermove' : 'MSPointerMove', this.onContainerPointerMove);
				fn(doc, hasPointerEvent ? 'pointerup' : 'MSPointerUp', this.onDocumentPointerUp);
			}
		});

		// Disable default IE actions for pinch and such on chart element
		wrap(Pointer.prototype, 'init', function (proceed, chart, options) {
			proceed.call(this, chart, options);
			if (this.hasZoom) { // #4014
				css(chart.container, {
					'-ms-touch-action': NONE,
					'touch-action': NONE
				});
			}
		});

		// Add IE specific touch events to chart
		wrap(Pointer.prototype, 'setDOMEvents', function (proceed) {
			proceed.apply(this);
			if (this.hasZoom || this.followTouchMove) {
				this.batchMSEvents(addEvent);
			}
		});
		// Destroy MS events also
		wrap(Pointer.prototype, 'destroy', function (proceed) {
			this.batchMSEvents(removeEvent);
			proceed.call(this);
		});
	}
	/**
	 * The overview of the chart's series
	 */
	var Legend = Highcharts.Legend = function (chart, options) {
		this.init(chart, options);
	};

	Legend.prototype = {
		
		/**
		 * Initialize the legend
		 */
		init: function (chart, options) {
			
			var legend = this,
				itemStyle = options.itemStyle,
				padding,
				itemMarginTop = options.itemMarginTop || 0;
		
			this.options = options;

			if (!options.enabled) {
				return;
			}
		
			legend.itemStyle = itemStyle;
			legend.itemHiddenStyle = merge(itemStyle, options.itemHiddenStyle);
			legend.itemMarginTop = itemMarginTop;
			legend.padding = padding = pick(options.padding, 8);
			legend.initialItemX = padding;
			legend.initialItemY = padding - 5; // 5 is the number of pixels above the text
			legend.maxItemWidth = 0;
			legend.chart = chart;
			legend.itemHeight = 0;
			legend.symbolWidth = pick(options.symbolWidth, 16);
			legend.pages = [];


			// Render it
			legend.render();

			// move checkboxes
			addEvent(legend.chart, 'endResize', function () { 
				legend.positionCheckboxes();
			});

		},

		/**
		 * Set the colors for the legend item
		 * @param {Object} item A Series or Point instance
		 * @param {Object} visible Dimmed or colored
		 */
		colorizeItem: function (item, visible) {
			var legend = this,
				options = legend.options,
				legendItem = item.legendItem,
				legendLine = item.legendLine,
				legendSymbol = item.legendSymbol,
				hiddenColor = legend.itemHiddenStyle.color,
				textColor = visible ? options.itemStyle.color : hiddenColor,
				symbolColor = visible ? (item.legendColor || item.color || '#CCC') : hiddenColor,
				markerOptions = item.options && item.options.marker,
				symbolAttr = { fill: symbolColor },
				key,
				val;
			
			if (legendItem) {
				legendItem.css({ fill: textColor, color: textColor }); // color for #1553, oldIE
			}
			if (legendLine) {
				legendLine.attr({ stroke: symbolColor });
			}
			
			if (legendSymbol) {
				
				// Apply marker options
				if (markerOptions && legendSymbol.isMarker) { // #585
					symbolAttr.stroke = symbolColor;
					markerOptions = item.convertAttribs(markerOptions);
					for (key in markerOptions) {
						val = markerOptions[key];
						if (val !== UNDEFINED) {
							symbolAttr[key] = val;
						}
					}
				}

				legendSymbol.attr(symbolAttr);
			}
		},

		/**
		 * Position the legend item
		 * @param {Object} item A Series or Point instance
		 */
		positionItem: function (item) {
			var legend = this,
				options = legend.options,
				symbolPadding = options.symbolPadding,
				ltr = !options.rtl,
				legendItemPos = item._legendItemPos,
				itemX = legendItemPos[0],
				itemY = legendItemPos[1],
				checkbox = item.checkbox,
				legendGroup = item.legendGroup;

			if (legendGroup && legendGroup.element) {
				legendGroup.translate(
					ltr ? itemX : legend.legendWidth - itemX - 2 * symbolPadding - 4,
					itemY
				);
			}

			if (checkbox) {
				checkbox.x = itemX;
				checkbox.y = itemY;
			}
		},

		/**
		 * Destroy a single legend item
		 * @param {Object} item The series or point
		 */
		destroyItem: function (item) {
			var checkbox = item.checkbox;

			// destroy SVG elements
			each(['legendItem', 'legendLine', 'legendSymbol', 'legendGroup'], function (key) {
				if (item[key]) {
					item[key] = item[key].destroy();
				}
			});

			if (checkbox) {
				discardElement(item.checkbox);
			}
		},

		/**
		 * Destroys the legend.
		 */
		destroy: function () {
			var legend = this,
				legendGroup = legend.group,
				box = legend.box;

			if (box) {
				legend.box = box.destroy();
			}

			if (legendGroup) {
				legend.group = legendGroup.destroy();
			}
		},

		/**
		 * Position the checkboxes after the width is determined
		 */
		positionCheckboxes: function (scrollOffset) {
			var alignAttr = this.group.alignAttr,
				translateY,
				clipHeight = this.clipHeight || this.legendHeight;

			if (alignAttr) {
				translateY = alignAttr.translateY;
				each(this.allItems, function (item) {
					var checkbox = item.checkbox,
						top;
					
					if (checkbox) {
						top = (translateY + checkbox.y + (scrollOffset || 0) + 3);
						css(checkbox, {
							left: (alignAttr.translateX + item.checkboxOffset + checkbox.x - 20) + PX,
							top: top + PX,
							display: top > translateY - 6 && top < translateY + clipHeight - 6 ? '' : NONE
						});
					}
				});
			}
		},
		
		/**
		 * Render the legend title on top of the legend
		 */
		renderTitle: function () {
			var options = this.options,
				padding = this.padding,
				titleOptions = options.title,
				titleHeight = 0,
				bBox;
			
			if (titleOptions.text) {
				if (!this.title) {
					this.title = this.chart.renderer.label(titleOptions.text, padding - 3, padding - 4, null, null, null, null, null, 'legend-title')
						.attr({ zIndex: 1 })
						.css(titleOptions.style)
						.add(this.group);
				}
				bBox = this.title.getBBox();
				titleHeight = bBox.height;
				this.offsetWidth = bBox.width; // #1717
				this.contentGroup.attr({ translateY: titleHeight });
			}
			this.titleHeight = titleHeight;
		},

		/**
		 * Set the legend item text
		 */
		setText: function (item) {
			var options = this.options;
			item.legendItem.attr({
				text: options.labelFormat ? format(options.labelFormat, item) : options.labelFormatter.call(item)
			});
		},

		/**
		 * Render a single specific legend item
		 * @param {Object} item A series or point
		 */
		renderItem: function (item) {
			var legend = this,
				chart = legend.chart,
				renderer = chart.renderer,
				options = legend.options,
				horizontal = options.layout === 'horizontal',
				symbolWidth = legend.symbolWidth,
				symbolPadding = options.symbolPadding,
				itemStyle = legend.itemStyle,
				itemHiddenStyle = legend.itemHiddenStyle,
				padding = legend.padding,
				itemDistance = horizontal ? pick(options.itemDistance, 20) : 0,
				ltr = !options.rtl,
				itemHeight,
				widthOption = options.width,
				itemMarginBottom = options.itemMarginBottom || 0,
				itemMarginTop = legend.itemMarginTop,
				initialItemX = legend.initialItemX,
				bBox,
				itemWidth,
				li = item.legendItem,
				series = item.series && item.series.drawLegendSymbol ? item.series : item,
				seriesOptions = series.options,
				showCheckbox = legend.createCheckboxForItem && seriesOptions && seriesOptions.showCheckbox,
				useHTML = options.useHTML;

			if (!li) { // generate it once, later move it

				// Generate the group box
				// A group to hold the symbol and text. Text is to be appended in Legend class.
				item.legendGroup = renderer.g('legend-item')
					.attr({ zIndex: 1 })
					.add(legend.scrollGroup);

				// Generate the list item text and add it to the group
				item.legendItem = li = renderer.text(
						'',
						ltr ? symbolWidth + symbolPadding : -symbolPadding,
						legend.baseline || 0,
						useHTML
					)
					.css(merge(item.visible ? itemStyle : itemHiddenStyle)) // merge to prevent modifying original (#1021)
					.attr({
						align: ltr ? 'left' : 'right',
						zIndex: 2
					})
					.add(item.legendGroup);

				// Get the baseline for the first item - the font size is equal for all
				if (!legend.baseline) {
					legend.fontMetrics = renderer.fontMetrics(itemStyle.fontSize, li);
					legend.baseline = legend.fontMetrics.f + 3 + itemMarginTop;
					li.attr('y', legend.baseline);
				}

				// Draw the legend symbol inside the group box
				series.drawLegendSymbol(legend, item);

				if (legend.setItemEvents) {
					legend.setItemEvents(item, li, useHTML, itemStyle, itemHiddenStyle);
				}			

				// Colorize the items
				legend.colorizeItem(item, item.visible);

				// add the HTML checkbox on top
				if (showCheckbox) {
					legend.createCheckboxForItem(item);				
				}
			}

			// Always update the text
			legend.setText(item);

			// calculate the positions for the next line
			bBox = li.getBBox();

			itemWidth = item.checkboxOffset = 
				options.itemWidth || 
				item.legendItemWidth || 
				symbolWidth + symbolPadding + bBox.width + itemDistance + (showCheckbox ? 20 : 0);
			legend.itemHeight = itemHeight = mathRound(item.legendItemHeight || bBox.height);

			// if the item exceeds the width, start a new line
			if (horizontal && legend.itemX - initialItemX + itemWidth >
					(widthOption || (chart.chartWidth - 2 * padding - initialItemX - options.x))) {
				legend.itemX = initialItemX;
				legend.itemY += itemMarginTop + legend.lastLineHeight + itemMarginBottom;
				legend.lastLineHeight = 0; // reset for next line (#915, #3976)
			}

			// If the item exceeds the height, start a new column
			/*if (!horizontal && legend.itemY + options.y + itemHeight > chart.chartHeight - spacingTop - spacingBottom) {
				legend.itemY = legend.initialItemY;
				legend.itemX += legend.maxItemWidth;
				legend.maxItemWidth = 0;
			}*/

			// Set the edge positions
			legend.maxItemWidth = mathMax(legend.maxItemWidth, itemWidth);
			legend.lastItemY = itemMarginTop + legend.itemY + itemMarginBottom;
			legend.lastLineHeight = mathMax(itemHeight, legend.lastLineHeight); // #915

			// cache the position of the newly generated or reordered items
			item._legendItemPos = [legend.itemX, legend.itemY];

			// advance
			if (horizontal) {
				legend.itemX += itemWidth;

			} else {
				legend.itemY += itemMarginTop + itemHeight + itemMarginBottom;
				legend.lastLineHeight = itemHeight;
			}

			// the width of the widest item
			legend.offsetWidth = widthOption || mathMax(
				(horizontal ? legend.itemX - initialItemX - itemDistance : itemWidth) + padding,
				legend.offsetWidth
			);
		},

		/**
		 * Get all items, which is one item per series for normal series and one item per point
		 * for pie series.
		 */
		getAllItems: function () {
			var allItems = [];
			each(this.chart.series, function (series) {
				var seriesOptions = series.options;

				// Handle showInLegend. If the series is linked to another series, defaults to false.
				if (!pick(seriesOptions.showInLegend, !defined(seriesOptions.linkedTo) ? UNDEFINED : false, true)) {
					return;
				}

				// use points or series for the legend item depending on legendType
				allItems = allItems.concat(
						series.legendItems ||
						(seriesOptions.legendType === 'point' ?
								series.data :
								series)
				);
			});
			return allItems;
		},

		/**
		 * Adjust the chart margins by reserving space for the legend on only one side
		 * of the chart. If the position is set to a corner, top or bottom is reserved
		 * for horizontal legends and left or right for vertical ones.
		 */
		adjustMargins: function (margin, spacing) {
			var chart = this.chart, 
				options = this.options,
				// Use the first letter of each alignment option in order to detect the side 
				alignment = options.align[0] + options.verticalAlign[0] + options.layout[0];
				
			if (this.display && !options.floating) {

				each([
					/(lth|ct|rth)/,
					/(rtv|rm|rbv)/,
					/(rbh|cb|lbh)/,
					/(lbv|lm|ltv)/
				], function (alignments, side) {
					if (alignments.test(alignment) && !defined(margin[side])) {
						// Now we have detected on which side of the chart we should reserve space for the legend
						chart[marginNames[side]] = mathMax(
							chart[marginNames[side]],
							chart.legend[(side + 1) % 2 ? 'legendHeight' : 'legendWidth'] + 
								[1, -1, -1, 1][side] * options[(side % 2) ? 'x' : 'y'] + 
								pick(options.margin, 12) +
								spacing[side]
						);
					}
				});
			}
		},

		/**
		 * Render the legend. This method can be called both before and after
		 * chart.render. If called after, it will only rearrange items instead
		 * of creating new ones.
		 */
		render: function () {
			var legend = this,
				chart = legend.chart,
				renderer = chart.renderer,
				legendGroup = legend.group,
				allItems,
				display,
				legendWidth,
				legendHeight,
				box = legend.box,
				options = legend.options,
				padding = legend.padding,
				legendBorderWidth = options.borderWidth,
				legendBackgroundColor = options.backgroundColor;

			legend.itemX = legend.initialItemX;
			legend.itemY = legend.initialItemY;
			legend.offsetWidth = 0;
			legend.lastItemY = 0;

			if (!legendGroup) {
				legend.group = legendGroup = renderer.g('legend')
					.attr({ zIndex: 7 }) 
					.add();
				legend.contentGroup = renderer.g()
					.attr({ zIndex: 1 }) // above background
					.add(legendGroup);
				legend.scrollGroup = renderer.g()
					.add(legend.contentGroup);
			}
			
			legend.renderTitle();

			// add each series or point
			allItems = legend.getAllItems();

			// sort by legendIndex
			stableSort(allItems, function (a, b) {
				return ((a.options && a.options.legendIndex) || 0) - ((b.options && b.options.legendIndex) || 0);
			});

			// reversed legend
			if (options.reversed) {
				allItems.reverse();
			}

			legend.allItems = allItems;
			legend.display = display = !!allItems.length;

			// render the items
			legend.lastLineHeight = 0;
			each(allItems, function (item) {
				legend.renderItem(item); 
			});

			// Get the box
			legendWidth = (options.width || legend.offsetWidth) + padding;
			legendHeight = legend.lastItemY + legend.lastLineHeight + legend.titleHeight;
			legendHeight = legend.handleOverflow(legendHeight);
			legendHeight += padding;

			// Draw the border and/or background
			if (legendBorderWidth || legendBackgroundColor) {

				if (!box) {
					legend.box = box = renderer.rect(
						0,
						0,
						legendWidth,
						legendHeight,
						options.borderRadius,
						legendBorderWidth || 0
					).attr({
						stroke: options.borderColor,
						'stroke-width': legendBorderWidth || 0,
						fill: legendBackgroundColor || NONE
					})
					.add(legendGroup)
					.shadow(options.shadow);
					box.isNew = true;

				} else if (legendWidth > 0 && legendHeight > 0) {
					box[box.isNew ? 'attr' : 'animate'](
						box.crisp({ width: legendWidth, height: legendHeight })
					);
					box.isNew = false;
				}

				// hide the border if no items
				box[display ? 'show' : 'hide']();
			}
			
			legend.legendWidth = legendWidth;
			legend.legendHeight = legendHeight;

			// Now that the legend width and height are established, put the items in the 
			// final position
			each(allItems, function (item) {
				legend.positionItem(item);
			});

			// 1.x compatibility: positioning based on style
			/*var props = ['left', 'right', 'top', 'bottom'],
				prop,
				i = 4;
			while (i--) {
				prop = props[i];
				if (options.style[prop] && options.style[prop] !== 'auto') {
					options[i < 2 ? 'align' : 'verticalAlign'] = prop;
					options[i < 2 ? 'x' : 'y'] = pInt(options.style[prop]) * (i % 2 ? -1 : 1);
				}
			}*/

			if (display) {
				legendGroup.align(extend({
					width: legendWidth,
					height: legendHeight
				}, options), true, 'spacingBox');
			}

			if (!chart.isResizing) {
				this.positionCheckboxes();
			}
		},
		
		/**
		 * Set up the overflow handling by adding navigation with up and down arrows below the
		 * legend.
		 */
		handleOverflow: function (legendHeight) {
			var legend = this,
				chart = this.chart,
				renderer = chart.renderer,
				options = this.options,
				optionsY = options.y,
				alignTop = options.verticalAlign === 'top',
				spaceHeight = chart.spacingBox.height + (alignTop ? -optionsY : optionsY) - this.padding,
				maxHeight = options.maxHeight,
				clipHeight,
				clipRect = this.clipRect,
				navOptions = options.navigation,
				animation = pick(navOptions.animation, true),
				arrowSize = navOptions.arrowSize || 12,
				nav = this.nav,
				pages = this.pages,
				padding = this.padding,
				lastY,
				allItems = this.allItems,
				clipToHeight = function (height) {
					clipRect.attr({
						height: height
					});

					// useHTML
					if (legend.contentGroup.div) {
						legend.contentGroup.div.style.clip = 'rect(' + padding + 'px,9999px,' + (padding + height) + 'px,0)';
					}
				};

				
			// Adjust the height
			if (options.layout === 'horizontal') {
				spaceHeight /= 2;
			}
			if (maxHeight) {
				spaceHeight = mathMin(spaceHeight, maxHeight);
			}
			
			// Reset the legend height and adjust the clipping rectangle
			pages.length = 0;
			if (legendHeight > spaceHeight) {

				this.clipHeight = clipHeight = mathMax(spaceHeight - 20 - this.titleHeight - padding, 0);
				this.currentPage = pick(this.currentPage, 1);
				this.fullHeight = legendHeight;
				
				// Fill pages with Y positions so that the top of each a legend item defines
				// the scroll top for each page (#2098)
				each(allItems, function (item, i) {
					var y = item._legendItemPos[1],
						h = mathRound(item.legendItem.getBBox().height),
						len = pages.length;
					
					if (!len || (y - pages[len - 1] > clipHeight && (lastY || y) !== pages[len - 1])) {
						pages.push(lastY || y);
						len++;
					}
					
					if (i === allItems.length - 1 && y + h - pages[len - 1] > clipHeight) {
						pages.push(y);
					}
					if (y !== lastY) {
						lastY = y;
					}
				});

				// Only apply clipping if needed. Clipping causes blurred legend in PDF export (#1787)
				if (!clipRect) {
					clipRect = legend.clipRect = renderer.clipRect(0, padding, 9999, 0);
					legend.contentGroup.clip(clipRect);
				}
					
				clipToHeight(clipHeight);

				// Add navigation elements
				if (!nav) {
					this.nav = nav = renderer.g().attr({ zIndex: 1 }).add(this.group);
					this.up = renderer.symbol('triangle', 0, 0, arrowSize, arrowSize)
						.on('click', function () {
							legend.scroll(-1, animation);
						})
						.add(nav);
					this.pager = renderer.text('', 15, 10)
						.css(navOptions.style)
						.add(nav);
					this.down = renderer.symbol('triangle-down', 0, 0, arrowSize, arrowSize)
						.on('click', function () {
							legend.scroll(1, animation);
						})
						.add(nav);
				}
				
				// Set initial position
				legend.scroll(0);
				
				legendHeight = spaceHeight;
				
			} else if (nav) {
				clipToHeight(chart.chartHeight);
				nav.hide();
				this.scrollGroup.attr({
					translateY: 1
				});
				this.clipHeight = 0; // #1379
			}
			
			return legendHeight;
		},
		
		/**
		 * Scroll the legend by a number of pages
		 * @param {Object} scrollBy
		 * @param {Object} animation
		 */
		scroll: function (scrollBy, animation) {
			var pages = this.pages,
				pageCount = pages.length,
				currentPage = this.currentPage + scrollBy,
				clipHeight = this.clipHeight,
				navOptions = this.options.navigation,
				activeColor = navOptions.activeColor,
				inactiveColor = navOptions.inactiveColor,
				pager = this.pager,
				padding = this.padding,
				scrollOffset;
			
			// When resizing while looking at the last page
			if (currentPage > pageCount) {
				currentPage = pageCount;
			}
			
			if (currentPage > 0) {
				
				if (animation !== UNDEFINED) {
					setAnimation(animation, this.chart);
				}
				
				this.nav.attr({
					translateX: padding,
					translateY: clipHeight + this.padding + 7 + this.titleHeight,
					visibility: VISIBLE
				});
				this.up.attr({
						fill: currentPage === 1 ? inactiveColor : activeColor
					})
					.css({
						cursor: currentPage === 1 ? 'default' : 'pointer'
					});
				pager.attr({
					text: currentPage + '/' + pageCount
				});
				this.down.attr({
						x: 18 + this.pager.getBBox().width, // adjust to text width
						fill: currentPage === pageCount ? inactiveColor : activeColor
					})
					.css({
						cursor: currentPage === pageCount ? 'default' : 'pointer'
					});
				
				scrollOffset = -pages[currentPage - 1] + this.initialItemY;

				this.scrollGroup.animate({
					translateY: scrollOffset
				});			
				
				this.currentPage = currentPage;
				this.positionCheckboxes(scrollOffset);
			}
				
		}
		
	};

	/*
	 * LegendSymbolMixin
	 */ 

	var LegendSymbolMixin = Highcharts.LegendSymbolMixin = {

		/**
		 * Get the series' symbol in the legend
		 * 
		 * @param {Object} legend The legend object
		 * @param {Object} item The series (this) or point
		 */
		drawRectangle: function (legend, item) {
			var symbolHeight = legend.options.symbolHeight || legend.fontMetrics.f;

			item.legendSymbol = this.chart.renderer.rect(
				0,
				legend.baseline - symbolHeight + 1, // #3988
				legend.symbolWidth,
				symbolHeight,
				legend.options.symbolRadius || 0
			).attr({
				zIndex: 3
			}).add(item.legendGroup);		
			
		},

		/**
		 * Get the series' symbol in the legend. This method should be overridable to create custom 
		 * symbols through Highcharts.seriesTypes[type].prototype.drawLegendSymbols.
		 * 
		 * @param {Object} legend The legend object
		 */
		drawLineMarker: function (legend) {

			var options = this.options,
				markerOptions = options.marker,
				radius,
				legendSymbol,
				symbolWidth = legend.symbolWidth,
				renderer = this.chart.renderer,
				legendItemGroup = this.legendGroup,
				verticalCenter = legend.baseline - mathRound(legend.fontMetrics.b * 0.3),
				attr;

			// Draw the line
			if (options.lineWidth) {
				attr = {
					'stroke-width': options.lineWidth
				};
				if (options.dashStyle) {
					attr.dashstyle = options.dashStyle;
				}
				this.legendLine = renderer.path([
					M,
					0,
					verticalCenter,
					L,
					symbolWidth,
					verticalCenter
				])
				.attr(attr)
				.add(legendItemGroup);
			}
			
			// Draw the marker
			if (markerOptions && markerOptions.enabled !== false) {
				radius = markerOptions.radius;
				this.legendSymbol = legendSymbol = renderer.symbol(
					this.symbol,
					(symbolWidth / 2) - radius,
					verticalCenter - radius,
					2 * radius,
					2 * radius
				)
				.add(legendItemGroup);
				legendSymbol.isMarker = true;
			}
		}
	};

	// Workaround for #2030, horizontal legend items not displaying in IE11 Preview,
	// and for #2580, a similar drawing flaw in Firefox 26.
	// TODO: Explore if there's a general cause for this. The problem may be related 
	// to nested group elements, as the legend item texts are within 4 group elements.
	if (/Trident\/7\.0/.test(userAgent) || isFirefox) {
		wrap(Legend.prototype, 'positionItem', function (proceed, item) {
			var legend = this,
				runPositionItem = function () { // If chart destroyed in sync, this is undefined (#2030)
					if (item._legendItemPos) {
						proceed.call(legend, item);
					}
				};

			// Do it now, for export and to get checkbox placement
			runPositionItem();
			
			// Do it after to work around the core issue
			setTimeout(runPositionItem);
		});
	}
	/**
	 * The chart class
	 * @param {Object} options
	 * @param {Function} callback Function to run when the chart has loaded
	 */
	var Chart = Highcharts.Chart = function () {
		this.init.apply(this, arguments);
	};

	Chart.prototype = {

		/**
		 * Hook for modules
		 */
		callbacks: [],

		/**
		 * Initialize the chart
		 */
		init: function (userOptions, callback) {

			// Handle regular options
			var options,
				seriesOptions = userOptions.series; // skip merging data points to increase performance

			userOptions.series = null;
			options = merge(defaultOptions, userOptions); // do the merge
			options.series = userOptions.series = seriesOptions; // set back the series data
			this.userOptions = userOptions;

			var optionsChart = options.chart;
			
			// Create margin & spacing array
			this.margin = this.splashArray('margin', optionsChart);
			this.spacing = this.splashArray('spacing', optionsChart);

			var chartEvents = optionsChart.events;

			//this.runChartClick = chartEvents && !!chartEvents.click;
			this.bounds = { h: {}, v: {} }; // Pixel data bounds for touch zoom

			this.callback = callback;
			this.isResizing = 0;
			this.options = options;
			//chartTitleOptions = UNDEFINED;
			//chartSubtitleOptions = UNDEFINED;

			this.axes = [];
			this.series = [];
			this.hasCartesianSeries = optionsChart.showAxes;
			//this.axisOffset = UNDEFINED;
			//this.maxTicks = UNDEFINED; // handle the greatest amount of ticks on grouped axes
			//this.inverted = UNDEFINED;
			//this.loadingShown = UNDEFINED;
			//this.container = UNDEFINED;
			//this.chartWidth = UNDEFINED;
			//this.chartHeight = UNDEFINED;
			//this.marginRight = UNDEFINED;
			//this.marginBottom = UNDEFINED;
			//this.containerWidth = UNDEFINED;
			//this.containerHeight = UNDEFINED;
			//this.oldChartWidth = UNDEFINED;
			//this.oldChartHeight = UNDEFINED;

			//this.renderTo = UNDEFINED;
			//this.renderToClone = UNDEFINED;

			//this.spacingBox = UNDEFINED

			//this.legend = UNDEFINED;

			// Elements
			//this.chartBackground = UNDEFINED;
			//this.plotBackground = UNDEFINED;
			//this.plotBGImage = UNDEFINED;
			//this.plotBorder = UNDEFINED;
			//this.loadingDiv = UNDEFINED;
			//this.loadingSpan = UNDEFINED;

			var chart = this,
				eventType;

			// Add the chart to the global lookup
			chart.index = charts.length;
			charts.push(chart);
			chartCount++;

			// Set up auto resize
			if (optionsChart.reflow !== false) {
				addEvent(chart, 'load', function () {
					chart.initReflow();
				});
			}

			// Chart event handlers
			if (chartEvents) {
				for (eventType in chartEvents) {
					addEvent(chart, eventType, chartEvents[eventType]);
				}
			}

			chart.xAxis = [];
			chart.yAxis = [];

			// Expose methods and variables
			chart.animation = useCanVG ? false : pick(optionsChart.animation, true);
			chart.pointCount = chart.colorCounter = chart.symbolCounter = 0;

			chart.firstRender();
		},

		/**
		 * Initialize an individual series, called internally before render time
		 */
		initSeries: function (options) {
			var chart = this,
				optionsChart = chart.options.chart,
				type = options.type || optionsChart.type || optionsChart.defaultSeriesType,
				series,
				constr = seriesTypes[type];

			// No such series type
			if (!constr) {
				error(17, true);
			}

			series = new constr();
			series.init(this, options);
			return series;
		},

		/**
		 * Check whether a given point is within the plot area
		 *
		 * @param {Number} plotX Pixel x relative to the plot area
		 * @param {Number} plotY Pixel y relative to the plot area
		 * @param {Boolean} inverted Whether the chart is inverted
		 */
		isInsidePlot: function (plotX, plotY, inverted) {
			var x = inverted ? plotY : plotX,
				y = inverted ? plotX : plotY;
				
			return x >= 0 &&
				x <= this.plotWidth &&
				y >= 0 &&
				y <= this.plotHeight;
		},

		/**
		 * Redraw legend, axes or series based on updated data
		 *
		 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
		 *    configuration
		 */
		redraw: function (animation) {
			var chart = this,
				axes = chart.axes,
				series = chart.series,
				pointer = chart.pointer,
				legend = chart.legend,
				redrawLegend = chart.isDirtyLegend,
				hasStackedSeries,
				hasDirtyStacks,
				hasCartesianSeries = chart.hasCartesianSeries,
				isDirtyBox = chart.isDirtyBox, // todo: check if it has actually changed?
				seriesLength = series.length,
				i = seriesLength,
				serie,
				renderer = chart.renderer,
				isHiddenChart = renderer.isHidden(),
				afterRedraw = [];
				
			setAnimation(animation, chart);
			
			if (isHiddenChart) {
				chart.cloneRenderTo();
			}

			// Adjust title layout (reflow multiline text)
			chart.layOutTitles();

			// link stacked series
			while (i--) {
				serie = series[i];

				if (serie.options.stacking) {
					hasStackedSeries = true;
					
					if (serie.isDirty) {
						hasDirtyStacks = true;
						break;
					}
				}
			}
			if (hasDirtyStacks) { // mark others as dirty
				i = seriesLength;
				while (i--) {
					serie = series[i];
					if (serie.options.stacking) {
						serie.isDirty = true;
					}
				}
			}

			// Handle updated data in the series
			each(series, function (serie) {
				if (serie.isDirty) {
					if (serie.options.legendType === 'point') {
						if (serie.updateTotals) {
							serie.updateTotals();
						}
						redrawLegend = true;
					}
				}
			});

			// handle added or removed series
			if (redrawLegend && legend.options.enabled) { // series or pie points are added or removed
				// draw legend graphics
				legend.render();

				chart.isDirtyLegend = false;
			}

			// reset stacks
			if (hasStackedSeries) {
				chart.getStacks();
			}


			if (hasCartesianSeries) {
				if (!chart.isResizing) {

					// reset maxTicks
					chart.maxTicks = null;

					// set axes scales
					each(axes, function (axis) {
						axis.setScale();
					});
				}
			}

			chart.getMargins(); // #3098

			if (hasCartesianSeries) {
				// If one axis is dirty, all axes must be redrawn (#792, #2169)
				each(axes, function (axis) {
					if (axis.isDirty) {
						isDirtyBox = true;
					}
				});

				// redraw axes
				each(axes, function (axis) {
					
					// Fire 'afterSetExtremes' only if extremes are set
					if (axis.isDirtyExtremes) { // #821
						axis.isDirtyExtremes = false;
						afterRedraw.push(function () { // prevent a recursive call to chart.redraw() (#1119)
							fireEvent(axis, 'afterSetExtremes', extend(axis.eventArgs, axis.getExtremes())); // #747, #751
							delete axis.eventArgs;
						});
					}
					
					if (isDirtyBox || hasStackedSeries) {
						axis.redraw();
					}
				});
			}
			
			// the plot areas size has changed
			if (isDirtyBox) {
				chart.drawChartBox();
			}


			// redraw affected series
			each(series, function (serie) {
				if (serie.isDirty && serie.visible &&
						(!serie.isCartesian || serie.xAxis)) { // issue #153
					serie.redraw();
				}
			});

			// move tooltip or reset
			if (pointer) {
				pointer.reset(true);
			}

			// redraw if canvas
			renderer.draw();

			// fire the event
			fireEvent(chart, 'redraw'); // jQuery breaks this when calling it from addEvent. Overwrites chart.redraw
			
			if (isHiddenChart) {
				chart.cloneRenderTo(true);
			}
			
			// Fire callbacks that are put on hold until after the redraw
			each(afterRedraw, function (callback) {
				callback.call();
			});
		},

		/**
		 * Get an axis, series or point object by id.
		 * @param id {String} The id as given in the configuration options
		 */
		get: function (id) {
			var chart = this,
				axes = chart.axes,
				series = chart.series;

			var i,
				j,
				points;

			// search axes
			for (i = 0; i < axes.length; i++) {
				if (axes[i].options.id === id) {
					return axes[i];
				}
			}

			// search series
			for (i = 0; i < series.length; i++) {
				if (series[i].options.id === id) {
					return series[i];
				}
			}

			// search points
			for (i = 0; i < series.length; i++) {
				points = series[i].points || [];
				for (j = 0; j < points.length; j++) {
					if (points[j].id === id) {
						return points[j];
					}
				}
			}
			return null;
		},

		/**
		 * Create the Axis instances based on the config options
		 */
		getAxes: function () {
			var chart = this,
				options = this.options,
				xAxisOptions = options.xAxis = splat(options.xAxis || {}),
				yAxisOptions = options.yAxis = splat(options.yAxis || {}),
				optionsArray,
				axis;

			// make sure the options are arrays and add some members
			each(xAxisOptions, function (axis, i) {
				axis.index = i;
				axis.isX = true;
			});

			each(yAxisOptions, function (axis, i) {
				axis.index = i;
			});

			// concatenate all axis options into one array
			optionsArray = xAxisOptions.concat(yAxisOptions);

			each(optionsArray, function (axisOptions) {
				axis = new Axis(chart, axisOptions);
			});
		},


		/**
		 * Get the currently selected points from all series
		 */
		getSelectedPoints: function () {
			var points = [];
			each(this.series, function (serie) {
				points = points.concat(grep(serie.points || [], function (point) {
					return point.selected;
				}));
			});
			return points;
		},

		/**
		 * Get the currently selected series
		 */
		getSelectedSeries: function () {
			return grep(this.series, function (serie) {
				return serie.selected;
			});
		},

		/**
		 * Generate stacks for each series and calculate stacks total values
		 */
		getStacks: function () {
			var chart = this;

			// reset stacks for each yAxis
			each(chart.yAxis, function (axis) {
				if (axis.stacks && axis.hasVisibleSeries) {
					axis.oldStacks = axis.stacks;
				}
			});

			each(chart.series, function (series) {
				if (series.options.stacking && (series.visible === true || chart.options.chart.ignoreHiddenSeries === false)) {
					series.stackKey = series.type + pick(series.options.stack, '');
				}
			});
		},	

		/**
		 * Show the title and subtitle of the chart
		 *
		 * @param titleOptions {Object} New title options
		 * @param subtitleOptions {Object} New subtitle options
		 *
		 */
		setTitle: function (titleOptions, subtitleOptions, redraw) {
			var chart = this,
				options = chart.options,
				chartTitleOptions,
				chartSubtitleOptions;

			chartTitleOptions = options.title = merge(options.title, titleOptions);
			chartSubtitleOptions = options.subtitle = merge(options.subtitle, subtitleOptions);

			// add title and subtitle
			each([
				['title', titleOptions, chartTitleOptions],
				['subtitle', subtitleOptions, chartSubtitleOptions]
			], function (arr) {
				var name = arr[0],
					title = chart[name],
					titleOptions = arr[1],
					chartTitleOptions = arr[2];

				if (title && titleOptions) {
					chart[name] = title = title.destroy(); // remove old
				}
				
				if (chartTitleOptions && chartTitleOptions.text && !title) {
					chart[name] = chart.renderer.text(
						chartTitleOptions.text,
						0,
						0,
						chartTitleOptions.useHTML
					)
					.attr({
						align: chartTitleOptions.align,
						'class': PREFIX + name,
						zIndex: chartTitleOptions.zIndex || 4
					})
					.css(chartTitleOptions.style)
					.add();
				}	
			});
			chart.layOutTitles(redraw);
		},

		/**
		 * Lay out the chart titles and cache the full offset height for use in getMargins
		 */
		layOutTitles: function (redraw) {
			var titleOffset = 0,
				title = this.title,
				subtitle = this.subtitle,
				options = this.options,
				titleOptions = options.title,
				subtitleOptions = options.subtitle,
				requiresDirtyBox,
				renderer = this.renderer,
				autoWidth = this.spacingBox.width - 44; // 44 makes room for default context button

			if (title) {
				title
					.css({ width: (titleOptions.width || autoWidth) + PX })
					.align(extend({ 
						y: renderer.fontMetrics(titleOptions.style.fontSize, title).b - 3
					}, titleOptions), false, 'spacingBox');
				
				if (!titleOptions.floating && !titleOptions.verticalAlign) {
					titleOffset = title.getBBox().height;
				}
			}
			if (subtitle) {
				subtitle
					.css({ width: (subtitleOptions.width || autoWidth) + PX })
					.align(extend({ 
						y: titleOffset + (titleOptions.margin - 13) + renderer.fontMetrics(titleOptions.style.fontSize, subtitle).b 
					}, subtitleOptions), false, 'spacingBox');
				
				if (!subtitleOptions.floating && !subtitleOptions.verticalAlign) {
					titleOffset = mathCeil(titleOffset + subtitle.getBBox().height);
				}
			}

			requiresDirtyBox = this.titleOffset !== titleOffset;				
			this.titleOffset = titleOffset; // used in getMargins

			if (!this.isDirtyBox && requiresDirtyBox) {
				this.isDirtyBox = requiresDirtyBox;
				// Redraw if necessary (#2719, #2744)		
				if (this.hasRendered && pick(redraw, true) && this.isDirtyBox) {
					this.redraw();
				}
			}
		},

		/**
		 * Get chart width and height according to options and container size
		 */
		getChartSize: function () {
			var chart = this,
				optionsChart = chart.options.chart,
				widthOption = optionsChart.width,
				heightOption = optionsChart.height,
				renderTo = chart.renderToClone || chart.renderTo;

			// get inner width and height from jQuery (#824)
			if (!defined(widthOption)) {
				chart.containerWidth = adapterRun(renderTo, 'width');
			}
			if (!defined(heightOption)) {
				chart.containerHeight = adapterRun(renderTo, 'height');
			}
			
			chart.chartWidth = mathMax(0, widthOption || chart.containerWidth || 600); // #1393, 1460
			chart.chartHeight = mathMax(0, pick(heightOption,
				// the offsetHeight of an empty container is 0 in standard browsers, but 19 in IE7:
				chart.containerHeight > 19 ? chart.containerHeight : 400));
		},

		/**
		 * Create a clone of the chart's renderTo div and place it outside the viewport to allow
		 * size computation on chart.render and chart.redraw
		 */
		cloneRenderTo: function (revert) {
			var clone = this.renderToClone,
				container = this.container;
			
			// Destroy the clone and bring the container back to the real renderTo div
			if (revert) {
				if (clone) {
					this.renderTo.appendChild(container);
					discardElement(clone);
					delete this.renderToClone;
				}
			
			// Set up the clone
			} else {
				if (container && container.parentNode === this.renderTo) {
					this.renderTo.removeChild(container); // do not clone this
				}
				this.renderToClone = clone = this.renderTo.cloneNode(0);
				css(clone, {
					position: ABSOLUTE,
					top: '-9999px',
					display: 'block' // #833
				});
				if (clone.style.setProperty) { // #2631
					clone.style.setProperty('display', 'block', 'important');
				}
				doc.body.appendChild(clone);
				if (container) {
					clone.appendChild(container);
				}
			}
		},

		/**
		 * Get the containing element, determine the size and create the inner container
		 * div to hold the chart
		 */
		getContainer: function () {
			var chart = this,
				container,
				optionsChart = chart.options.chart,
				chartWidth,
				chartHeight,
				renderTo,
				indexAttrName = 'data-highcharts-chart',
				oldChartIndex,
				containerId;

			chart.renderTo = renderTo = optionsChart.renderTo;
			containerId = PREFIX + idCounter++;

			if (isString(renderTo)) {
				chart.renderTo = renderTo = doc.getElementById(renderTo);
			}
			
			// Display an error if the renderTo is wrong
			if (!renderTo) {
				error(13, true);
			}
			
			// If the container already holds a chart, destroy it. The check for hasRendered is there
			// because web pages that are saved to disk from the browser, will preserve the data-highcharts-chart
			// attribute and the SVG contents, but not an interactive chart. So in this case,
			// charts[oldChartIndex] will point to the wrong chart if any (#2609).
			oldChartIndex = pInt(attr(renderTo, indexAttrName));
			if (!isNaN(oldChartIndex) && charts[oldChartIndex] && charts[oldChartIndex].hasRendered) {
				charts[oldChartIndex].destroy();
			}		
			
			// Make a reference to the chart from the div
			attr(renderTo, indexAttrName, chart.index);

			// remove previous chart
			renderTo.innerHTML = '';

			// If the container doesn't have an offsetWidth, it has or is a child of a node
			// that has display:none. We need to temporarily move it out to a visible
			// state to determine the size, else the legend and tooltips won't render
			// properly. The allowClone option is used in sparklines as a micro optimization,
			// saving about 1-2 ms each chart.
			if (!optionsChart.skipClone && !renderTo.offsetWidth) {
				chart.cloneRenderTo();
			}

			// get the width and height
			chart.getChartSize();
			chartWidth = chart.chartWidth;
			chartHeight = chart.chartHeight;

			// create the inner container
			chart.container = container = createElement(DIV, {
					className: PREFIX + 'container' +
						(optionsChart.className ? ' ' + optionsChart.className : ''),
					id: containerId
				}, extend({
					position: RELATIVE,
					overflow: HIDDEN, // needed for context menu (avoid scrollbars) and
						// content overflow in IE
					width: chartWidth + PX,
					height: chartHeight + PX,
					textAlign: 'left',
					lineHeight: 'normal', // #427
					zIndex: 0, // #1072
					'-webkit-tap-highlight-color': 'rgba(0,0,0,0)'
				}, optionsChart.style),
				chart.renderToClone || renderTo
			);

			// cache the cursor (#1650)
			chart._cursor = container.style.cursor;

			// Initialize the renderer
			chart.renderer =
				optionsChart.forExport ? // force SVG, used for SVG export
					new SVGRenderer(container, chartWidth, chartHeight, optionsChart.style, true) :
					new Renderer(container, chartWidth, chartHeight, optionsChart.style);

			if (useCanVG) {
				// If we need canvg library, extend and configure the renderer
				// to get the tracker for translating mouse events
				chart.renderer.create(chart, container, chartWidth, chartHeight);
			}
			// Add a reference to the charts index
			chart.renderer.chartIndex = chart.index;
		},

		/**
		 * Calculate margins by rendering axis labels in a preliminary position. Title,
		 * subtitle and legend have already been rendered at this stage, but will be
		 * moved into their final positions
		 */
		getMargins: function (skipAxes) {
			var chart = this,
				spacing = chart.spacing,
				margin = chart.margin,
				titleOffset = chart.titleOffset;

			chart.resetMargins();

			// Adjust for title and subtitle
			if (titleOffset && !defined(margin[0])) {
				chart.plotTop = mathMax(chart.plotTop, titleOffset + chart.options.title.margin + spacing[0]);
			}
			
			// Adjust for legend
			chart.legend.adjustMargins(margin, spacing);

			// adjust for scroller
			if (chart.extraBottomMargin) {
				chart.marginBottom += chart.extraBottomMargin;
			}
			if (chart.extraTopMargin) {
				chart.plotTop += chart.extraTopMargin;
			}
			if (!skipAxes) {
				this.getAxisMargins();
			}
		},

		getAxisMargins: function () {

			var chart = this,
				axisOffset = chart.axisOffset = [0, 0, 0, 0], // top, right, bottom, left
				margin = chart.margin;
			
			// pre-render axes to get labels offset width
			if (chart.hasCartesianSeries) {
				each(chart.axes, function (axis) {
					axis.getOffset();
				});
			}

			// Add the axis offsets
			each(marginNames, function (m, side) {
				if (!defined(margin[side])) {
					chart[m] += axisOffset[side];
				}		
			});

			chart.setChartSize();

		},

		/**
		 * Resize the chart to its container if size is not explicitly set
		 */
		reflow: function (e) {
			var chart = this,
				optionsChart = chart.options.chart,
				renderTo = chart.renderTo,
				width = optionsChart.width || adapterRun(renderTo, 'width'),
				height = optionsChart.height || adapterRun(renderTo, 'height'),
				target = e ? e.target : win, // #805 - MooTools doesn't supply e
				doReflow = function () {
					if (chart.container) { // It may have been destroyed in the meantime (#1257)
						chart.setSize(width, height, false);
						chart.hasUserSize = null;
					}
				};
				
			// Width and height checks for display:none. Target is doc in IE8 and Opera,
			// win in Firefox, Chrome and IE9.
			if (!chart.hasUserSize && !chart.isPrinting && width && height && (target === win || target === doc)) { // #1093
				if (width !== chart.containerWidth || height !== chart.containerHeight) {
					clearTimeout(chart.reflowTimeout);
					if (e) { // Called from window.resize
						chart.reflowTimeout = setTimeout(doReflow, 100);
					} else { // Called directly (#2224)
						doReflow();
					}
				}
				chart.containerWidth = width;
				chart.containerHeight = height;
			}
		},

		/**
		 * Add the event handlers necessary for auto resizing
		 */
		initReflow: function () {
			var chart = this,
				reflow = function (e) {
					chart.reflow(e);
				};
				
			
			addEvent(win, 'resize', reflow);
			addEvent(chart, 'destroy', function () {
				removeEvent(win, 'resize', reflow);
			});
		},

		/**
		 * Resize the chart to a given width and height
		 * @param {Number} width
		 * @param {Number} height
		 * @param {Object|Boolean} animation
		 */
		setSize: function (width, height, animation) {
			var chart = this,
				chartWidth,
				chartHeight,
				fireEndResize;

			// Handle the isResizing counter
			chart.isResizing += 1;
			fireEndResize = function () {
				if (chart) {
					fireEvent(chart, 'endResize', null, function () {
						chart.isResizing -= 1;
					});
				}
			};

			// set the animation for the current process
			setAnimation(animation, chart);

			chart.oldChartHeight = chart.chartHeight;
			chart.oldChartWidth = chart.chartWidth;
			if (defined(width)) {
				chart.chartWidth = chartWidth = mathMax(0, mathRound(width));
				chart.hasUserSize = !!chartWidth;
			}
			if (defined(height)) {
				chart.chartHeight = chartHeight = mathMax(0, mathRound(height));
			}

			// Resize the container with the global animation applied if enabled (#2503)
			(globalAnimation ? animate : css)(chart.container, {
				width: chartWidth + PX,
				height: chartHeight + PX
			}, globalAnimation);

			chart.setChartSize(true);
			chart.renderer.setSize(chartWidth, chartHeight, animation);

			// handle axes
			chart.maxTicks = null;
			each(chart.axes, function (axis) {
				axis.isDirty = true;
				axis.setScale();
			});

			// make sure non-cartesian series are also handled
			each(chart.series, function (serie) {
				serie.isDirty = true;
			});

			chart.isDirtyLegend = true; // force legend redraw
			chart.isDirtyBox = true; // force redraw of plot and chart border

			chart.layOutTitles(); // #2857
			chart.getMargins();

			chart.redraw(animation);


			chart.oldChartHeight = null;
			fireEvent(chart, 'resize');

			// fire endResize and set isResizing back
			// If animation is disabled, fire without delay
			if (globalAnimation === false) {
				fireEndResize();
			} else { // else set a timeout with the animation duration
				setTimeout(fireEndResize, (globalAnimation && globalAnimation.duration) || 500);
			}
		},

		/**
		 * Set the public chart properties. This is done before and after the pre-render
		 * to determine margin sizes
		 */
		setChartSize: function (skipAxes) {
			var chart = this,
				inverted = chart.inverted,
				renderer = chart.renderer,
				chartWidth = chart.chartWidth,
				chartHeight = chart.chartHeight,
				optionsChart = chart.options.chart,
				spacing = chart.spacing,
				clipOffset = chart.clipOffset,
				clipX,
				clipY,
				plotLeft,
				plotTop,
				plotWidth,
				plotHeight,
				plotBorderWidth;

			chart.plotLeft = plotLeft = mathRound(chart.plotLeft);
			chart.plotTop = plotTop = mathRound(chart.plotTop);
			chart.plotWidth = plotWidth = mathMax(0, mathRound(chartWidth - plotLeft - chart.marginRight));
			chart.plotHeight = plotHeight = mathMax(0, mathRound(chartHeight - plotTop - chart.marginBottom));

			chart.plotSizeX = inverted ? plotHeight : plotWidth;
			chart.plotSizeY = inverted ? plotWidth : plotHeight;
			
			chart.plotBorderWidth = optionsChart.plotBorderWidth || 0;

			// Set boxes used for alignment
			chart.spacingBox = renderer.spacingBox = {
				x: spacing[3],
				y: spacing[0],
				width: chartWidth - spacing[3] - spacing[1],
				height: chartHeight - spacing[0] - spacing[2]
			};
			chart.plotBox = renderer.plotBox = {
				x: plotLeft,
				y: plotTop,
				width: plotWidth,
				height: plotHeight
			};

			plotBorderWidth = 2 * mathFloor(chart.plotBorderWidth / 2);
			clipX = mathCeil(mathMax(plotBorderWidth, clipOffset[3]) / 2);
			clipY = mathCeil(mathMax(plotBorderWidth, clipOffset[0]) / 2);
			chart.clipBox = {
				x: clipX, 
				y: clipY, 
				width: mathFloor(chart.plotSizeX - mathMax(plotBorderWidth, clipOffset[1]) / 2 - clipX), 
				height: mathMax(0, mathFloor(chart.plotSizeY - mathMax(plotBorderWidth, clipOffset[2]) / 2 - clipY))
			};

			if (!skipAxes) {
				each(chart.axes, function (axis) {
					axis.setAxisSize();
					axis.setAxisTranslation();
				});
			}
		},

		/**
		 * Initial margins before auto size margins are applied
		 */
		resetMargins: function () {
			var chart = this;

			each(marginNames, function (m, side) {
				chart[m] = pick(chart.margin[side], chart.spacing[side]);
			});
			chart.axisOffset = [0, 0, 0, 0]; // top, right, bottom, left
			chart.clipOffset = [0, 0, 0, 0];
		},

		/**
		 * Draw the borders and backgrounds for chart and plot area
		 */
		drawChartBox: function () {
			var chart = this,
				optionsChart = chart.options.chart,
				renderer = chart.renderer,
				chartWidth = chart.chartWidth,
				chartHeight = chart.chartHeight,
				chartBackground = chart.chartBackground,
				plotBackground = chart.plotBackground,
				plotBorder = chart.plotBorder,
				plotBGImage = chart.plotBGImage,
				chartBorderWidth = optionsChart.borderWidth || 0,
				chartBackgroundColor = optionsChart.backgroundColor,
				plotBackgroundColor = optionsChart.plotBackgroundColor,
				plotBackgroundImage = optionsChart.plotBackgroundImage,
				plotBorderWidth = optionsChart.plotBorderWidth || 0,
				mgn,
				bgAttr,
				plotLeft = chart.plotLeft,
				plotTop = chart.plotTop,
				plotWidth = chart.plotWidth,
				plotHeight = chart.plotHeight,
				plotBox = chart.plotBox,
				clipRect = chart.clipRect,
				clipBox = chart.clipBox;

			// Chart area
			mgn = chartBorderWidth + (optionsChart.shadow ? 8 : 0);

			if (chartBorderWidth || chartBackgroundColor) {
				if (!chartBackground) {
					
					bgAttr = {
						fill: chartBackgroundColor || NONE
					};
					if (chartBorderWidth) { // #980
						bgAttr.stroke = optionsChart.borderColor;
						bgAttr['stroke-width'] = chartBorderWidth;
					}
					chart.chartBackground = renderer.rect(mgn / 2, mgn / 2, chartWidth - mgn, chartHeight - mgn,
							optionsChart.borderRadius, chartBorderWidth)
						.attr(bgAttr)
						.addClass(PREFIX + 'background')
						.add()
						.shadow(optionsChart.shadow);

				} else { // resize
					chartBackground.animate(
						chartBackground.crisp({ width: chartWidth - mgn, height: chartHeight - mgn })
					);
				}
			}


			// Plot background
			if (plotBackgroundColor) {
				if (!plotBackground) {
					chart.plotBackground = renderer.rect(plotLeft, plotTop, plotWidth, plotHeight, 0)
						.attr({
							fill: plotBackgroundColor
						})
						.add()
						.shadow(optionsChart.plotShadow);
				} else {
					plotBackground.animate(plotBox);
				}
			}
			if (plotBackgroundImage) {
				if (!plotBGImage) {
					chart.plotBGImage = renderer.image(plotBackgroundImage, plotLeft, plotTop, plotWidth, plotHeight)
						.add();
				} else {
					plotBGImage.animate(plotBox);
				}
			}
			
			// Plot clip
			if (!clipRect) {
				chart.clipRect = renderer.clipRect(clipBox);
			} else {
				clipRect.animate({
					width: clipBox.width,
					height: clipBox.height
				});
			}

			// Plot area border
			if (plotBorderWidth) {
				if (!plotBorder) {
					chart.plotBorder = renderer.rect(plotLeft, plotTop, plotWidth, plotHeight, 0, -plotBorderWidth)
						.attr({
							stroke: optionsChart.plotBorderColor,
							'stroke-width': plotBorderWidth,
							fill: NONE,
							zIndex: 1
						})
						.add();
				} else {
					plotBorder.animate(
						plotBorder.crisp({ x: plotLeft, y: plotTop, width: plotWidth, height: plotHeight, strokeWidth: -plotBorderWidth }) //#3282 plotBorder should be negative
					);
				}
			}

			// reset
			chart.isDirtyBox = false;
		},

		/**
		 * Detect whether a certain chart property is needed based on inspecting its options
		 * and series. This mainly applies to the chart.invert property, and in extensions to 
		 * the chart.angular and chart.polar properties.
		 */
		propFromSeries: function () {
			var chart = this,
				optionsChart = chart.options.chart,
				klass,
				seriesOptions = chart.options.series,
				i,
				value;
				
				
			each(['inverted', 'angular', 'polar'], function (key) {
				
				// The default series type's class
				klass = seriesTypes[optionsChart.type || optionsChart.defaultSeriesType];
				
				// Get the value from available chart-wide properties
				value = (
					chart[key] || // 1. it is set before
					optionsChart[key] || // 2. it is set in the options
					(klass && klass.prototype[key]) // 3. it's default series class requires it
				);
		
				// 4. Check if any the chart's series require it
				i = seriesOptions && seriesOptions.length;
				while (!value && i--) {
					klass = seriesTypes[seriesOptions[i].type];
					if (klass && klass.prototype[key]) {
						value = true;
					}
				}
		
				// Set the chart property
				chart[key] = value;	
			});
			
		},

		/**
		 * Link two or more series together. This is done initially from Chart.render,
		 * and after Chart.addSeries and Series.remove.
		 */
		linkSeries: function () {
			var chart = this,
				chartSeries = chart.series;

			// Reset links
			each(chartSeries, function (series) {
				series.linkedSeries.length = 0;
			});

			// Apply new links
			each(chartSeries, function (series) {
				var linkedTo = series.options.linkedTo;
				if (isString(linkedTo)) {
					if (linkedTo === ':previous') {
						linkedTo = chart.series[series.index - 1];
					} else {
						linkedTo = chart.get(linkedTo);
					}
					if (linkedTo) {
						linkedTo.linkedSeries.push(series);
						series.linkedParent = linkedTo;
					}
				}
			});
		},

		/**
		 * Render series for the chart
		 */
		renderSeries: function () {
			each(this.series, function (serie) {
				serie.translate();
				serie.render();
			});
		},
			
		/**
		 * Render labels for the chart
		 */
		renderLabels: function () {
			var chart = this,
				labels = chart.options.labels;
			if (labels.items) {
				each(labels.items, function (label) {
					var style = extend(labels.style, label.style),
						x = pInt(style.left) + chart.plotLeft,
						y = pInt(style.top) + chart.plotTop + 12;

					// delete to prevent rewriting in IE
					delete style.left;
					delete style.top;

					chart.renderer.text(
						label.html,
						x,
						y
					)
					.attr({ zIndex: 2 })
					.css(style)
					.add();

				});
			}
		},

		/**
		 * Render all graphics for the chart
		 */
		render: function () {
			var chart = this,
				axes = chart.axes,
				renderer = chart.renderer,
				options = chart.options,
				tempWidth,
				tempHeight,
				redoHorizontal,
				redoVertical;

			// Title
			chart.setTitle();


			// Legend
			chart.legend = new Legend(chart, options.legend);

			chart.getStacks(); // render stacks

			// Get chart margins
			chart.getMargins(true);
			chart.setChartSize();

			// Record preliminary dimensions for later comparison
			tempWidth = chart.plotWidth;
			tempHeight = chart.plotHeight = chart.plotHeight - 13; // 13 is the most common height of X axis labels

			// Get margins by pre-rendering axes
			each(axes, function (axis) {
				axis.setScale();
			});
			chart.getAxisMargins();

			// If the plot area size has changed significantly, calculate tick positions again
			redoHorizontal = tempWidth / chart.plotWidth > 1.1;
			redoVertical = tempHeight / chart.plotHeight > 1.1;

			if (redoHorizontal || redoVertical) {

				chart.maxTicks = null; // reset for second pass
				each(axes, function (axis) {
					if ((axis.horiz && redoHorizontal) || (!axis.horiz && redoVertical)) {
						axis.setTickInterval(true); // update to reflect the new margins
					}
				});
				chart.getMargins(); // second pass to check for new labels
			}

			// Draw the borders and backgrounds
			chart.drawChartBox();		


			// Axes
			if (chart.hasCartesianSeries) {
				each(axes, function (axis) {
					axis.render();
				});
			}

			// The series
			if (!chart.seriesGroup) {
				chart.seriesGroup = renderer.g('series-group')
					.attr({ zIndex: 3 })
					.add();
			}
			chart.renderSeries();

			// Labels
			chart.renderLabels();

			// Credits
			chart.showCredits(options.credits);

			// Set flag
			chart.hasRendered = true;

		},

		/**
		 * Show chart credits based on config options
		 */
		showCredits: function (credits) {
			if (credits.enabled && !this.credits) {
				this.credits = this.renderer.text(
					credits.text,
					0,
					0
				)
				.on('click', function () {
					if (credits.href) {
						location.href = credits.href;
					}
				})
				.attr({
					align: credits.position.align,
					zIndex: 8
				})
				.css(credits.style)
				.add()
				.align(credits.position);
			}
		},

		/**
		 * Clean up memory usage
		 */
		destroy: function () {
			var chart = this,
				axes = chart.axes,
				series = chart.series,
				container = chart.container,
				i,
				parentNode = container && container.parentNode;
				
			// fire the chart.destoy event
			fireEvent(chart, 'destroy');
			
			// Delete the chart from charts lookup array
			charts[chart.index] = UNDEFINED;
			chartCount--;
			chart.renderTo.removeAttribute('data-highcharts-chart');

			// remove events
			removeEvent(chart);

			// ==== Destroy collections:
			// Destroy axes
			i = axes.length;
			while (i--) {
				axes[i] = axes[i].destroy();
			}

			// Destroy each series
			i = series.length;
			while (i--) {
				series[i] = series[i].destroy();
			}

			// ==== Destroy chart properties:
			each(['title', 'subtitle', 'chartBackground', 'plotBackground', 'plotBGImage', 
					'plotBorder', 'seriesGroup', 'clipRect', 'credits', 'pointer', 'scroller', 
					'rangeSelector', 'legend', 'resetZoomButton', 'tooltip', 'renderer'], function (name) {
				var prop = chart[name];

				if (prop && prop.destroy) {
					chart[name] = prop.destroy();
				}
			});

			// remove container and all SVG
			if (container) { // can break in IE when destroyed before finished loading
				container.innerHTML = '';
				removeEvent(container);
				if (parentNode) {
					discardElement(container);
				}

			}

			// clean it all up
			for (i in chart) {
				delete chart[i];
			}

		},


		/**
		 * VML namespaces can't be added until after complete. Listening
		 * for Perini's doScroll hack is not enough.
		 */
		isReadyToRender: function () {
			var chart = this;

			// Note: in spite of JSLint's complaints, win == win.top is required
			/*jslint eqeq: true*/
			if ((!hasSVG && (win == win.top && doc.readyState !== 'complete')) || (useCanVG && !win.canvg)) {
			/*jslint eqeq: false*/
				if (useCanVG) {
					// Delay rendering until canvg library is downloaded and ready
					CanVGController.push(function () { chart.firstRender(); }, chart.options.global.canvasToolsURL);
				} else {
					doc.attachEvent('onreadystatechange', function () {
						doc.detachEvent('onreadystatechange', chart.firstRender);
						if (doc.readyState === 'complete') {
							chart.firstRender();
						}
					});
				}
				return false;
			}
			return true;
		},

		/**
		 * Prepare for first rendering after all data are loaded
		 */
		firstRender: function () {
			var chart = this,
				options = chart.options,
				callback = chart.callback;

			// Check whether the chart is ready to render
			if (!chart.isReadyToRender()) {
				return;
			}

			// Create the container
			chart.getContainer();

			// Run an early event after the container and renderer are established
			fireEvent(chart, 'init');

			
			chart.resetMargins();
			chart.setChartSize();

			// Set the common chart properties (mainly invert) from the given series
			chart.propFromSeries();

			// get axes
			chart.getAxes();

			// Initialize the series
			each(options.series || [], function (serieOptions) {
				chart.initSeries(serieOptions);
			});

			chart.linkSeries();

			// Run an event after axes and series are initialized, but before render. At this stage,
			// the series data is indexed and cached in the xData and yData arrays, so we can access
			// those before rendering. Used in Highstock. 
			fireEvent(chart, 'beforeRender'); 

			// depends on inverted and on margins being set
			if (Highcharts.Pointer) {
				chart.pointer = new Pointer(chart, options);
			}

			chart.render();

			// add canvas
			chart.renderer.draw();
			// run callbacks
			if (callback) {
				callback.apply(chart, [chart]);
			}
			each(chart.callbacks, function (fn) {
				if (chart.index !== UNDEFINED) { // Chart destroyed in its own callback (#3600)
					fn.apply(chart, [chart]);
				}
			});
			
			// Fire the load event
			fireEvent(chart, 'load');		
			
			// If the chart was rendered outside the top container, put it back in (#3679)
			chart.cloneRenderTo(true);

		},

		/**
		* Creates arrays for spacing and margin from given options.
		*/
		splashArray: function (target, options) {
			var oVar = options[target],
				tArray = isObject(oVar) ? oVar : [oVar, oVar, oVar, oVar];

			return [pick(options[target + 'Top'], tArray[0]),
					pick(options[target + 'Right'], tArray[1]),
					pick(options[target + 'Bottom'], tArray[2]),
					pick(options[target + 'Left'], tArray[3])];
		}
	}; // end Chart

	var CenteredSeriesMixin = Highcharts.CenteredSeriesMixin = {
		/**
		 * Get the center of the pie based on the size and center options relative to the  
		 * plot area. Borrowed by the polar and gauge series types.
		 */
		getCenter: function () {
			
			var options = this.options,
				chart = this.chart,
				slicingRoom = 2 * (options.slicedOffset || 0),
				handleSlicingRoom,
				plotWidth = chart.plotWidth - 2 * slicingRoom,
				plotHeight = chart.plotHeight - 2 * slicingRoom,
				centerOption = options.center,
				positions = [pick(centerOption[0], '50%'), pick(centerOption[1], '50%'), options.size || '100%', options.innerSize || 0],
				smallestSize = mathMin(plotWidth, plotHeight),
				i,
				value;

			for (i = 0; i < 4; ++i) {
				value = positions[i];
				handleSlicingRoom = i < 2 || (i === 2 && /%$/.test(value));
				
				// i == 0: centerX, relative to width
				// i == 1: centerY, relative to height
				// i == 2: size, relative to smallestSize
				// i == 3: innerSize, relative to size
				positions[i] = relativeLength(value, [plotWidth, plotHeight, smallestSize, positions[2]][i]) +
					(handleSlicingRoom ? slicingRoom : 0);

			}
			return positions;
		}
	};

	/**
	 * The Point object and prototype. Inheritable and used as base for PiePoint
	 */
	var Point = function () {};
	Point.prototype = {

		/**
		 * Initialize the point
		 * @param {Object} series The series object containing this point
		 * @param {Object} options The data in either number, array or object format
		 */
		init: function (series, options, x) {

			var point = this,
				colors;
			point.series = series;
			point.color = series.color; // #3445
			point.applyOptions(options, x);
			point.pointAttr = {};

			if (series.options.colorByPoint) {
				colors = series.options.colors || series.chart.options.colors;
				point.color = point.color || colors[series.colorCounter++];
				// loop back to zero
				if (series.colorCounter === colors.length) {
					series.colorCounter = 0;
				}
			}

			series.chart.pointCount++;
			return point;
		},
		/**
		 * Apply the options containing the x and y data and possible some extra properties.
		 * This is called on point init or from point.update.
		 *
		 * @param {Object} options
		 */
		applyOptions: function (options, x) {
			var point = this,
				series = point.series,
				pointValKey = series.options.pointValKey || series.pointValKey;

			options = Point.prototype.optionsToObject.call(this, options);

			// copy options directly to point
			extend(point, options);
			point.options = point.options ? extend(point.options, options) : options;

			// For higher dimension series types. For instance, for ranges, point.y is mapped to point.low.
			if (pointValKey) {
				point.y = point[pointValKey];
			}

			// If no x is set by now, get auto incremented value. All points must have an
			// x value, however the y value can be null to create a gap in the series
			if (point.x === UNDEFINED && series) {
				point.x = x === UNDEFINED ? series.autoIncrement() : x;
			}

			return point;
		},

		/**
		 * Transform number or array configs into objects
		 */
		optionsToObject: function (options) {
			var ret = {},
				series = this.series,
				keys = series.options.keys,
				pointArrayMap = keys || series.pointArrayMap || ['y'],
				valueCount = pointArrayMap.length,
				firstItemType,
				i = 0,
				j = 0;

			if (typeof options === 'number' || options === null) {
				ret[pointArrayMap[0]] = options;

			} else if (isArray(options)) {
				// with leading x value
				if (!keys && options.length > valueCount) {
					firstItemType = typeof options[0];
					if (firstItemType === 'string') {
						ret.name = options[0];
					} else if (firstItemType === 'number') {
						ret.x = options[0];
					}
					i++;
				}
				while (j < valueCount) {
					ret[pointArrayMap[j++]] = options[i++];
				}
			} else if (typeof options === 'object') {
				ret = options;

				// This is the fastest way to detect if there are individual point dataLabels that need
				// to be considered in drawDataLabels. These can only occur in object configs.
				if (options.dataLabels) {
					series._hasPointLabels = true;
				}

				// Same approach as above for markers
				if (options.marker) {
					series._hasPointMarkers = true;
				}
			}
			return ret;
		},

		/**
		 * Destroy a point to clear memory. Its reference still stays in series.data.
		 */
		destroy: function () {
			var point = this,
				series = point.series,
				chart = series.chart,
				hoverPoints = chart.hoverPoints,
				prop;

			chart.pointCount--;

			if (hoverPoints) {
				point.setState();
				erase(hoverPoints, point);
				if (!hoverPoints.length) {
					chart.hoverPoints = null;
				}

			}
			if (point === chart.hoverPoint) {
				point.onMouseOut();
			}

			// remove all events
			if (point.graphic || point.dataLabel) { // removeEvent and destroyElements are performance expensive
				removeEvent(point);
				point.destroyElements();
			}

			if (point.legendItem) { // pies have legend items
				chart.legend.destroyItem(point);
			}

			for (prop in point) {
				point[prop] = null;
			}


		},

		/**
		 * Destroy SVG elements associated with the point
		 */
		destroyElements: function () {
			var point = this,
				props = ['graphic', 'dataLabel', 'dataLabelUpper', 'group', 'connector', 'shadowGroup'],
				prop,
				i = 6;
			while (i--) {
				prop = props[i];
				if (point[prop]) {
					point[prop] = point[prop].destroy();
				}
			}
		},

		/**
		 * Return the configuration hash needed for the data label and tooltip formatters
		 */
		getLabelConfig: function () {
			var point = this;
			return {
				x: point.category,
				y: point.y,
				key: point.name || point.category,
				series: point.series,
				point: point,
				percentage: point.percentage,
				total: point.total || point.stackTotal
			};
		},	

		/**
		 * Extendable method for formatting each point's tooltip line
		 *
		 * @return {String} A string to be concatenated in to the common tooltip text
		 */
		tooltipFormatter: function (pointFormat) {

			// Insert options for valueDecimals, valuePrefix, and valueSuffix
			var series = this.series,
				seriesTooltipOptions = series.tooltipOptions,
				valueDecimals = pick(seriesTooltipOptions.valueDecimals, ''),
				valuePrefix = seriesTooltipOptions.valuePrefix || '',
				valueSuffix = seriesTooltipOptions.valueSuffix || '';

			// Loop over the point array map and replace unformatted values with sprintf formatting markup
			each(series.pointArrayMap || ['y'], function (key) {
				key = '{point.' + key; // without the closing bracket
				if (valuePrefix || valueSuffix) {
					pointFormat = pointFormat.replace(key + '}', valuePrefix + key + '}' + valueSuffix);
				}
				pointFormat = pointFormat.replace(key + '}', key + ':,.' + valueDecimals + 'f}');
			});

			return format(pointFormat, {
				point: this,
				series: this.series
			});
		},

		/**
		 * Fire an event on the Point object. Must not be renamed to fireEvent, as this
		 * causes a name clash in MooTools
		 * @param {String} eventType
		 * @param {Object} eventArgs Additional event arguments
		 * @param {Function} defaultFunction Default event handler
		 */
		firePointEvent: function (eventType, eventArgs, defaultFunction) {
			var point = this,
				series = this.series,
				seriesOptions = series.options;

			// load event handlers on demand to save time on mouseover/out
			if (seriesOptions.point.events[eventType] || (point.options && point.options.events && point.options.events[eventType])) {
				this.importEvents();
			}

			// add default handler if in selection mode
			if (eventType === 'click' && seriesOptions.allowPointSelect) {
				defaultFunction = function (event) {
					// Control key is for Windows, meta (= Cmd key) for Mac, Shift for Opera
					if (point.select) { // Could be destroyed by prior event handlers (#2911)
						point.select(null, event.ctrlKey || event.metaKey || event.shiftKey);
					}
				};
			}

			fireEvent(this, eventType, eventArgs, defaultFunction);
		}
	};/**
	 * @classDescription The base function which all other series types inherit from. The data in the series is stored
	 * in various arrays.
	 *
	 * - First, series.options.data contains all the original config options for
	 * each point whether added by options or methods like series.addPoint.
	 * - Next, series.data contains those values converted to points, but in case the series data length
	 * exceeds the cropThreshold, or if the data is grouped, series.data doesn't contain all the points. It
	 * only contains the points that have been created on demand.
	 * - Then there's series.points that contains all currently visible point objects. In case of cropping,
	 * the cropped-away points are not part of this array. The series.points array starts at series.cropStart
	 * compared to series.data and series.options.data. If however the series data is grouped, these can't
	 * be correlated one to one.
	 * - series.xData and series.processedXData contain clean x values, equivalent to series.data and series.points.
	 * - series.yData and series.processedYData contain clean x values, equivalent to series.data and series.points.
	 *
	 * @param {Object} chart
	 * @param {Object} options
	 */
	var Series = Highcharts.Series = function () {};

	Series.prototype = {

		isCartesian: true,
		type: 'line',
		pointClass: Point,
		sorted: true, // requires the data to be sorted
		requireSorting: true,
		pointAttrToOptions: { // mapping between SVG attributes and the corresponding options
			stroke: 'lineColor',
			'stroke-width': 'lineWidth',
			fill: 'fillColor',
			r: 'radius'
		},
		axisTypes: ['xAxis', 'yAxis'],
		colorCounter: 0,
		parallelArrays: ['x', 'y'], // each point's x and y values are stored in this.xData and this.yData
		init: function (chart, options) {
			var series = this,
				eventType,
				events,
				chartSeries = chart.series,
				sortByIndex = function (a, b) {
					return pick(a.options.index, a._i) - pick(b.options.index, b._i);
				};

			series.chart = chart;
			series.options = options = series.setOptions(options); // merge with plotOptions
			series.linkedSeries = [];

			// bind the axes
			series.bindAxes();

			// set some variables
			extend(series, {
				name: options.name,
				state: NORMAL_STATE,
				pointAttr: {},
				visible: options.visible !== false, // true by default
				selected: options.selected === true // false by default
			});

			// special
			if (useCanVG) {
				options.animation = false;
			}

			// register event listeners
			events = options.events;
			for (eventType in events) {
				addEvent(series, eventType, events[eventType]);
			}
			if (
				(events && events.click) ||
				(options.point && options.point.events && options.point.events.click) ||
				options.allowPointSelect
			) {
				chart.runTrackerClick = true;
			}

			series.getColor();
			series.getSymbol();

			// Set the data
			each(series.parallelArrays, function (key) {
				series[key + 'Data'] = [];
			});
			series.setData(options.data, false);

			// Mark cartesian
			if (series.isCartesian) {
				chart.hasCartesianSeries = true;
			}

			// Register it in the chart
			chartSeries.push(series);
			series._i = chartSeries.length - 1;

			// Sort series according to index option (#248, #1123, #2456)
			stableSort(chartSeries, sortByIndex);
			if (this.yAxis) {
				stableSort(this.yAxis.series, sortByIndex);
			}

			each(chartSeries, function (series, i) {
				series.index = i;
				series.name = series.name || 'Series ' + (i + 1);
			});

		},

		/**
		 * Set the xAxis and yAxis properties of cartesian series, and register the series
		 * in the axis.series array
		 */
		bindAxes: function () {
			var series = this,
				seriesOptions = series.options,
				chart = series.chart,
				axisOptions;

			each(series.axisTypes || [], function (AXIS) { // repeat for xAxis and yAxis

				each(chart[AXIS], function (axis) { // loop through the chart's axis objects
					axisOptions = axis.options;

					// apply if the series xAxis or yAxis option mathches the number of the
					// axis, or if undefined, use the first axis
					if ((seriesOptions[AXIS] === axisOptions.index) ||
							(seriesOptions[AXIS] !== UNDEFINED && seriesOptions[AXIS] === axisOptions.id) ||
							(seriesOptions[AXIS] === UNDEFINED && axisOptions.index === 0)) {

						// register this series in the axis.series lookup
						axis.series.push(series);

						// set this series.xAxis or series.yAxis reference
						series[AXIS] = axis;

						// mark dirty for redraw
						axis.isDirty = true;
					}
				});

				// The series needs an X and an Y axis
				if (!series[AXIS] && series.optionalAxis !== AXIS) {
					error(18, true);
				}

			});
		},

		/**
		 * For simple series types like line and column, the data values are held in arrays like
		 * xData and yData for quick lookup to find extremes and more. For multidimensional series
		 * like bubble and map, this can be extended with arrays like zData and valueData by
		 * adding to the series.parallelArrays array.
		 */
		updateParallelArrays: function (point, i) {
			var series = point.series,
				args = arguments,
				fn = typeof i === 'number' ?
					 // Insert the value in the given position
					function (key) {
						var val = key === 'y' && series.toYData ? series.toYData(point) : point[key];
						series[key + 'Data'][i] = val;
					} :
					// Apply the method specified in i with the following arguments as arguments
					function (key) {
						Array.prototype[i].apply(series[key + 'Data'], Array.prototype.slice.call(args, 2));
					};

			each(series.parallelArrays, fn);
		},

		/**
		 * Return an auto incremented x value based on the pointStart and pointInterval options.
		 * This is only used if an x value is not given for the point that calls autoIncrement.
		 */
		autoIncrement: function () {

			var options = this.options,
				xIncrement = this.xIncrement,
				date,
				pointInterval,
				pointIntervalUnit = options.pointIntervalUnit;
			
			xIncrement = pick(xIncrement, options.pointStart, 0);
			
			this.pointInterval = pointInterval = pick(this.pointInterval, options.pointInterval, 1);
			
			// Added code for pointInterval strings
			if (pointIntervalUnit === 'month' || pointIntervalUnit === 'year') {
				date = new Date(xIncrement);
				date = (pointIntervalUnit === 'month') ?
					+date[setMonth](date[getMonth]() + pointInterval) :
					+date[setFullYear](date[getFullYear]() + pointInterval);
				pointInterval = date - xIncrement;
			}
			
			this.xIncrement = xIncrement + pointInterval;
			return xIncrement;
		},

		/**
		 * Divide the series data into segments divided by null values.
		 */
		getSegments: function () {
			var series = this,
				lastNull = -1,
				segments = [],
				i,
				points = series.points,
				pointsLength = points.length;

			if (pointsLength) { // no action required for []

				// if connect nulls, just remove null points
				if (series.options.connectNulls) {
					i = pointsLength;
					while (i--) {
						if (points[i].y === null) {
							points.splice(i, 1);
						}
					}
					if (points.length) {
						segments = [points];
					}

				// else, split on null points
				} else {
					each(points, function (point, i) {
						if (point.y === null) {
							if (i > lastNull + 1) {
								segments.push(points.slice(lastNull + 1, i));
							}
							lastNull = i;
						} else if (i === pointsLength - 1) { // last value
							segments.push(points.slice(lastNull + 1, i + 1));
						}
					});
				}
			}

			// register it
			series.segments = segments;
		},

		/**
		 * Set the series options by merging from the options tree
		 * @param {Object} itemOptions
		 */
		setOptions: function (itemOptions) {
			var chart = this.chart,
				chartOptions = chart.options,
				plotOptions = chartOptions.plotOptions,
				userOptions = chart.userOptions || {},
				userPlotOptions = userOptions.plotOptions || {},
				typeOptions = plotOptions[this.type],
				options,
				zones;

			this.userOptions = itemOptions;

			// General series options take precedence over type options because otherwise, default
			// type options like column.animation would be overwritten by the general option.
			// But issues have been raised here (#3881), and the solution may be to distinguish 
			// between default option and userOptions like in the tooltip below.
			options = merge(
				typeOptions,
				plotOptions.series,
				itemOptions
			);

			// The tooltip options are merged between global and series specific options
			this.tooltipOptions = merge(
				defaultOptions.tooltip,
				defaultOptions.plotOptions[this.type].tooltip,
				userOptions.tooltip,
				userPlotOptions.series && userPlotOptions.series.tooltip,
				userPlotOptions[this.type] && userPlotOptions[this.type].tooltip,
				itemOptions.tooltip
			);

			// Delete marker object if not allowed (#1125)
			if (typeOptions.marker === null) {
				delete options.marker;
			}

			// Handle color zones
			this.zoneAxis = options.zoneAxis;
			zones = this.zones = (options.zones || []).slice();
			if ((options.negativeColor || options.negativeFillColor) && !options.zones) {
				zones.push({
					value: options[this.zoneAxis + 'Threshold'] || options.threshold || 0,
					color: options.negativeColor,
					fillColor: options.negativeFillColor
				});
			}
			if (zones.length) { // Push one extra zone for the rest
				if (defined(zones[zones.length - 1].value)) {
					zones.push({
						color: this.color,
						fillColor: this.fillColor
					});
				}
			}
			return options;
		},

		getCyclic: function (prop, value, defaults) {
			var i,
				userOptions = this.userOptions,
				indexName = '_' + prop + 'Index',
				counterName = prop + 'Counter';

			if (!value) {
				if (defined(userOptions[indexName])) { // after Series.update()
					i = userOptions[indexName];
				} else {
					userOptions[indexName] = i = this.chart[counterName] % defaults.length;
					this.chart[counterName] += 1;
				}
				value = defaults[i];
			}
			this[prop] = value;
		},

		/**
		 * Get the series' color
		 */
		getColor: function () {
			if (!this.options.colorByPoint) {
				this.getCyclic('color', this.options.color || defaultPlotOptions[this.type].color, this.chart.options.colors);
			}
		},
		/**
		 * Get the series' symbol
		 */
		getSymbol: function () {
			var seriesMarkerOption = this.options.marker;

			this.getCyclic('symbol', seriesMarkerOption.symbol, this.chart.options.symbols);

			// don't substract radius in image symbols (#604)
			if (/^url/.test(this.symbol)) {
				seriesMarkerOption.radius = 0;
			}
		},

		drawLegendSymbol: LegendSymbolMixin.drawLineMarker,

		/**
		 * Replace the series data with a new set of data
		 * @param {Object} data
		 * @param {Object} redraw
		 */
		setData: function (data, redraw, animation, updatePoints) {
			var series = this,
				oldData = series.points,
				oldDataLength = (oldData && oldData.length) || 0,
				dataLength,
				options = series.options,
				chart = series.chart,
				firstPoint = null,
				xAxis = series.xAxis,
				hasCategories = xAxis && !!xAxis.categories,
				i,
				turboThreshold = options.turboThreshold,
				pt,
				xData = this.xData,
				yData = this.yData,
				pointArrayMap = series.pointArrayMap,
				valueCount = pointArrayMap && pointArrayMap.length;

			data = data || [];
			dataLength = data.length;
			redraw = pick(redraw, true);

			// If the point count is the same as is was, just run Point.update which is
			// cheaper, allows animation, and keeps references to points.
			if (updatePoints !== false && dataLength && oldDataLength === dataLength && !series.cropped && !series.hasGroupedData && series.visible) {
				each(data, function (point, i) {
					if (oldData[i].update) { // Linked, previously hidden series (#3709)
						oldData[i].update(point, false, null, false);
					}
				});

			} else {

				// Reset properties
				series.xIncrement = null;
				series.pointRange = hasCategories ? 1 : options.pointRange;

				series.colorCounter = 0; // for series with colorByPoint (#1547)
				
				// Update parallel arrays
				each(this.parallelArrays, function (key) {
					series[key + 'Data'].length = 0;
				});

				// In turbo mode, only one- or twodimensional arrays of numbers are allowed. The
				// first value is tested, and we assume that all the rest are defined the same
				// way. Although the 'for' loops are similar, they are repeated inside each
				// if-else conditional for max performance.
				if (turboThreshold && dataLength > turboThreshold) {

					// find the first non-null point
					i = 0;
					while (firstPoint === null && i < dataLength) {
						firstPoint = data[i];
						i++;
					}


					if (isNumber(firstPoint)) { // assume all points are numbers
						var x = pick(options.pointStart, 0),
							pointInterval = pick(options.pointInterval, 1);

						for (i = 0; i < dataLength; i++) {
							xData[i] = x;
							yData[i] = data[i];
							x += pointInterval;
						}
						series.xIncrement = x;
					} else if (isArray(firstPoint)) { // assume all points are arrays
						if (valueCount) { // [x, low, high] or [x, o, h, l, c]
							for (i = 0; i < dataLength; i++) {
								pt = data[i];
								xData[i] = pt[0];
								yData[i] = pt.slice(1, valueCount + 1);
							}
						} else { // [x, y]
							for (i = 0; i < dataLength; i++) {
								pt = data[i];
								xData[i] = pt[0];
								yData[i] = pt[1];
							}
						}
					} else {
						error(12); // Highcharts expects configs to be numbers or arrays in turbo mode
					}
				} else {
					for (i = 0; i < dataLength; i++) {
						if (data[i] !== UNDEFINED) { // stray commas in oldIE
							pt = { series: series };
							series.pointClass.prototype.applyOptions.apply(pt, [data[i]]);
							series.updateParallelArrays(pt, i);
							if (hasCategories && pt.name) {
								xAxis.names[pt.x] = pt.name; // #2046
							}
						}
					}
				}

				// Forgetting to cast strings to numbers is a common caveat when handling CSV or JSON
				if (isString(yData[0])) {
					error(14, true);
				}

				series.data = [];
				series.options.data = data;
				//series.zData = zData;

				// destroy old points
				i = oldDataLength;
				while (i--) {
					if (oldData[i] && oldData[i].destroy) {
						oldData[i].destroy();
					}
				}

				// reset minRange (#878)
				if (xAxis) {
					xAxis.minRange = xAxis.userMinRange;
				}

				// redraw
				series.isDirty = series.isDirtyData = chart.isDirtyBox = true;
				animation = false;
			}

			if (redraw) {
				chart.redraw(animation);
			}
		},

		/**
		 * Process the data by cropping away unused data points if the series is longer
		 * than the crop threshold. This saves computing time for lage series.
		 */
		processData: function (force) {
			var series = this,
				processedXData = series.xData, // copied during slice operation below
				processedYData = series.yData,
				dataLength = processedXData.length,
				croppedData,
				cropStart = 0,
				cropped,
				distance,
				closestPointRange,
				xAxis = series.xAxis,
				i, // loop variable
				options = series.options,
				cropThreshold = options.cropThreshold,
				isCartesian = series.isCartesian,
				xExtremes,
				min,
				max;

			// If the series data or axes haven't changed, don't go through this. Return false to pass
			// the message on to override methods like in data grouping.
			if (isCartesian && !series.isDirty && !xAxis.isDirty && !series.yAxis.isDirty && !force) {
				return false;
			}

			if (xAxis) {
				xExtremes = xAxis.getExtremes(); // corrected for log axis (#3053)
				min = xExtremes.min;
				max = xExtremes.max;
			}

			// optionally filter out points outside the plot area
			if (isCartesian && series.sorted && (!cropThreshold || dataLength > cropThreshold || series.forceCrop)) {
				
				// it's outside current extremes
				if (processedXData[dataLength - 1] < min || processedXData[0] > max) {
					processedXData = [];
					processedYData = [];

				// only crop if it's actually spilling out
				} else if (processedXData[0] < min || processedXData[dataLength - 1] > max) {
					croppedData = this.cropData(series.xData, series.yData, min, max);
					processedXData = croppedData.xData;
					processedYData = croppedData.yData;
					cropStart = croppedData.start;
					cropped = true;
				}
			}


			// Find the closest distance between processed points
			for (i = processedXData.length - 1; i >= 0; i--) {
				distance = processedXData[i] - processedXData[i - 1];
				
				if (distance > 0 && (closestPointRange === UNDEFINED || distance < closestPointRange)) {
					closestPointRange = distance;

				// Unsorted data is not supported by the line tooltip, as well as data grouping and
				// navigation in Stock charts (#725) and width calculation of columns (#1900)
				} else if (distance < 0 && series.requireSorting) {
					error(15);
				}
			}

			// Record the properties
			series.cropped = cropped; // undefined or true
			series.cropStart = cropStart;
			series.processedXData = processedXData;
			series.processedYData = processedYData;

			if (options.pointRange === null) { // null means auto, as for columns, candlesticks and OHLC
				series.pointRange = closestPointRange || 1;
			}
			series.closestPointRange = closestPointRange;

		},

		/**
		 * Iterate over xData and crop values between min and max. Returns object containing crop start/end
		 * cropped xData with corresponding part of yData, dataMin and dataMax within the cropped range
		 */
		cropData: function (xData, yData, min, max) {
			var dataLength = xData.length,
				cropStart = 0,
				cropEnd = dataLength,
				cropShoulder = pick(this.cropShoulder, 1), // line-type series need one point outside
				i;

			// iterate up to find slice start
			for (i = 0; i < dataLength; i++) {
				if (xData[i] >= min) {
					cropStart = mathMax(0, i - cropShoulder);
					break;
				}
			}

			// proceed to find slice end
			for (; i < dataLength; i++) {
				if (xData[i] > max) {
					cropEnd = i + cropShoulder;
					break;
				}
			}

			return {
				xData: xData.slice(cropStart, cropEnd),
				yData: yData.slice(cropStart, cropEnd),
				start: cropStart,
				end: cropEnd
			};
		},


		/**
		 * Generate the data point after the data has been processed by cropping away
		 * unused points and optionally grouped in Highcharts Stock.
		 */
		generatePoints: function () {
			var series = this,
				options = series.options,
				dataOptions = options.data,
				data = series.data,
				dataLength,
				processedXData = series.processedXData,
				processedYData = series.processedYData,
				pointClass = series.pointClass,
				processedDataLength = processedXData.length,
				cropStart = series.cropStart || 0,
				cursor,
				hasGroupedData = series.hasGroupedData,
				point,
				points = [],
				i;

			if (!data && !hasGroupedData) {
				var arr = [];
				arr.length = dataOptions.length;
				data = series.data = arr;
			}

			for (i = 0; i < processedDataLength; i++) {
				cursor = cropStart + i;
				if (!hasGroupedData) {
					if (data[cursor]) {
						point = data[cursor];
					} else if (dataOptions[cursor] !== UNDEFINED) { // #970
						data[cursor] = point = (new pointClass()).init(series, dataOptions[cursor], processedXData[i]);
					}
					points[i] = point;
				} else {
					// splat the y data in case of ohlc data array
					points[i] = (new pointClass()).init(series, [processedXData[i]].concat(splat(processedYData[i])));
				}
				points[i].index = cursor; // For faster access in Point.update
			}

			// Hide cropped-away points - this only runs when the number of points is above cropThreshold, or when
			// swithching view from non-grouped data to grouped data (#637)
			if (data && (processedDataLength !== (dataLength = data.length) || hasGroupedData)) {
				for (i = 0; i < dataLength; i++) {
					if (i === cropStart && !hasGroupedData) { // when has grouped data, clear all points
						i += processedDataLength;
					}
					if (data[i]) {
						data[i].destroyElements();
						data[i].plotX = UNDEFINED; // #1003
					}
				}
			}

			series.data = data;
			series.points = points;
		},

		/**
		 * Calculate Y extremes for visible data
		 */
		getExtremes: function (yData) {
			var xAxis = this.xAxis,
				yAxis = this.yAxis,
				xData = this.processedXData,
				yDataLength,
				activeYData = [],
				activeCounter = 0,
				xExtremes = xAxis.getExtremes(), // #2117, need to compensate for log X axis
				xMin = xExtremes.min,
				xMax = xExtremes.max,
				validValue,
				withinRange,
				x,
				y,
				i,
				j;

			yData = yData || this.stackedYData || this.processedYData;
			yDataLength = yData.length;

			for (i = 0; i < yDataLength; i++) {

				x = xData[i];
				y = yData[i];

				// For points within the visible range, including the first point outside the
				// visible range, consider y extremes
				validValue = y !== null && y !== UNDEFINED && (!yAxis.isLog || (y.length || y > 0));
				withinRange = this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped ||
					((xData[i + 1] || x) >= xMin &&	(xData[i - 1] || x) <= xMax);

				if (validValue && withinRange) {

					j = y.length;
					if (j) { // array, like ohlc or range data
						while (j--) {
							if (y[j] !== null) {
								activeYData[activeCounter++] = y[j];
							}
						}
					} else {
						activeYData[activeCounter++] = y;
					}
				}
			}
			this.dataMin = arrayMin(activeYData);
			this.dataMax = arrayMax(activeYData);
		},

		/**
		 * Translate data points from raw data values to chart specific positioning data
		 * needed later in drawPoints, drawGraph and drawTracker.
		 */
		translate: function () {
			if (!this.processedXData) { // hidden series
				this.processData();
			}
			this.generatePoints();
			var series = this,
				options = series.options,
				stacking = options.stacking,
				xAxis = series.xAxis,
				categories = xAxis.categories,
				yAxis = series.yAxis,
				points = series.points,
				dataLength = points.length,
				hasModifyValue = !!series.modifyValue,
				i,
				pointPlacement = options.pointPlacement,
				dynamicallyPlaced = pointPlacement === 'between' || isNumber(pointPlacement),
				threshold = options.threshold,
				stackThreshold = options.startFromThreshold ? threshold : 0,
				plotX,
				plotY,
				lastPlotX,
				closestPointRangePx = Number.MAX_VALUE;

			// Translate each point
			for (i = 0; i < dataLength; i++) {
				var point = points[i],
					xValue = point.x,
					yValue = point.y,
					yBottom = point.low,
					stack = stacking && yAxis.stacks[(series.negStacks && yValue < (stackThreshold ? 0 : threshold) ? '-' : '') + series.stackKey],
					pointStack,
					stackValues;

				// Discard disallowed y values for log axes (#3434)
				if (yAxis.isLog && yValue !== null && yValue <= 0) {
					point.y = yValue = null;
					error(10);
				}

				// Get the plotX translation
				point.plotX = plotX = mathMin(mathMax(-1e5, xAxis.translate(xValue, 0, 0, 0, 1, pointPlacement, this.type === 'flags')), 1e5); // #3923


				// Calculate the bottom y value for stacked series
				if (stacking && series.visible && stack && stack[xValue]) {

					pointStack = stack[xValue];
					stackValues = pointStack.points[series.index + ',' + i];
					yBottom = stackValues[0];
					yValue = stackValues[1];

					if (yBottom === stackThreshold) {
						yBottom = pick(threshold, yAxis.min);
					}
					if (yAxis.isLog && yBottom <= 0) { // #1200, #1232
						yBottom = null;
					}

					point.total = point.stackTotal = pointStack.total;
					point.percentage = pointStack.total && (point.y / pointStack.total * 100);
					point.stackY = yValue;

					// Place the stack label
					pointStack.setOffset(series.pointXOffset || 0, series.barW || 0);

				}

				// Set translated yBottom or remove it
				point.yBottom = defined(yBottom) ?
					yAxis.translate(yBottom, 0, 1, 0, 1) :
					null;

				// general hook, used for Highstock compare mode
				if (hasModifyValue) {
					yValue = series.modifyValue(yValue, point);
				}

				// Set the the plotY value, reset it for redraws
				point.plotY = plotY = (typeof yValue === 'number' && yValue !== Infinity) ?
					mathMin(mathMax(-1e5, yAxis.translate(yValue, 0, 1, 0, 1)), 1e5) : // #3201
					UNDEFINED;
				point.isInside = plotY !== UNDEFINED && plotY >= 0 && plotY <= yAxis.len && // #3519
					plotX >= 0 && plotX <= xAxis.len;


				// Set client related positions for mouse tracking
				point.clientX = dynamicallyPlaced ? xAxis.translate(xValue, 0, 0, 0, 1) : plotX; // #1514

				point.negative = point.y < (threshold || 0);

				// some API data
				point.category = categories && categories[point.x] !== UNDEFINED ?
					categories[point.x] : point.x;

				// Determine auto enabling of markers (#3635)
				if (i) {
					closestPointRangePx = mathMin(closestPointRangePx, mathAbs(plotX - lastPlotX));
				}
				lastPlotX = plotX;

			}

			series.closestPointRangePx = closestPointRangePx;

			// now that we have the cropped data, build the segments
			series.getSegments();
		},

		/**
		 * Set the clipping for the series. For animated series it is called twice, first to initiate
		 * animating the clip then the second time without the animation to set the final clip.
		 */
		setClip: function (animation) {
			var chart = this.chart,
				renderer = chart.renderer,
				inverted = chart.inverted,
				seriesClipBox = this.clipBox,
				clipBox = seriesClipBox || chart.clipBox,
				sharedClipKey = this.sharedClipKey || ['_sharedClip', animation && animation.duration, animation && animation.easing, clipBox.height].join(','),
				clipRect = chart[sharedClipKey],
				markerClipRect = chart[sharedClipKey + 'm'];

			// If a clipping rectangle with the same properties is currently present in the chart, use that.
			if (!clipRect) {

				// When animation is set, prepare the initial positions
				if (animation) { 
					clipBox.width = 0;

					chart[sharedClipKey + 'm'] = markerClipRect = renderer.clipRect(
						-99, // include the width of the first marker
						inverted ? -chart.plotLeft : -chart.plotTop,
						99,
						inverted ? chart.chartWidth : chart.chartHeight
					);
				}
				chart[sharedClipKey] = clipRect = renderer.clipRect(clipBox);
				
			}
			if (animation) {
				clipRect.count += 1;
			}

			if (this.options.clip !== false) {
				this.group.clip(animation || seriesClipBox ? clipRect : chart.clipRect);
				this.markerGroup.clip(markerClipRect);
				this.sharedClipKey = sharedClipKey;
			}

			// Remove the shared clipping rectangle when all series are shown
			if (!animation) {
				clipRect.count -= 1;
				if (clipRect.count <= 0 && sharedClipKey && chart[sharedClipKey]) {
					if (!seriesClipBox) {
						chart[sharedClipKey] = chart[sharedClipKey].destroy();
					}
					if (chart[sharedClipKey + 'm']) {
						chart[sharedClipKey + 'm'] = chart[sharedClipKey + 'm'].destroy();
					}
				}
			}
		},

		/**
		 * Animate in the series
		 */
		animate: function (init) {
			var series = this,
				chart = series.chart,
				clipRect,
				animation = series.options.animation,
				sharedClipKey;

			// Animation option is set to true
			if (animation && !isObject(animation)) {
				animation = defaultPlotOptions[series.type].animation;
			}

			// Initialize the animation. Set up the clipping rectangle.
			if (init) {

				series.setClip(animation);

			// Run the animation
			} else {
				sharedClipKey = this.sharedClipKey;
				clipRect = chart[sharedClipKey];
				if (clipRect) {
					clipRect.animate({
						width: chart.plotSizeX
					}, animation);
				}
				if (chart[sharedClipKey + 'm']) {
					chart[sharedClipKey + 'm'].animate({
						width: chart.plotSizeX + 99
					}, animation);
				}

				// Delete this function to allow it only once
				series.animate = null;
	 
			}
		},

		/**
		 * This runs after animation to land on the final plot clipping
		 */
		afterAnimate: function () {
			this.setClip();
			fireEvent(this, 'afterAnimate');
		},

		/**
		 * Draw the markers
		 */
		drawPoints: function () {
			var series = this,
				pointAttr,
				points = series.points,
				chart = series.chart,
				plotX,
				plotY,
				i,
				point,
				radius,
				symbol,
				isImage,
				graphic,
				options = series.options,
				seriesMarkerOptions = options.marker,
				seriesPointAttr = series.pointAttr[''],
				pointMarkerOptions,
				hasPointMarker,
				enabled,
				isInside,
				markerGroup = series.markerGroup,
				xAxis = series.xAxis,
				globallyEnabled = pick(
					seriesMarkerOptions.enabled, 
					xAxis.isRadial,
					series.closestPointRangePx > 2 * seriesMarkerOptions.radius
				);

			if (seriesMarkerOptions.enabled !== false || series._hasPointMarkers) {

				i = points.length;
				while (i--) {
					point = points[i];
					plotX = mathFloor(point.plotX); // #1843
					plotY = point.plotY;
					graphic = point.graphic;
					pointMarkerOptions = point.marker || {};
					hasPointMarker = !!point.marker;
					enabled = (globallyEnabled && pointMarkerOptions.enabled === UNDEFINED) || pointMarkerOptions.enabled;
					isInside = point.isInside;

					// only draw the point if y is defined
					if (enabled && plotY !== UNDEFINED && !isNaN(plotY) && point.y !== null) {

						// shortcuts
						pointAttr = point.pointAttr[point.selected ? SELECT_STATE : NORMAL_STATE] || seriesPointAttr;
						radius = pointAttr.r;
						symbol = pick(pointMarkerOptions.symbol, series.symbol);
						isImage = symbol.indexOf('url') === 0;

						if (graphic) { // update
							graphic[isInside ? 'show' : 'hide'](true) // Since the marker group isn't clipped, each individual marker must be toggled
								.animate(extend({
									x: plotX - radius,
									y: plotY - radius
								}, graphic.symbolName ? { // don't apply to image symbols #507
									width: 2 * radius,
									height: 2 * radius
								} : {}));
						} else if (isInside && (radius > 0 || isImage)) {
							point.graphic = graphic = chart.renderer.symbol(
								symbol,
								plotX - radius,
								plotY - radius,
								2 * radius,
								2 * radius,
								hasPointMarker ? pointMarkerOptions : seriesMarkerOptions
							)
							.attr(pointAttr)
							.add(markerGroup);
						}

					} else if (graphic) {
						point.graphic = graphic.destroy(); // #1269
					}
				}
			}

		},

		/**
		 * Convert state properties from API naming conventions to SVG attributes
		 *
		 * @param {Object} options API options object
		 * @param {Object} base1 SVG attribute object to inherit from
		 * @param {Object} base2 Second level SVG attribute object to inherit from
		 */
		convertAttribs: function (options, base1, base2, base3) {
			var conversion = this.pointAttrToOptions,
				attr,
				option,
				obj = {};

			options = options || {};
			base1 = base1 || {};
			base2 = base2 || {};
			base3 = base3 || {};

			for (attr in conversion) {
				option = conversion[attr];
				obj[attr] = pick(options[option], base1[attr], base2[attr], base3[attr]);
			}
			return obj;
		},

		/**
		 * Get the state attributes. Each series type has its own set of attributes
		 * that are allowed to change on a point's state change. Series wide attributes are stored for
		 * all series, and additionally point specific attributes are stored for all
		 * points with individual marker options. If such options are not defined for the point,
		 * a reference to the series wide attributes is stored in point.pointAttr.
		 */
		getAttribs: function () {
			var series = this,
				seriesOptions = series.options,
				normalOptions = defaultPlotOptions[series.type].marker ? seriesOptions.marker : seriesOptions,
				stateOptions = normalOptions.states,
				stateOptionsHover = stateOptions[HOVER_STATE],
				pointStateOptionsHover,
				seriesColor = series.color,
				seriesNegativeColor = series.options.negativeColor,
				normalDefaults = {
					stroke: seriesColor,
					fill: seriesColor
				},
				points = series.points || [], // #927
				i,
				point,
				seriesPointAttr = [],
				pointAttr,
				pointAttrToOptions = series.pointAttrToOptions,
				hasPointSpecificOptions = series.hasPointSpecificOptions,
				defaultLineColor = normalOptions.lineColor,
				defaultFillColor = normalOptions.fillColor,
				turboThreshold = seriesOptions.turboThreshold,
				zones = series.zones,
				zoneAxis = series.zoneAxis || 'y',
				attr,
				key;

			// series type specific modifications
			if (seriesOptions.marker) { // line, spline, area, areaspline, scatter

				// if no hover radius is given, default to normal radius + 2
				stateOptionsHover.radius = stateOptionsHover.radius || normalOptions.radius + stateOptionsHover.radiusPlus;
				stateOptionsHover.lineWidth = stateOptionsHover.lineWidth || normalOptions.lineWidth + stateOptionsHover.lineWidthPlus;

			} else { // column, bar, pie

				// if no hover color is given, brighten the normal color
				stateOptionsHover.color = stateOptionsHover.color ||
					Color(stateOptionsHover.color || seriesColor)
						.brighten(stateOptionsHover.brightness).get();

				// if no hover negativeColor is given, brighten the normal negativeColor
				stateOptionsHover.negativeColor = stateOptionsHover.negativeColor ||
					Color(stateOptionsHover.negativeColor || seriesNegativeColor)
						.brighten(stateOptionsHover.brightness).get();
			}

			// general point attributes for the series normal state
			seriesPointAttr[NORMAL_STATE] = series.convertAttribs(normalOptions, normalDefaults);

			// HOVER_STATE and SELECT_STATE states inherit from normal state except the default radius
			each([HOVER_STATE, SELECT_STATE], function (state) {
				seriesPointAttr[state] =
						series.convertAttribs(stateOptions[state], seriesPointAttr[NORMAL_STATE]);
			});

			// set it
			series.pointAttr = seriesPointAttr;


			// Generate the point-specific attribute collections if specific point
			// options are given. If not, create a referance to the series wide point
			// attributes
			i = points.length;
			if (!turboThreshold || i < turboThreshold || hasPointSpecificOptions) {
				while (i--) {
					point = points[i];
					normalOptions = (point.options && point.options.marker) || point.options;
					if (normalOptions && normalOptions.enabled === false) {
						normalOptions.radius = 0;
					}

					if (zones.length) {
						var j = 0,
							threshold = zones[j];
						while (point[zoneAxis] >= threshold.value) {				
							threshold = zones[++j];
						}
						
						point.color = point.fillColor = threshold.color;
					}

					hasPointSpecificOptions = seriesOptions.colorByPoint || point.color; // #868

					// check if the point has specific visual options
					if (point.options) {
						for (key in pointAttrToOptions) {
							if (defined(normalOptions[pointAttrToOptions[key]])) {
								hasPointSpecificOptions = true;
							}
						}
					}

					// a specific marker config object is defined for the individual point:
					// create it's own attribute collection
					if (hasPointSpecificOptions) {
						normalOptions = normalOptions || {};
						pointAttr = [];
						stateOptions = normalOptions.states || {}; // reassign for individual point
						pointStateOptionsHover = stateOptions[HOVER_STATE] = stateOptions[HOVER_STATE] || {};

						// Handle colors for column and pies
						if (!seriesOptions.marker) { // column, bar, point
							// If no hover color is given, brighten the normal color. #1619, #2579
							pointStateOptionsHover.color = pointStateOptionsHover.color || (!point.options.color && stateOptionsHover[(point.negative && seriesNegativeColor ? 'negativeColor' : 'color')]) ||
								Color(point.color)
									.brighten(pointStateOptionsHover.brightness || stateOptionsHover.brightness)
									.get();
						}

						// normal point state inherits series wide normal state
						attr = { color: point.color }; // #868
						if (!defaultFillColor) { // Individual point color or negative color markers (#2219)
							attr.fillColor = point.color;
						}
						if (!defaultLineColor) {
							attr.lineColor = point.color; // Bubbles take point color, line markers use white
						}
						// Color is explicitly set to null or undefined (#1288, #4068)
						if (normalOptions.hasOwnProperty('color') && !normalOptions.color) {
							delete normalOptions.color;
						}
						pointAttr[NORMAL_STATE] = series.convertAttribs(extend(attr, normalOptions), seriesPointAttr[NORMAL_STATE]);

						// inherit from point normal and series hover
						pointAttr[HOVER_STATE] = series.convertAttribs(
							stateOptions[HOVER_STATE],
							seriesPointAttr[HOVER_STATE],
							pointAttr[NORMAL_STATE]
						);

						// inherit from point normal and series hover
						pointAttr[SELECT_STATE] = series.convertAttribs(
							stateOptions[SELECT_STATE],
							seriesPointAttr[SELECT_STATE],
							pointAttr[NORMAL_STATE]
						);


					// no marker config object is created: copy a reference to the series-wide
					// attribute collection
					} else {
						pointAttr = seriesPointAttr;
					}

					point.pointAttr = pointAttr;
				}
			}
		},

		/**
		 * Clear DOM objects and free up memory
		 */
		destroy: function () {
			var series = this,
				chart = series.chart,
				issue134 = /AppleWebKit\/533/.test(userAgent),
				destroy,
				i,
				data = series.data || [],
				point,
				prop,
				axis;

			// add event hook
			fireEvent(series, 'destroy');

			// remove all events
			removeEvent(series);

			// erase from axes
			each(series.axisTypes || [], function (AXIS) {
				axis = series[AXIS];
				if (axis) {
					erase(axis.series, series);
					axis.isDirty = axis.forceRedraw = true;
				}
			});

			// remove legend items
			if (series.legendItem) {
				series.chart.legend.destroyItem(series);
			}

			// destroy all points with their elements
			i = data.length;
			while (i--) {
				point = data[i];
				if (point && point.destroy) {
					point.destroy();
				}
			}
			series.points = null;

			// Clear the animation timeout if we are destroying the series during initial animation
			clearTimeout(series.animationTimeout);

			// Destroy all SVGElements associated to the series
			for (prop in series) {
				if (series[prop] instanceof SVGElement && !series[prop].survive) { // Survive provides a hook for not destroying

					// issue 134 workaround
					destroy = issue134 && prop === 'group' ?
						'hide' :
						'destroy';

					series[prop][destroy]();
				}
			}

			// remove from hoverSeries
			if (chart.hoverSeries === series) {
				chart.hoverSeries = null;
			}
			erase(chart.series, series);

			// clear all members
			for (prop in series) {
				delete series[prop];
			}
		},

		/**
		 * Return the graph path of a segment
		 */
		getSegmentPath: function (segment) {
			var series = this,
				segmentPath = [],
				step = series.options.step;

			// build the segment line
			each(segment, function (point, i) {

				var plotX = point.plotX,
					plotY = point.plotY,
					lastPoint;

				if (series.getPointSpline) { // generate the spline as defined in the SplineSeries object
					segmentPath.push.apply(segmentPath, series.getPointSpline(segment, point, i));

				} else {

					// moveTo or lineTo
					segmentPath.push(i ? L : M);

					// step line?
					if (step && i) {
						lastPoint = segment[i - 1];
						if (step === 'right') {
							segmentPath.push(
								lastPoint.plotX,
								plotY
							);

						} else if (step === 'center') {
							segmentPath.push(
								(lastPoint.plotX + plotX) / 2,
								lastPoint.plotY,
								(lastPoint.plotX + plotX) / 2,
								plotY
							);

						} else {
							segmentPath.push(
								plotX,
								lastPoint.plotY
							);
						}
					}

					// normal line to next point
					segmentPath.push(
						point.plotX,
						point.plotY
					);
				}
			});

			return segmentPath;
		},

		/**
		 * Get the graph path
		 */
		getGraphPath: function () {
			var series = this,
				graphPath = [],
				segmentPath,
				singlePoints = []; // used in drawTracker

			// Divide into segments and build graph and area paths
			each(series.segments, function (segment) {

				segmentPath = series.getSegmentPath(segment);

				// add the segment to the graph, or a single point for tracking
				if (segment.length > 1) {
					graphPath = graphPath.concat(segmentPath);
				} else {
					singlePoints.push(segment[0]);
				}
			});

			// Record it for use in drawGraph and drawTracker, and return graphPath
			series.singlePoints = singlePoints;
			series.graphPath = graphPath;

			return graphPath;

		},

		/**
		 * Draw the actual graph
		 */
		drawGraph: function () {
			var series = this,
				options = this.options,
				props = [['graph', options.lineColor || this.color, options.dashStyle]],
				lineWidth = options.lineWidth,
				roundCap = options.linecap !== 'square',
				graphPath = this.getGraphPath(),
				fillColor = (this.fillGraph && this.color) || NONE, // polygon series use filled graph
				zones = this.zones;

			each(zones, function (threshold, i) {
				props.push(['zoneGraph' + i, threshold.color || series.color, threshold.dashStyle || options.dashStyle]);
			});
			
			// Draw the graph
			each(props, function (prop, i) {
				var graphKey = prop[0],
					graph = series[graphKey],
					attribs;

				if (graph) {
					stop(graph); // cancel running animations, #459
					graph.animate({ d: graphPath });

				} else if ((lineWidth || fillColor) && graphPath.length) { // #1487
					attribs = {
						stroke: prop[1],
						'stroke-width': lineWidth,
						fill: fillColor,
						zIndex: 1 // #1069
					};
					if (prop[2]) {
						attribs.dashstyle = prop[2];
					} else if (roundCap) {
						attribs['stroke-linecap'] = attribs['stroke-linejoin'] = 'round';
					}

					series[graphKey] = series.chart.renderer.path(graphPath)
						.attr(attribs)
						.add(series.group)
						.shadow((i < 2) && options.shadow); // add shadow to normal series (0) or to first zone (1) #3932
				}
			});
		},

		/**
		 * Clip the graphs into the positive and negative coloured graphs
		 */
		applyZones: function () {
			var series = this,
				chart = this.chart,
				renderer = chart.renderer,
				zones = this.zones,
				translatedFrom,
				translatedTo,
				clips = this.clips || [],
				clipAttr,
				graph = this.graph,
				area = this.area,
				chartSizeMax = mathMax(chart.chartWidth, chart.chartHeight),
				zoneAxis = this.zoneAxis || 'y',
				axis = this[zoneAxis + 'Axis'],
				extremes,
				reversed = axis.reversed,
				inverted = chart.inverted,
				horiz = axis.horiz,
				pxRange,
				pxPosMin,
				pxPosMax,
				ignoreZones = false;

			if (zones.length && (graph || area)) {
				// The use of the Color Threshold assumes there are no gaps
				// so it is safe to hide the original graph and area
				if (graph) {
					graph.hide();
				}
				if (area) { 
					area.hide(); 
				}

				// Create the clips
				extremes = axis.getExtremes();
				each(zones, function (threshold, i) {

					translatedFrom = reversed ? 
						(horiz ? chart.plotWidth : 0) : 
						(horiz ? 0 : axis.toPixels(extremes.min));
					translatedFrom = mathMin(mathMax(pick(translatedTo, translatedFrom), 0), chartSizeMax);
					translatedTo = mathMin(mathMax(mathRound(axis.toPixels(pick(threshold.value, extremes.max), true)), 0), chartSizeMax);
					
					if (ignoreZones) {
						translatedFrom = translatedTo = axis.toPixels(extremes.max);
					}

					pxRange = Math.abs(translatedFrom - translatedTo);
					pxPosMin = mathMin(translatedFrom, translatedTo);
					pxPosMax = mathMax(translatedFrom, translatedTo);
					if (axis.isXAxis) {
						clipAttr = {
							x: inverted ? pxPosMax : pxPosMin,
							y: 0,
							width: pxRange, 
							height: chartSizeMax
						};
						if (!horiz) {
							clipAttr.x = chart.plotHeight - clipAttr.x;
						}
					} else {
						clipAttr = {
							x: 0,
							y: inverted ? pxPosMax : pxPosMin,
							width: chartSizeMax, 
							height: pxRange
						};					
						if (horiz) {
							clipAttr.y = chart.plotWidth - clipAttr.y;
						}
					}

					/// VML SUPPPORT
					if (chart.inverted && renderer.isVML) {
						if (axis.isXAxis) {			
							clipAttr = {
								x: 0,
								y: reversed ? pxPosMin : pxPosMax,
								height: clipAttr.width,
								width: chart.chartWidth
							};		
						} else {				
							clipAttr = {
								x: clipAttr.y - chart.plotLeft - chart.spacingBox.x,
								y: 0,
								width: clipAttr.height,
								height: chart.chartHeight
							};	
						}				
					}
					/// END OF VML SUPPORT

					if (clips[i]) {
						clips[i].animate(clipAttr);
					} else {
						clips[i] = renderer.clipRect(clipAttr);

						if (graph) {
							series['zoneGraph' + i].clip(clips[i]);
						}

						if (area) {
							series['zoneArea' + i].clip(clips[i]);
						}
					}
					// if this zone extends out of the axis, ignore the others
					ignoreZones = threshold.value > extremes.max;
				});
				this.clips = clips;
			}
		},

		/**
		 * Initialize and perform group inversion on series.group and series.markerGroup
		 */
		invertGroups: function () {
			var series = this,
				chart = series.chart;

			// Pie, go away (#1736)
			if (!series.xAxis) {
				return;
			}

			// A fixed size is needed for inversion to work
			function setInvert() {
				var size = {
					width: series.yAxis.len,
					height: series.xAxis.len
				};

				each(['group', 'markerGroup'], function (groupName) {
					if (series[groupName]) {
						series[groupName].attr(size).invert();
					}
				});
			}

			addEvent(chart, 'resize', setInvert); // do it on resize
			addEvent(series, 'destroy', function () {
				removeEvent(chart, 'resize', setInvert);
			});

			// Do it now
			setInvert(); // do it now

			// On subsequent render and redraw, just do setInvert without setting up events again
			series.invertGroups = setInvert;
		},

		/**
		 * General abstraction for creating plot groups like series.group, series.dataLabelsGroup and
		 * series.markerGroup. On subsequent calls, the group will only be adjusted to the updated plot size.
		 */
		plotGroup: function (prop, name, visibility, zIndex, parent) {
			var group = this[prop],
				isNew = !group;

			// Generate it on first call
			if (isNew) {
				this[prop] = group = this.chart.renderer.g(name)
					.attr({
						visibility: visibility,
						zIndex: zIndex || 0.1 // IE8 needs this
					})
					.add(parent);
			}
			// Place it on first and subsequent (redraw) calls
			group[isNew ? 'attr' : 'animate'](this.getPlotBox());
			return group;
		},

		/**
		 * Get the translation and scale for the plot area of this series
		 */
		getPlotBox: function () {
			var chart = this.chart,
				xAxis = this.xAxis,
				yAxis = this.yAxis;

			// Swap axes for inverted (#2339)
			if (chart.inverted) {
				xAxis = yAxis;
				yAxis = this.xAxis;
			}
			return {
				translateX: xAxis ? xAxis.left : chart.plotLeft,
				translateY: yAxis ? yAxis.top : chart.plotTop,
				scaleX: 1, // #1623
				scaleY: 1
			};
		},

		/**
		 * Render the graph and markers
		 */
		render: function () {
			var series = this,
				chart = series.chart,
				group,
				options = series.options,
				animation = options.animation,
				// Animation doesn't work in IE8 quirks when the group div is hidden,
				// and looks bad in other oldIE
				animDuration = (animation && !!series.animate && chart.renderer.isSVG && pick(animation.duration, 500)) || 0,
				visibility = series.visible ? VISIBLE : HIDDEN,
				zIndex = options.zIndex,
				hasRendered = series.hasRendered,
				chartSeriesGroup = chart.seriesGroup;

			// the group
			group = series.plotGroup(
				'group',
				'series',
				visibility,
				zIndex,
				chartSeriesGroup
			);

			series.markerGroup = series.plotGroup(
				'markerGroup',
				'markers',
				visibility,
				zIndex,
				chartSeriesGroup
			);

			// initiate the animation
			if (animDuration) {
				series.animate(true);
			}

			// cache attributes for shapes
			series.getAttribs();

			// SVGRenderer needs to know this before drawing elements (#1089, #1795)
			group.inverted = series.isCartesian ? chart.inverted : false;

			// draw the graph if any
			if (series.drawGraph) {
				series.drawGraph();
				series.applyZones();
			}

			each(series.points, function (point) {
				if (point.redraw) {
					point.redraw();
				}
			});

			// draw the data labels (inn pies they go before the points)
			if (series.drawDataLabels) {
				series.drawDataLabels();
			}

			// draw the points
			if (series.visible) {
				series.drawPoints();
			}


			// draw the mouse tracking area
			if (series.drawTracker && series.options.enableMouseTracking !== false) {
				series.drawTracker();
			}

			// Handle inverted series and tracker groups
			if (chart.inverted) {
				series.invertGroups();
			}

			// Initial clipping, must be defined after inverting groups for VML. Applies to columns etc. (#3839).
			if (options.clip !== false && !series.sharedClipKey && !hasRendered) {
				group.clip(chart.clipRect);
			}

			// Run the animation
			if (animDuration) {
				series.animate();
			} 

			// Call the afterAnimate function on animation complete (but don't overwrite the animation.complete option
			// which should be available to the user).
			if (!hasRendered) {
				if (animDuration) {
					series.animationTimeout = setTimeout(function () {
						series.afterAnimate();
					}, animDuration);
				} else {
					series.afterAnimate();
				}
			}

			series.isDirty = series.isDirtyData = false; // means data is in accordance with what you see
			// (See #322) series.isDirty = series.isDirtyData = false; // means data is in accordance with what you see
			series.hasRendered = true;
		},

		/**
		 * Redraw the series after an update in the axes.
		 */
		redraw: function () {
			var series = this,
				chart = series.chart,
				wasDirtyData = series.isDirtyData, // cache it here as it is set to false in render, but used after
				wasDirty = series.isDirty,
				group = series.group,
				xAxis = series.xAxis,
				yAxis = series.yAxis;

			// reposition on resize
			if (group) {
				if (chart.inverted) {
					group.attr({
						width: chart.plotWidth,
						height: chart.plotHeight
					});
				}

				group.animate({
					translateX: pick(xAxis && xAxis.left, chart.plotLeft),
					translateY: pick(yAxis && yAxis.top, chart.plotTop)
				});
			}

			series.translate();
			series.render();
			if (wasDirtyData) {
				fireEvent(series, 'updatedData');
			}
			if (wasDirty || wasDirtyData) {			// #3945 recalculate the kdtree when dirty
				delete this.kdTree; // #3868 recalculate the kdtree with dirty data
			}
		},

		/**
		 * KD Tree && PointSearching Implementation
		 */

		kdDimensions: 1,
		kdAxisArray: ['clientX', 'plotY'],

		searchPoint: function (e, compareX) {
			var series = this,
				xAxis = series.xAxis,
				yAxis = series.yAxis,
				inverted = series.chart.inverted;
			
			return this.searchKDTree({
				clientX: inverted ? xAxis.len - e.chartY + xAxis.pos : e.chartX - xAxis.pos,
				plotY: inverted ? yAxis.len - e.chartX + yAxis.pos : e.chartY - yAxis.pos
			}, compareX);
		},

		buildKDTree: function () {
			var series = this,
				dimensions = series.kdDimensions;

			// Internal function
			function _kdtree(points, depth, dimensions) {
				var axis, median, length = points && points.length;

				if (length) {

					// alternate between the axis
					axis = series.kdAxisArray[depth % dimensions];

					// sort point array
					points.sort(function(a, b) {
						return a[axis] - b[axis];
					});
				
					median = Math.floor(length / 2);
					
					// build and return nod
					return {
						point: points[median],
						left: _kdtree(points.slice(0, median), depth + 1, dimensions),
						right: _kdtree(points.slice(median + 1), depth + 1, dimensions)
					};
				
				}
			}

			// Start the recursive build process with a clone of the points array and null points filtered out (#3873)
			function startRecursive() {
				var points = grep(series.points, function (point) {
					return point.y !== null;
				});

				series.kdTree = _kdtree(points, dimensions, dimensions);
			}
			delete series.kdTree;
			
			if (series.options.kdSync) {  // For testing tooltips, don't build async
				startRecursive();
			} else {
				setTimeout(startRecursive);
			}
		},

		searchKDTree: function (point, compareX) {
			var series = this,
				kdX = this.kdAxisArray[0],
				kdY = this.kdAxisArray[1],
				kdComparer = compareX ? 'distX' : 'dist';

			// Set the one and two dimensional distance on the point object
			function setDistance(p1, p2) {
				var x = (defined(p1[kdX]) && defined(p2[kdX])) ? Math.pow(p1[kdX] - p2[kdX], 2) : null,
					y = (defined(p1[kdY]) && defined(p2[kdY])) ? Math.pow(p1[kdY] - p2[kdY], 2) : null,
					r = (x || 0) + (y || 0);

				p2.dist = defined(r) ? Math.sqrt(r) : Number.MAX_VALUE;
				p2.distX = defined(x) ? Math.sqrt(x) : Number.MAX_VALUE;
			}
			function _search(search, tree, depth, dimensions) {
				var point = tree.point,
					axis = series.kdAxisArray[depth % dimensions],
					tdist,
					sideA,
					sideB,
					ret = point,
					nPoint1,
					nPoint2;
				
				setDistance(search, point);

				// Pick side based on distance to splitting point
				tdist = search[axis] - point[axis];
				sideA = tdist < 0 ? 'left' : 'right';
				sideB = tdist < 0 ? 'right' : 'left';

				// End of tree
				if (tree[sideA]) {
					nPoint1 =_search(search, tree[sideA], depth + 1, dimensions);

					ret = (nPoint1[kdComparer] < ret[kdComparer] ? nPoint1 : point);
				} 
				if (tree[sideB]) {
					// compare distance to current best to splitting point to decide wether to check side B or not
					if (Math.sqrt(tdist * tdist) < ret[kdComparer]) {
						nPoint2 = _search(search, tree[sideB], depth + 1, dimensions);
						ret = (nPoint2[kdComparer] < ret[kdComparer] ? nPoint2 : ret);
					}
				}
				
				return ret;
			}

			if (!this.kdTree) {
				this.buildKDTree();
			}

			if (this.kdTree) {
				return _search(point, 
					this.kdTree, this.kdDimensions, this.kdDimensions);
			}
		}

	}; // end Series prototype

	/**
	 * The class for stack items
	 */
	function StackItem(axis, options, isNegative, x, stackOption) {
		
		var inverted = axis.chart.inverted;

		this.axis = axis;

		// Tells if the stack is negative
		this.isNegative = isNegative;

		// Save the options to be able to style the label
		this.options = options;

		// Save the x value to be able to position the label later
		this.x = x;

		// Initialize total value
		this.total = null;

		// This will keep each points' extremes stored by series.index and point index
		this.points = {};

		// Save the stack option on the series configuration object, and whether to treat it as percent
		this.stack = stackOption;

		// The align options and text align varies on whether the stack is negative and
		// if the chart is inverted or not.
		// First test the user supplied value, then use the dynamic.
		this.alignOptions = {
			align: options.align || (inverted ? (isNegative ? 'left' : 'right') : 'center'),
			verticalAlign: options.verticalAlign || (inverted ? 'middle' : (isNegative ? 'bottom' : 'top')),
			y: pick(options.y, inverted ? 4 : (isNegative ? 14 : -6)),
			x: pick(options.x, inverted ? (isNegative ? -6 : 6) : 0)
		};

		this.textAlign = options.textAlign || (inverted ? (isNegative ? 'right' : 'left') : 'center');
	}

	StackItem.prototype = {
		destroy: function () {
			destroyObjectProperties(this, this.axis);
		},

		/**
		 * Renders the stack total label and adds it to the stack label group.
		 */
		render: function (group) {
			var options = this.options,
				formatOption = options.format,
				str = formatOption ?
					format(formatOption, this) : 
					options.formatter.call(this);  // format the text in the label

			// Change the text to reflect the new total and set visibility to hidden in case the serie is hidden
			if (this.label) {
				this.label.attr({text: str, visibility: HIDDEN});
			// Create new label
			} else {
				this.label =
					this.axis.chart.renderer.text(str, null, null, options.useHTML)		// dummy positions, actual position updated with setOffset method in columnseries
						.css(options.style)				// apply style
						.attr({
							align: this.textAlign,				// fix the text-anchor
							rotation: options.rotation,	// rotation
							visibility: HIDDEN					// hidden until setOffset is called
						})				
						.add(group);							// add to the labels-group
			}
		},

		/**
		 * Sets the offset that the stack has from the x value and repositions the label.
		 */
		setOffset: function (xOffset, xWidth) {
			var stackItem = this,
				axis = stackItem.axis,
				chart = axis.chart,
				inverted = chart.inverted,
				reversed = axis.reversed,
				neg = (this.isNegative && !reversed) || (!this.isNegative && reversed), // #4056
				y = axis.translate(axis.usePercentage ? 100 : this.total, 0, 0, 0, 1), // stack value translated mapped to chart coordinates
				yZero = axis.translate(0),						// stack origin
				h = mathAbs(y - yZero),							// stack height
				x = chart.xAxis[0].translate(this.x) + xOffset,	// stack x position
				plotHeight = chart.plotHeight,
				stackBox = {	// this is the box for the complete stack
					x: inverted ? (neg ? y : y - h) : x,
					y: inverted ? plotHeight - x - xWidth : (neg ? (plotHeight - y - h) : plotHeight - y),
					width: inverted ? h : xWidth,
					height: inverted ? xWidth : h
				},
				label = this.label,
				alignAttr;
			
			if (label) {
				label.align(this.alignOptions, null, stackBox);	// align the label to the box
					
				// Set visibility (#678)
				alignAttr = label.alignAttr;
				label[this.options.crop === false || chart.isInsidePlot(alignAttr.x, alignAttr.y) ? 'show' : 'hide'](true);
			}
		}
	};


	// Stacking methods defined on the Axis prototype

	/**
	 * Build the stacks from top down
	 */
	Axis.prototype.buildStacks = function () {
		var series = this.series,
			reversedStacks = pick(this.options.reversedStacks, true),
			i = series.length;
		if (!this.isXAxis) {
			this.usePercentage = false;
			while (i--) {
				series[reversedStacks ? i : series.length - i - 1].setStackedPoints();
			}
			// Loop up again to compute percent stack
			if (this.usePercentage) {
				for (i = 0; i < series.length; i++) {
					series[i].setPercentStacks();
				}
			}
		}
	};

	Axis.prototype.renderStackTotals = function () {
		var axis = this,
			chart = axis.chart,
			renderer = chart.renderer,
			stacks = axis.stacks,
			stackKey, 
			oneStack, 
			stackCategory,
			stackTotalGroup = axis.stackTotalGroup;

		// Create a separate group for the stack total labels
		if (!stackTotalGroup) {
			axis.stackTotalGroup = stackTotalGroup =
				renderer.g('stack-labels')
					.attr({
						visibility: VISIBLE,
						zIndex: 6
					})
					.add();
		}

		// plotLeft/Top will change when y axis gets wider so we need to translate the
		// stackTotalGroup at every render call. See bug #506 and #516
		stackTotalGroup.translate(chart.plotLeft, chart.plotTop);

		// Render each stack total
		for (stackKey in stacks) {
			oneStack = stacks[stackKey];
			for (stackCategory in oneStack) {
				oneStack[stackCategory].render(stackTotalGroup);
			}
		}
	};


	// Stacking methods defnied for Series prototype

	/**
	 * Adds series' points value to corresponding stack
	 */
	Series.prototype.setStackedPoints = function () {
		if (!this.options.stacking || (this.visible !== true && this.chart.options.chart.ignoreHiddenSeries !== false)) {
			return;
		}

		var series = this,
			xData = series.processedXData,
			yData = series.processedYData,
			stackedYData = [],
			yDataLength = yData.length,
			seriesOptions = series.options,
			threshold = seriesOptions.threshold,
			stackThreshold = seriesOptions.startFromThreshold ? threshold : 0,
			stackOption = seriesOptions.stack,
			stacking = seriesOptions.stacking,
			stackKey = series.stackKey,
			negKey = '-' + stackKey,
			negStacks = series.negStacks,
			yAxis = series.yAxis,
			stacks = yAxis.stacks,
			oldStacks = yAxis.oldStacks,
			isNegative,
			stack,
			other,
			key,
			pointKey,
			i,
			x,
			y;

		// loop over the non-null y values and read them into a local array
		for (i = 0; i < yDataLength; i++) {
			x = xData[i];
			y = yData[i];
			pointKey = series.index + ',' + i;

			// Read stacked values into a stack based on the x value,
			// the sign of y and the stack key. Stacking is also handled for null values (#739)
			isNegative = negStacks && y < (stackThreshold ? 0 : threshold);
			key = isNegative ? negKey : stackKey;

			// Create empty object for this stack if it doesn't exist yet
			if (!stacks[key]) {
				stacks[key] = {};
			}

			// Initialize StackItem for this x
			if (!stacks[key][x]) {
				if (oldStacks[key] && oldStacks[key][x]) {
					stacks[key][x] = oldStacks[key][x];
					stacks[key][x].total = null;
				} else {
					stacks[key][x] = new StackItem(yAxis, yAxis.options.stackLabels, isNegative, x, stackOption);
				}
			}

			// If the StackItem doesn't exist, create it first
			stack = stacks[key][x];
			//stack.points[pointKey] = [stack.cum || stackThreshold];
			stack.points[pointKey] = [pick(stack.cum, stackThreshold)];

			

			// Add value to the stack total
			if (stacking === 'percent') {

				// Percent stacked column, totals are the same for the positive and negative stacks
				other = isNegative ? stackKey : negKey;
				if (negStacks && stacks[other] && stacks[other][x]) {
					other = stacks[other][x];
					stack.total = other.total = mathMax(other.total, stack.total) + mathAbs(y) || 0;

				// Percent stacked areas
				} else {
					stack.total = correctFloat(stack.total + (mathAbs(y) || 0));
				}
			} else {
				stack.total = correctFloat(stack.total + (y || 0));
			}

			stack.cum = pick(stack.cum, stackThreshold) + (y || 0);

			stack.points[pointKey].push(stack.cum);
			stackedYData[i] = stack.cum;

		}

		if (stacking === 'percent') {
			yAxis.usePercentage = true;
		}

		this.stackedYData = stackedYData; // To be used in getExtremes

		// Reset old stacks
		yAxis.oldStacks = {};
	};

	/**
	 * Iterate over all stacks and compute the absolute values to percent
	 */
	Series.prototype.setPercentStacks = function () {
		var series = this,
			stackKey = series.stackKey,
			stacks = series.yAxis.stacks,
			processedXData = series.processedXData;

		each([stackKey, '-' + stackKey], function (key) {
			var i = processedXData.length,
				x,
				stack,
				pointExtremes,
				totalFactor;

			while (i--) {
				x = processedXData[i];
				stack = stacks[key] && stacks[key][x];
				pointExtremes = stack && stack.points[series.index + ',' + i];
				if (pointExtremes) {
					totalFactor = stack.total ? 100 / stack.total : 0;
					pointExtremes[0] = correctFloat(pointExtremes[0] * totalFactor); // Y bottom value
					pointExtremes[1] = correctFloat(pointExtremes[1] * totalFactor); // Y value
					series.stackedYData[i] = pointExtremes[1];
				}
			}
		});
	};

	// Extend the Chart prototype for dynamic methods
	extend(Chart.prototype, {

		/**
		 * Add a series dynamically after  time
		 *
		 * @param {Object} options The config options
		 * @param {Boolean} redraw Whether to redraw the chart after adding. Defaults to true.
		 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
		 *    configuration
		 *
		 * @return {Object} series The newly created series object
		 */
		addSeries: function (options, redraw, animation) {
			var series,
				chart = this;

			if (options) {
				redraw = pick(redraw, true); // defaults to true

				fireEvent(chart, 'addSeries', { options: options }, function () {
					series = chart.initSeries(options);

					chart.isDirtyLegend = true; // the series array is out of sync with the display
					chart.linkSeries();
					if (redraw) {
						chart.redraw(animation);
					}
				});
			}

			return series;
		},

		/**
	     * Add an axis to the chart
	     * @param {Object} options The axis option
	     * @param {Boolean} isX Whether it is an X axis or a value axis
	     */
		addAxis: function (options, isX, redraw, animation) {
			var key = isX ? 'xAxis' : 'yAxis',
				chartOptions = this.options,
				axis;

			/*jslint unused: false*/
			axis = new Axis(this, merge(options, {
				index: this[key].length,
				isX: isX
			}));
			/*jslint unused: true*/

			// Push the new axis options to the chart options
			chartOptions[key] = splat(chartOptions[key] || {});
			chartOptions[key].push(options);

			if (pick(redraw, true)) {
				this.redraw(animation);
			}
		},

		/**
		 * Dim the chart and show a loading text or symbol
		 * @param {String} str An optional text to show in the loading label instead of the default one
		 */
		showLoading: function (str) {
			var chart = this,
				options = chart.options,
				loadingDiv = chart.loadingDiv,
				loadingOptions = options.loading,
				setLoadingSize = function () {
					if (loadingDiv) {
						css(loadingDiv, {
							left: chart.plotLeft + PX,
							top: chart.plotTop + PX,
							width: chart.plotWidth + PX,
							height: chart.plotHeight + PX
						});
					}
				};

			// create the layer at the first call
			if (!loadingDiv) {
				chart.loadingDiv = loadingDiv = createElement(DIV, {
					className: PREFIX + 'loading'
				}, extend(loadingOptions.style, {
					zIndex: 10,
					display: NONE
				}), chart.container);

				chart.loadingSpan = createElement(
					'span',
					null,
					loadingOptions.labelStyle,
					loadingDiv
				);
				addEvent(chart, 'redraw', setLoadingSize); // #1080
			}

			// update text
			chart.loadingSpan.innerHTML = str || options.lang.loading;

			// show it
			if (!chart.loadingShown) {
				css(loadingDiv, {
					opacity: 0,
					display: ''				
				});
				animate(loadingDiv, {
					opacity: loadingOptions.style.opacity
				}, {
					duration: loadingOptions.showDuration || 0
				});
				chart.loadingShown = true;
			}
			setLoadingSize();
		},

		/**
		 * Hide the loading layer
		 */
		hideLoading: function () {
			var options = this.options,
				loadingDiv = this.loadingDiv;

			if (loadingDiv) {
				animate(loadingDiv, {
					opacity: 0
				}, {
					duration: options.loading.hideDuration || 100,
					complete: function () {
						css(loadingDiv, { display: NONE });
					}
				});
			}
			this.loadingShown = false;
		}
	});

	// extend the Point prototype for dynamic methods
	extend(Point.prototype, {
		/**
		 * Update the point with new options (typically x/y data) and optionally redraw the series.
		 *
		 * @param {Object} options Point options as defined in the series.data array
		 * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call
		 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
		 *    configuration
		 *
		 */
		update: function (options, redraw, animation, runEvent) {
			var point = this,
				series = point.series,
				graphic = point.graphic,
				i,
				chart = series.chart,
				seriesOptions = series.options,
				names = series.xAxis && series.xAxis.names;

			redraw = pick(redraw, true);

			function update() {

				point.applyOptions(options);

				// Update visuals
				if (point.y === null && graphic) { // #4146
					point.graphic = graphic.destroy();
				}
				if (isObject(options) && !isArray(options)) {
					// Defer the actual redraw until getAttribs has been called (#3260)
					point.redraw = function () {
						if (graphic) {
							if (options && options.marker && options.marker.symbol) {
								point.graphic = graphic.destroy();
							} else {
								graphic.attr(point.pointAttr[point.state || ''])[point.visible === false ? 'hide' : 'show'](); // #2430
							}
						}
						if (options && options.dataLabels && point.dataLabel) { // #2468
							point.dataLabel = point.dataLabel.destroy();
						}
						point.redraw = null;
					};
				}

				// record changes in the parallel arrays
				i = point.index;
				series.updateParallelArrays(point, i);
				if (names && point.name) {
					names[point.x] = point.name;
				}

				seriesOptions.data[i] = point.options;

				// redraw
				series.isDirty = series.isDirtyData = true;
				if (!series.fixedBox && series.hasCartesianSeries) { // #1906, #2320
					chart.isDirtyBox = true;
				}

				if (seriesOptions.legendType === 'point') { // #1831, #1885
					chart.isDirtyLegend = true;
				}
				if (redraw) {
					chart.redraw(animation);
				}
			}

			// Fire the event with a default handler of doing the update
			if (runEvent === false) { // When called from setData
				update();
			} else {
				point.firePointEvent('update', { options: options }, update);
			}
		},

		/**
		 * Remove a point and optionally redraw the series and if necessary the axes
		 * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call
		 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
		 *    configuration
		 */
		remove: function (redraw, animation) {
			this.series.removePoint(inArray(this, this.series.data), redraw, animation);
		}
	});

	// Extend the series prototype for dynamic methods
	extend(Series.prototype, {
		/**
		 * Add a point dynamically after chart load time
		 * @param {Object} options Point options as given in series.data
		 * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call
		 * @param {Boolean} shift If shift is true, a point is shifted off the start
		 *    of the series as one is appended to the end.
		 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
		 *    configuration
		 */
		addPoint: function (options, redraw, shift, animation) {
			var series = this,
				seriesOptions = series.options,
				data = series.data,
				graph = series.graph,
				area = series.area,
				chart = series.chart,
				names = series.xAxis && series.xAxis.names,
				currentShift = (graph && graph.shift) || 0,
				shiftShapes = ['graph', 'area'],
				dataOptions = seriesOptions.data,
				point,
				isInTheMiddle,
				xData = series.xData,
				i,
				x;

			setAnimation(animation, chart);

			// Make graph animate sideways
			if (shift) {
				i = series.zones.length;
				while (i--) {
					shiftShapes.push('zoneGraph' + i, 'zoneArea' + i);
				}
				each(shiftShapes, function (shape) {
					if (series[shape]) {
						series[shape].shift = currentShift + 1;
					}
				});
			}
			if (area) {
				area.isArea = true; // needed in animation, both with and without shift
			}

			// Optional redraw, defaults to true
			redraw = pick(redraw, true);

			// Get options and push the point to xData, yData and series.options. In series.generatePoints
			// the Point instance will be created on demand and pushed to the series.data array.
			point = { series: series };
			series.pointClass.prototype.applyOptions.apply(point, [options]);
			x = point.x;

			// Get the insertion point
			i = xData.length;
			if (series.requireSorting && x < xData[i - 1]) {
				isInTheMiddle = true;
				while (i && xData[i - 1] > x) {
					i--;
				}
			}

			series.updateParallelArrays(point, 'splice', i, 0, 0); // insert undefined item
			series.updateParallelArrays(point, i); // update it

			if (names && point.name) {
				names[x] = point.name;
			}
			dataOptions.splice(i, 0, options);

			if (isInTheMiddle) {
				series.data.splice(i, 0, null);
				series.processData();
			}

			// Generate points to be added to the legend (#1329)
			if (seriesOptions.legendType === 'point') {
				series.generatePoints();
			}

			// Shift the first point off the parallel arrays
			// todo: consider series.removePoint(i) method
			if (shift) {
				if (data[0] && data[0].remove) {
					data[0].remove(false);
				} else {
					data.shift();
					series.updateParallelArrays(point, 'shift');

					dataOptions.shift();
				}
			}

			// redraw
			series.isDirty = true;
			series.isDirtyData = true;
			if (redraw) {
				series.getAttribs(); // #1937
				chart.redraw();
			}
		},

		/**
		 * Remove a point (rendered or not), by index
		 */
		removePoint: function (i, redraw, animation) {

			var series = this,
				data = series.data,
				point = data[i],
				points = series.points,
				chart = series.chart,
				remove = function () {

					if (data.length === points.length) {
						points.splice(i, 1);
					}
					data.splice(i, 1);
					series.options.data.splice(i, 1);
					series.updateParallelArrays(point || { series: series }, 'splice', i, 1);

					if (point) {
						point.destroy();
					}

					// redraw
					series.isDirty = true;
					series.isDirtyData = true;
					if (redraw) {
						chart.redraw();
					}
				};

			setAnimation(animation, chart);
			redraw = pick(redraw, true);

			// Fire the event with a default handler of removing the point
			if (point) {
				point.firePointEvent('remove', null, remove);
			} else {
				remove();
			}
		},

		/**
		 * Remove a series and optionally redraw the chart
		 *
		 * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call
		 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
		 *    configuration
		 */

		remove: function (redraw, animation) {
			var series = this,
				chart = series.chart;
			redraw = pick(redraw, true);

			if (!series.isRemoving) {  /* prevent triggering native event in jQuery
					(calling the remove function from the remove event) */
				series.isRemoving = true;

				// fire the event with a default handler of removing the point
				fireEvent(series, 'remove', null, function () {


					// destroy elements
					series.destroy();


					// redraw
					chart.isDirtyLegend = chart.isDirtyBox = true;
					chart.linkSeries();

					if (redraw) {
						chart.redraw(animation);
					}
				});

			}
			series.isRemoving = false;
		},

		/**
		 * Update the series with a new set of options
		 */
		update: function (newOptions, redraw) {
			var series = this,
				chart = this.chart,
				// must use user options when changing type because this.options is merged
				// in with type specific plotOptions
				oldOptions = this.userOptions,
				oldType = this.type,
				proto = seriesTypes[oldType].prototype,
				preserve = ['group', 'markerGroup', 'dataLabelsGroup'],
				n;

			// If we're changing type or zIndex, create new groups (#3380, #3404)
			if ((newOptions.type && newOptions.type !== oldType) || newOptions.zIndex !== undefined) {
				preserve.length = 0;
			}

			// Make sure groups are not destroyed (#3094)
			each(preserve, function (prop) {
				preserve[prop] = series[prop];
				delete series[prop];
			});

			// Do the merge, with some forced options
			newOptions = merge(oldOptions, {
				animation: false,
				index: this.index,
				pointStart: this.xData[0] // when updating after addPoint
			}, { data: this.options.data }, newOptions);

			// Destroy the series and delete all properties. Reinsert all methods 
			// and properties from the new type prototype (#2270, #3719)
			this.remove(false);
			for (n in proto) {
				this[n] = UNDEFINED;
			}
			extend(this, seriesTypes[newOptions.type || oldType].prototype);

			// Re-register groups (#3094)
			each(preserve, function (prop) {
				series[prop] = preserve[prop];
			});

			this.init(chart, newOptions);
			chart.linkSeries(); // Links are lost in this.remove (#3028)
			if (pick(redraw, true)) {
				chart.redraw(false);
			}
		}
	});

	// Extend the Axis.prototype for dynamic methods
	extend(Axis.prototype, {

		/**
		 * Update the axis with a new options structure
		 */
		update: function (newOptions, redraw) {
			var chart = this.chart;

			newOptions = chart.options[this.coll][this.options.index] = merge(this.userOptions, newOptions);

			this.destroy(true);
			this._addedPlotLB = this.chart._labelPanes = UNDEFINED; // #1611, #2887, #4314

			this.init(chart, extend(newOptions, { events: UNDEFINED }));

			chart.isDirtyBox = true;
			if (pick(redraw, true)) {
				chart.redraw();
			}
		},

		/**
	     * Remove the axis from the chart
	     */
		remove: function (redraw) {
			var chart = this.chart,
				key = this.coll, // xAxis or yAxis
				axisSeries = this.series,
				i = axisSeries.length;

			// Remove associated series (#2687)
			while (i--) {
				if (axisSeries[i]) {
					axisSeries[i].remove(false);
				}
			}

			// Remove the axis
			erase(chart.axes, this);
			erase(chart[key], this);
			chart.options[key].splice(this.options.index, 1);
			each(chart[key], function (axis, i) { // Re-index, #1706
				axis.options.index = i;
			});
			this.destroy();
			chart.isDirtyBox = true;

			if (pick(redraw, true)) {
				chart.redraw();
			}
		},

		/**
		 * Update the axis title by options
		 */
		setTitle: function (newTitleOptions, redraw) {
			this.update({ title: newTitleOptions }, redraw);
		},

		/**
		 * Set new axis categories and optionally redraw
		 * @param {Array} categories
		 * @param {Boolean} redraw
		 */
		setCategories: function (categories, redraw) {
			this.update({ categories: categories }, redraw);
		}

	});


	/**
	 * LineSeries object
	 */
	var LineSeries = extendClass(Series);
	seriesTypes.line = LineSeries;

	/**
	 * Set the default options for area
	 */
	defaultPlotOptions.area = merge(defaultSeriesOptions, {
		threshold: 0
		// trackByArea: false,
		// lineColor: null, // overrides color, but lets fillColor be unaltered
		// fillOpacity: 0.75,
		// fillColor: null
	});

	/**
	 * AreaSeries object
	 */
	var AreaSeries = extendClass(Series, {
		type: 'area',
		/**
		 * For stacks, don't split segments on null values. Instead, draw null values with 
		 * no marker. Also insert dummy points for any X position that exists in other series
		 * in the stack.
		 */ 
		getSegments: function () {
			var series = this,
				segments = [],
				segment = [],
				keys = [],
				xAxis = this.xAxis,
				yAxis = this.yAxis,
				stack = yAxis.stacks[this.stackKey],
				pointMap = {},
				plotX,
				plotY,
				points = this.points,
				connectNulls = this.options.connectNulls,
				i,
				x;

			if (this.options.stacking && !this.cropped) { // cropped causes artefacts in Stock, and perf issue
				// Create a map where we can quickly look up the points by their X value.
				for (i = 0; i < points.length; i++) {
					pointMap[points[i].x] = points[i];
				}

				// Sort the keys (#1651)
				for (x in stack) {
					if (stack[x].total !== null) { // nulled after switching between grouping and not (#1651, #2336)
						keys.push(+x);
					}
				}
				keys.sort(function (a, b) {
					return a - b;
				});

				each(keys, function (x) {
					var y = 0,
						stackPoint;

					if (connectNulls && (!pointMap[x] || pointMap[x].y === null)) { // #1836
						return;

					// The point exists, push it to the segment
					} else if (pointMap[x]) {
						segment.push(pointMap[x]);

					// There is no point for this X value in this series, so we 
					// insert a dummy point in order for the areas to be drawn
					// correctly.
					} else {

						// Loop down the stack to find the series below this one that has
						// a value (#1991)
						for (i = series.index; i <= yAxis.series.length; i++) {
							stackPoint = stack[x].points[i + ',' + x];
							if (stackPoint) {
								y = stackPoint[1];
								break;
							}
						}

						plotX = xAxis.translate(x);
						plotY = yAxis.toPixels(y, true);
						segment.push({ 
							y: null, 
							plotX: plotX,
							clientX: plotX, 
							plotY: plotY, 
							yBottom: plotY,
							onMouseOver: noop
						});
					}
				});

				if (segment.length) {
					segments.push(segment);
				}

			} else {
				Series.prototype.getSegments.call(this);
				segments = this.segments;
			}

			this.segments = segments;
		},
		
		/**
		 * Extend the base Series getSegmentPath method by adding the path for the area.
		 * This path is pushed to the series.areaPath property.
		 */
		getSegmentPath: function (segment) {
			
			var segmentPath = Series.prototype.getSegmentPath.call(this, segment), // call base method
				areaSegmentPath = [].concat(segmentPath), // work on a copy for the area path
				i,
				options = this.options,
				segLength = segmentPath.length,
				translatedThreshold = this.yAxis.getThreshold(options.threshold), // #2181
				yBottom;
			
			if (segLength === 3) { // for animation from 1 to two points
				areaSegmentPath.push(L, segmentPath[1], segmentPath[2]);
			}
			if (options.stacking && !this.closedStacks) {
				
				// Follow stack back. Todo: implement areaspline. A general solution could be to 
				// reverse the entire graphPath of the previous series, though may be hard with
				// splines and with series with different extremes
				for (i = segment.length - 1; i >= 0; i--) {

					yBottom = pick(segment[i].yBottom, translatedThreshold);
				
					// step line?
					if (i < segment.length - 1 && options.step) {
						areaSegmentPath.push(segment[i + 1].plotX, yBottom);
					}
					
					areaSegmentPath.push(segment[i].plotX, yBottom);
				}

			} else { // follow zero line back
				this.closeSegment(areaSegmentPath, segment, translatedThreshold);
			}
			this.areaPath = this.areaPath.concat(areaSegmentPath);
			return segmentPath;
		},
		
		/**
		 * Extendable method to close the segment path of an area. This is overridden in polar 
		 * charts.
		 */
		closeSegment: function (path, segment, translatedThreshold) {
			path.push(
				L,
				segment[segment.length - 1].plotX,
				translatedThreshold,
				L,
				segment[0].plotX,
				translatedThreshold
			);
		},
		
		/**
		 * Draw the graph and the underlying area. This method calls the Series base
		 * function and adds the area. The areaPath is calculated in the getSegmentPath
		 * method called from Series.prototype.drawGraph.
		 */
		drawGraph: function () {
			
			// Define or reset areaPath
			this.areaPath = [];
			
			// Call the base method
			Series.prototype.drawGraph.apply(this);
			
			// Define local variables
			var series = this,
				areaPath = this.areaPath,
				options = this.options,
				zones = this.zones,
				props = [['area', this.color, options.fillColor]]; // area name, main color, fill color
			
			each(zones, function (threshold, i) {
				props.push(['zoneArea' + i, threshold.color || series.color, threshold.fillColor || options.fillColor]);
			});
			each(props, function (prop) {
				var areaKey = prop[0],
					area = series[areaKey];
					
				// Create or update the area
				if (area) { // update
					area.animate({ d: areaPath });
		
				} else { // create
					series[areaKey] = series.chart.renderer.path(areaPath)
						.attr({
							fill: pick(
								prop[2],
								Color(prop[1]).setOpacity(pick(options.fillOpacity, 0.75)).get()
							),
							zIndex: 0 // #1069
						}).add(series.group);
				}
			});
		},

		drawLegendSymbol: LegendSymbolMixin.drawRectangle
	});

	seriesTypes.area = AreaSeries;
	/**
	 * Set the default options for spline
	 */
	defaultPlotOptions.spline = merge(defaultSeriesOptions);

	/**
	 * SplineSeries object
	 */
	var SplineSeries = extendClass(Series, {
		type: 'spline',

		/**
		 * Get the spline segment from a given point's previous neighbour to the given point
		 */
		getPointSpline: function (segment, point, i) {
			var smoothing = 1.5, // 1 means control points midway between points, 2 means 1/3 from the point, 3 is 1/4 etc
				denom = smoothing + 1,
				plotX = point.plotX,
				plotY = point.plotY,
				lastPoint = segment[i - 1],
				nextPoint = segment[i + 1],
				leftContX,
				leftContY,
				rightContX,
				rightContY,
				ret;

			// find control points
			if (lastPoint && nextPoint) {
			
				var lastX = lastPoint.plotX,
					lastY = lastPoint.plotY,
					nextX = nextPoint.plotX,
					nextY = nextPoint.plotY,
					correction;

				leftContX = (smoothing * plotX + lastX) / denom;
				leftContY = (smoothing * plotY + lastY) / denom;
				rightContX = (smoothing * plotX + nextX) / denom;
				rightContY = (smoothing * plotY + nextY) / denom;

				// have the two control points make a straight line through main point
				correction = ((rightContY - leftContY) * (rightContX - plotX)) /
					(rightContX - leftContX) + plotY - rightContY;

				leftContY += correction;
				rightContY += correction;

				// to prevent false extremes, check that control points are between
				// neighbouring points' y values
				if (leftContY > lastY && leftContY > plotY) {
					leftContY = mathMax(lastY, plotY);
					rightContY = 2 * plotY - leftContY; // mirror of left control point
				} else if (leftContY < lastY && leftContY < plotY) {
					leftContY = mathMin(lastY, plotY);
					rightContY = 2 * plotY - leftContY;
				}
				if (rightContY > nextY && rightContY > plotY) {
					rightContY = mathMax(nextY, plotY);
					leftContY = 2 * plotY - rightContY;
				} else if (rightContY < nextY && rightContY < plotY) {
					rightContY = mathMin(nextY, plotY);
					leftContY = 2 * plotY - rightContY;
				}

				// record for drawing in next point
				point.rightContX = rightContX;
				point.rightContY = rightContY;

			}
			
			// Visualize control points for debugging
			/*
			if (leftContX) {
				this.chart.renderer.circle(leftContX + this.chart.plotLeft, leftContY + this.chart.plotTop, 2)
					.attr({
						stroke: 'red',
						'stroke-width': 1,
						fill: 'none'
					})
					.add();
				this.chart.renderer.path(['M', leftContX + this.chart.plotLeft, leftContY + this.chart.plotTop,
					'L', plotX + this.chart.plotLeft, plotY + this.chart.plotTop])
					.attr({
						stroke: 'red',
						'stroke-width': 1
					})
					.add();
				this.chart.renderer.circle(rightContX + this.chart.plotLeft, rightContY + this.chart.plotTop, 2)
					.attr({
						stroke: 'green',
						'stroke-width': 1,
						fill: 'none'
					})
					.add();
				this.chart.renderer.path(['M', rightContX + this.chart.plotLeft, rightContY + this.chart.plotTop,
					'L', plotX + this.chart.plotLeft, plotY + this.chart.plotTop])
					.attr({
						stroke: 'green',
						'stroke-width': 1
					})
					.add();
			}
			*/

			// moveTo or lineTo
			if (!i) {
				ret = [M, plotX, plotY];
			} else { // curve from last point to this
				ret = [
					'C',
					lastPoint.rightContX || lastPoint.plotX,
					lastPoint.rightContY || lastPoint.plotY,
					leftContX || plotX,
					leftContY || plotY,
					plotX,
					plotY
				];
				lastPoint.rightContX = lastPoint.rightContY = null; // reset for updating series later
			}
			return ret;
		}
	});
	seriesTypes.spline = SplineSeries;

	/**
	 * Set the default options for areaspline
	 */
	defaultPlotOptions.areaspline = merge(defaultPlotOptions.area);

	/**
	 * AreaSplineSeries object
	 */
	var areaProto = AreaSeries.prototype,
		AreaSplineSeries = extendClass(SplineSeries, {
			type: 'areaspline',
			closedStacks: true, // instead of following the previous graph back, follow the threshold back
			
			// Mix in methods from the area series
			getSegmentPath: areaProto.getSegmentPath,
			closeSegment: areaProto.closeSegment,
			drawGraph: areaProto.drawGraph,
			drawLegendSymbol: LegendSymbolMixin.drawRectangle
		});

	seriesTypes.areaspline = AreaSplineSeries;

	/**
	 * Set the default options for column
	 */
	defaultPlotOptions.column = merge(defaultSeriesOptions, {
		borderColor: '#FFFFFF',
		//borderWidth: 1,
		borderRadius: 0,
		//colorByPoint: undefined,
		groupPadding: 0.2,
		//grouping: true,
		marker: null, // point options are specified in the base options
		pointPadding: 0.1,
		//pointWidth: null,
		minPointLength: 0,
		cropThreshold: 50, // when there are more points, they will not animate out of the chart on xAxis.setExtremes
		pointRange: null, // null means auto, meaning 1 in a categorized axis and least distance between points if not categories
		states: {
			hover: {
				brightness: 0.1,
				shadow: false,
				halo: false
			},
			select: {
				color: '#C0C0C0',
				borderColor: '#000000',
				shadow: false
			}
		},
		dataLabels: {
			align: null, // auto
			verticalAlign: null, // auto
			y: null
		},
		startFromThreshold: true, // docs: http://jsfiddle.net/highcharts/hz8fopan/14/
		stickyTracking: false,
		tooltip: {
			distance: 6
		},
		threshold: 0
	});

	/**
	 * ColumnSeries object
	 */
	var ColumnSeries = extendClass(Series, {
		type: 'column',
		pointAttrToOptions: { // mapping between SVG attributes and the corresponding options
			stroke: 'borderColor',
			fill: 'color',
			r: 'borderRadius'
		},
		cropShoulder: 0,
		directTouch: true, // When tooltip is not shared, this series (and derivatives) requires direct touch/hover. KD-tree does not apply.
		trackerGroups: ['group', 'dataLabelsGroup'],
		negStacks: true, // use separate negative stacks, unlike area stacks where a negative 
			// point is substracted from previous (#1910)
		
		/**
		 * Initialize the series
		 */
		init: function () {
			Series.prototype.init.apply(this, arguments);

			var series = this,
				chart = series.chart;

			// if the series is added dynamically, force redraw of other
			// series affected by a new column
			if (chart.hasRendered) {
				each(chart.series, function (otherSeries) {
					if (otherSeries.type === series.type) {
						otherSeries.isDirty = true;
					}
				});
			}
		},

		/**
		 * Return the width and x offset of the columns adjusted for grouping, groupPadding, pointPadding,
		 * pointWidth etc. 
		 */
		getColumnMetrics: function () {

			var series = this,
				options = series.options,
				xAxis = series.xAxis,
				yAxis = series.yAxis,
				reversedXAxis = xAxis.reversed,
				stackKey,
				stackGroups = {},
				columnIndex,
				columnCount = 0;

			// Get the total number of column type series.
			// This is called on every series. Consider moving this logic to a
			// chart.orderStacks() function and call it on init, addSeries and removeSeries
			if (options.grouping === false) {
				columnCount = 1;
			} else {
				each(series.chart.series, function (otherSeries) {
					var otherOptions = otherSeries.options,
						otherYAxis = otherSeries.yAxis;
					if (otherSeries.type === series.type && otherSeries.visible &&
							yAxis.len === otherYAxis.len && yAxis.pos === otherYAxis.pos) {  // #642, #2086
						if (otherOptions.stacking) {
							stackKey = otherSeries.stackKey;
							if (stackGroups[stackKey] === UNDEFINED) {
								stackGroups[stackKey] = columnCount++;
							}
							columnIndex = stackGroups[stackKey];
						} else if (otherOptions.grouping !== false) { // #1162
							columnIndex = columnCount++;
						}
						otherSeries.columnIndex = columnIndex;
					}
				});
			}

			var categoryWidth = mathMin(
					mathAbs(xAxis.transA) * (xAxis.ordinalSlope || options.pointRange || xAxis.closestPointRange || xAxis.tickInterval || 1), // #2610
					xAxis.len // #1535
				),
				groupPadding = categoryWidth * options.groupPadding,
				groupWidth = categoryWidth - 2 * groupPadding,
				pointOffsetWidth = groupWidth / columnCount,
				optionPointWidth = options.pointWidth,
				pointPadding = defined(optionPointWidth) ? (pointOffsetWidth - optionPointWidth) / 2 :
					pointOffsetWidth * options.pointPadding,
				pointWidth = pick(optionPointWidth, pointOffsetWidth - 2 * pointPadding), // exact point width, used in polar charts
				colIndex = (reversedXAxis ? 
					columnCount - (series.columnIndex || 0) : // #1251
					series.columnIndex) || 0,
				pointXOffset = pointPadding + (groupPadding + colIndex *
					pointOffsetWidth - (categoryWidth / 2)) *
					(reversedXAxis ? -1 : 1);

			// Save it for reading in linked series (Error bars particularly)
			return (series.columnMetrics = { 
				width: pointWidth, 
				offset: pointXOffset 
			});
				
		},

		/**
		 * Translate each point to the plot area coordinate system and find shape positions
		 */
		translate: function () {
			var series = this,
				chart = series.chart,
				options = series.options,
				borderWidth = series.borderWidth = pick(
					options.borderWidth, 
					series.closestPointRange * series.xAxis.transA < 2 ? 0 : 1 // #3635
				),
				yAxis = series.yAxis,
				threshold = options.threshold,
				translatedThreshold = series.translatedThreshold = yAxis.getThreshold(threshold),
				minPointLength = pick(options.minPointLength, 5),
				metrics = series.getColumnMetrics(),
				pointWidth = metrics.width,
				seriesBarW = series.barW = mathMax(pointWidth, 1 + 2 * borderWidth), // postprocessed for border width
				pointXOffset = series.pointXOffset = metrics.offset,
				xCrisp = -(borderWidth % 2 ? 0.5 : 0),
				yCrisp = borderWidth % 2 ? 0.5 : 1;

			if (chart.inverted) {
				translatedThreshold -= 0.5; // #3355
				if (chart.renderer.isVML) {
					yCrisp += 1;
				}
			}

			// When the pointPadding is 0, we want the columns to be packed tightly, so we allow individual
			// columns to have individual sizes. When pointPadding is greater, we strive for equal-width
			// columns (#2694).
			if (options.pointPadding) {
				seriesBarW = mathCeil(seriesBarW);
			}

			Series.prototype.translate.apply(series);

			// Record the new values
			each(series.points, function (point) {
				var yBottom = pick(point.yBottom, translatedThreshold),
					safeDistance = 999 + mathAbs(yBottom),
					plotY = mathMin(mathMax(-safeDistance, point.plotY), yAxis.len + safeDistance), // Don't draw too far outside plot area (#1303, #2241, #4264)
					barX = point.plotX + pointXOffset,
					barW = seriesBarW,
					barY = mathMin(plotY, yBottom),
					right,
					bottom,
					fromTop,
					up,
					barH = mathMax(plotY, yBottom) - barY;

				// Handle options.minPointLength
				if (mathAbs(barH) < minPointLength) {
					if (minPointLength) {
						barH = minPointLength;
						up = (!yAxis.reversed && !point.negative) || (yAxis.reversed && point.negative);
						barY =
							mathRound(mathAbs(barY - translatedThreshold) > minPointLength ? // stacked
								yBottom - minPointLength : // keep position
								translatedThreshold - (up ? minPointLength : 0)); // #1485, #4051
					}
				}

				// Cache for access in polar
				point.barX = barX;
				point.pointWidth = pointWidth;

				// Round off to obtain crisp edges and avoid overlapping with neighbours (#2694)
				right = mathRound(barX + barW) + xCrisp;
				barX = mathRound(barX) + xCrisp;
				barW = right - barX;

				fromTop = mathAbs(barY) < 0.5;
				bottom = mathMin(mathRound(barY + barH) + yCrisp, 9e4); // #3575
				barY = mathRound(barY) + yCrisp;
				barH = bottom - barY;

				// Top edges are exceptions
				if (fromTop) {
					barY -= 1;
					barH += 1;
				}

				// Fix the tooltip on center of grouped columns (#1216, #424, #3648)
				point.tooltipPos = chart.inverted ? 
					[yAxis.len + yAxis.pos - chart.plotLeft - plotY, series.xAxis.len - barX - barW / 2, barH] : 
					[barX + barW / 2, plotY + yAxis.pos - chart.plotTop, barH];

				// Register shape type and arguments to be used in drawPoints
				point.shapeType = 'rect';
				point.shapeArgs = {
					x: barX,
					y: barY,
					width: barW,
					height: barH
				};
			});

		},

		getSymbol: noop,
		
		/**
		 * Use a solid rectangle like the area series types
		 */
		drawLegendSymbol: LegendSymbolMixin.drawRectangle,
		
		
		/**
		 * Columns have no graph
		 */
		drawGraph: noop,

		/**
		 * Draw the columns. For bars, the series.group is rotated, so the same coordinates
		 * apply for columns and bars. This method is inherited by scatter series.
		 *
		 */
		drawPoints: function () {
			var series = this,
				chart = this.chart,
				options = series.options,
				renderer = chart.renderer,
				animationLimit = options.animationLimit || 250,
				shapeArgs,
				pointAttr;

			// draw the columns
			each(series.points, function (point) {
				var plotY = point.plotY,
					graphic = point.graphic,
					borderAttr;

				if (plotY !== UNDEFINED && !isNaN(plotY) && point.y !== null) {
					shapeArgs = point.shapeArgs;

					borderAttr = defined(series.borderWidth) ? {
						'stroke-width': series.borderWidth
					} : {};

					pointAttr = point.pointAttr[point.selected ? SELECT_STATE : NORMAL_STATE] || series.pointAttr[NORMAL_STATE];
					
					if (graphic) { // update
						stop(graphic);
						graphic.attr(borderAttr)[chart.pointCount < animationLimit ? 'animate' : 'attr'](merge(shapeArgs));

					} else {
						point.graphic = graphic = renderer[point.shapeType](shapeArgs)
							.attr(borderAttr)
							.attr(pointAttr)
							.add(series.group)
							.shadow(options.shadow, null, options.stacking && !options.borderRadius);
					}

				} else if (graphic) {
					point.graphic = graphic.destroy(); // #1269
				}
			});
		},

		/**
		 * Animate the column heights one by one from zero
		 * @param {Boolean} init Whether to initialize the animation or run it
		 */
		animate: function (init) {
			var series = this,
				yAxis = this.yAxis,
				options = series.options,
				inverted = this.chart.inverted,
				attr = {},
				translatedThreshold;

			if (hasSVG) { // VML is too slow anyway
				if (init) {
					attr.scaleY = 0.001;
					translatedThreshold = mathMin(yAxis.pos + yAxis.len, mathMax(yAxis.pos, yAxis.toPixels(options.threshold)));
					if (inverted) {
						attr.translateX = translatedThreshold - yAxis.len;
					} else {
						attr.translateY = translatedThreshold;
					}
					series.group.attr(attr);

				} else { // run the animation
					
					attr.scaleY = 1;
					attr[inverted ? 'translateX' : 'translateY'] = yAxis.pos;
					series.group.animate(attr, series.options.animation);

					// delete this function to allow it only once
					series.animate = null;
				}
			}
		},
		
		/**
		 * Remove this series from the chart
		 */
		remove: function () {
			var series = this,
				chart = series.chart;

			// column and bar series affects other series of the same type
			// as they are either stacked or grouped
			if (chart.hasRendered) {
				each(chart.series, function (otherSeries) {
					if (otherSeries.type === series.type) {
						otherSeries.isDirty = true;
					}
				});
			}

			Series.prototype.remove.apply(series, arguments);
		}
	});
	seriesTypes.column = ColumnSeries;
	/**
	 * Set the default options for bar
	 */
	defaultPlotOptions.bar = merge(defaultPlotOptions.column);
	/**
	 * The Bar series class
	 */
	var BarSeries = extendClass(ColumnSeries, {
		type: 'bar',
		inverted: true
	});
	seriesTypes.bar = BarSeries;

	/**
	 * Set the default options for scatter
	 */
	defaultPlotOptions.scatter = merge(defaultSeriesOptions, {
		lineWidth: 0,
		marker: {
			enabled: true // Overrides auto-enabling in line series (#3647)
		},
		tooltip: {
			headerFormat: '<span style="color:{series.color}">\u25CF</span> <span style="font-size: 10px;"> {series.name}</span><br/>',
			pointFormat: 'x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>'
		}
	});

	/**
	 * The scatter series class
	 */
	var ScatterSeries = extendClass(Series, {
		type: 'scatter',
		sorted: false,
		requireSorting: false,
		noSharedTooltip: true,
		trackerGroups: ['group', 'markerGroup', 'dataLabelsGroup'],
		takeOrdinalPosition: false, // #2342
		kdDimensions: 2,
		drawGraph: function () {
			if (this.options.lineWidth) {
				Series.prototype.drawGraph.call(this);
			}
		}
	});

	seriesTypes.scatter = ScatterSeries;

	/**
	 * Set the default options for pie
	 */
	defaultPlotOptions.pie = merge(defaultSeriesOptions, {
		borderColor: '#FFFFFF',
		borderWidth: 1,
		center: [null, null],
		clip: false,
		colorByPoint: true, // always true for pies
		dataLabels: {
			// align: null,
			// connectorWidth: 1,
			// connectorColor: point.color,
			// connectorPadding: 5,
			distance: 30,
			enabled: true,
			formatter: function () { // #2945
				return this.point.name;
			},
			// softConnector: true,
			x: 0
			// y: 0
		},
		ignoreHiddenPoint: true,
		//innerSize: 0,
		legendType: 'point',
		marker: null, // point options are specified in the base options
		size: null,
		showInLegend: false,
		slicedOffset: 10,
		states: {
			hover: {
				brightness: 0.1,
				shadow: false
			}
		},
		stickyTracking: false,
		tooltip: {
			followPointer: true
		}
	});

	/**
	 * Extended point object for pies
	 */
	var PiePoint = extendClass(Point, {
		/**
		 * Initiate the pie slice
		 */
		init: function () {

			Point.prototype.init.apply(this, arguments);

			var point = this,
				toggleSlice;

			extend(point, {
				visible: point.visible !== false,
				name: pick(point.name, 'Slice')
			});

			// add event listener for select
			toggleSlice = function (e) {
				point.slice(e.type === 'select');
			};
			addEvent(point, 'select', toggleSlice);
			addEvent(point, 'unselect', toggleSlice);

			return point;
		},

		/**
		 * Toggle the visibility of the pie slice
		 * @param {Boolean} vis Whether to show the slice or not. If undefined, the
		 *    visibility is toggled
		 */
		setVisible: function (vis, redraw) {
			var point = this,
				series = point.series,
				chart = series.chart,
				ignoreHiddenPoint = series.options.ignoreHiddenPoint;
			
			redraw = pick(redraw, ignoreHiddenPoint);

			if (vis !== point.visible) {

				// If called without an argument, toggle visibility
				point.visible = point.options.visible = vis = vis === UNDEFINED ? !point.visible : vis;
				series.options.data[inArray(point, series.data)] = point.options; // update userOptions.data

				// Show and hide associated elements. This is performed regardless of redraw or not,
				// because chart.redraw only handles full series.
				each(['graphic', 'dataLabel', 'connector', 'shadowGroup'], function (key) {
					if (point[key]) {
						point[key][vis ? 'show' : 'hide'](true);
					}
				});

				if (point.legendItem) {
					chart.legend.colorizeItem(point, vis);
				}

				// #4170, hide halo after hiding point
				if (!vis && point.state === 'hover') {
					point.setState('');
				}
				
				// Handle ignore hidden slices
				if (ignoreHiddenPoint) {
					series.isDirty = true;
				}

				if (redraw) {
					chart.redraw();
				}
			}
		},

		/**
		 * Set or toggle whether the slice is cut out from the pie
		 * @param {Boolean} sliced When undefined, the slice state is toggled
		 * @param {Boolean} redraw Whether to redraw the chart. True by default.
		 */
		slice: function (sliced, redraw, animation) {
			var point = this,
				series = point.series,
				chart = series.chart,
				translation;

			setAnimation(animation, chart);

			// redraw is true by default
			redraw = pick(redraw, true);

			// if called without an argument, toggle
			point.sliced = point.options.sliced = sliced = defined(sliced) ? sliced : !point.sliced;
			series.options.data[inArray(point, series.data)] = point.options; // update userOptions.data

			translation = sliced ? point.slicedTranslation : {
				translateX: 0,
				translateY: 0
			};

			point.graphic.animate(translation);
			
			if (point.shadowGroup) {
				point.shadowGroup.animate(translation);
			}

		},

		haloPath: function (size) {
			var shapeArgs = this.shapeArgs,
				chart = this.series.chart;

			return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(chart.plotLeft + shapeArgs.x, chart.plotTop + shapeArgs.y, shapeArgs.r + size, shapeArgs.r + size, {
				innerR: this.shapeArgs.r,
				start: shapeArgs.start,
				end: shapeArgs.end
			});
		}
	});

	/**
	 * The Pie series class
	 */
	var PieSeries = {
		type: 'pie',
		isCartesian: false,
		pointClass: PiePoint,
		requireSorting: false,
		directTouch: true,
		noSharedTooltip: true,
		trackerGroups: ['group', 'dataLabelsGroup'],
		axisTypes: [],
		pointAttrToOptions: { // mapping between SVG attributes and the corresponding options
			stroke: 'borderColor',
			'stroke-width': 'borderWidth',
			fill: 'color'
		},

		/**
		 * Pies have one color each point
		 */
		getColor: noop,

		/**
		 * Animate the pies in
		 */
		animate: function (init) {
			var series = this,
				points = series.points,
				startAngleRad = series.startAngleRad;

			if (!init) {
				each(points, function (point) {
					var graphic = point.graphic,
						args = point.shapeArgs;

					if (graphic) {
						// start values
						graphic.attr({
							r: point.startR || (series.center[3] / 2), // animate from inner radius (#779)
							start: startAngleRad,
							end: startAngleRad
						});

						// animate
						graphic.animate({
							r: args.r,
							start: args.start,
							end: args.end
						}, series.options.animation);
					}
				});

				// delete this function to allow it only once
				series.animate = null;
			}
		},

		/**
		 * Extend the basic setData method by running processData and generatePoints immediately,
		 * in order to access the points from the legend.
		 */
		setData: function (data, redraw, animation, updatePoints) {
			Series.prototype.setData.call(this, data, false, animation, updatePoints);
			this.processData();
			this.generatePoints();
			if (pick(redraw, true)) {
				this.chart.redraw(animation);
			} 
		},

		/**
		 * Recompute total chart sum and update percentages of points.
		 */
		updateTotals: function () {
			var i,
				total = 0,
				points = this.points,
				len = points.length,
				point,
				ignoreHiddenPoint = this.options.ignoreHiddenPoint;

			// Get the total sum
			for (i = 0; i < len; i++) {
				point = points[i];
				total += (ignoreHiddenPoint && !point.visible) ? 0 : point.y;
			}
			this.total = total;

			// Set each point's properties
			for (i = 0; i < len; i++) {
				point = points[i];
				point.percentage = (total > 0 && (point.visible || !ignoreHiddenPoint)) ? point.y / total * 100 : 0;
				point.total = total;
			}
		},

		/**
		 * Extend the generatePoints method by adding total and percentage properties to each point
		 */
		generatePoints: function () {
			Series.prototype.generatePoints.call(this);
			this.updateTotals();
		},
		
		/**
		 * Do translation for pie slices
		 */
		translate: function (positions) {
			this.generatePoints();
			
			var series = this,
				cumulative = 0,
				precision = 1000, // issue #172
				options = series.options,
				slicedOffset = options.slicedOffset,
				connectorOffset = slicedOffset + options.borderWidth,
				start,
				end,
				angle,
				startAngle = options.startAngle || 0,
				startAngleRad = series.startAngleRad = mathPI / 180 * (startAngle - 90),
				endAngleRad = series.endAngleRad = mathPI / 180 * ((pick(options.endAngle, startAngle + 360)) - 90),
				circ = endAngleRad - startAngleRad, //2 * mathPI,
				points = series.points,
				radiusX, // the x component of the radius vector for a given point
				radiusY,
				labelDistance = options.dataLabels.distance,
				ignoreHiddenPoint = options.ignoreHiddenPoint,
				i,
				len = points.length,
				point;

			// Get positions - either an integer or a percentage string must be given.
			// If positions are passed as a parameter, we're in a recursive loop for adjusting
			// space for data labels.
			if (!positions) {
				series.center = positions = series.getCenter();
			}

			// utility for getting the x value from a given y, used for anticollision logic in data labels
			series.getX = function (y, left) {

				angle = math.asin(mathMin((y - positions[1]) / (positions[2] / 2 + labelDistance), 1));

				return positions[0] +
					(left ? -1 : 1) *
					(mathCos(angle) * (positions[2] / 2 + labelDistance));
			};

			// Calculate the geometry for each point
			for (i = 0; i < len; i++) {
				
				point = points[i];
				
				// set start and end angle
				start = startAngleRad + (cumulative * circ);
				if (!ignoreHiddenPoint || point.visible) {
					cumulative += point.percentage / 100;
				}
				end = startAngleRad + (cumulative * circ);

				// set the shape
				point.shapeType = 'arc';
				point.shapeArgs = {
					x: positions[0],
					y: positions[1],
					r: positions[2] / 2,
					innerR: positions[3] / 2,
					start: mathRound(start * precision) / precision,
					end: mathRound(end * precision) / precision
				};

				// The angle must stay within -90 and 270 (#2645)
				angle = (end + start) / 2;
				if (angle > 1.5 * mathPI) {
					angle -= 2 * mathPI;
				} else if (angle < -mathPI / 2) {
					angle += 2 * mathPI;
				}

				// Center for the sliced out slice
				point.slicedTranslation = {
					translateX: mathRound(mathCos(angle) * slicedOffset),
					translateY: mathRound(mathSin(angle) * slicedOffset)
				};

				// set the anchor point for tooltips
				radiusX = mathCos(angle) * positions[2] / 2;
				radiusY = mathSin(angle) * positions[2] / 2;
				point.tooltipPos = [
					positions[0] + radiusX * 0.7,
					positions[1] + radiusY * 0.7
				];
				
				point.half = angle < -mathPI / 2 || angle > mathPI / 2 ? 1 : 0;
				point.angle = angle;

				// set the anchor point for data labels
				connectorOffset = mathMin(connectorOffset, labelDistance / 2); // #1678
				point.labelPos = [
					positions[0] + radiusX + mathCos(angle) * labelDistance, // first break of connector
					positions[1] + radiusY + mathSin(angle) * labelDistance, // a/a
					positions[0] + radiusX + mathCos(angle) * connectorOffset, // second break, right outside pie
					positions[1] + radiusY + mathSin(angle) * connectorOffset, // a/a
					positions[0] + radiusX, // landing point for connector
					positions[1] + radiusY, // a/a
					labelDistance < 0 ? // alignment
						'center' :
						point.half ? 'right' : 'left', // alignment
					angle // center angle
				];

			}
		},
		
		drawGraph: null,

		/**
		 * Draw the data points
		 */
		drawPoints: function () {
			var series = this,
				chart = series.chart,
				renderer = chart.renderer,
				groupTranslation,
				//center,
				graphic,
				//group,
				shadow = series.options.shadow,
				shadowGroup,
				shapeArgs,
				attr;

			if (shadow && !series.shadowGroup) {
				series.shadowGroup = renderer.g('shadow')
					.add(series.group);
			}

			// draw the slices
			each(series.points, function (point) {
				graphic = point.graphic;
				shapeArgs = point.shapeArgs;
				shadowGroup = point.shadowGroup;

				// put the shadow behind all points
				if (shadow && !shadowGroup) {
					shadowGroup = point.shadowGroup = renderer.g('shadow')
						.add(series.shadowGroup);
				}

				// if the point is sliced, use special translation, else use plot area traslation
				groupTranslation = point.sliced ? point.slicedTranslation : {
					translateX: 0,
					translateY: 0
				};

				//group.translate(groupTranslation[0], groupTranslation[1]);
				if (shadowGroup) {
					shadowGroup.attr(groupTranslation);
				}

				// draw the slice
				if (graphic) {
					graphic.animate(extend(shapeArgs, groupTranslation));				
				} else {
					attr = { 'stroke-linejoin': 'round' };
					if (!point.visible) {
						attr.visibility = 'hidden';
					}

					point.graphic = graphic = renderer[point.shapeType](shapeArgs)
						.setRadialReference(series.center)
						.attr(
							point.pointAttr[point.selected ? SELECT_STATE : NORMAL_STATE]
						)
						.attr(attr)
						.attr(groupTranslation)
						.add(series.group)
						.shadow(shadow, shadowGroup);	
				}

			});

		},


		searchPoint: noop,

		/**
		 * Utility for sorting data labels
		 */
		sortByAngle: function (points, sign) {
			points.sort(function (a, b) {
				return a.angle !== undefined && (b.angle - a.angle) * sign;
			});
		},		

		/**
		 * Use a simple symbol from LegendSymbolMixin
		 */
		drawLegendSymbol: LegendSymbolMixin.drawRectangle,

		/**
		 * Use the getCenter method from drawLegendSymbol
		 */
		getCenter: CenteredSeriesMixin.getCenter,

		/**
		 * Pies don't have point marker symbols
		 */
		getSymbol: noop

	};
	PieSeries = extendClass(Series, PieSeries);
	seriesTypes.pie = PieSeries;

	/**
	 * Draw the data labels
	 */
	Series.prototype.drawDataLabels = function () {

		var series = this,
			seriesOptions = series.options,
			cursor = seriesOptions.cursor,
			options = seriesOptions.dataLabels,
			points = series.points,
			pointOptions,
			generalOptions,
			hasRendered = series.hasRendered || 0,
			str,
			dataLabelsGroup,
			renderer = series.chart.renderer;

		if (options.enabled || series._hasPointLabels) {

			// Process default alignment of data labels for columns
			if (series.dlProcessOptions) {
				series.dlProcessOptions(options);
			}

			// Create a separate group for the data labels to avoid rotation
			dataLabelsGroup = series.plotGroup(
				'dataLabelsGroup',
				'data-labels',
				options.defer ? HIDDEN : VISIBLE,
				options.zIndex || 6
			);

			if (pick(options.defer, true)) {
				dataLabelsGroup.attr({ opacity: +hasRendered }); // #3300
				if (!hasRendered) {
					addEvent(series, 'afterAnimate', function () {
						if (series.visible) { // #3023, #3024
							dataLabelsGroup.show();
						}
						dataLabelsGroup[seriesOptions.animation ? 'animate' : 'attr']({ opacity: 1 }, { duration: 200 });
					});
				}
			}

			// Make the labels for each point
			generalOptions = options;
			each(points, function (point) {

				var enabled,
					dataLabel = point.dataLabel,
					labelConfig,
					attr,
					name,
					rotation,
					connector = point.connector,
					isNew = true,
					style,
					moreStyle = {};

				// Determine if each data label is enabled
				pointOptions = point.dlOptions || (point.options && point.options.dataLabels); // dlOptions is used in treemaps
				enabled = pick(pointOptions && pointOptions.enabled, generalOptions.enabled); // #2282


				// If the point is outside the plot area, destroy it. #678, #820
				if (dataLabel && !enabled) {
					point.dataLabel = dataLabel.destroy();

				// Individual labels are disabled if the are explicitly disabled
				// in the point options, or if they fall outside the plot area.
				} else if (enabled) {

					// Create individual options structure that can be extended without
					// affecting others
					options = merge(generalOptions, pointOptions);
					style = options.style;

					rotation = options.rotation;

					// Get the string
					labelConfig = point.getLabelConfig();
					str = options.format ?
						format(options.format, labelConfig) :
						options.formatter.call(labelConfig, options);

					// Determine the color
					style.color = pick(options.color, style.color, series.color, 'black');


					// update existing label
					if (dataLabel) {

						if (defined(str)) {
							dataLabel
								.attr({
									text: str
								});
							isNew = false;

						} else { // #1437 - the label is shown conditionally
							point.dataLabel = dataLabel = dataLabel.destroy();
							if (connector) {
								point.connector = connector.destroy();
							}
						}

					// create new label
					} else if (defined(str)) {
						attr = {
							//align: align,
							fill: options.backgroundColor,
							stroke: options.borderColor,
							'stroke-width': options.borderWidth,
							r: options.borderRadius || 0,
							rotation: rotation,
							padding: options.padding,
							zIndex: 1
						};
						
						// Get automated contrast color
						if (style.color === 'contrast') {
							moreStyle.color = options.inside || options.distance < 0 || !!seriesOptions.stacking ? 
								renderer.getContrast(point.color || series.color) : 
								'#000000';
						}
						if (cursor) {
							moreStyle.cursor = cursor;
						}
						

						// Remove unused attributes (#947)
						for (name in attr) {
							if (attr[name] === UNDEFINED) {
								delete attr[name];
							}
						}

						dataLabel = point.dataLabel = renderer[rotation ? 'text' : 'label']( // labels don't support rotation
							str,
							0,
							-999,
							options.shape,
							null,
							null,
							options.useHTML
						)
						.attr(attr)
						.css(extend(style, moreStyle))
						.add(dataLabelsGroup)
						.shadow(options.shadow);

					}

					if (dataLabel) {
						// Now the data label is created and placed at 0,0, so we need to align it
						series.alignDataLabel(point, dataLabel, options, null, isNew);
					}
				}
			});
		}
	};

	/**
	 * Align each individual data label
	 */
	Series.prototype.alignDataLabel = function (point, dataLabel, options, alignTo, isNew) {
		var chart = this.chart,
			inverted = chart.inverted,
			plotX = pick(point.plotX, -999),
			plotY = pick(point.plotY, -999),
			bBox = dataLabel.getBBox(),
			baseline = chart.renderer.fontMetrics(options.style.fontSize).b,
			rotCorr, // rotation correction
			// Math.round for rounding errors (#2683), alignTo to allow column labels (#2700)
			visible = this.visible && (point.series.forceDL || chart.isInsidePlot(plotX, mathRound(plotY), inverted) ||
				(alignTo && chart.isInsidePlot(plotX, inverted ? alignTo.x + 1 : alignTo.y + alignTo.height - 1, inverted))),
			alignAttr; // the final position;

		if (visible) {

			// The alignment box is a singular point
			alignTo = extend({
				x: inverted ? chart.plotWidth - plotY : plotX,
				y: mathRound(inverted ? chart.plotHeight - plotX : plotY),
				width: 0,
				height: 0
			}, alignTo);

			// Add the text size for alignment calculation
			extend(options, {
				width: bBox.width,
				height: bBox.height
			});

			// Allow a hook for changing alignment in the last moment, then do the alignment
			if (options.rotation) { // Fancy box alignment isn't supported for rotated text
				rotCorr = chart.renderer.rotCorr(baseline, options.rotation); // #3723
				dataLabel[isNew ? 'attr' : 'animate']({
						x: alignTo.x + options.x + alignTo.width / 2 + rotCorr.x,
						y: alignTo.y + options.y + alignTo.height / 2
					})
					.attr({ // #3003
						align: options.align
					});
			} else {
				dataLabel.align(options, null, alignTo);
				alignAttr = dataLabel.alignAttr;

				// Handle justify or crop
				if (pick(options.overflow, 'justify') === 'justify') {
					this.justifyDataLabel(dataLabel, options, alignAttr, bBox, alignTo, isNew);

				} else if (pick(options.crop, true)) {
					// Now check that the data label is within the plot area
					visible = chart.isInsidePlot(alignAttr.x, alignAttr.y) && chart.isInsidePlot(alignAttr.x + bBox.width, alignAttr.y + bBox.height);

				}

				// When we're using a shape, make it possible with a connector or an arrow pointing to thie point
				if (options.shape) {
					dataLabel.attr({
						anchorX: point.plotX,
						anchorY: point.plotY
					});
				}

			}
		}

		// Show or hide based on the final aligned position
		if (!visible) {
			dataLabel.attr({ y: -999 });
			dataLabel.placed = false; // don't animate back in
		}

	};

	/**
	 * If data labels fall partly outside the plot area, align them back in, in a way that
	 * doesn't hide the point.
	 */
	Series.prototype.justifyDataLabel = function (dataLabel, options, alignAttr, bBox, alignTo, isNew) {
		var chart = this.chart,
			align = options.align,
			verticalAlign = options.verticalAlign,
			off,
			justified,
			padding = dataLabel.box ? 0 : (dataLabel.padding || 0);

		// Off left
		off = alignAttr.x + padding;
		if (off < 0) {
			if (align === 'right') {
				options.align = 'left';
			} else {
				options.x = -off;
			}
			justified = true;
		}

		// Off right
		off = alignAttr.x + bBox.width - padding;
		if (off > chart.plotWidth) {
			if (align === 'left') {
				options.align = 'right';
			} else {
				options.x = chart.plotWidth - off;
			}
			justified = true;
		}

		// Off top
		off = alignAttr.y + padding;
		if (off < 0) {
			if (verticalAlign === 'bottom') {
				options.verticalAlign = 'top';
			} else {
				options.y = -off;
			}
			justified = true;
		}

		// Off bottom
		off = alignAttr.y + bBox.height - padding;
		if (off > chart.plotHeight) {
			if (verticalAlign === 'top') {
				options.verticalAlign = 'bottom';
			} else {
				options.y = chart.plotHeight - off;
			}
			justified = true;
		}

		if (justified) {
			dataLabel.placed = !isNew;
			dataLabel.align(options, null, alignTo);
		}
	};

	/**
	 * Override the base drawDataLabels method by pie specific functionality
	 */
	if (seriesTypes.pie) {
		seriesTypes.pie.prototype.drawDataLabels = function () {
			var series = this,
				data = series.data,
				point,
				chart = series.chart,
				options = series.options.dataLabels,
				connectorPadding = pick(options.connectorPadding, 10),
				connectorWidth = pick(options.connectorWidth, 1),
				plotWidth = chart.plotWidth,
				plotHeight = chart.plotHeight,
				connector,
				connectorPath,
				softConnector = pick(options.softConnector, true),
				distanceOption = options.distance,
				seriesCenter = series.center,
				radius = seriesCenter[2] / 2,
				centerY = seriesCenter[1],
				outside = distanceOption > 0,
				dataLabel,
				dataLabelWidth,
				labelPos,
				labelHeight,
				halves = [// divide the points into right and left halves for anti collision
					[], // right
					[]  // left
				],
				x,
				y,
				visibility,
				rankArr,
				i,
				j,
				overflow = [0, 0, 0, 0], // top, right, bottom, left
				sort = function (a, b) {
					return b.y - a.y;
				};

			// get out if not enabled
			if (!series.visible || (!options.enabled && !series._hasPointLabels)) {
				return;
			}

			// run parent method
			Series.prototype.drawDataLabels.apply(series);

			// arrange points for detection collision
			each(data, function (point) {
				if (point.dataLabel && point.visible) { // #407, #2510
					halves[point.half].push(point);
				}
			});

			/* Loop over the points in each half, starting from the top and bottom
			 * of the pie to detect overlapping labels.
			 */
			i = 2;
			while (i--) {

				var slots = [],
					slotsLength,
					usedSlots = [],
					points = halves[i],
					pos,
					bottom,
					length = points.length,
					slotIndex;

				if (!length) {
					continue;
				}

				// Sort by angle
				series.sortByAngle(points, i - 0.5);

				// Assume equal label heights on either hemisphere (#2630)
				j = labelHeight = 0;
				while (!labelHeight && points[j]) { // #1569
					labelHeight = points[j] && points[j].dataLabel && (points[j].dataLabel.getBBox().height || 21); // 21 is for #968
					j++;
				}

				// Only do anti-collision when we are outside the pie and have connectors (#856)
				if (distanceOption > 0) {

					// Build the slots
					bottom = mathMin(centerY + radius + distanceOption, chart.plotHeight);
					for (pos = mathMax(0, centerY - radius - distanceOption); pos <= bottom; pos += labelHeight) {
						slots.push(pos);
					}
					slotsLength = slots.length;


					/* Visualize the slots
					if (!series.slotElements) {
						series.slotElements = [];
					}
					if (i === 1) {
						series.slotElements.forEach(function (elem) {
							elem.destroy();
						});
						series.slotElements.length = 0;
					}
						
					slots.forEach(function (pos, no) {
						var slotX = series.getX(pos, i) + chart.plotLeft - (i ? 100 : 0),
							slotY = pos + chart.plotTop;
						
						if (!isNaN(slotX)) {
							series.slotElements.push(chart.renderer.rect(slotX, slotY - 7, 100, labelHeight, 1)
								.attr({
									'stroke-width': 1,
									stroke: 'silver',
									fill: 'rgba(0,0,255,0.1)'
								})
								.add());
							series.slotElements.push(chart.renderer.text('Slot '+ no, slotX, slotY + 4)
								.attr({
									fill: 'silver'
								}).add());
						}
					});
					// */

					// if there are more values than available slots, remove lowest values
					if (length > slotsLength) {
						// create an array for sorting and ranking the points within each quarter
						rankArr = [].concat(points);
						rankArr.sort(sort);
						j = length;
						while (j--) {
							rankArr[j].rank = j;
						}
						j = length;
						while (j--) {
							if (points[j].rank >= slotsLength) {
								points.splice(j, 1);
							}
						}
						length = points.length;
					}

					// The label goes to the nearest open slot, but not closer to the edge than
					// the label's index.
					for (j = 0; j < length; j++) {

						point = points[j];
						labelPos = point.labelPos;

						var closest = 9999,
							distance,
							slotI;

						// find the closest slot index
						for (slotI = 0; slotI < slotsLength; slotI++) {
							distance = mathAbs(slots[slotI] - labelPos[1]);
							if (distance < closest) {
								closest = distance;
								slotIndex = slotI;
							}
						}

						// if that slot index is closer to the edges of the slots, move it
						// to the closest appropriate slot
						if (slotIndex < j && slots[j] !== null) { // cluster at the top
							slotIndex = j;
						} else if (slotsLength  < length - j + slotIndex && slots[j] !== null) { // cluster at the bottom
							slotIndex = slotsLength - length + j;
							while (slots[slotIndex] === null) { // make sure it is not taken
								slotIndex++;
							}
						} else {
							// Slot is taken, find next free slot below. In the next run, the next slice will find the
							// slot above these, because it is the closest one
							while (slots[slotIndex] === null) { // make sure it is not taken
								slotIndex++;
							}
						}

						usedSlots.push({ i: slotIndex, y: slots[slotIndex] });
						slots[slotIndex] = null; // mark as taken
					}
					// sort them in order to fill in from the top
					usedSlots.sort(sort);
				}

				// now the used slots are sorted, fill them up sequentially
				for (j = 0; j < length; j++) {

					var slot, naturalY;

					point = points[j];
					labelPos = point.labelPos;
					dataLabel = point.dataLabel;
					visibility = point.visible === false ? HIDDEN : 'inherit';
					naturalY = labelPos[1];

					if (distanceOption > 0) {
						slot = usedSlots.pop();
						slotIndex = slot.i;

						// if the slot next to currrent slot is free, the y value is allowed
						// to fall back to the natural position
						y = slot.y;
						if ((naturalY > y && slots[slotIndex + 1] !== null) ||
								(naturalY < y &&  slots[slotIndex - 1] !== null)) {
							y = mathMin(mathMax(0, naturalY), chart.plotHeight);
						}

					} else {
						y = naturalY;
					}

					// get the x - use the natural x position for first and last slot, to prevent the top
					// and botton slice connectors from touching each other on either side
					x = options.justify ?
						seriesCenter[0] + (i ? -1 : 1) * (radius + distanceOption) :
						series.getX(y === centerY - radius - distanceOption || y === centerY + radius + distanceOption ? naturalY : y, i);


					// Record the placement and visibility
					dataLabel._attr = {
						visibility: visibility,
						align: labelPos[6]
					};
					dataLabel._pos = {
						x: x + options.x +
							({ left: connectorPadding, right: -connectorPadding }[labelPos[6]] || 0),
						y: y + options.y - 10 // 10 is for the baseline (label vs text)
					};
					dataLabel.connX = x;
					dataLabel.connY = y;


					// Detect overflowing data labels
					if (this.options.size === null) {
						dataLabelWidth = dataLabel.width;
						// Overflow left
						if (x - dataLabelWidth < connectorPadding) {
							overflow[3] = mathMax(mathRound(dataLabelWidth - x + connectorPadding), overflow[3]);

						// Overflow right
						} else if (x + dataLabelWidth > plotWidth - connectorPadding) {
							overflow[1] = mathMax(mathRound(x + dataLabelWidth - plotWidth + connectorPadding), overflow[1]);
						}

						// Overflow top
						if (y - labelHeight / 2 < 0) {
							overflow[0] = mathMax(mathRound(-y + labelHeight / 2), overflow[0]);

						// Overflow left
						} else if (y + labelHeight / 2 > plotHeight) {
							overflow[2] = mathMax(mathRound(y + labelHeight / 2 - plotHeight), overflow[2]);
						}
					}
				} // for each point
			} // for each half

			// Do not apply the final placement and draw the connectors until we have verified
			// that labels are not spilling over.
			if (arrayMax(overflow) === 0 || this.verifyDataLabelOverflow(overflow)) {

				// Place the labels in the final position
				this.placeDataLabels();

				// Draw the connectors
				if (outside && connectorWidth) {
					each(this.points, function (point) {
						connector = point.connector;
						labelPos = point.labelPos;
						dataLabel = point.dataLabel;

						if (dataLabel && dataLabel._pos && point.visible) {
							visibility = dataLabel._attr.visibility;
							x = dataLabel.connX;
							y = dataLabel.connY;
							connectorPath = softConnector ? [
								M,
								x + (labelPos[6] === 'left' ? 5 : -5), y, // end of the string at the label
								'C',
								x, y, // first break, next to the label
								2 * labelPos[2] - labelPos[4], 2 * labelPos[3] - labelPos[5],
								labelPos[2], labelPos[3], // second break
								L,
								labelPos[4], labelPos[5] // base
							] : [
								M,
								x + (labelPos[6] === 'left' ? 5 : -5), y, // end of the string at the label
								L,
								labelPos[2], labelPos[3], // second break
								L,
								labelPos[4], labelPos[5] // base
							];

							if (connector) {
								connector.animate({ d: connectorPath });
								connector.attr('visibility', visibility);

							} else {
								point.connector = connector = series.chart.renderer.path(connectorPath).attr({
									'stroke-width': connectorWidth,
									stroke: options.connectorColor || point.color || '#606060',
									visibility: visibility
									//zIndex: 0 // #2722 (reversed)
								})
								.add(series.dataLabelsGroup);
							}
						} else if (connector) {
							point.connector = connector.destroy();
						}
					});
				}
			}
		};
		/**
		 * Perform the final placement of the data labels after we have verified that they
		 * fall within the plot area.
		 */
		seriesTypes.pie.prototype.placeDataLabels = function () {
			each(this.points, function (point) {
				var dataLabel = point.dataLabel,
					_pos;

				if (dataLabel && point.visible) {
					_pos = dataLabel._pos;
					if (_pos) {
						dataLabel.attr(dataLabel._attr);
						dataLabel[dataLabel.moved ? 'animate' : 'attr'](_pos);
						dataLabel.moved = true;
					} else if (dataLabel) {
						dataLabel.attr({ y: -999 });
					}
				}
			});
		};

		seriesTypes.pie.prototype.alignDataLabel =  noop;

		/**
		 * Verify whether the data labels are allowed to draw, or we should run more translation and data
		 * label positioning to keep them inside the plot area. Returns true when data labels are ready
		 * to draw.
		 */
		seriesTypes.pie.prototype.verifyDataLabelOverflow = function (overflow) {

			var center = this.center,
				options = this.options,
				centerOption = options.center,
				minSize = options.minSize || 80,
				newSize = minSize,
				ret;

			// Handle horizontal size and center
			if (centerOption[0] !== null) { // Fixed center
				newSize = mathMax(center[2] - mathMax(overflow[1], overflow[3]), minSize);

			} else { // Auto center
				newSize = mathMax(
					center[2] - overflow[1] - overflow[3], // horizontal overflow
					minSize
				);
				center[0] += (overflow[3] - overflow[1]) / 2; // horizontal center
			}

			// Handle vertical size and center
			if (centerOption[1] !== null) { // Fixed center
				newSize = mathMax(mathMin(newSize, center[2] - mathMax(overflow[0], overflow[2])), minSize);

			} else { // Auto center
				newSize = mathMax(
					mathMin(
						newSize,
						center[2] - overflow[0] - overflow[2] // vertical overflow
					),
					minSize
				);
				center[1] += (overflow[0] - overflow[2]) / 2; // vertical center
			}

			// If the size must be decreased, we need to run translate and drawDataLabels again
			if (newSize < center[2]) {
				center[2] = newSize;
				center[3] = relativeLength(options.innerSize || 0, newSize);
				this.translate(center);
				each(this.points, function (point) {
					if (point.dataLabel) {
						point.dataLabel._pos = null; // reset
					}
				});

				if (this.drawDataLabels) {
					this.drawDataLabels();
				}
			// Else, return true to indicate that the pie and its labels is within the plot area
			} else {
				ret = true;
			}
			return ret;
		};
	}

	if (seriesTypes.column) {

		/**
		 * Override the basic data label alignment by adjusting for the position of the column
		 */
		seriesTypes.column.prototype.alignDataLabel = function (point, dataLabel, options,  alignTo, isNew) {
			var inverted = this.chart.inverted,
				series = point.series,
				dlBox = point.dlBox || point.shapeArgs, // data label box for alignment
				below = pick(point.below, point.plotY > pick(this.translatedThreshold, series.yAxis.len)), // point.below is used in range series
				inside = pick(options.inside, !!this.options.stacking); // draw it inside the box?

			// Align to the column itself, or the top of it
			if (dlBox) { // Area range uses this method but not alignTo
				alignTo = merge(dlBox);

				if (inverted) {
					alignTo = {
						x: series.yAxis.len - alignTo.y - alignTo.height,
						y: series.xAxis.len - alignTo.x - alignTo.width,
						width: alignTo.height,
						height: alignTo.width
					};
				}

				// Compute the alignment box
				if (!inside) {
					if (inverted) {
						alignTo.x += below ? 0 : alignTo.width;
						alignTo.width = 0;
					} else {
						alignTo.y += below ? alignTo.height : 0;
						alignTo.height = 0;
					}
				}
			}


			// When alignment is undefined (typically columns and bars), display the individual
			// point below or above the point depending on the threshold
			options.align = pick(
				options.align,
				!inverted || inside ? 'center' : below ? 'right' : 'left'
			);
			options.verticalAlign = pick(
				options.verticalAlign,
				inverted || inside ? 'middle' : below ? 'top' : 'bottom'
			);

			// Call the parent method
			Series.prototype.alignDataLabel.call(this, point, dataLabel, options, alignTo, isNew);
		};
	}



	/**
	 * Highcharts JS v4.1.7 (2015-06-26)
	 * Highcharts module to hide overlapping data labels. This module is included by default in Highmaps.
	 *
	 * (c) 2010-2014 Torstein Honsi
	 *
	 * License: www.highcharts.com/license
	 */

	/*global Highcharts, HighchartsAdapter */
	(function (H) {
		var Chart = H.Chart,
			each = H.each,
			pick = H.pick,
			addEvent = HighchartsAdapter.addEvent;

		// Collect potensial overlapping data labels. Stack labels probably don't need to be 
		// considered because they are usually accompanied by data labels that lie inside the columns.
		Chart.prototype.callbacks.push(function (chart) {
			function collectAndHide() {
				var labels = [];

				each(chart.series, function (series) {
					var dlOptions = series.options.dataLabels;
					if ((dlOptions.enabled || series._hasPointLabels) && !dlOptions.allowOverlap && series.visible) { // #3866
						each(series.points, function (point) { 
							if (point.dataLabel) {
								point.dataLabel.labelrank = pick(point.labelrank, point.shapeArgs && point.shapeArgs.height); // #4118
								labels.push(point.dataLabel);
							}
						});
					}
				});
				chart.hideOverlappingLabels(labels);
			}

			// Do it now ...
			collectAndHide();

			// ... and after each chart redraw
			addEvent(chart, 'redraw', collectAndHide);

		});

		/**
		 * Hide overlapping labels. Labels are moved and faded in and out on zoom to provide a smooth 
		 * visual imression.
		 */		
		Chart.prototype.hideOverlappingLabels = function (labels) {

			var len = labels.length,
				label,
				i,
				j,
				label1,
				label2,
				intersectRect = function (pos1, pos2, size1, size2) {
					return !(
						pos2.x > pos1.x + size1.width ||
						pos2.x + size2.width < pos1.x ||
						pos2.y > pos1.y + size1.height ||
						pos2.y + size2.height < pos1.y
					);
				};
		
			// Mark with initial opacity
			for (i = 0; i < len; i++) {
				label = labels[i];
				if (label) {
					label.oldOpacity = label.opacity;
					label.newOpacity = 1;
				}
			}

			// Prevent a situation in a gradually rising slope, that each label
			// will hide the previous one because the previous one always has
			// lower rank.
			labels.sort(function (a, b) {
				return b.labelrank - a.labelrank;
			});

			// Detect overlapping labels
			for (i = 0; i < len; i++) {
				label1 = labels[i];

				for (j = i + 1; j < len; ++j) {
					label2 = labels[j];
					if (label1 && label2 && label1.placed && label2.placed && label1.newOpacity !== 0 && label2.newOpacity !== 0 && 
							intersectRect(label1.alignAttr, label2.alignAttr, label1, label2)) {
						(label1.labelrank < label2.labelrank ? label1 : label2).newOpacity = 0;
					}
				}
			}

			// Hide or show
			for (i = 0; i < len; i++) {
				label = labels[i];
				if (label) {
					if (label.oldOpacity !== label.newOpacity && label.placed) {
						label.alignAttr.opacity = label.newOpacity;
						label[label.isOld && label.newOpacity ? 'animate' : 'attr'](label.alignAttr);
					}
					label.isOld = true;
				}
			}
		};

	}(Highcharts));/**
	 * TrackerMixin for points and graphs
	 */

	var TrackerMixin = Highcharts.TrackerMixin = {

		drawTrackerPoint: function () {
			var series = this,
				chart = series.chart,
				pointer = chart.pointer,
				cursor = series.options.cursor,
				css = cursor && { cursor: cursor },
				onMouseOver = function (e) {
					var target = e.target,
					point;

					while (target && !point) {
						point = target.point;
						target = target.parentNode;
					}

					if (point !== UNDEFINED && point !== chart.hoverPoint) { // undefined on graph in scatterchart
						point.onMouseOver(e);
					}
				};

			// Add reference to the point
			each(series.points, function (point) {
				if (point.graphic) {
					point.graphic.element.point = point;
				}
				if (point.dataLabel) {
					point.dataLabel.element.point = point;
				}
			});

			// Add the event listeners, we need to do this only once
			if (!series._hasTracking) {
				each(series.trackerGroups, function (key) {
					if (series[key]) { // we don't always have dataLabelsGroup
						series[key]
							.addClass(PREFIX + 'tracker')
							.on('mouseover', onMouseOver)
							.on('mouseout', function (e) { pointer.onTrackerMouseOut(e); })
							.css(css);
						if (hasTouch) {
							series[key].on('touchstart', onMouseOver);
						}
					}
				});
				series._hasTracking = true;
			}
		},

		/**
		 * Draw the tracker object that sits above all data labels and markers to
		 * track mouse events on the graph or points. For the line type charts
		 * the tracker uses the same graphPath, but with a greater stroke width
		 * for better control.
		 */
		drawTrackerGraph: function () {
			var series = this,
				options = series.options,
				trackByArea = options.trackByArea,
				trackerPath = [].concat(trackByArea ? series.areaPath : series.graphPath),
				trackerPathLength = trackerPath.length,
				chart = series.chart,
				pointer = chart.pointer,
				renderer = chart.renderer,
				snap = chart.options.tooltip.snap,
				tracker = series.tracker,
				cursor = options.cursor,
				css = cursor && { cursor: cursor },
				singlePoints = series.singlePoints,
				singlePoint,
				i,
				onMouseOver = function () {
					if (chart.hoverSeries !== series) {
						series.onMouseOver();
					}
				},
				/*
				 * Empirical lowest possible opacities for TRACKER_FILL for an element to stay invisible but clickable
				 * IE6: 0.002
				 * IE7: 0.002
				 * IE8: 0.002
				 * IE9: 0.00000000001 (unlimited)
				 * IE10: 0.0001 (exporting only)
				 * FF: 0.00000000001 (unlimited)
				 * Chrome: 0.000001
				 * Safari: 0.000001
				 * Opera: 0.00000000001 (unlimited)
				 */
				TRACKER_FILL = 'rgba(192,192,192,' + (hasSVG ? 0.0001 : 0.002) + ')';

			// Extend end points. A better way would be to use round linecaps,
			// but those are not clickable in VML.
			if (trackerPathLength && !trackByArea) {
				i = trackerPathLength + 1;
				while (i--) {
					if (trackerPath[i] === M) { // extend left side
						trackerPath.splice(i + 1, 0, trackerPath[i + 1] - snap, trackerPath[i + 2], L);
					}
					if ((i && trackerPath[i] === M) || i === trackerPathLength) { // extend right side
						trackerPath.splice(i, 0, L, trackerPath[i - 2] + snap, trackerPath[i - 1]);
					}
				}
			}

			// handle single points
			for (i = 0; i < singlePoints.length; i++) {
				singlePoint = singlePoints[i];
				trackerPath.push(M, singlePoint.plotX - snap, singlePoint.plotY,
				L, singlePoint.plotX + snap, singlePoint.plotY);
			}

			// draw the tracker
			if (tracker) {
				tracker.attr({ d: trackerPath });
			} else { // create

				series.tracker = renderer.path(trackerPath)
				.attr({
					'stroke-linejoin': 'round', // #1225
					visibility: series.visible ? VISIBLE : HIDDEN,
					stroke: TRACKER_FILL,
					fill: trackByArea ? TRACKER_FILL : NONE,
					'stroke-width' : options.lineWidth + (trackByArea ? 0 : 2 * snap),
					zIndex: 2
				})
				.add(series.group);

				// The tracker is added to the series group, which is clipped, but is covered
				// by the marker group. So the marker group also needs to capture events.
				each([series.tracker, series.markerGroup], function (tracker) {
					tracker.addClass(PREFIX + 'tracker')
						.on('mouseover', onMouseOver)
						.on('mouseout', function (e) { pointer.onTrackerMouseOut(e); })
						.css(css);

					if (hasTouch) {
						tracker.on('touchstart', onMouseOver);
					}
				});
			}
		}
	};
	/* End TrackerMixin */


	/**
	 * Add tracking event listener to the series group, so the point graphics
	 * themselves act as trackers
	 */ 

	if (seriesTypes.column) {
		ColumnSeries.prototype.drawTracker = TrackerMixin.drawTrackerPoint;	
	}

	if (seriesTypes.pie) {
		seriesTypes.pie.prototype.drawTracker = TrackerMixin.drawTrackerPoint;
	}

	if (seriesTypes.scatter) {
		ScatterSeries.prototype.drawTracker = TrackerMixin.drawTrackerPoint;
	}

	/* 
	 * Extend Legend for item events 
	 */ 
	extend(Legend.prototype, {

		setItemEvents: function (item, legendItem, useHTML, itemStyle, itemHiddenStyle) {
		var legend = this;
		// Set the events on the item group, or in case of useHTML, the item itself (#1249)
		(useHTML ? legendItem : item.legendGroup).on('mouseover', function () {
				item.setState(HOVER_STATE);
				legendItem.css(legend.options.itemHoverStyle);
			})
			.on('mouseout', function () {
				legendItem.css(item.visible ? itemStyle : itemHiddenStyle);
				item.setState();
			})
			.on('click', function (event) {
				var strLegendItemClick = 'legendItemClick',
					fnLegendItemClick = function () {
						item.setVisible();
					};
					
				// Pass over the click/touch event. #4.
				event = {
					browserEvent: event
				};

				// click the name or symbol
				if (item.firePointEvent) { // point
					item.firePointEvent(strLegendItemClick, event, fnLegendItemClick);
				} else {
					fireEvent(item, strLegendItemClick, event, fnLegendItemClick);
				}
			});
		},

		createCheckboxForItem: function (item) {
			var legend = this;

			item.checkbox = createElement('input', {
				type: 'checkbox',
				checked: item.selected,
				defaultChecked: item.selected // required by IE7
			}, legend.options.itemCheckboxStyle, legend.chart.container);

			addEvent(item.checkbox, 'click', function (event) {
				var target = event.target;
				fireEvent(item.series || item, 'checkboxClick', { // #3712
						checked: target.checked,
						item: item
					},
					function () {
						item.select();
					}
				);
			});
		}	
	});

	/* 
	 * Add pointer cursor to legend itemstyle in defaultOptions
	 */
	defaultOptions.legend.itemStyle.cursor = 'pointer';


	/* 
	 * Extend the Chart object with interaction
	 */

	extend(Chart.prototype, {
		/**
		 * Display the zoom button
		 */
		showResetZoom: function () {
			var chart = this,
				lang = defaultOptions.lang,
				btnOptions = chart.options.chart.resetZoomButton,
				theme = btnOptions.theme,
				states = theme.states,
				alignTo = btnOptions.relativeTo === 'chart' ? null : 'plotBox';
				
			this.resetZoomButton = chart.renderer.button(lang.resetZoom, null, null, function () { chart.zoomOut(); }, theme, states && states.hover)
				.attr({
					align: btnOptions.position.align,
					title: lang.resetZoomTitle
				})
				.add()
				.align(btnOptions.position, false, alignTo);
				
		},

		/**
		 * Zoom out to 1:1
		 */
		zoomOut: function () {
			var chart = this;
			fireEvent(chart, 'selection', { resetSelection: true }, function () { 
				chart.zoom();
			});
		},

		/**
		 * Zoom into a given portion of the chart given by axis coordinates
		 * @param {Object} event
		 */
		zoom: function (event) {
			var chart = this,
				hasZoomed,
				pointer = chart.pointer,
				displayButton = false,
				resetZoomButton;

			// If zoom is called with no arguments, reset the axes
			if (!event || event.resetSelection) {
				each(chart.axes, function (axis) {
					hasZoomed = axis.zoom();
				});
			} else { // else, zoom in on all axes
				each(event.xAxis.concat(event.yAxis), function (axisData) {
					var axis = axisData.axis,
						isXAxis = axis.isXAxis;

					// don't zoom more than minRange
					if (pointer[isXAxis ? 'zoomX' : 'zoomY'] || pointer[isXAxis ? 'pinchX' : 'pinchY']) {
						hasZoomed = axis.zoom(axisData.min, axisData.max);
						if (axis.displayBtn) {
							displayButton = true;
						}
					}
				});
			}
			
			// Show or hide the Reset zoom button
			resetZoomButton = chart.resetZoomButton;
			if (displayButton && !resetZoomButton) {
				chart.showResetZoom();
			} else if (!displayButton && isObject(resetZoomButton)) {
				chart.resetZoomButton = resetZoomButton.destroy();
			}
			

			// Redraw
			if (hasZoomed) {
				chart.redraw(
					pick(chart.options.chart.animation, event && event.animation, chart.pointCount < 100) // animation
				);
			}
		},

		/**
		 * Pan the chart by dragging the mouse across the pane. This function is called
		 * on mouse move, and the distance to pan is computed from chartX compared to
		 * the first chartX position in the dragging operation.
		 */
		pan: function (e, panning) {

			var chart = this,
				hoverPoints = chart.hoverPoints,
				doRedraw;

			// remove active points for shared tooltip
			if (hoverPoints) {
				each(hoverPoints, function (point) {
					point.setState();
				});
			}

			each(panning === 'xy' ? [1, 0] : [1], function (isX) { // xy is used in maps
				var mousePos = e[isX ? 'chartX' : 'chartY'],
					axis = chart[isX ? 'xAxis' : 'yAxis'][0],
					startPos = chart[isX ? 'mouseDownX' : 'mouseDownY'],
					halfPointRange = (axis.pointRange || 0) / 2,
					extremes = axis.getExtremes(),
					newMin = axis.toValue(startPos - mousePos, true) + halfPointRange,
					newMax = axis.toValue(startPos + chart[isX ? 'plotWidth' : 'plotHeight'] - mousePos, true) - halfPointRange,
					goingLeft = startPos > mousePos; // #3613

				if (axis.series.length && 
						(goingLeft || newMin > mathMin(extremes.dataMin, extremes.min)) && 
						(!goingLeft || newMax < mathMax(extremes.dataMax, extremes.max))) {
					axis.setExtremes(newMin, newMax, false, false, { trigger: 'pan' });
					doRedraw = true;
				}

				chart[isX ? 'mouseDownX' : 'mouseDownY'] = mousePos; // set new reference for next run
			});

			if (doRedraw) {
				chart.redraw(false);
			}
			css(chart.container, { cursor: 'move' });
		}
	});

	/*
	 * Extend the Point object with interaction
	 */
	extend(Point.prototype, {
		/**
		 * Toggle the selection status of a point
		 * @param {Boolean} selected Whether to select or unselect the point.
		 * @param {Boolean} accumulate Whether to add to the previous selection. By default,
		 *		 this happens if the control key (Cmd on Mac) was pressed during clicking.
		 */
		select: function (selected, accumulate) {
			var point = this,
				series = point.series,
				chart = series.chart;

			selected = pick(selected, !point.selected);

			// fire the event with the defalut handler
			point.firePointEvent(selected ? 'select' : 'unselect', { accumulate: accumulate }, function () {
				point.selected = point.options.selected = selected;
				series.options.data[inArray(point, series.data)] = point.options;

				point.setState(selected && SELECT_STATE);

				// unselect all other points unless Ctrl or Cmd + click
				if (!accumulate) {
					each(chart.getSelectedPoints(), function (loopPoint) {
						if (loopPoint.selected && loopPoint !== point) {
							loopPoint.selected = loopPoint.options.selected = false;
							series.options.data[inArray(loopPoint, series.data)] = loopPoint.options;
							loopPoint.setState(NORMAL_STATE);
								loopPoint.firePointEvent('unselect');
						}
					});
				}
			});
		},

		/**
		 * Runs on mouse over the point
		 */
		onMouseOver: function (e) {
			var point = this,
				series = point.series,
				chart = series.chart,
				tooltip = chart.tooltip,
				hoverPoint = chart.hoverPoint;

			if (chart.hoverSeries !== series) {
				series.onMouseOver();
			}		

			// set normal state to previous series
			if (hoverPoint && hoverPoint !== point) {
				hoverPoint.onMouseOut();
			}

			if (point.series) { // It may have been destroyed, #4130

				// trigger the event
				point.firePointEvent('mouseOver');

				// update the tooltip
				if (tooltip && (!tooltip.shared || series.noSharedTooltip)) {
					tooltip.refresh(point, e);
				}

				// hover this
				point.setState(HOVER_STATE);
				chart.hoverPoint = point;
			}
		},

		/**
		 * Runs on mouse out from the point
		 */
		onMouseOut: function () {
			var chart = this.series.chart,
				hoverPoints = chart.hoverPoints;

			this.firePointEvent('mouseOut');

			if (!hoverPoints || inArray(this, hoverPoints) === -1) { // #887, #2240
				this.setState();
				chart.hoverPoint = null;
			}
		},

		/**
		 * Import events from the series' and point's options. Only do it on
		 * demand, to save processing time on hovering.
		 */
		importEvents: function () {
			if (!this.hasImportedEvents) {
				var point = this,
					options = merge(point.series.options.point, point.options),
					events = options.events,
					eventType;

				point.events = events;

				for (eventType in events) {
					addEvent(point, eventType, events[eventType]);
				}
				this.hasImportedEvents = true;

			}
		},

		/**
		 * Set the point's state
		 * @param {String} state
		 */
		setState: function (state, move) {
			var point = this,
				plotX = point.plotX,
				plotY = point.plotY,
				series = point.series,
				stateOptions = series.options.states,
				markerOptions = defaultPlotOptions[series.type].marker && series.options.marker,
				normalDisabled = markerOptions && !markerOptions.enabled,
				markerStateOptions = markerOptions && markerOptions.states[state],
				stateDisabled = markerStateOptions && markerStateOptions.enabled === false,
				stateMarkerGraphic = series.stateMarkerGraphic,
				pointMarker = point.marker || {},
				chart = series.chart,
				radius,
				halo = series.halo,
				haloOptions,
				newSymbol,
				pointAttr;

			state = state || NORMAL_STATE; // empty string
			pointAttr = point.pointAttr[state] || series.pointAttr[state];

			if (
					// already has this state
					(state === point.state && !move) ||
					// selected points don't respond to hover
					(point.selected && state !== SELECT_STATE) ||
					// series' state options is disabled
					(stateOptions[state] && stateOptions[state].enabled === false) ||
					// general point marker's state options is disabled
					(state && (stateDisabled || (normalDisabled && markerStateOptions.enabled === false))) ||
					// individual point marker's state options is disabled
					(state && pointMarker.states && pointMarker.states[state] && pointMarker.states[state].enabled === false) // #1610

				) {
				return;
			}

			// apply hover styles to the existing point
			if (point.graphic) {
				radius = markerOptions && point.graphic.symbolName && pointAttr.r;
				point.graphic.attr(merge(
					pointAttr,
					radius ? { // new symbol attributes (#507, #612)
						x: plotX - radius,
						y: plotY - radius,
						width: 2 * radius,
						height: 2 * radius
					} : {}
				));

				// Zooming in from a range with no markers to a range with markers
				if (stateMarkerGraphic) {
					stateMarkerGraphic.hide();
				}
			} else {
				// if a graphic is not applied to each point in the normal state, create a shared
				// graphic for the hover state
				if (state && markerStateOptions) {
					radius = markerStateOptions.radius;
					newSymbol = pointMarker.symbol || series.symbol;

					// If the point has another symbol than the previous one, throw away the
					// state marker graphic and force a new one (#1459)
					if (stateMarkerGraphic && stateMarkerGraphic.currentSymbol !== newSymbol) {
						stateMarkerGraphic = stateMarkerGraphic.destroy();
					}

					// Add a new state marker graphic
					if (!stateMarkerGraphic) {
						if (newSymbol) {
							series.stateMarkerGraphic = stateMarkerGraphic = chart.renderer.symbol(
								newSymbol,
								plotX - radius,
								plotY - radius,
								2 * radius,
								2 * radius
							)
							.attr(pointAttr)
							.add(series.markerGroup);
							stateMarkerGraphic.currentSymbol = newSymbol;
						}

					// Move the existing graphic
					} else {
						stateMarkerGraphic[move ? 'animate' : 'attr']({ // #1054
							x: plotX - radius,
							y: plotY - radius
						});
					}
				}

				if (stateMarkerGraphic) {
					stateMarkerGraphic[state && chart.isInsidePlot(plotX, plotY, chart.inverted) ? 'show' : 'hide'](); // #2450
					stateMarkerGraphic.element.point = point; // #4310
				}
			}

			// Show me your halo
			haloOptions = stateOptions[state] && stateOptions[state].halo;
			if (haloOptions && haloOptions.size) {
				if (!halo) {
					series.halo = halo = chart.renderer.path()
						.add(chart.seriesGroup);
				}
				halo.attr(extend({
					fill: Color(point.color || series.color).setOpacity(haloOptions.opacity).get()
				}, haloOptions.attributes))[move ? 'animate' : 'attr']({
					d: point.haloPath(haloOptions.size)
				});
			} else if (halo) {
				halo.attr({ d: [] });
			}

			point.state = state;
		},

		haloPath: function (size) {
			var series = this.series,
				chart = series.chart,
				plotBox = series.getPlotBox(),
				inverted = chart.inverted;

			return chart.renderer.symbols.circle(
				plotBox.translateX + (inverted ? series.yAxis.len - this.plotY : this.plotX) - size, 
				plotBox.translateY + (inverted ? series.xAxis.len - this.plotX : this.plotY) - size, 
				size * 2, 
				size * 2
			);
		}
	});

	/*
	 * Extend the Series object with interaction
	 */

	extend(Series.prototype, {
		/**
		 * Series mouse over handler
		 */
		onMouseOver: function () {
			var series = this,
				chart = series.chart,
				hoverSeries = chart.hoverSeries;

			// set normal state to previous series
			if (hoverSeries && hoverSeries !== series) {
				hoverSeries.onMouseOut();
			}

			// trigger the event, but to save processing time,
			// only if defined
			if (series.options.events.mouseOver) {
				fireEvent(series, 'mouseOver');
			}

			// hover this
			series.setState(HOVER_STATE);
			chart.hoverSeries = series;
		},

		/**
		 * Series mouse out handler
		 */
		onMouseOut: function () {
			// trigger the event only if listeners exist
			var series = this,
				options = series.options,
				chart = series.chart,
				tooltip = chart.tooltip,
				hoverPoint = chart.hoverPoint;

			chart.hoverSeries = null; // #182, set to null before the mouseOut event fires

			// trigger mouse out on the point, which must be in this series
			if (hoverPoint) {
				hoverPoint.onMouseOut();
			}

			// fire the mouse out event
			if (series && options.events.mouseOut) {
				fireEvent(series, 'mouseOut');
			}


			// hide the tooltip
			if (tooltip && !options.stickyTracking && (!tooltip.shared || series.noSharedTooltip)) {
				tooltip.hide();
			}

			// set normal state
			series.setState();
		},

		/**
		 * Set the state of the graph
		 */
		setState: function (state) {
			var series = this,
				options = series.options,
				graph = series.graph,
				stateOptions = options.states,
				lineWidth = options.lineWidth,
				attribs,
				i = 0;

			state = state || NORMAL_STATE;

			if (series.state !== state) {
				series.state = state;

				if (stateOptions[state] && stateOptions[state].enabled === false) {
					return;
				}

				if (state) {
					lineWidth = stateOptions[state].lineWidth || lineWidth + (stateOptions[state].lineWidthPlus || 0); // #4035
				}

				if (graph && !graph.dashstyle) { // hover is turned off for dashed lines in VML
					attribs = {
						'stroke-width': lineWidth
					};
					// use attr because animate will cause any other animation on the graph to stop
					graph.attr(attribs);
					while (series['zoneGraph' + i]) {
						series['zoneGraph' + i].attr(attribs);
						i = i + 1;
					}
				}
			}
		},

		/**
		 * Set the visibility of the graph
		 *
		 * @param vis {Boolean} True to show the series, false to hide. If UNDEFINED,
		 *				the visibility is toggled.
		 */
		setVisible: function (vis, redraw) {
			var series = this,
				chart = series.chart,
				legendItem = series.legendItem,
				showOrHide,
				ignoreHiddenSeries = chart.options.chart.ignoreHiddenSeries,
				oldVisibility = series.visible;

			// if called without an argument, toggle visibility
			series.visible = vis = series.userOptions.visible = vis === UNDEFINED ? !oldVisibility : vis;
			showOrHide = vis ? 'show' : 'hide';

			// show or hide elements
			each(['group', 'dataLabelsGroup', 'markerGroup', 'tracker'], function (key) {
				if (series[key]) {
					series[key][showOrHide]();
				}
			});


			// hide tooltip (#1361)
			if (chart.hoverSeries === series || (chart.hoverPoint && chart.hoverPoint.series) === series) {
				series.onMouseOut();
			}


			if (legendItem) {
				chart.legend.colorizeItem(series, vis);
			}


			// rescale or adapt to resized chart
			series.isDirty = true;
			// in a stack, all other series are affected
			if (series.options.stacking) {
				each(chart.series, function (otherSeries) {
					if (otherSeries.options.stacking && otherSeries.visible) {
						otherSeries.isDirty = true;
					}
				});
			}

			// show or hide linked series
			each(series.linkedSeries, function (otherSeries) {
				otherSeries.setVisible(vis, false);
			});

			if (ignoreHiddenSeries) {
				chart.isDirtyBox = true;
			}
			if (redraw !== false) {
				chart.redraw();
			}

			fireEvent(series, showOrHide);
		},

		/**
		 * Show the graph
		 */
		show: function () {
			this.setVisible(true);
		},

		/**
		 * Hide the graph
		 */
		hide: function () {
			this.setVisible(false);
		},


		/**
		 * Set the selected state of the graph
		 *
		 * @param selected {Boolean} True to select the series, false to unselect. If
		 *				UNDEFINED, the selection state is toggled.
		 */
		select: function (selected) {
			var series = this;
			// if called without an argument, toggle
			series.selected = selected = (selected === UNDEFINED) ? !series.selected : selected;

			if (series.checkbox) {
				series.checkbox.checked = selected;
			}

			fireEvent(series, selected ? 'select' : 'unselect');
		},

		drawTracker: TrackerMixin.drawTrackerGraph
	});
	// global variables
	extend(Highcharts, {
		
		// Constructors
		Color: Color,
		Point: Point,
		Tick: Tick,	
		Renderer: Renderer,
		SVGElement: SVGElement,
		SVGRenderer: SVGRenderer,
		
		// Various
		arrayMin: arrayMin,
		arrayMax: arrayMax,
		charts: charts,
		dateFormat: dateFormat,
		error: error,
		format: format,
		pathAnim: pathAnim,
		getOptions: getOptions,
		hasBidiBug: hasBidiBug,
		isTouchDevice: isTouchDevice,
		setOptions: setOptions,
		addEvent: addEvent,
		removeEvent: removeEvent,
		createElement: createElement,
		discardElement: discardElement,
		css: css,
		each: each,
		map: map,
		merge: merge,
		splat: splat,
		extendClass: extendClass,
		pInt: pInt,
		svg: hasSVG,
		canvas: useCanVG,
		vml: !hasSVG && !useCanVG,
		product: PRODUCT,
		version: VERSION
	});

	module.exports = Highcharts;
	/*eslint-enable*/


/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * jQuery JavaScript Library v2.1.3
	 * http://jquery.com/
	 *
	 * Includes Sizzle.js
	 * http://sizzlejs.com/
	 *
	 * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors
	 * Released under the MIT license
	 * http://jquery.org/license
	 *
	 * Date: 2014-12-18T15:11Z
	 */

	(function( global, factory ) {

		if ( typeof module === "object" && typeof module.exports === "object" ) {
			// For CommonJS and CommonJS-like environments where a proper `window`
			// is present, execute the factory and get jQuery.
			// For environments that do not have a `window` with a `document`
			// (such as Node.js), expose a factory as module.exports.
			// This accentuates the need for the creation of a real `window`.
			// e.g. var jQuery = require("jquery")(window);
			// See ticket #14549 for more info.
			module.exports = global.document ?
				factory( global, true ) :
				function( w ) {
					if ( !w.document ) {
						throw new Error( "jQuery requires a window with a document" );
					}
					return factory( w );
				};
		} else {
			factory( global );
		}

	// Pass this if window is not defined yet
	}(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

	// Support: Firefox 18+
	// Can't be in strict mode, several libs including ASP.NET trace
	// the stack via arguments.caller.callee and Firefox dies if
	// you try to trace through "use strict" call chains. (#13335)
	//

	var arr = [];

	var slice = arr.slice;

	var concat = arr.concat;

	var push = arr.push;

	var indexOf = arr.indexOf;

	var class2type = {};

	var toString = class2type.toString;

	var hasOwn = class2type.hasOwnProperty;

	var support = {};



	var
		// Use the correct document accordingly with window argument (sandbox)
		document = window.document,

		version = "2.1.3",

		// Define a local copy of jQuery
		jQuery = function( selector, context ) {
			// The jQuery object is actually just the init constructor 'enhanced'
			// Need init if jQuery is called (just allow error to be thrown if not included)
			return new jQuery.fn.init( selector, context );
		},

		// Support: Android<4.1
		// Make sure we trim BOM and NBSP
		rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

		// Matches dashed string for camelizing
		rmsPrefix = /^-ms-/,
		rdashAlpha = /-([\da-z])/gi,

		// Used by jQuery.camelCase as callback to replace()
		fcamelCase = function( all, letter ) {
			return letter.toUpperCase();
		};

	jQuery.fn = jQuery.prototype = {
		// The current version of jQuery being used
		jquery: version,

		constructor: jQuery,

		// Start with an empty selector
		selector: "",

		// The default length of a jQuery object is 0
		length: 0,

		toArray: function() {
			return slice.call( this );
		},

		// Get the Nth element in the matched element set OR
		// Get the whole matched element set as a clean array
		get: function( num ) {
			return num != null ?

				// Return just the one element from the set
				( num < 0 ? this[ num + this.length ] : this[ num ] ) :

				// Return all the elements in a clean array
				slice.call( this );
		},

		// Take an array of elements and push it onto the stack
		// (returning the new matched element set)
		pushStack: function( elems ) {

			// Build a new jQuery matched element set
			var ret = jQuery.merge( this.constructor(), elems );

			// Add the old object onto the stack (as a reference)
			ret.prevObject = this;
			ret.context = this.context;

			// Return the newly-formed element set
			return ret;
		},

		// Execute a callback for every element in the matched set.
		// (You can seed the arguments with an array of args, but this is
		// only used internally.)
		each: function( callback, args ) {
			return jQuery.each( this, callback, args );
		},

		map: function( callback ) {
			return this.pushStack( jQuery.map(this, function( elem, i ) {
				return callback.call( elem, i, elem );
			}));
		},

		slice: function() {
			return this.pushStack( slice.apply( this, arguments ) );
		},

		first: function() {
			return this.eq( 0 );
		},

		last: function() {
			return this.eq( -1 );
		},

		eq: function( i ) {
			var len = this.length,
				j = +i + ( i < 0 ? len : 0 );
			return this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );
		},

		end: function() {
			return this.prevObject || this.constructor(null);
		},

		// For internal use only.
		// Behaves like an Array's method, not like a jQuery method.
		push: push,
		sort: arr.sort,
		splice: arr.splice
	};

	jQuery.extend = jQuery.fn.extend = function() {
		var options, name, src, copy, copyIsArray, clone,
			target = arguments[0] || {},
			i = 1,
			length = arguments.length,
			deep = false;

		// Handle a deep copy situation
		if ( typeof target === "boolean" ) {
			deep = target;

			// Skip the boolean and the target
			target = arguments[ i ] || {};
			i++;
		}

		// Handle case when target is a string or something (possible in deep copy)
		if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
			target = {};
		}

		// Extend jQuery itself if only one argument is passed
		if ( i === length ) {
			target = this;
			i--;
		}

		for ( ; i < length; i++ ) {
			// Only deal with non-null/undefined values
			if ( (options = arguments[ i ]) != null ) {
				// Extend the base object
				for ( name in options ) {
					src = target[ name ];
					copy = options[ name ];

					// Prevent never-ending loop
					if ( target === copy ) {
						continue;
					}

					// Recurse if we're merging plain objects or arrays
					if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
						if ( copyIsArray ) {
							copyIsArray = false;
							clone = src && jQuery.isArray(src) ? src : [];

						} else {
							clone = src && jQuery.isPlainObject(src) ? src : {};
						}

						// Never move original objects, clone them
						target[ name ] = jQuery.extend( deep, clone, copy );

					// Don't bring in undefined values
					} else if ( copy !== undefined ) {
						target[ name ] = copy;
					}
				}
			}
		}

		// Return the modified object
		return target;
	};

	jQuery.extend({
		// Unique for each copy of jQuery on the page
		expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

		// Assume jQuery is ready without the ready module
		isReady: true,

		error: function( msg ) {
			throw new Error( msg );
		},

		noop: function() {},

		isFunction: function( obj ) {
			return jQuery.type(obj) === "function";
		},

		isArray: Array.isArray,

		isWindow: function( obj ) {
			return obj != null && obj === obj.window;
		},

		isNumeric: function( obj ) {
			// parseFloat NaNs numeric-cast false positives (null|true|false|"")
			// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
			// subtraction forces infinities to NaN
			// adding 1 corrects loss of precision from parseFloat (#15100)
			return !jQuery.isArray( obj ) && (obj - parseFloat( obj ) + 1) >= 0;
		},

		isPlainObject: function( obj ) {
			// Not plain objects:
			// - Any object or value whose internal [[Class]] property is not "[object Object]"
			// - DOM nodes
			// - window
			if ( jQuery.type( obj ) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
				return false;
			}

			if ( obj.constructor &&
					!hasOwn.call( obj.constructor.prototype, "isPrototypeOf" ) ) {
				return false;
			}

			// If the function hasn't returned already, we're confident that
			// |obj| is a plain object, created by {} or constructed with new Object
			return true;
		},

		isEmptyObject: function( obj ) {
			var name;
			for ( name in obj ) {
				return false;
			}
			return true;
		},

		type: function( obj ) {
			if ( obj == null ) {
				return obj + "";
			}
			// Support: Android<4.0, iOS<6 (functionish RegExp)
			return typeof obj === "object" || typeof obj === "function" ?
				class2type[ toString.call(obj) ] || "object" :
				typeof obj;
		},

		// Evaluates a script in a global context
		globalEval: function( code ) {
			var script,
				indirect = eval;

			code = jQuery.trim( code );

			if ( code ) {
				// If the code includes a valid, prologue position
				// strict mode pragma, execute code by injecting a
				// script tag into the document.
				if ( code.indexOf("use strict") === 1 ) {
					script = document.createElement("script");
					script.text = code;
					document.head.appendChild( script ).parentNode.removeChild( script );
				} else {
				// Otherwise, avoid the DOM node creation, insertion
				// and removal by using an indirect global eval
					indirect( code );
				}
			}
		},

		// Convert dashed to camelCase; used by the css and data modules
		// Support: IE9-11+
		// Microsoft forgot to hump their vendor prefix (#9572)
		camelCase: function( string ) {
			return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
		},

		nodeName: function( elem, name ) {
			return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
		},

		// args is for internal usage only
		each: function( obj, callback, args ) {
			var value,
				i = 0,
				length = obj.length,
				isArray = isArraylike( obj );

			if ( args ) {
				if ( isArray ) {
					for ( ; i < length; i++ ) {
						value = callback.apply( obj[ i ], args );

						if ( value === false ) {
							break;
						}
					}
				} else {
					for ( i in obj ) {
						value = callback.apply( obj[ i ], args );

						if ( value === false ) {
							break;
						}
					}
				}

			// A special, fast, case for the most common use of each
			} else {
				if ( isArray ) {
					for ( ; i < length; i++ ) {
						value = callback.call( obj[ i ], i, obj[ i ] );

						if ( value === false ) {
							break;
						}
					}
				} else {
					for ( i in obj ) {
						value = callback.call( obj[ i ], i, obj[ i ] );

						if ( value === false ) {
							break;
						}
					}
				}
			}

			return obj;
		},

		// Support: Android<4.1
		trim: function( text ) {
			return text == null ?
				"" :
				( text + "" ).replace( rtrim, "" );
		},

		// results is for internal usage only
		makeArray: function( arr, results ) {
			var ret = results || [];

			if ( arr != null ) {
				if ( isArraylike( Object(arr) ) ) {
					jQuery.merge( ret,
						typeof arr === "string" ?
						[ arr ] : arr
					);
				} else {
					push.call( ret, arr );
				}
			}

			return ret;
		},

		inArray: function( elem, arr, i ) {
			return arr == null ? -1 : indexOf.call( arr, elem, i );
		},

		merge: function( first, second ) {
			var len = +second.length,
				j = 0,
				i = first.length;

			for ( ; j < len; j++ ) {
				first[ i++ ] = second[ j ];
			}

			first.length = i;

			return first;
		},

		grep: function( elems, callback, invert ) {
			var callbackInverse,
				matches = [],
				i = 0,
				length = elems.length,
				callbackExpect = !invert;

			// Go through the array, only saving the items
			// that pass the validator function
			for ( ; i < length; i++ ) {
				callbackInverse = !callback( elems[ i ], i );
				if ( callbackInverse !== callbackExpect ) {
					matches.push( elems[ i ] );
				}
			}

			return matches;
		},

		// arg is for internal usage only
		map: function( elems, callback, arg ) {
			var value,
				i = 0,
				length = elems.length,
				isArray = isArraylike( elems ),
				ret = [];

			// Go through the array, translating each of the items to their new values
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback( elems[ i ], i, arg );

					if ( value != null ) {
						ret.push( value );
					}
				}

			// Go through every key on the object,
			} else {
				for ( i in elems ) {
					value = callback( elems[ i ], i, arg );

					if ( value != null ) {
						ret.push( value );
					}
				}
			}

			// Flatten any nested arrays
			return concat.apply( [], ret );
		},

		// A global GUID counter for objects
		guid: 1,

		// Bind a function to a context, optionally partially applying any
		// arguments.
		proxy: function( fn, context ) {
			var tmp, args, proxy;

			if ( typeof context === "string" ) {
				tmp = fn[ context ];
				context = fn;
				fn = tmp;
			}

			// Quick check to determine if target is callable, in the spec
			// this throws a TypeError, but we will just return undefined.
			if ( !jQuery.isFunction( fn ) ) {
				return undefined;
			}

			// Simulated bind
			args = slice.call( arguments, 2 );
			proxy = function() {
				return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
			};

			// Set the guid of unique handler to the same of original handler, so it can be removed
			proxy.guid = fn.guid = fn.guid || jQuery.guid++;

			return proxy;
		},

		now: Date.now,

		// jQuery.support is not used in Core but other projects attach their
		// properties to it so it needs to exist.
		support: support
	});

	// Populate the class2type map
	jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
		class2type[ "[object " + name + "]" ] = name.toLowerCase();
	});

	function isArraylike( obj ) {
		var length = obj.length,
			type = jQuery.type( obj );

		if ( type === "function" || jQuery.isWindow( obj ) ) {
			return false;
		}

		if ( obj.nodeType === 1 && length ) {
			return true;
		}

		return type === "array" || length === 0 ||
			typeof length === "number" && length > 0 && ( length - 1 ) in obj;
	}
	var Sizzle =
	/*!
	 * Sizzle CSS Selector Engine v2.2.0-pre
	 * http://sizzlejs.com/
	 *
	 * Copyright 2008, 2014 jQuery Foundation, Inc. and other contributors
	 * Released under the MIT license
	 * http://jquery.org/license
	 *
	 * Date: 2014-12-16
	 */
	(function( window ) {

	var i,
		support,
		Expr,
		getText,
		isXML,
		tokenize,
		compile,
		select,
		outermostContext,
		sortInput,
		hasDuplicate,

		// Local document vars
		setDocument,
		document,
		docElem,
		documentIsHTML,
		rbuggyQSA,
		rbuggyMatches,
		matches,
		contains,

		// Instance-specific data
		expando = "sizzle" + 1 * new Date(),
		preferredDoc = window.document,
		dirruns = 0,
		done = 0,
		classCache = createCache(),
		tokenCache = createCache(),
		compilerCache = createCache(),
		sortOrder = function( a, b ) {
			if ( a === b ) {
				hasDuplicate = true;
			}
			return 0;
		},

		// General-purpose constants
		MAX_NEGATIVE = 1 << 31,

		// Instance methods
		hasOwn = ({}).hasOwnProperty,
		arr = [],
		pop = arr.pop,
		push_native = arr.push,
		push = arr.push,
		slice = arr.slice,
		// Use a stripped-down indexOf as it's faster than native
		// http://jsperf.com/thor-indexof-vs-for/5
		indexOf = function( list, elem ) {
			var i = 0,
				len = list.length;
			for ( ; i < len; i++ ) {
				if ( list[i] === elem ) {
					return i;
				}
			}
			return -1;
		},

		booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

		// Regular expressions

		// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
		whitespace = "[\\x20\\t\\r\\n\\f]",
		// http://www.w3.org/TR/css3-syntax/#characters
		characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

		// Loosely modeled on CSS identifier characters
		// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
		// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
		identifier = characterEncoding.replace( "w", "w#" ),

		// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
		attributes = "\\[" + whitespace + "*(" + characterEncoding + ")(?:" + whitespace +
			// Operator (capture 2)
			"*([*^$|!~]?=)" + whitespace +
			// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
			"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
			"*\\]",

		pseudos = ":(" + characterEncoding + ")(?:\\((" +
			// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
			// 1. quoted (capture 3; capture 4 or capture 5)
			"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
			// 2. simple (capture 6)
			"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
			// 3. anything else (capture 2)
			".*" +
			")\\)|)",

		// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
		rwhitespace = new RegExp( whitespace + "+", "g" ),
		rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

		rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
		rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

		rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

		rpseudo = new RegExp( pseudos ),
		ridentifier = new RegExp( "^" + identifier + "$" ),

		matchExpr = {
			"ID": new RegExp( "^#(" + characterEncoding + ")" ),
			"CLASS": new RegExp( "^\\.(" + characterEncoding + ")" ),
			"TAG": new RegExp( "^(" + characterEncoding.replace( "w", "w*" ) + ")" ),
			"ATTR": new RegExp( "^" + attributes ),
			"PSEUDO": new RegExp( "^" + pseudos ),
			"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
				"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
				"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
			"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
			// For use in libraries implementing .is()
			// We use this for POS matching in `select`
			"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
				whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
		},

		rinputs = /^(?:input|select|textarea|button)$/i,
		rheader = /^h\d$/i,

		rnative = /^[^{]+\{\s*\[native \w/,

		// Easily-parseable/retrievable ID or TAG or CLASS selectors
		rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

		rsibling = /[+~]/,
		rescape = /'|\\/g,

		// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
		runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
		funescape = function( _, escaped, escapedWhitespace ) {
			var high = "0x" + escaped - 0x10000;
			// NaN means non-codepoint
			// Support: Firefox<24
			// Workaround erroneous numeric interpretation of +"0x"
			return high !== high || escapedWhitespace ?
				escaped :
				high < 0 ?
					// BMP codepoint
					String.fromCharCode( high + 0x10000 ) :
					// Supplemental Plane codepoint (surrogate pair)
					String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
		},

		// Used for iframes
		// See setDocument()
		// Removing the function wrapper causes a "Permission Denied"
		// error in IE
		unloadHandler = function() {
			setDocument();
		};

	// Optimize for push.apply( _, NodeList )
	try {
		push.apply(
			(arr = slice.call( preferredDoc.childNodes )),
			preferredDoc.childNodes
		);
		// Support: Android<4.0
		// Detect silently failing push.apply
		arr[ preferredDoc.childNodes.length ].nodeType;
	} catch ( e ) {
		push = { apply: arr.length ?

			// Leverage slice if possible
			function( target, els ) {
				push_native.apply( target, slice.call(els) );
			} :

			// Support: IE<9
			// Otherwise append directly
			function( target, els ) {
				var j = target.length,
					i = 0;
				// Can't trust NodeList.length
				while ( (target[j++] = els[i++]) ) {}
				target.length = j - 1;
			}
		};
	}

	function Sizzle( selector, context, results, seed ) {
		var match, elem, m, nodeType,
			// QSA vars
			i, groups, old, nid, newContext, newSelector;

		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
			setDocument( context );
		}

		context = context || document;
		results = results || [];
		nodeType = context.nodeType;

		if ( typeof selector !== "string" || !selector ||
			nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

			return results;
		}

		if ( !seed && documentIsHTML ) {

			// Try to shortcut find operations when possible (e.g., not under DocumentFragment)
			if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {
				// Speed-up: Sizzle("#ID")
				if ( (m = match[1]) ) {
					if ( nodeType === 9 ) {
						elem = context.getElementById( m );
						// Check parentNode to catch when Blackberry 4.6 returns
						// nodes that are no longer in the document (jQuery #6963)
						if ( elem && elem.parentNode ) {
							// Handle the case where IE, Opera, and Webkit return items
							// by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}
					} else {
						// Context is not a document
						if ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&
							contains( context, elem ) && elem.id === m ) {
							results.push( elem );
							return results;
						}
					}

				// Speed-up: Sizzle("TAG")
				} else if ( match[2] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Speed-up: Sizzle(".CLASS")
				} else if ( (m = match[3]) && support.getElementsByClassName ) {
					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// QSA path
			if ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
				nid = old = expando;
				newContext = context;
				newSelector = nodeType !== 1 && selector;

				// qSA works strangely on Element-rooted queries
				// We can work around this by specifying an extra ID on the root
				// and working up from there (Thanks to Andrew Dupont for the technique)
				// IE 8 doesn't work on object elements
				if ( nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
					groups = tokenize( selector );

					if ( (old = context.getAttribute("id")) ) {
						nid = old.replace( rescape, "\\$&" );
					} else {
						context.setAttribute( "id", nid );
					}
					nid = "[id='" + nid + "'] ";

					i = groups.length;
					while ( i-- ) {
						groups[i] = nid + toSelector( groups[i] );
					}
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) || context;
					newSelector = groups.join(",");
				}

				if ( newSelector ) {
					try {
						push.apply( results,
							newContext.querySelectorAll( newSelector )
						);
						return results;
					} catch(qsaError) {
					} finally {
						if ( !old ) {
							context.removeAttribute("id");
						}
					}
				}
			}
		}

		// All others
		return select( selector.replace( rtrim, "$1" ), context, results, seed );
	}

	/**
	 * Create key-value caches of limited size
	 * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
	 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
	 *	deleting the oldest entry
	 */
	function createCache() {
		var keys = [];

		function cache( key, value ) {
			// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
			if ( keys.push( key + " " ) > Expr.cacheLength ) {
				// Only keep the most recent entries
				delete cache[ keys.shift() ];
			}
			return (cache[ key + " " ] = value);
		}
		return cache;
	}

	/**
	 * Mark a function for special use by Sizzle
	 * @param {Function} fn The function to mark
	 */
	function markFunction( fn ) {
		fn[ expando ] = true;
		return fn;
	}

	/**
	 * Support testing using an element
	 * @param {Function} fn Passed the created div and expects a boolean result
	 */
	function assert( fn ) {
		var div = document.createElement("div");

		try {
			return !!fn( div );
		} catch (e) {
			return false;
		} finally {
			// Remove from its parent by default
			if ( div.parentNode ) {
				div.parentNode.removeChild( div );
			}
			// release memory in IE
			div = null;
		}
	}

	/**
	 * Adds the same handler for all of the specified attrs
	 * @param {String} attrs Pipe-separated list of attributes
	 * @param {Function} handler The method that will be applied
	 */
	function addHandle( attrs, handler ) {
		var arr = attrs.split("|"),
			i = attrs.length;

		while ( i-- ) {
			Expr.attrHandle[ arr[i] ] = handler;
		}
	}

	/**
	 * Checks document order of two siblings
	 * @param {Element} a
	 * @param {Element} b
	 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
	 */
	function siblingCheck( a, b ) {
		var cur = b && a,
			diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
				( ~b.sourceIndex || MAX_NEGATIVE ) -
				( ~a.sourceIndex || MAX_NEGATIVE );

		// Use IE sourceIndex if available on both nodes
		if ( diff ) {
			return diff;
		}

		// Check if b follows a
		if ( cur ) {
			while ( (cur = cur.nextSibling) ) {
				if ( cur === b ) {
					return -1;
				}
			}
		}

		return a ? 1 : -1;
	}

	/**
	 * Returns a function to use in pseudos for input types
	 * @param {String} type
	 */
	function createInputPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === type;
		};
	}

	/**
	 * Returns a function to use in pseudos for buttons
	 * @param {String} type
	 */
	function createButtonPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return (name === "input" || name === "button") && elem.type === type;
		};
	}

	/**
	 * Returns a function to use in pseudos for positionals
	 * @param {Function} fn
	 */
	function createPositionalPseudo( fn ) {
		return markFunction(function( argument ) {
			argument = +argument;
			return markFunction(function( seed, matches ) {
				var j,
					matchIndexes = fn( [], seed.length, argument ),
					i = matchIndexes.length;

				// Match elements found at the specified indexes
				while ( i-- ) {
					if ( seed[ (j = matchIndexes[i]) ] ) {
						seed[j] = !(matches[j] = seed[j]);
					}
				}
			});
		});
	}

	/**
	 * Checks a node for validity as a Sizzle context
	 * @param {Element|Object=} context
	 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
	 */
	function testContext( context ) {
		return context && typeof context.getElementsByTagName !== "undefined" && context;
	}

	// Expose support vars for convenience
	support = Sizzle.support = {};

	/**
	 * Detects XML nodes
	 * @param {Element|Object} elem An element or a document
	 * @returns {Boolean} True iff elem is a non-HTML XML node
	 */
	isXML = Sizzle.isXML = function( elem ) {
		// documentElement is verified for cases where it doesn't yet exist
		// (such as loading iframes in IE - #4833)
		var documentElement = elem && (elem.ownerDocument || elem).documentElement;
		return documentElement ? documentElement.nodeName !== "HTML" : false;
	};

	/**
	 * Sets document-related variables once based on the current document
	 * @param {Element|Object} [doc] An element or document object to use to set the document
	 * @returns {Object} Returns the current document
	 */
	setDocument = Sizzle.setDocument = function( node ) {
		var hasCompare, parent,
			doc = node ? node.ownerDocument || node : preferredDoc;

		// If no document and documentElement is available, return
		if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
			return document;
		}

		// Set our document
		document = doc;
		docElem = doc.documentElement;
		parent = doc.defaultView;

		// Support: IE>8
		// If iframe document is assigned to "document" variable and if iframe has been reloaded,
		// IE will throw "permission denied" error when accessing "document" variable, see jQuery #13936
		// IE6-8 do not support the defaultView property so parent will be undefined
		if ( parent && parent !== parent.top ) {
			// IE11 does not have attachEvent, so all must suffer
			if ( parent.addEventListener ) {
				parent.addEventListener( "unload", unloadHandler, false );
			} else if ( parent.attachEvent ) {
				parent.attachEvent( "onunload", unloadHandler );
			}
		}

		/* Support tests
		---------------------------------------------------------------------- */
		documentIsHTML = !isXML( doc );

		/* Attributes
		---------------------------------------------------------------------- */

		// Support: IE<8
		// Verify that getAttribute really returns attributes and not properties
		// (excepting IE8 booleans)
		support.attributes = assert(function( div ) {
			div.className = "i";
			return !div.getAttribute("className");
		});

		/* getElement(s)By*
		---------------------------------------------------------------------- */

		// Check if getElementsByTagName("*") returns only elements
		support.getElementsByTagName = assert(function( div ) {
			div.appendChild( doc.createComment("") );
			return !div.getElementsByTagName("*").length;
		});

		// Support: IE<9
		support.getElementsByClassName = rnative.test( doc.getElementsByClassName );

		// Support: IE<10
		// Check if getElementById returns elements by name
		// The broken getElementById methods don't pick up programatically-set names,
		// so use a roundabout getElementsByName test
		support.getById = assert(function( div ) {
			docElem.appendChild( div ).id = expando;
			return !doc.getElementsByName || !doc.getElementsByName( expando ).length;
		});

		// ID find and filter
		if ( support.getById ) {
			Expr.find["ID"] = function( id, context ) {
				if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
					var m = context.getElementById( id );
					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document #6963
					return m && m.parentNode ? [ m ] : [];
				}
			};
			Expr.filter["ID"] = function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					return elem.getAttribute("id") === attrId;
				};
			};
		} else {
			// Support: IE6/7
			// getElementById is not reliable as a find shortcut
			delete Expr.find["ID"];

			Expr.filter["ID"] =  function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
					return node && node.value === attrId;
				};
			};
		}

		// Tag
		Expr.find["TAG"] = support.getElementsByTagName ?
			function( tag, context ) {
				if ( typeof context.getElementsByTagName !== "undefined" ) {
					return context.getElementsByTagName( tag );

				// DocumentFragment nodes don't have gEBTN
				} else if ( support.qsa ) {
					return context.querySelectorAll( tag );
				}
			} :

			function( tag, context ) {
				var elem,
					tmp = [],
					i = 0,
					// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
					results = context.getElementsByTagName( tag );

				// Filter out possible comments
				if ( tag === "*" ) {
					while ( (elem = results[i++]) ) {
						if ( elem.nodeType === 1 ) {
							tmp.push( elem );
						}
					}

					return tmp;
				}
				return results;
			};

		// Class
		Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
			if ( documentIsHTML ) {
				return context.getElementsByClassName( className );
			}
		};

		/* QSA/matchesSelector
		---------------------------------------------------------------------- */

		// QSA and matchesSelector support

		// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
		rbuggyMatches = [];

		// qSa(:focus) reports false when true (Chrome 21)
		// We allow this because of a bug in IE8/9 that throws an error
		// whenever `document.activeElement` is accessed on an iframe
		// So, we allow :focus to pass through QSA all the time to avoid the IE error
		// See http://bugs.jquery.com/ticket/13378
		rbuggyQSA = [];

		if ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {
			// Build QSA regex
			// Regex strategy adopted from Diego Perini
			assert(function( div ) {
				// Select is set to empty string on purpose
				// This is to test IE's treatment of not explicitly
				// setting a boolean content attribute,
				// since its presence should be enough
				// http://bugs.jquery.com/ticket/12359
				docElem.appendChild( div ).innerHTML = "<a id='" + expando + "'></a>" +
					"<select id='" + expando + "-\f]' msallowcapture=''>" +
					"<option selected=''></option></select>";

				// Support: IE8, Opera 11-12.16
				// Nothing should be selected when empty strings follow ^= or $= or *=
				// The test attribute must be unknown in Opera but "safe" for WinRT
				// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
				if ( div.querySelectorAll("[msallowcapture^='']").length ) {
					rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
				}

				// Support: IE8
				// Boolean attributes and "value" are not treated correctly
				if ( !div.querySelectorAll("[selected]").length ) {
					rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
				}

				// Support: Chrome<29, Android<4.2+, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.7+
				if ( !div.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
					rbuggyQSA.push("~=");
				}

				// Webkit/Opera - :checked should return selected option elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				// IE8 throws error here and will not see later tests
				if ( !div.querySelectorAll(":checked").length ) {
					rbuggyQSA.push(":checked");
				}

				// Support: Safari 8+, iOS 8+
				// https://bugs.webkit.org/show_bug.cgi?id=136851
				// In-page `selector#id sibing-combinator selector` fails
				if ( !div.querySelectorAll( "a#" + expando + "+*" ).length ) {
					rbuggyQSA.push(".#.+[+~]");
				}
			});

			assert(function( div ) {
				// Support: Windows 8 Native Apps
				// The type and name attributes are restricted during .innerHTML assignment
				var input = doc.createElement("input");
				input.setAttribute( "type", "hidden" );
				div.appendChild( input ).setAttribute( "name", "D" );

				// Support: IE8
				// Enforce case-sensitivity of name attribute
				if ( div.querySelectorAll("[name=d]").length ) {
					rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
				}

				// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
				// IE8 throws error here and will not see later tests
				if ( !div.querySelectorAll(":enabled").length ) {
					rbuggyQSA.push( ":enabled", ":disabled" );
				}

				// Opera 10-11 does not throw on post-comma invalid pseudos
				div.querySelectorAll("*,:x");
				rbuggyQSA.push(",.*:");
			});
		}

		if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
			docElem.webkitMatchesSelector ||
			docElem.mozMatchesSelector ||
			docElem.oMatchesSelector ||
			docElem.msMatchesSelector) )) ) {

			assert(function( div ) {
				// Check to see if it's possible to do matchesSelector
				// on a disconnected node (IE 9)
				support.disconnectedMatch = matches.call( div, "div" );

				// This should fail with an exception
				// Gecko does not error, returns false instead
				matches.call( div, "[s!='']:x" );
				rbuggyMatches.push( "!=", pseudos );
			});
		}

		rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
		rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

		/* Contains
		---------------------------------------------------------------------- */
		hasCompare = rnative.test( docElem.compareDocumentPosition );

		// Element contains another
		// Purposefully does not implement inclusive descendent
		// As in, an element does not contain itself
		contains = hasCompare || rnative.test( docElem.contains ) ?
			function( a, b ) {
				var adown = a.nodeType === 9 ? a.documentElement : a,
					bup = b && b.parentNode;
				return a === bup || !!( bup && bup.nodeType === 1 && (
					adown.contains ?
						adown.contains( bup ) :
						a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
				));
			} :
			function( a, b ) {
				if ( b ) {
					while ( (b = b.parentNode) ) {
						if ( b === a ) {
							return true;
						}
					}
				}
				return false;
			};

		/* Sorting
		---------------------------------------------------------------------- */

		// Document order sorting
		sortOrder = hasCompare ?
		function( a, b ) {

			// Flag for duplicate removal
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}

			// Sort on method existence if only one input has compareDocumentPosition
			var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
			if ( compare ) {
				return compare;
			}

			// Calculate position if both inputs belong to the same document
			compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
				a.compareDocumentPosition( b ) :

				// Otherwise we know they are disconnected
				1;

			// Disconnected nodes
			if ( compare & 1 ||
				(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

				// Choose the first element that is related to our preferred document
				if ( a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
					return -1;
				}
				if ( b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
					return 1;
				}

				// Maintain original order
				return sortInput ?
					( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
					0;
			}

			return compare & 4 ? -1 : 1;
		} :
		function( a, b ) {
			// Exit early if the nodes are identical
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}

			var cur,
				i = 0,
				aup = a.parentNode,
				bup = b.parentNode,
				ap = [ a ],
				bp = [ b ];

			// Parentless nodes are either documents or disconnected
			if ( !aup || !bup ) {
				return a === doc ? -1 :
					b === doc ? 1 :
					aup ? -1 :
					bup ? 1 :
					sortInput ?
					( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
					0;

			// If the nodes are siblings, we can do a quick check
			} else if ( aup === bup ) {
				return siblingCheck( a, b );
			}

			// Otherwise we need full lists of their ancestors for comparison
			cur = a;
			while ( (cur = cur.parentNode) ) {
				ap.unshift( cur );
			}
			cur = b;
			while ( (cur = cur.parentNode) ) {
				bp.unshift( cur );
			}

			// Walk down the tree looking for a discrepancy
			while ( ap[i] === bp[i] ) {
				i++;
			}

			return i ?
				// Do a sibling check if the nodes have a common ancestor
				siblingCheck( ap[i], bp[i] ) :

				// Otherwise nodes in our document sort first
				ap[i] === preferredDoc ? -1 :
				bp[i] === preferredDoc ? 1 :
				0;
		};

		return doc;
	};

	Sizzle.matches = function( expr, elements ) {
		return Sizzle( expr, null, null, elements );
	};

	Sizzle.matchesSelector = function( elem, expr ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}

		// Make sure that attribute selectors are quoted
		expr = expr.replace( rattributeQuotes, "='$1']" );

		if ( support.matchesSelector && documentIsHTML &&
			( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
			( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

			try {
				var ret = matches.call( elem, expr );

				// IE 9's matchesSelector returns false on disconnected nodes
				if ( ret || support.disconnectedMatch ||
						// As well, disconnected nodes are said to be in a document
						// fragment in IE 9
						elem.document && elem.document.nodeType !== 11 ) {
					return ret;
				}
			} catch (e) {}
		}

		return Sizzle( expr, document, null, [ elem ] ).length > 0;
	};

	Sizzle.contains = function( context, elem ) {
		// Set document vars if needed
		if ( ( context.ownerDocument || context ) !== document ) {
			setDocument( context );
		}
		return contains( context, elem );
	};

	Sizzle.attr = function( elem, name ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}

		var fn = Expr.attrHandle[ name.toLowerCase() ],
			// Don't get fooled by Object.prototype properties (jQuery #13807)
			val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
				fn( elem, name, !documentIsHTML ) :
				undefined;

		return val !== undefined ?
			val :
			support.attributes || !documentIsHTML ?
				elem.getAttribute( name ) :
				(val = elem.getAttributeNode(name)) && val.specified ?
					val.value :
					null;
	};

	Sizzle.error = function( msg ) {
		throw new Error( "Syntax error, unrecognized expression: " + msg );
	};

	/**
	 * Document sorting and removing duplicates
	 * @param {ArrayLike} results
	 */
	Sizzle.uniqueSort = function( results ) {
		var elem,
			duplicates = [],
			j = 0,
			i = 0;

		// Unless we *know* we can detect duplicates, assume their presence
		hasDuplicate = !support.detectDuplicates;
		sortInput = !support.sortStable && results.slice( 0 );
		results.sort( sortOrder );

		if ( hasDuplicate ) {
			while ( (elem = results[i++]) ) {
				if ( elem === results[ i ] ) {
					j = duplicates.push( i );
				}
			}
			while ( j-- ) {
				results.splice( duplicates[ j ], 1 );
			}
		}

		// Clear input after sorting to release objects
		// See https://github.com/jquery/sizzle/pull/225
		sortInput = null;

		return results;
	};

	/**
	 * Utility function for retrieving the text value of an array of DOM nodes
	 * @param {Array|Element} elem
	 */
	getText = Sizzle.getText = function( elem ) {
		var node,
			ret = "",
			i = 0,
			nodeType = elem.nodeType;

		if ( !nodeType ) {
			// If no nodeType, this is expected to be an array
			while ( (node = elem[i++]) ) {
				// Do not traverse comment nodes
				ret += getText( node );
			}
		} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
			// Use textContent for elements
			// innerText usage removed for consistency of new lines (jQuery #11153)
			if ( typeof elem.textContent === "string" ) {
				return elem.textContent;
			} else {
				// Traverse its children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					ret += getText( elem );
				}
			}
		} else if ( nodeType === 3 || nodeType === 4 ) {
			return elem.nodeValue;
		}
		// Do not include comment or processing instruction nodes

		return ret;
	};

	Expr = Sizzle.selectors = {

		// Can be adjusted by the user
		cacheLength: 50,

		createPseudo: markFunction,

		match: matchExpr,

		attrHandle: {},

		find: {},

		relative: {
			">": { dir: "parentNode", first: true },
			" ": { dir: "parentNode" },
			"+": { dir: "previousSibling", first: true },
			"~": { dir: "previousSibling" }
		},

		preFilter: {
			"ATTR": function( match ) {
				match[1] = match[1].replace( runescape, funescape );

				// Move the given value to match[3] whether quoted or unquoted
				match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

				if ( match[2] === "~=" ) {
					match[3] = " " + match[3] + " ";
				}

				return match.slice( 0, 4 );
			},

			"CHILD": function( match ) {
				/* matches from matchExpr["CHILD"]
					1 type (only|nth|...)
					2 what (child|of-type)
					3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
					4 xn-component of xn+y argument ([+-]?\d*n|)
					5 sign of xn-component
					6 x of xn-component
					7 sign of y-component
					8 y of y-component
				*/
				match[1] = match[1].toLowerCase();

				if ( match[1].slice( 0, 3 ) === "nth" ) {
					// nth-* requires argument
					if ( !match[3] ) {
						Sizzle.error( match[0] );
					}

					// numeric x and y parameters for Expr.filter.CHILD
					// remember that false/true cast respectively to 0/1
					match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
					match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

				// other types prohibit arguments
				} else if ( match[3] ) {
					Sizzle.error( match[0] );
				}

				return match;
			},

			"PSEUDO": function( match ) {
				var excess,
					unquoted = !match[6] && match[2];

				if ( matchExpr["CHILD"].test( match[0] ) ) {
					return null;
				}

				// Accept quoted arguments as-is
				if ( match[3] ) {
					match[2] = match[4] || match[5] || "";

				// Strip excess characters from unquoted arguments
				} else if ( unquoted && rpseudo.test( unquoted ) &&
					// Get excess from tokenize (recursively)
					(excess = tokenize( unquoted, true )) &&
					// advance to the next closing parenthesis
					(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

					// excess is a negative index
					match[0] = match[0].slice( 0, excess );
					match[2] = unquoted.slice( 0, excess );
				}

				// Return only captures needed by the pseudo filter method (type and argument)
				return match.slice( 0, 3 );
			}
		},

		filter: {

			"TAG": function( nodeNameSelector ) {
				var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
				return nodeNameSelector === "*" ?
					function() { return true; } :
					function( elem ) {
						return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
					};
			},

			"CLASS": function( className ) {
				var pattern = classCache[ className + " " ];

				return pattern ||
					(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
					classCache( className, function( elem ) {
						return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
					});
			},

			"ATTR": function( name, operator, check ) {
				return function( elem ) {
					var result = Sizzle.attr( elem, name );

					if ( result == null ) {
						return operator === "!=";
					}
					if ( !operator ) {
						return true;
					}

					result += "";

					return operator === "=" ? result === check :
						operator === "!=" ? result !== check :
						operator === "^=" ? check && result.indexOf( check ) === 0 :
						operator === "*=" ? check && result.indexOf( check ) > -1 :
						operator === "$=" ? check && result.slice( -check.length ) === check :
						operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
						operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
						false;
				};
			},

			"CHILD": function( type, what, argument, first, last ) {
				var simple = type.slice( 0, 3 ) !== "nth",
					forward = type.slice( -4 ) !== "last",
					ofType = what === "of-type";

				return first === 1 && last === 0 ?

					// Shortcut for :nth-*(n)
					function( elem ) {
						return !!elem.parentNode;
					} :

					function( elem, context, xml ) {
						var cache, outerCache, node, diff, nodeIndex, start,
							dir = simple !== forward ? "nextSibling" : "previousSibling",
							parent = elem.parentNode,
							name = ofType && elem.nodeName.toLowerCase(),
							useCache = !xml && !ofType;

						if ( parent ) {

							// :(first|last|only)-(child|of-type)
							if ( simple ) {
								while ( dir ) {
									node = elem;
									while ( (node = node[ dir ]) ) {
										if ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {
											return false;
										}
									}
									// Reverse direction for :only-* (if we haven't yet done so)
									start = dir = type === "only" && !start && "nextSibling";
								}
								return true;
							}

							start = [ forward ? parent.firstChild : parent.lastChild ];

							// non-xml :nth-child(...) stores cache data on `parent`
							if ( forward && useCache ) {
								// Seek `elem` from a previously-cached index
								outerCache = parent[ expando ] || (parent[ expando ] = {});
								cache = outerCache[ type ] || [];
								nodeIndex = cache[0] === dirruns && cache[1];
								diff = cache[0] === dirruns && cache[2];
								node = nodeIndex && parent.childNodes[ nodeIndex ];

								while ( (node = ++nodeIndex && node && node[ dir ] ||

									// Fallback to seeking `elem` from the start
									(diff = nodeIndex = 0) || start.pop()) ) {

									// When found, cache indexes on `parent` and break
									if ( node.nodeType === 1 && ++diff && node === elem ) {
										outerCache[ type ] = [ dirruns, nodeIndex, diff ];
										break;
									}
								}

							// Use previously-cached element index if available
							} else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {
								diff = cache[1];

							// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
							} else {
								// Use the same loop as above to seek `elem` from the start
								while ( (node = ++nodeIndex && node && node[ dir ] ||
									(diff = nodeIndex = 0) || start.pop()) ) {

									if ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {
										// Cache the index of each encountered element
										if ( useCache ) {
											(node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}

							// Incorporate the offset, then check against cycle size
							diff -= last;
							return diff === first || ( diff % first === 0 && diff / first >= 0 );
						}
					};
			},

			"PSEUDO": function( pseudo, argument ) {
				// pseudo-class names are case-insensitive
				// http://www.w3.org/TR/selectors/#pseudo-classes
				// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
				// Remember that setFilters inherits from pseudos
				var args,
					fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
						Sizzle.error( "unsupported pseudo: " + pseudo );

				// The user may use createPseudo to indicate that
				// arguments are needed to create the filter function
				// just as Sizzle does
				if ( fn[ expando ] ) {
					return fn( argument );
				}

				// But maintain support for old signatures
				if ( fn.length > 1 ) {
					args = [ pseudo, pseudo, "", argument ];
					return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
						markFunction(function( seed, matches ) {
							var idx,
								matched = fn( seed, argument ),
								i = matched.length;
							while ( i-- ) {
								idx = indexOf( seed, matched[i] );
								seed[ idx ] = !( matches[ idx ] = matched[i] );
							}
						}) :
						function( elem ) {
							return fn( elem, 0, args );
						};
				}

				return fn;
			}
		},

		pseudos: {
			// Potentially complex pseudos
			"not": markFunction(function( selector ) {
				// Trim the selector passed to compile
				// to avoid treating leading and trailing
				// spaces as combinators
				var input = [],
					results = [],
					matcher = compile( selector.replace( rtrim, "$1" ) );

				return matcher[ expando ] ?
					markFunction(function( seed, matches, context, xml ) {
						var elem,
							unmatched = matcher( seed, null, xml, [] ),
							i = seed.length;

						// Match elements unmatched by `matcher`
						while ( i-- ) {
							if ( (elem = unmatched[i]) ) {
								seed[i] = !(matches[i] = elem);
							}
						}
					}) :
					function( elem, context, xml ) {
						input[0] = elem;
						matcher( input, null, xml, results );
						// Don't keep the element (issue #299)
						input[0] = null;
						return !results.pop();
					};
			}),

			"has": markFunction(function( selector ) {
				return function( elem ) {
					return Sizzle( selector, elem ).length > 0;
				};
			}),

			"contains": markFunction(function( text ) {
				text = text.replace( runescape, funescape );
				return function( elem ) {
					return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
				};
			}),

			// "Whether an element is represented by a :lang() selector
			// is based solely on the element's language value
			// being equal to the identifier C,
			// or beginning with the identifier C immediately followed by "-".
			// The matching of C against the element's language value is performed case-insensitively.
			// The identifier C does not have to be a valid language name."
			// http://www.w3.org/TR/selectors/#lang-pseudo
			"lang": markFunction( function( lang ) {
				// lang value must be a valid identifier
				if ( !ridentifier.test(lang || "") ) {
					Sizzle.error( "unsupported lang: " + lang );
				}
				lang = lang.replace( runescape, funescape ).toLowerCase();
				return function( elem ) {
					var elemLang;
					do {
						if ( (elemLang = documentIsHTML ?
							elem.lang :
							elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

							elemLang = elemLang.toLowerCase();
							return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
						}
					} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
					return false;
				};
			}),

			// Miscellaneous
			"target": function( elem ) {
				var hash = window.location && window.location.hash;
				return hash && hash.slice( 1 ) === elem.id;
			},

			"root": function( elem ) {
				return elem === docElem;
			},

			"focus": function( elem ) {
				return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
			},

			// Boolean properties
			"enabled": function( elem ) {
				return elem.disabled === false;
			},

			"disabled": function( elem ) {
				return elem.disabled === true;
			},

			"checked": function( elem ) {
				// In CSS3, :checked should return both checked and selected elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				var nodeName = elem.nodeName.toLowerCase();
				return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
			},

			"selected": function( elem ) {
				// Accessing this property makes selected-by-default
				// options in Safari work properly
				if ( elem.parentNode ) {
					elem.parentNode.selectedIndex;
				}

				return elem.selected === true;
			},

			// Contents
			"empty": function( elem ) {
				// http://www.w3.org/TR/selectors/#empty-pseudo
				// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
				//   but not by others (comment: 8; processing instruction: 7; etc.)
				// nodeType < 6 works because attributes (2) do not appear as children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					if ( elem.nodeType < 6 ) {
						return false;
					}
				}
				return true;
			},

			"parent": function( elem ) {
				return !Expr.pseudos["empty"]( elem );
			},

			// Element/input types
			"header": function( elem ) {
				return rheader.test( elem.nodeName );
			},

			"input": function( elem ) {
				return rinputs.test( elem.nodeName );
			},

			"button": function( elem ) {
				var name = elem.nodeName.toLowerCase();
				return name === "input" && elem.type === "button" || name === "button";
			},

			"text": function( elem ) {
				var attr;
				return elem.nodeName.toLowerCase() === "input" &&
					elem.type === "text" &&

					// Support: IE<8
					// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
					( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
			},

			// Position-in-collection
			"first": createPositionalPseudo(function() {
				return [ 0 ];
			}),

			"last": createPositionalPseudo(function( matchIndexes, length ) {
				return [ length - 1 ];
			}),

			"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
				return [ argument < 0 ? argument + length : argument ];
			}),

			"even": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 0;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),

			"odd": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 1;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),

			"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; --i >= 0; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),

			"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; ++i < length; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			})
		}
	};

	Expr.pseudos["nth"] = Expr.pseudos["eq"];

	// Add button/input type pseudos
	for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
		Expr.pseudos[ i ] = createInputPseudo( i );
	}
	for ( i in { submit: true, reset: true } ) {
		Expr.pseudos[ i ] = createButtonPseudo( i );
	}

	// Easy API for creating new setFilters
	function setFilters() {}
	setFilters.prototype = Expr.filters = Expr.pseudos;
	Expr.setFilters = new setFilters();

	tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
		var matched, match, tokens, type,
			soFar, groups, preFilters,
			cached = tokenCache[ selector + " " ];

		if ( cached ) {
			return parseOnly ? 0 : cached.slice( 0 );
		}

		soFar = selector;
		groups = [];
		preFilters = Expr.preFilter;

		while ( soFar ) {

			// Comma and first run
			if ( !matched || (match = rcomma.exec( soFar )) ) {
				if ( match ) {
					// Don't consume trailing commas as valid
					soFar = soFar.slice( match[0].length ) || soFar;
				}
				groups.push( (tokens = []) );
			}

			matched = false;

			// Combinators
			if ( (match = rcombinators.exec( soFar )) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					// Cast descendant combinators to space
					type: match[0].replace( rtrim, " " )
				});
				soFar = soFar.slice( matched.length );
			}

			// Filters
			for ( type in Expr.filter ) {
				if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
					(match = preFilters[ type ]( match ))) ) {
					matched = match.shift();
					tokens.push({
						value: matched,
						type: type,
						matches: match
					});
					soFar = soFar.slice( matched.length );
				}
			}

			if ( !matched ) {
				break;
			}
		}

		// Return the length of the invalid excess
		// if we're just parsing
		// Otherwise, throw an error or return tokens
		return parseOnly ?
			soFar.length :
			soFar ?
				Sizzle.error( selector ) :
				// Cache the tokens
				tokenCache( selector, groups ).slice( 0 );
	};

	function toSelector( tokens ) {
		var i = 0,
			len = tokens.length,
			selector = "";
		for ( ; i < len; i++ ) {
			selector += tokens[i].value;
		}
		return selector;
	}

	function addCombinator( matcher, combinator, base ) {
		var dir = combinator.dir,
			checkNonElements = base && dir === "parentNode",
			doneName = done++;

		return combinator.first ?
			// Check against closest ancestor/preceding element
			function( elem, context, xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						return matcher( elem, context, xml );
					}
				}
			} :

			// Check against all ancestor/preceding elements
			function( elem, context, xml ) {
				var oldCache, outerCache,
					newCache = [ dirruns, doneName ];

				// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
				if ( xml ) {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							if ( matcher( elem, context, xml ) ) {
								return true;
							}
						}
					}
				} else {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							outerCache = elem[ expando ] || (elem[ expando ] = {});
							if ( (oldCache = outerCache[ dir ]) &&
								oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

								// Assign to newCache so results back-propagate to previous elements
								return (newCache[ 2 ] = oldCache[ 2 ]);
							} else {
								// Reuse newcache so results back-propagate to previous elements
								outerCache[ dir ] = newCache;

								// A match means we're done; a fail means we have to keep checking
								if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
									return true;
								}
							}
						}
					}
				}
			};
	}

	function elementMatcher( matchers ) {
		return matchers.length > 1 ?
			function( elem, context, xml ) {
				var i = matchers.length;
				while ( i-- ) {
					if ( !matchers[i]( elem, context, xml ) ) {
						return false;
					}
				}
				return true;
			} :
			matchers[0];
	}

	function multipleContexts( selector, contexts, results ) {
		var i = 0,
			len = contexts.length;
		for ( ; i < len; i++ ) {
			Sizzle( selector, contexts[i], results );
		}
		return results;
	}

	function condense( unmatched, map, filter, context, xml ) {
		var elem,
			newUnmatched = [],
			i = 0,
			len = unmatched.length,
			mapped = map != null;

		for ( ; i < len; i++ ) {
			if ( (elem = unmatched[i]) ) {
				if ( !filter || filter( elem, context, xml ) ) {
					newUnmatched.push( elem );
					if ( mapped ) {
						map.push( i );
					}
				}
			}
		}

		return newUnmatched;
	}

	function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
		if ( postFilter && !postFilter[ expando ] ) {
			postFilter = setMatcher( postFilter );
		}
		if ( postFinder && !postFinder[ expando ] ) {
			postFinder = setMatcher( postFinder, postSelector );
		}
		return markFunction(function( seed, results, context, xml ) {
			var temp, i, elem,
				preMap = [],
				postMap = [],
				preexisting = results.length,

				// Get initial elements from seed or context
				elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

				// Prefilter to get matcher input, preserving a map for seed-results synchronization
				matcherIn = preFilter && ( seed || !selector ) ?
					condense( elems, preMap, preFilter, context, xml ) :
					elems,

				matcherOut = matcher ?
					// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
					postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

						// ...intermediate processing is necessary
						[] :

						// ...otherwise use results directly
						results :
					matcherIn;

			// Find primary matches
			if ( matcher ) {
				matcher( matcherIn, matcherOut, context, xml );
			}

			// Apply postFilter
			if ( postFilter ) {
				temp = condense( matcherOut, postMap );
				postFilter( temp, [], context, xml );

				// Un-match failing elements by moving them back to matcherIn
				i = temp.length;
				while ( i-- ) {
					if ( (elem = temp[i]) ) {
						matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
					}
				}
			}

			if ( seed ) {
				if ( postFinder || preFilter ) {
					if ( postFinder ) {
						// Get the final matcherOut by condensing this intermediate into postFinder contexts
						temp = [];
						i = matcherOut.length;
						while ( i-- ) {
							if ( (elem = matcherOut[i]) ) {
								// Restore matcherIn since elem is not yet a final match
								temp.push( (matcherIn[i] = elem) );
							}
						}
						postFinder( null, (matcherOut = []), temp, xml );
					}

					// Move matched elements from seed to results to keep them synchronized
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) &&
							(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

							seed[temp] = !(results[temp] = elem);
						}
					}
				}

			// Add elements to results, through postFinder if defined
			} else {
				matcherOut = condense(
					matcherOut === results ?
						matcherOut.splice( preexisting, matcherOut.length ) :
						matcherOut
				);
				if ( postFinder ) {
					postFinder( null, results, matcherOut, xml );
				} else {
					push.apply( results, matcherOut );
				}
			}
		});
	}

	function matcherFromTokens( tokens ) {
		var checkContext, matcher, j,
			len = tokens.length,
			leadingRelative = Expr.relative[ tokens[0].type ],
			implicitRelative = leadingRelative || Expr.relative[" "],
			i = leadingRelative ? 1 : 0,

			// The foundational matcher ensures that elements are reachable from top-level context(s)
			matchContext = addCombinator( function( elem ) {
				return elem === checkContext;
			}, implicitRelative, true ),
			matchAnyContext = addCombinator( function( elem ) {
				return indexOf( checkContext, elem ) > -1;
			}, implicitRelative, true ),
			matchers = [ function( elem, context, xml ) {
				var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
					(checkContext = context).nodeType ?
						matchContext( elem, context, xml ) :
						matchAnyContext( elem, context, xml ) );
				// Avoid hanging onto element (issue #299)
				checkContext = null;
				return ret;
			} ];

		for ( ; i < len; i++ ) {
			if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
				matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
			} else {
				matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

				// Return special upon seeing a positional matcher
				if ( matcher[ expando ] ) {
					// Find the next relative operator (if any) for proper handling
					j = ++i;
					for ( ; j < len; j++ ) {
						if ( Expr.relative[ tokens[j].type ] ) {
							break;
						}
					}
					return setMatcher(
						i > 1 && elementMatcher( matchers ),
						i > 1 && toSelector(
							// If the preceding token was a descendant combinator, insert an implicit any-element `*`
							tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
						).replace( rtrim, "$1" ),
						matcher,
						i < j && matcherFromTokens( tokens.slice( i, j ) ),
						j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
						j < len && toSelector( tokens )
					);
				}
				matchers.push( matcher );
			}
		}

		return elementMatcher( matchers );
	}

	function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
		var bySet = setMatchers.length > 0,
			byElement = elementMatchers.length > 0,
			superMatcher = function( seed, context, xml, results, outermost ) {
				var elem, j, matcher,
					matchedCount = 0,
					i = "0",
					unmatched = seed && [],
					setMatched = [],
					contextBackup = outermostContext,
					// We must always have either seed elements or outermost context
					elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
					// Use integer dirruns iff this is the outermost matcher
					dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
					len = elems.length;

				if ( outermost ) {
					outermostContext = context !== document && context;
				}

				// Add elements passing elementMatchers directly to results
				// Keep `i` a string if there are no elements so `matchedCount` will be "00" below
				// Support: IE<9, Safari
				// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
				for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
					if ( byElement && elem ) {
						j = 0;
						while ( (matcher = elementMatchers[j++]) ) {
							if ( matcher( elem, context, xml ) ) {
								results.push( elem );
								break;
							}
						}
						if ( outermost ) {
							dirruns = dirrunsUnique;
						}
					}

					// Track unmatched elements for set filters
					if ( bySet ) {
						// They will have gone through all possible matchers
						if ( (elem = !matcher && elem) ) {
							matchedCount--;
						}

						// Lengthen the array for every element, matched or not
						if ( seed ) {
							unmatched.push( elem );
						}
					}
				}

				// Apply set filters to unmatched elements
				matchedCount += i;
				if ( bySet && i !== matchedCount ) {
					j = 0;
					while ( (matcher = setMatchers[j++]) ) {
						matcher( unmatched, setMatched, context, xml );
					}

					if ( seed ) {
						// Reintegrate element matches to eliminate the need for sorting
						if ( matchedCount > 0 ) {
							while ( i-- ) {
								if ( !(unmatched[i] || setMatched[i]) ) {
									setMatched[i] = pop.call( results );
								}
							}
						}

						// Discard index placeholder values to get only actual matches
						setMatched = condense( setMatched );
					}

					// Add matches to results
					push.apply( results, setMatched );

					// Seedless set matches succeeding multiple successful matchers stipulate sorting
					if ( outermost && !seed && setMatched.length > 0 &&
						( matchedCount + setMatchers.length ) > 1 ) {

						Sizzle.uniqueSort( results );
					}
				}

				// Override manipulation of globals by nested matchers
				if ( outermost ) {
					dirruns = dirrunsUnique;
					outermostContext = contextBackup;
				}

				return unmatched;
			};

		return bySet ?
			markFunction( superMatcher ) :
			superMatcher;
	}

	compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
		var i,
			setMatchers = [],
			elementMatchers = [],
			cached = compilerCache[ selector + " " ];

		if ( !cached ) {
			// Generate a function of recursive functions that can be used to check each element
			if ( !match ) {
				match = tokenize( selector );
			}
			i = match.length;
			while ( i-- ) {
				cached = matcherFromTokens( match[i] );
				if ( cached[ expando ] ) {
					setMatchers.push( cached );
				} else {
					elementMatchers.push( cached );
				}
			}

			// Cache the compiled function
			cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

			// Save selector and tokenization
			cached.selector = selector;
		}
		return cached;
	};

	/**
	 * A low-level selection function that works with Sizzle's compiled
	 *  selector functions
	 * @param {String|Function} selector A selector or a pre-compiled
	 *  selector function built with Sizzle.compile
	 * @param {Element} context
	 * @param {Array} [results]
	 * @param {Array} [seed] A set of elements to match against
	 */
	select = Sizzle.select = function( selector, context, results, seed ) {
		var i, tokens, token, type, find,
			compiled = typeof selector === "function" && selector,
			match = !seed && tokenize( (selector = compiled.selector || selector) );

		results = results || [];

		// Try to minimize operations if there is no seed and only one group
		if ( match.length === 1 ) {

			// Take a shortcut and set the context if the root selector is an ID
			tokens = match[0] = match[0].slice( 0 );
			if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
					support.getById && context.nodeType === 9 && documentIsHTML &&
					Expr.relative[ tokens[1].type ] ) {

				context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
				if ( !context ) {
					return results;

				// Precompiled matchers will still verify ancestry, so step up a level
				} else if ( compiled ) {
					context = context.parentNode;
				}

				selector = selector.slice( tokens.shift().value.length );
			}

			// Fetch a seed set for right-to-left matching
			i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
			while ( i-- ) {
				token = tokens[i];

				// Abort if we hit a combinator
				if ( Expr.relative[ (type = token.type) ] ) {
					break;
				}
				if ( (find = Expr.find[ type ]) ) {
					// Search, expanding context for leading sibling combinators
					if ( (seed = find(
						token.matches[0].replace( runescape, funescape ),
						rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
					)) ) {

						// If seed is empty or no tokens remain, we can return early
						tokens.splice( i, 1 );
						selector = seed.length && toSelector( tokens );
						if ( !selector ) {
							push.apply( results, seed );
							return results;
						}

						break;
					}
				}
			}
		}

		// Compile and execute a filtering function if one is not provided
		// Provide `match` to avoid retokenization if we modified the selector above
		( compiled || compile( selector, match ) )(
			seed,
			context,
			!documentIsHTML,
			results,
			rsibling.test( selector ) && testContext( context.parentNode ) || context
		);
		return results;
	};

	// One-time assignments

	// Sort stability
	support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

	// Support: Chrome 14-35+
	// Always assume duplicates if they aren't passed to the comparison function
	support.detectDuplicates = !!hasDuplicate;

	// Initialize against the default document
	setDocument();

	// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
	// Detached nodes confoundingly follow *each other*
	support.sortDetached = assert(function( div1 ) {
		// Should return 1, but returns 4 (following)
		return div1.compareDocumentPosition( document.createElement("div") ) & 1;
	});

	// Support: IE<8
	// Prevent attribute/property "interpolation"
	// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
	if ( !assert(function( div ) {
		div.innerHTML = "<a href='#'></a>";
		return div.firstChild.getAttribute("href") === "#" ;
	}) ) {
		addHandle( "type|href|height|width", function( elem, name, isXML ) {
			if ( !isXML ) {
				return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
			}
		});
	}

	// Support: IE<9
	// Use defaultValue in place of getAttribute("value")
	if ( !support.attributes || !assert(function( div ) {
		div.innerHTML = "<input/>";
		div.firstChild.setAttribute( "value", "" );
		return div.firstChild.getAttribute( "value" ) === "";
	}) ) {
		addHandle( "value", function( elem, name, isXML ) {
			if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
				return elem.defaultValue;
			}
		});
	}

	// Support: IE<9
	// Use getAttributeNode to fetch booleans when getAttribute lies
	if ( !assert(function( div ) {
		return div.getAttribute("disabled") == null;
	}) ) {
		addHandle( booleans, function( elem, name, isXML ) {
			var val;
			if ( !isXML ) {
				return elem[ name ] === true ? name.toLowerCase() :
						(val = elem.getAttributeNode( name )) && val.specified ?
						val.value :
					null;
			}
		});
	}

	return Sizzle;

	})( window );



	jQuery.find = Sizzle;
	jQuery.expr = Sizzle.selectors;
	jQuery.expr[":"] = jQuery.expr.pseudos;
	jQuery.unique = Sizzle.uniqueSort;
	jQuery.text = Sizzle.getText;
	jQuery.isXMLDoc = Sizzle.isXML;
	jQuery.contains = Sizzle.contains;



	var rneedsContext = jQuery.expr.match.needsContext;

	var rsingleTag = (/^<(\w+)\s*\/?>(?:<\/\1>|)$/);



	var risSimple = /^.[^:#\[\.,]*$/;

	// Implement the identical functionality for filter and not
	function winnow( elements, qualifier, not ) {
		if ( jQuery.isFunction( qualifier ) ) {
			return jQuery.grep( elements, function( elem, i ) {
				/* jshint -W018 */
				return !!qualifier.call( elem, i, elem ) !== not;
			});

		}

		if ( qualifier.nodeType ) {
			return jQuery.grep( elements, function( elem ) {
				return ( elem === qualifier ) !== not;
			});

		}

		if ( typeof qualifier === "string" ) {
			if ( risSimple.test( qualifier ) ) {
				return jQuery.filter( qualifier, elements, not );
			}

			qualifier = jQuery.filter( qualifier, elements );
		}

		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) >= 0 ) !== not;
		});
	}

	jQuery.filter = function( expr, elems, not ) {
		var elem = elems[ 0 ];

		if ( not ) {
			expr = ":not(" + expr + ")";
		}

		return elems.length === 1 && elem.nodeType === 1 ?
			jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
			jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
				return elem.nodeType === 1;
			}));
	};

	jQuery.fn.extend({
		find: function( selector ) {
			var i,
				len = this.length,
				ret = [],
				self = this;

			if ( typeof selector !== "string" ) {
				return this.pushStack( jQuery( selector ).filter(function() {
					for ( i = 0; i < len; i++ ) {
						if ( jQuery.contains( self[ i ], this ) ) {
							return true;
						}
					}
				}) );
			}

			for ( i = 0; i < len; i++ ) {
				jQuery.find( selector, self[ i ], ret );
			}

			// Needed because $( selector, context ) becomes $( context ).find( selector )
			ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
			ret.selector = this.selector ? this.selector + " " + selector : selector;
			return ret;
		},
		filter: function( selector ) {
			return this.pushStack( winnow(this, selector || [], false) );
		},
		not: function( selector ) {
			return this.pushStack( winnow(this, selector || [], true) );
		},
		is: function( selector ) {
			return !!winnow(
				this,

				// If this is a positional/relative selector, check membership in the returned set
				// so $("p:first").is("p:last") won't return true for a doc with two "p".
				typeof selector === "string" && rneedsContext.test( selector ) ?
					jQuery( selector ) :
					selector || [],
				false
			).length;
		}
	});


	// Initialize a jQuery object


	// A central reference to the root jQuery(document)
	var rootjQuery,

		// A simple way to check for HTML strings
		// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
		// Strict HTML recognition (#11290: must start with <)
		rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,

		init = jQuery.fn.init = function( selector, context ) {
			var match, elem;

			// HANDLE: $(""), $(null), $(undefined), $(false)
			if ( !selector ) {
				return this;
			}

			// Handle HTML strings
			if ( typeof selector === "string" ) {
				if ( selector[0] === "<" && selector[ selector.length - 1 ] === ">" && selector.length >= 3 ) {
					// Assume that strings that start and end with <> are HTML and skip the regex check
					match = [ null, selector, null ];

				} else {
					match = rquickExpr.exec( selector );
				}

				// Match html or make sure no context is specified for #id
				if ( match && (match[1] || !context) ) {

					// HANDLE: $(html) -> $(array)
					if ( match[1] ) {
						context = context instanceof jQuery ? context[0] : context;

						// Option to run scripts is true for back-compat
						// Intentionally let the error be thrown if parseHTML is not present
						jQuery.merge( this, jQuery.parseHTML(
							match[1],
							context && context.nodeType ? context.ownerDocument || context : document,
							true
						) );

						// HANDLE: $(html, props)
						if ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {
							for ( match in context ) {
								// Properties of context are called as methods if possible
								if ( jQuery.isFunction( this[ match ] ) ) {
									this[ match ]( context[ match ] );

								// ...and otherwise set as attributes
								} else {
									this.attr( match, context[ match ] );
								}
							}
						}

						return this;

					// HANDLE: $(#id)
					} else {
						elem = document.getElementById( match[2] );

						// Support: Blackberry 4.6
						// gEBID returns nodes no longer in the document (#6963)
						if ( elem && elem.parentNode ) {
							// Inject the element directly into the jQuery object
							this.length = 1;
							this[0] = elem;
						}

						this.context = document;
						this.selector = selector;
						return this;
					}

				// HANDLE: $(expr, $(...))
				} else if ( !context || context.jquery ) {
					return ( context || rootjQuery ).find( selector );

				// HANDLE: $(expr, context)
				// (which is just equivalent to: $(context).find(expr)
				} else {
					return this.constructor( context ).find( selector );
				}

			// HANDLE: $(DOMElement)
			} else if ( selector.nodeType ) {
				this.context = this[0] = selector;
				this.length = 1;
				return this;

			// HANDLE: $(function)
			// Shortcut for document ready
			} else if ( jQuery.isFunction( selector ) ) {
				return typeof rootjQuery.ready !== "undefined" ?
					rootjQuery.ready( selector ) :
					// Execute immediately if ready is not present
					selector( jQuery );
			}

			if ( selector.selector !== undefined ) {
				this.selector = selector.selector;
				this.context = selector.context;
			}

			return jQuery.makeArray( selector, this );
		};

	// Give the init function the jQuery prototype for later instantiation
	init.prototype = jQuery.fn;

	// Initialize central reference
	rootjQuery = jQuery( document );


	var rparentsprev = /^(?:parents|prev(?:Until|All))/,
		// Methods guaranteed to produce a unique set when starting from a unique set
		guaranteedUnique = {
			children: true,
			contents: true,
			next: true,
			prev: true
		};

	jQuery.extend({
		dir: function( elem, dir, until ) {
			var matched = [],
				truncate = until !== undefined;

			while ( (elem = elem[ dir ]) && elem.nodeType !== 9 ) {
				if ( elem.nodeType === 1 ) {
					if ( truncate && jQuery( elem ).is( until ) ) {
						break;
					}
					matched.push( elem );
				}
			}
			return matched;
		},

		sibling: function( n, elem ) {
			var matched = [];

			for ( ; n; n = n.nextSibling ) {
				if ( n.nodeType === 1 && n !== elem ) {
					matched.push( n );
				}
			}

			return matched;
		}
	});

	jQuery.fn.extend({
		has: function( target ) {
			var targets = jQuery( target, this ),
				l = targets.length;

			return this.filter(function() {
				var i = 0;
				for ( ; i < l; i++ ) {
					if ( jQuery.contains( this, targets[i] ) ) {
						return true;
					}
				}
			});
		},

		closest: function( selectors, context ) {
			var cur,
				i = 0,
				l = this.length,
				matched = [],
				pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
					jQuery( selectors, context || this.context ) :
					0;

			for ( ; i < l; i++ ) {
				for ( cur = this[i]; cur && cur !== context; cur = cur.parentNode ) {
					// Always skip document fragments
					if ( cur.nodeType < 11 && (pos ?
						pos.index(cur) > -1 :

						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector(cur, selectors)) ) {

						matched.push( cur );
						break;
					}
				}
			}

			return this.pushStack( matched.length > 1 ? jQuery.unique( matched ) : matched );
		},

		// Determine the position of an element within the set
		index: function( elem ) {

			// No argument, return index in parent
			if ( !elem ) {
				return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
			}

			// Index in selector
			if ( typeof elem === "string" ) {
				return indexOf.call( jQuery( elem ), this[ 0 ] );
			}

			// Locate the position of the desired element
			return indexOf.call( this,

				// If it receives a jQuery object, the first element is used
				elem.jquery ? elem[ 0 ] : elem
			);
		},

		add: function( selector, context ) {
			return this.pushStack(
				jQuery.unique(
					jQuery.merge( this.get(), jQuery( selector, context ) )
				)
			);
		},

		addBack: function( selector ) {
			return this.add( selector == null ?
				this.prevObject : this.prevObject.filter(selector)
			);
		}
	});

	function sibling( cur, dir ) {
		while ( (cur = cur[dir]) && cur.nodeType !== 1 ) {}
		return cur;
	}

	jQuery.each({
		parent: function( elem ) {
			var parent = elem.parentNode;
			return parent && parent.nodeType !== 11 ? parent : null;
		},
		parents: function( elem ) {
			return jQuery.dir( elem, "parentNode" );
		},
		parentsUntil: function( elem, i, until ) {
			return jQuery.dir( elem, "parentNode", until );
		},
		next: function( elem ) {
			return sibling( elem, "nextSibling" );
		},
		prev: function( elem ) {
			return sibling( elem, "previousSibling" );
		},
		nextAll: function( elem ) {
			return jQuery.dir( elem, "nextSibling" );
		},
		prevAll: function( elem ) {
			return jQuery.dir( elem, "previousSibling" );
		},
		nextUntil: function( elem, i, until ) {
			return jQuery.dir( elem, "nextSibling", until );
		},
		prevUntil: function( elem, i, until ) {
			return jQuery.dir( elem, "previousSibling", until );
		},
		siblings: function( elem ) {
			return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
		},
		children: function( elem ) {
			return jQuery.sibling( elem.firstChild );
		},
		contents: function( elem ) {
			return elem.contentDocument || jQuery.merge( [], elem.childNodes );
		}
	}, function( name, fn ) {
		jQuery.fn[ name ] = function( until, selector ) {
			var matched = jQuery.map( this, fn, until );

			if ( name.slice( -5 ) !== "Until" ) {
				selector = until;
			}

			if ( selector && typeof selector === "string" ) {
				matched = jQuery.filter( selector, matched );
			}

			if ( this.length > 1 ) {
				// Remove duplicates
				if ( !guaranteedUnique[ name ] ) {
					jQuery.unique( matched );
				}

				// Reverse order for parents* and prev-derivatives
				if ( rparentsprev.test( name ) ) {
					matched.reverse();
				}
			}

			return this.pushStack( matched );
		};
	});
	var rnotwhite = (/\S+/g);



	// String to Object options format cache
	var optionsCache = {};

	// Convert String-formatted options into Object-formatted ones and store in cache
	function createOptions( options ) {
		var object = optionsCache[ options ] = {};
		jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
			object[ flag ] = true;
		});
		return object;
	}

	/*
	 * Create a callback list using the following parameters:
	 *
	 *	options: an optional list of space-separated options that will change how
	 *			the callback list behaves or a more traditional option object
	 *
	 * By default a callback list will act like an event callback list and can be
	 * "fired" multiple times.
	 *
	 * Possible options:
	 *
	 *	once:			will ensure the callback list can only be fired once (like a Deferred)
	 *
	 *	memory:			will keep track of previous values and will call any callback added
	 *					after the list has been fired right away with the latest "memorized"
	 *					values (like a Deferred)
	 *
	 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
	 *
	 *	stopOnFalse:	interrupt callings when a callback returns false
	 *
	 */
	jQuery.Callbacks = function( options ) {

		// Convert options from String-formatted to Object-formatted if needed
		// (we check in cache first)
		options = typeof options === "string" ?
			( optionsCache[ options ] || createOptions( options ) ) :
			jQuery.extend( {}, options );

		var // Last fire value (for non-forgettable lists)
			memory,
			// Flag to know if list was already fired
			fired,
			// Flag to know if list is currently firing
			firing,
			// First callback to fire (used internally by add and fireWith)
			firingStart,
			// End of the loop when firing
			firingLength,
			// Index of currently firing callback (modified by remove if needed)
			firingIndex,
			// Actual callback list
			list = [],
			// Stack of fire calls for repeatable lists
			stack = !options.once && [],
			// Fire callbacks
			fire = function( data ) {
				memory = options.memory && data;
				fired = true;
				firingIndex = firingStart || 0;
				firingStart = 0;
				firingLength = list.length;
				firing = true;
				for ( ; list && firingIndex < firingLength; firingIndex++ ) {
					if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {
						memory = false; // To prevent further calls using add
						break;
					}
				}
				firing = false;
				if ( list ) {
					if ( stack ) {
						if ( stack.length ) {
							fire( stack.shift() );
						}
					} else if ( memory ) {
						list = [];
					} else {
						self.disable();
					}
				}
			},
			// Actual Callbacks object
			self = {
				// Add a callback or a collection of callbacks to the list
				add: function() {
					if ( list ) {
						// First, we save the current length
						var start = list.length;
						(function add( args ) {
							jQuery.each( args, function( _, arg ) {
								var type = jQuery.type( arg );
								if ( type === "function" ) {
									if ( !options.unique || !self.has( arg ) ) {
										list.push( arg );
									}
								} else if ( arg && arg.length && type !== "string" ) {
									// Inspect recursively
									add( arg );
								}
							});
						})( arguments );
						// Do we need to add the callbacks to the
						// current firing batch?
						if ( firing ) {
							firingLength = list.length;
						// With memory, if we're not firing then
						// we should call right away
						} else if ( memory ) {
							firingStart = start;
							fire( memory );
						}
					}
					return this;
				},
				// Remove a callback from the list
				remove: function() {
					if ( list ) {
						jQuery.each( arguments, function( _, arg ) {
							var index;
							while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
								list.splice( index, 1 );
								// Handle firing indexes
								if ( firing ) {
									if ( index <= firingLength ) {
										firingLength--;
									}
									if ( index <= firingIndex ) {
										firingIndex--;
									}
								}
							}
						});
					}
					return this;
				},
				// Check if a given callback is in the list.
				// If no argument is given, return whether or not list has callbacks attached.
				has: function( fn ) {
					return fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );
				},
				// Remove all callbacks from the list
				empty: function() {
					list = [];
					firingLength = 0;
					return this;
				},
				// Have the list do nothing anymore
				disable: function() {
					list = stack = memory = undefined;
					return this;
				},
				// Is it disabled?
				disabled: function() {
					return !list;
				},
				// Lock the list in its current state
				lock: function() {
					stack = undefined;
					if ( !memory ) {
						self.disable();
					}
					return this;
				},
				// Is it locked?
				locked: function() {
					return !stack;
				},
				// Call all callbacks with the given context and arguments
				fireWith: function( context, args ) {
					if ( list && ( !fired || stack ) ) {
						args = args || [];
						args = [ context, args.slice ? args.slice() : args ];
						if ( firing ) {
							stack.push( args );
						} else {
							fire( args );
						}
					}
					return this;
				},
				// Call all the callbacks with the given arguments
				fire: function() {
					self.fireWith( this, arguments );
					return this;
				},
				// To know if the callbacks have already been called at least once
				fired: function() {
					return !!fired;
				}
			};

		return self;
	};


	jQuery.extend({

		Deferred: function( func ) {
			var tuples = [
					// action, add listener, listener list, final state
					[ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ],
					[ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ],
					[ "notify", "progress", jQuery.Callbacks("memory") ]
				],
				state = "pending",
				promise = {
					state: function() {
						return state;
					},
					always: function() {
						deferred.done( arguments ).fail( arguments );
						return this;
					},
					then: function( /* fnDone, fnFail, fnProgress */ ) {
						var fns = arguments;
						return jQuery.Deferred(function( newDefer ) {
							jQuery.each( tuples, function( i, tuple ) {
								var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];
								// deferred[ done | fail | progress ] for forwarding actions to newDefer
								deferred[ tuple[1] ](function() {
									var returned = fn && fn.apply( this, arguments );
									if ( returned && jQuery.isFunction( returned.promise ) ) {
										returned.promise()
											.done( newDefer.resolve )
											.fail( newDefer.reject )
											.progress( newDefer.notify );
									} else {
										newDefer[ tuple[ 0 ] + "With" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );
									}
								});
							});
							fns = null;
						}).promise();
					},
					// Get a promise for this deferred
					// If obj is provided, the promise aspect is added to the object
					promise: function( obj ) {
						return obj != null ? jQuery.extend( obj, promise ) : promise;
					}
				},
				deferred = {};

			// Keep pipe for back-compat
			promise.pipe = promise.then;

			// Add list-specific methods
			jQuery.each( tuples, function( i, tuple ) {
				var list = tuple[ 2 ],
					stateString = tuple[ 3 ];

				// promise[ done | fail | progress ] = list.add
				promise[ tuple[1] ] = list.add;

				// Handle state
				if ( stateString ) {
					list.add(function() {
						// state = [ resolved | rejected ]
						state = stateString;

					// [ reject_list | resolve_list ].disable; progress_list.lock
					}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
				}

				// deferred[ resolve | reject | notify ]
				deferred[ tuple[0] ] = function() {
					deferred[ tuple[0] + "With" ]( this === deferred ? promise : this, arguments );
					return this;
				};
				deferred[ tuple[0] + "With" ] = list.fireWith;
			});

			// Make the deferred a promise
			promise.promise( deferred );

			// Call given func if any
			if ( func ) {
				func.call( deferred, deferred );
			}

			// All done!
			return deferred;
		},

		// Deferred helper
		when: function( subordinate /* , ..., subordinateN */ ) {
			var i = 0,
				resolveValues = slice.call( arguments ),
				length = resolveValues.length,

				// the count of uncompleted subordinates
				remaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,

				// the master Deferred. If resolveValues consist of only a single Deferred, just use that.
				deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

				// Update function for both resolve and progress values
				updateFunc = function( i, contexts, values ) {
					return function( value ) {
						contexts[ i ] = this;
						values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
						if ( values === progressValues ) {
							deferred.notifyWith( contexts, values );
						} else if ( !( --remaining ) ) {
							deferred.resolveWith( contexts, values );
						}
					};
				},

				progressValues, progressContexts, resolveContexts;

			// Add listeners to Deferred subordinates; treat others as resolved
			if ( length > 1 ) {
				progressValues = new Array( length );
				progressContexts = new Array( length );
				resolveContexts = new Array( length );
				for ( ; i < length; i++ ) {
					if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
						resolveValues[ i ].promise()
							.done( updateFunc( i, resolveContexts, resolveValues ) )
							.fail( deferred.reject )
							.progress( updateFunc( i, progressContexts, progressValues ) );
					} else {
						--remaining;
					}
				}
			}

			// If we're not waiting on anything, resolve the master
			if ( !remaining ) {
				deferred.resolveWith( resolveContexts, resolveValues );
			}

			return deferred.promise();
		}
	});


	// The deferred used on DOM ready
	var readyList;

	jQuery.fn.ready = function( fn ) {
		// Add the callback
		jQuery.ready.promise().done( fn );

		return this;
	};

	jQuery.extend({
		// Is the DOM ready to be used? Set to true once it occurs.
		isReady: false,

		// A counter to track how many items to wait for before
		// the ready event fires. See #6781
		readyWait: 1,

		// Hold (or release) the ready event
		holdReady: function( hold ) {
			if ( hold ) {
				jQuery.readyWait++;
			} else {
				jQuery.ready( true );
			}
		},

		// Handle when the DOM is ready
		ready: function( wait ) {

			// Abort if there are pending holds or we're already ready
			if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
				return;
			}

			// Remember that the DOM is ready
			jQuery.isReady = true;

			// If a normal DOM Ready event fired, decrement, and wait if need be
			if ( wait !== true && --jQuery.readyWait > 0 ) {
				return;
			}

			// If there are functions bound, to execute
			readyList.resolveWith( document, [ jQuery ] );

			// Trigger any bound ready events
			if ( jQuery.fn.triggerHandler ) {
				jQuery( document ).triggerHandler( "ready" );
				jQuery( document ).off( "ready" );
			}
		}
	});

	/**
	 * The ready event handler and self cleanup method
	 */
	function completed() {
		document.removeEventListener( "DOMContentLoaded", completed, false );
		window.removeEventListener( "load", completed, false );
		jQuery.ready();
	}

	jQuery.ready.promise = function( obj ) {
		if ( !readyList ) {

			readyList = jQuery.Deferred();

			// Catch cases where $(document).ready() is called after the browser event has already occurred.
			// We once tried to use readyState "interactive" here, but it caused issues like the one
			// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
			if ( document.readyState === "complete" ) {
				// Handle it asynchronously to allow scripts the opportunity to delay ready
				setTimeout( jQuery.ready );

			} else {

				// Use the handy event callback
				document.addEventListener( "DOMContentLoaded", completed, false );

				// A fallback to window.onload, that will always work
				window.addEventListener( "load", completed, false );
			}
		}
		return readyList.promise( obj );
	};

	// Kick off the DOM ready check even if the user does not
	jQuery.ready.promise();




	// Multifunctional method to get and set values of a collection
	// The value/s can optionally be executed if it's a function
	var access = jQuery.access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
		var i = 0,
			len = elems.length,
			bulk = key == null;

		// Sets many values
		if ( jQuery.type( key ) === "object" ) {
			chainable = true;
			for ( i in key ) {
				jQuery.access( elems, fn, i, key[i], true, emptyGet, raw );
			}

		// Sets one value
		} else if ( value !== undefined ) {
			chainable = true;

			if ( !jQuery.isFunction( value ) ) {
				raw = true;
			}

			if ( bulk ) {
				// Bulk operations run against the entire set
				if ( raw ) {
					fn.call( elems, value );
					fn = null;

				// ...except when executing function values
				} else {
					bulk = fn;
					fn = function( elem, key, value ) {
						return bulk.call( jQuery( elem ), value );
					};
				}
			}

			if ( fn ) {
				for ( ; i < len; i++ ) {
					fn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );
				}
			}
		}

		return chainable ?
			elems :

			// Gets
			bulk ?
				fn.call( elems ) :
				len ? fn( elems[0], key ) : emptyGet;
	};


	/**
	 * Determines whether an object can have data
	 */
	jQuery.acceptData = function( owner ) {
		// Accepts only:
		//  - Node
		//    - Node.ELEMENT_NODE
		//    - Node.DOCUMENT_NODE
		//  - Object
		//    - Any
		/* jshint -W018 */
		return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
	};


	function Data() {
		// Support: Android<4,
		// Old WebKit does not have Object.preventExtensions/freeze method,
		// return new empty object instead with no [[set]] accessor
		Object.defineProperty( this.cache = {}, 0, {
			get: function() {
				return {};
			}
		});

		this.expando = jQuery.expando + Data.uid++;
	}

	Data.uid = 1;
	Data.accepts = jQuery.acceptData;

	Data.prototype = {
		key: function( owner ) {
			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return the key for a frozen object.
			if ( !Data.accepts( owner ) ) {
				return 0;
			}

			var descriptor = {},
				// Check if the owner object already has a cache key
				unlock = owner[ this.expando ];

			// If not, create one
			if ( !unlock ) {
				unlock = Data.uid++;

				// Secure it in a non-enumerable, non-writable property
				try {
					descriptor[ this.expando ] = { value: unlock };
					Object.defineProperties( owner, descriptor );

				// Support: Android<4
				// Fallback to a less secure definition
				} catch ( e ) {
					descriptor[ this.expando ] = unlock;
					jQuery.extend( owner, descriptor );
				}
			}

			// Ensure the cache object
			if ( !this.cache[ unlock ] ) {
				this.cache[ unlock ] = {};
			}

			return unlock;
		},
		set: function( owner, data, value ) {
			var prop,
				// There may be an unlock assigned to this node,
				// if there is no entry for this "owner", create one inline
				// and set the unlock as though an owner entry had always existed
				unlock = this.key( owner ),
				cache = this.cache[ unlock ];

			// Handle: [ owner, key, value ] args
			if ( typeof data === "string" ) {
				cache[ data ] = value;

			// Handle: [ owner, { properties } ] args
			} else {
				// Fresh assignments by object are shallow copied
				if ( jQuery.isEmptyObject( cache ) ) {
					jQuery.extend( this.cache[ unlock ], data );
				// Otherwise, copy the properties one-by-one to the cache object
				} else {
					for ( prop in data ) {
						cache[ prop ] = data[ prop ];
					}
				}
			}
			return cache;
		},
		get: function( owner, key ) {
			// Either a valid cache is found, or will be created.
			// New caches will be created and the unlock returned,
			// allowing direct access to the newly created
			// empty data object. A valid owner object must be provided.
			var cache = this.cache[ this.key( owner ) ];

			return key === undefined ?
				cache : cache[ key ];
		},
		access: function( owner, key, value ) {
			var stored;
			// In cases where either:
			//
			//   1. No key was specified
			//   2. A string key was specified, but no value provided
			//
			// Take the "read" path and allow the get method to determine
			// which value to return, respectively either:
			//
			//   1. The entire cache object
			//   2. The data stored at the key
			//
			if ( key === undefined ||
					((key && typeof key === "string") && value === undefined) ) {

				stored = this.get( owner, key );

				return stored !== undefined ?
					stored : this.get( owner, jQuery.camelCase(key) );
			}

			// [*]When the key is not a string, or both a key and value
			// are specified, set or extend (existing objects) with either:
			//
			//   1. An object of properties
			//   2. A key and value
			//
			this.set( owner, key, value );

			// Since the "set" path can have two possible entry points
			// return the expected data based on which path was taken[*]
			return value !== undefined ? value : key;
		},
		remove: function( owner, key ) {
			var i, name, camel,
				unlock = this.key( owner ),
				cache = this.cache[ unlock ];

			if ( key === undefined ) {
				this.cache[ unlock ] = {};

			} else {
				// Support array or space separated string of keys
				if ( jQuery.isArray( key ) ) {
					// If "name" is an array of keys...
					// When data is initially created, via ("key", "val") signature,
					// keys will be converted to camelCase.
					// Since there is no way to tell _how_ a key was added, remove
					// both plain key and camelCase key. #12786
					// This will only penalize the array argument path.
					name = key.concat( key.map( jQuery.camelCase ) );
				} else {
					camel = jQuery.camelCase( key );
					// Try the string as a key before any manipulation
					if ( key in cache ) {
						name = [ key, camel ];
					} else {
						// If a key with the spaces exists, use it.
						// Otherwise, create an array by matching non-whitespace
						name = camel;
						name = name in cache ?
							[ name ] : ( name.match( rnotwhite ) || [] );
					}
				}

				i = name.length;
				while ( i-- ) {
					delete cache[ name[ i ] ];
				}
			}
		},
		hasData: function( owner ) {
			return !jQuery.isEmptyObject(
				this.cache[ owner[ this.expando ] ] || {}
			);
		},
		discard: function( owner ) {
			if ( owner[ this.expando ] ) {
				delete this.cache[ owner[ this.expando ] ];
			}
		}
	};
	var data_priv = new Data();

	var data_user = new Data();



	//	Implementation Summary
	//
	//	1. Enforce API surface and semantic compatibility with 1.9.x branch
	//	2. Improve the module's maintainability by reducing the storage
	//		paths to a single mechanism.
	//	3. Use the same single mechanism to support "private" and "user" data.
	//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
	//	5. Avoid exposing implementation details on user objects (eg. expando properties)
	//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

	var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
		rmultiDash = /([A-Z])/g;

	function dataAttr( elem, key, data ) {
		var name;

		// If nothing was found internally, try to fetch any
		// data from the HTML5 data-* attribute
		if ( data === undefined && elem.nodeType === 1 ) {
			name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();
			data = elem.getAttribute( name );

			if ( typeof data === "string" ) {
				try {
					data = data === "true" ? true :
						data === "false" ? false :
						data === "null" ? null :
						// Only convert to a number if it doesn't change the string
						+data + "" === data ? +data :
						rbrace.test( data ) ? jQuery.parseJSON( data ) :
						data;
				} catch( e ) {}

				// Make sure we set the data so it isn't changed later
				data_user.set( elem, key, data );
			} else {
				data = undefined;
			}
		}
		return data;
	}

	jQuery.extend({
		hasData: function( elem ) {
			return data_user.hasData( elem ) || data_priv.hasData( elem );
		},

		data: function( elem, name, data ) {
			return data_user.access( elem, name, data );
		},

		removeData: function( elem, name ) {
			data_user.remove( elem, name );
		},

		// TODO: Now that all calls to _data and _removeData have been replaced
		// with direct calls to data_priv methods, these can be deprecated.
		_data: function( elem, name, data ) {
			return data_priv.access( elem, name, data );
		},

		_removeData: function( elem, name ) {
			data_priv.remove( elem, name );
		}
	});

	jQuery.fn.extend({
		data: function( key, value ) {
			var i, name, data,
				elem = this[ 0 ],
				attrs = elem && elem.attributes;

			// Gets all values
			if ( key === undefined ) {
				if ( this.length ) {
					data = data_user.get( elem );

					if ( elem.nodeType === 1 && !data_priv.get( elem, "hasDataAttrs" ) ) {
						i = attrs.length;
						while ( i-- ) {

							// Support: IE11+
							// The attrs elements can be null (#14894)
							if ( attrs[ i ] ) {
								name = attrs[ i ].name;
								if ( name.indexOf( "data-" ) === 0 ) {
									name = jQuery.camelCase( name.slice(5) );
									dataAttr( elem, name, data[ name ] );
								}
							}
						}
						data_priv.set( elem, "hasDataAttrs", true );
					}
				}

				return data;
			}

			// Sets multiple values
			if ( typeof key === "object" ) {
				return this.each(function() {
					data_user.set( this, key );
				});
			}

			return access( this, function( value ) {
				var data,
					camelKey = jQuery.camelCase( key );

				// The calling jQuery object (element matches) is not empty
				// (and therefore has an element appears at this[ 0 ]) and the
				// `value` parameter was not undefined. An empty jQuery object
				// will result in `undefined` for elem = this[ 0 ] which will
				// throw an exception if an attempt to read a data cache is made.
				if ( elem && value === undefined ) {
					// Attempt to get data from the cache
					// with the key as-is
					data = data_user.get( elem, key );
					if ( data !== undefined ) {
						return data;
					}

					// Attempt to get data from the cache
					// with the key camelized
					data = data_user.get( elem, camelKey );
					if ( data !== undefined ) {
						return data;
					}

					// Attempt to "discover" the data in
					// HTML5 custom data-* attrs
					data = dataAttr( elem, camelKey, undefined );
					if ( data !== undefined ) {
						return data;
					}

					// We tried really hard, but the data doesn't exist.
					return;
				}

				// Set the data...
				this.each(function() {
					// First, attempt to store a copy or reference of any
					// data that might've been store with a camelCased key.
					var data = data_user.get( this, camelKey );

					// For HTML5 data-* attribute interop, we have to
					// store property names with dashes in a camelCase form.
					// This might not apply to all properties...*
					data_user.set( this, camelKey, value );

					// *... In the case of properties that might _actually_
					// have dashes, we need to also store a copy of that
					// unchanged property.
					if ( key.indexOf("-") !== -1 && data !== undefined ) {
						data_user.set( this, key, value );
					}
				});
			}, null, value, arguments.length > 1, null, true );
		},

		removeData: function( key ) {
			return this.each(function() {
				data_user.remove( this, key );
			});
		}
	});


	jQuery.extend({
		queue: function( elem, type, data ) {
			var queue;

			if ( elem ) {
				type = ( type || "fx" ) + "queue";
				queue = data_priv.get( elem, type );

				// Speed up dequeue by getting out quickly if this is just a lookup
				if ( data ) {
					if ( !queue || jQuery.isArray( data ) ) {
						queue = data_priv.access( elem, type, jQuery.makeArray(data) );
					} else {
						queue.push( data );
					}
				}
				return queue || [];
			}
		},

		dequeue: function( elem, type ) {
			type = type || "fx";

			var queue = jQuery.queue( elem, type ),
				startLength = queue.length,
				fn = queue.shift(),
				hooks = jQuery._queueHooks( elem, type ),
				next = function() {
					jQuery.dequeue( elem, type );
				};

			// If the fx queue is dequeued, always remove the progress sentinel
			if ( fn === "inprogress" ) {
				fn = queue.shift();
				startLength--;
			}

			if ( fn ) {

				// Add a progress sentinel to prevent the fx queue from being
				// automatically dequeued
				if ( type === "fx" ) {
					queue.unshift( "inprogress" );
				}

				// Clear up the last queue stop function
				delete hooks.stop;
				fn.call( elem, next, hooks );
			}

			if ( !startLength && hooks ) {
				hooks.empty.fire();
			}
		},

		// Not public - generate a queueHooks object, or return the current one
		_queueHooks: function( elem, type ) {
			var key = type + "queueHooks";
			return data_priv.get( elem, key ) || data_priv.access( elem, key, {
				empty: jQuery.Callbacks("once memory").add(function() {
					data_priv.remove( elem, [ type + "queue", key ] );
				})
			});
		}
	});

	jQuery.fn.extend({
		queue: function( type, data ) {
			var setter = 2;

			if ( typeof type !== "string" ) {
				data = type;
				type = "fx";
				setter--;
			}

			if ( arguments.length < setter ) {
				return jQuery.queue( this[0], type );
			}

			return data === undefined ?
				this :
				this.each(function() {
					var queue = jQuery.queue( this, type, data );

					// Ensure a hooks for this queue
					jQuery._queueHooks( this, type );

					if ( type === "fx" && queue[0] !== "inprogress" ) {
						jQuery.dequeue( this, type );
					}
				});
		},
		dequeue: function( type ) {
			return this.each(function() {
				jQuery.dequeue( this, type );
			});
		},
		clearQueue: function( type ) {
			return this.queue( type || "fx", [] );
		},
		// Get a promise resolved when queues of a certain type
		// are emptied (fx is the type by default)
		promise: function( type, obj ) {
			var tmp,
				count = 1,
				defer = jQuery.Deferred(),
				elements = this,
				i = this.length,
				resolve = function() {
					if ( !( --count ) ) {
						defer.resolveWith( elements, [ elements ] );
					}
				};

			if ( typeof type !== "string" ) {
				obj = type;
				type = undefined;
			}
			type = type || "fx";

			while ( i-- ) {
				tmp = data_priv.get( elements[ i ], type + "queueHooks" );
				if ( tmp && tmp.empty ) {
					count++;
					tmp.empty.add( resolve );
				}
			}
			resolve();
			return defer.promise( obj );
		}
	});
	var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;

	var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

	var isHidden = function( elem, el ) {
			// isHidden might be called from jQuery#filter function;
			// in that case, element will be second argument
			elem = el || elem;
			return jQuery.css( elem, "display" ) === "none" || !jQuery.contains( elem.ownerDocument, elem );
		};

	var rcheckableType = (/^(?:checkbox|radio)$/i);



	(function() {
		var fragment = document.createDocumentFragment(),
			div = fragment.appendChild( document.createElement( "div" ) ),
			input = document.createElement( "input" );

		// Support: Safari<=5.1
		// Check state lost if the name is set (#11217)
		// Support: Windows Web Apps (WWA)
		// `name` and `type` must use .setAttribute for WWA (#14901)
		input.setAttribute( "type", "radio" );
		input.setAttribute( "checked", "checked" );
		input.setAttribute( "name", "t" );

		div.appendChild( input );

		// Support: Safari<=5.1, Android<4.2
		// Older WebKit doesn't clone checked state correctly in fragments
		support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

		// Support: IE<=11+
		// Make sure textarea (and checkbox) defaultValue is properly cloned
		div.innerHTML = "<textarea>x</textarea>";
		support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
	})();
	var strundefined = typeof undefined;



	support.focusinBubbles = "onfocusin" in window;


	var
		rkeyEvent = /^key/,
		rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,
		rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
		rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;

	function returnTrue() {
		return true;
	}

	function returnFalse() {
		return false;
	}

	function safeActiveElement() {
		try {
			return document.activeElement;
		} catch ( err ) { }
	}

	/*
	 * Helper functions for managing events -- not part of the public interface.
	 * Props to Dean Edwards' addEvent library for many of the ideas.
	 */
	jQuery.event = {

		global: {},

		add: function( elem, types, handler, data, selector ) {

			var handleObjIn, eventHandle, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = data_priv.get( elem );

			// Don't attach events to noData or text/comment nodes (but allow plain objects)
			if ( !elemData ) {
				return;
			}

			// Caller can pass in an object of custom data in lieu of the handler
			if ( handler.handler ) {
				handleObjIn = handler;
				handler = handleObjIn.handler;
				selector = handleObjIn.selector;
			}

			// Make sure that the handler has a unique ID, used to find/remove it later
			if ( !handler.guid ) {
				handler.guid = jQuery.guid++;
			}

			// Init the element's event structure and main handler, if this is the first
			if ( !(events = elemData.events) ) {
				events = elemData.events = {};
			}
			if ( !(eventHandle = elemData.handle) ) {
				eventHandle = elemData.handle = function( e ) {
					// Discard the second event of a jQuery.event.trigger() and
					// when an event is called after a page has unloaded
					return typeof jQuery !== strundefined && jQuery.event.triggered !== e.type ?
						jQuery.event.dispatch.apply( elem, arguments ) : undefined;
				};
			}

			// Handle multiple events separated by a space
			types = ( types || "" ).match( rnotwhite ) || [ "" ];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[t] ) || [];
				type = origType = tmp[1];
				namespaces = ( tmp[2] || "" ).split( "." ).sort();

				// There *must* be a type, no attaching namespace-only handlers
				if ( !type ) {
					continue;
				}

				// If event changes its type, use the special event handlers for the changed type
				special = jQuery.event.special[ type ] || {};

				// If selector defined, determine special event api type, otherwise given type
				type = ( selector ? special.delegateType : special.bindType ) || type;

				// Update special based on newly reset type
				special = jQuery.event.special[ type ] || {};

				// handleObj is passed to all event handlers
				handleObj = jQuery.extend({
					type: type,
					origType: origType,
					data: data,
					handler: handler,
					guid: handler.guid,
					selector: selector,
					needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
					namespace: namespaces.join(".")
				}, handleObjIn );

				// Init the event handler queue if we're the first
				if ( !(handlers = events[ type ]) ) {
					handlers = events[ type ] = [];
					handlers.delegateCount = 0;

					// Only use addEventListener if the special events handler returns false
					if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
						if ( elem.addEventListener ) {
							elem.addEventListener( type, eventHandle, false );
						}
					}
				}

				if ( special.add ) {
					special.add.call( elem, handleObj );

					if ( !handleObj.handler.guid ) {
						handleObj.handler.guid = handler.guid;
					}
				}

				// Add to the element's handler list, delegates in front
				if ( selector ) {
					handlers.splice( handlers.delegateCount++, 0, handleObj );
				} else {
					handlers.push( handleObj );
				}

				// Keep track of which events have ever been used, for event optimization
				jQuery.event.global[ type ] = true;
			}

		},

		// Detach an event or set of events from an element
		remove: function( elem, types, handler, selector, mappedTypes ) {

			var j, origCount, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = data_priv.hasData( elem ) && data_priv.get( elem );

			if ( !elemData || !(events = elemData.events) ) {
				return;
			}

			// Once for each type.namespace in types; type may be omitted
			types = ( types || "" ).match( rnotwhite ) || [ "" ];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[t] ) || [];
				type = origType = tmp[1];
				namespaces = ( tmp[2] || "" ).split( "." ).sort();

				// Unbind all events (on this namespace, if provided) for the element
				if ( !type ) {
					for ( type in events ) {
						jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
					}
					continue;
				}

				special = jQuery.event.special[ type ] || {};
				type = ( selector ? special.delegateType : special.bindType ) || type;
				handlers = events[ type ] || [];
				tmp = tmp[2] && new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" );

				// Remove matching events
				origCount = j = handlers.length;
				while ( j-- ) {
					handleObj = handlers[ j ];

					if ( ( mappedTypes || origType === handleObj.origType ) &&
						( !handler || handler.guid === handleObj.guid ) &&
						( !tmp || tmp.test( handleObj.namespace ) ) &&
						( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
						handlers.splice( j, 1 );

						if ( handleObj.selector ) {
							handlers.delegateCount--;
						}
						if ( special.remove ) {
							special.remove.call( elem, handleObj );
						}
					}
				}

				// Remove generic event handler if we removed something and no more handlers exist
				// (avoids potential for endless recursion during removal of special event handlers)
				if ( origCount && !handlers.length ) {
					if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
						jQuery.removeEvent( elem, type, elemData.handle );
					}

					delete events[ type ];
				}
			}

			// Remove the expando if it's no longer used
			if ( jQuery.isEmptyObject( events ) ) {
				delete elemData.handle;
				data_priv.remove( elem, "events" );
			}
		},

		trigger: function( event, data, elem, onlyHandlers ) {

			var i, cur, tmp, bubbleType, ontype, handle, special,
				eventPath = [ elem || document ],
				type = hasOwn.call( event, "type" ) ? event.type : event,
				namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split(".") : [];

			cur = tmp = elem = elem || document;

			// Don't do events on text and comment nodes
			if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
				return;
			}

			// focus/blur morphs to focusin/out; ensure we're not firing them right now
			if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
				return;
			}

			if ( type.indexOf(".") >= 0 ) {
				// Namespaced trigger; create a regexp to match event type in handle()
				namespaces = type.split(".");
				type = namespaces.shift();
				namespaces.sort();
			}
			ontype = type.indexOf(":") < 0 && "on" + type;

			// Caller can pass in a jQuery.Event object, Object, or just an event type string
			event = event[ jQuery.expando ] ?
				event :
				new jQuery.Event( type, typeof event === "object" && event );

			// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
			event.isTrigger = onlyHandlers ? 2 : 3;
			event.namespace = namespaces.join(".");
			event.namespace_re = event.namespace ?
				new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" ) :
				null;

			// Clean up the event in case it is being reused
			event.result = undefined;
			if ( !event.target ) {
				event.target = elem;
			}

			// Clone any incoming data and prepend the event, creating the handler arg list
			data = data == null ?
				[ event ] :
				jQuery.makeArray( data, [ event ] );

			// Allow special events to draw outside the lines
			special = jQuery.event.special[ type ] || {};
			if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
				return;
			}

			// Determine event propagation path in advance, per W3C events spec (#9951)
			// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
			if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

				bubbleType = special.delegateType || type;
				if ( !rfocusMorph.test( bubbleType + type ) ) {
					cur = cur.parentNode;
				}
				for ( ; cur; cur = cur.parentNode ) {
					eventPath.push( cur );
					tmp = cur;
				}

				// Only add window if we got to document (e.g., not plain obj or detached DOM)
				if ( tmp === (elem.ownerDocument || document) ) {
					eventPath.push( tmp.defaultView || tmp.parentWindow || window );
				}
			}

			// Fire handlers on the event path
			i = 0;
			while ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {

				event.type = i > 1 ?
					bubbleType :
					special.bindType || type;

				// jQuery handler
				handle = ( data_priv.get( cur, "events" ) || {} )[ event.type ] && data_priv.get( cur, "handle" );
				if ( handle ) {
					handle.apply( cur, data );
				}

				// Native handler
				handle = ontype && cur[ ontype ];
				if ( handle && handle.apply && jQuery.acceptData( cur ) ) {
					event.result = handle.apply( cur, data );
					if ( event.result === false ) {
						event.preventDefault();
					}
				}
			}
			event.type = type;

			// If nobody prevented the default action, do it now
			if ( !onlyHandlers && !event.isDefaultPrevented() ) {

				if ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&
					jQuery.acceptData( elem ) ) {

					// Call a native DOM method on the target with the same name name as the event.
					// Don't do default actions on window, that's where global variables be (#6170)
					if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {

						// Don't re-trigger an onFOO event when we call its FOO() method
						tmp = elem[ ontype ];

						if ( tmp ) {
							elem[ ontype ] = null;
						}

						// Prevent re-triggering of the same event, since we already bubbled it above
						jQuery.event.triggered = type;
						elem[ type ]();
						jQuery.event.triggered = undefined;

						if ( tmp ) {
							elem[ ontype ] = tmp;
						}
					}
				}
			}

			return event.result;
		},

		dispatch: function( event ) {

			// Make a writable jQuery.Event from the native event object
			event = jQuery.event.fix( event );

			var i, j, ret, matched, handleObj,
				handlerQueue = [],
				args = slice.call( arguments ),
				handlers = ( data_priv.get( this, "events" ) || {} )[ event.type ] || [],
				special = jQuery.event.special[ event.type ] || {};

			// Use the fix-ed jQuery.Event rather than the (read-only) native event
			args[0] = event;
			event.delegateTarget = this;

			// Call the preDispatch hook for the mapped type, and let it bail if desired
			if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
				return;
			}

			// Determine handlers
			handlerQueue = jQuery.event.handlers.call( this, event, handlers );

			// Run delegates first; they may want to stop propagation beneath us
			i = 0;
			while ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {
				event.currentTarget = matched.elem;

				j = 0;
				while ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {

					// Triggered event must either 1) have no namespace, or 2) have namespace(s)
					// a subset or equal to those in the bound event (both can have no namespace).
					if ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {

						event.handleObj = handleObj;
						event.data = handleObj.data;

						ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
								.apply( matched.elem, args );

						if ( ret !== undefined ) {
							if ( (event.result = ret) === false ) {
								event.preventDefault();
								event.stopPropagation();
							}
						}
					}
				}
			}

			// Call the postDispatch hook for the mapped type
			if ( special.postDispatch ) {
				special.postDispatch.call( this, event );
			}

			return event.result;
		},

		handlers: function( event, handlers ) {
			var i, matches, sel, handleObj,
				handlerQueue = [],
				delegateCount = handlers.delegateCount,
				cur = event.target;

			// Find delegate handlers
			// Black-hole SVG <use> instance trees (#13180)
			// Avoid non-left-click bubbling in Firefox (#3861)
			if ( delegateCount && cur.nodeType && (!event.button || event.type !== "click") ) {

				for ( ; cur !== this; cur = cur.parentNode || this ) {

					// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
					if ( cur.disabled !== true || event.type !== "click" ) {
						matches = [];
						for ( i = 0; i < delegateCount; i++ ) {
							handleObj = handlers[ i ];

							// Don't conflict with Object.prototype properties (#13203)
							sel = handleObj.selector + " ";

							if ( matches[ sel ] === undefined ) {
								matches[ sel ] = handleObj.needsContext ?
									jQuery( sel, this ).index( cur ) >= 0 :
									jQuery.find( sel, this, null, [ cur ] ).length;
							}
							if ( matches[ sel ] ) {
								matches.push( handleObj );
							}
						}
						if ( matches.length ) {
							handlerQueue.push({ elem: cur, handlers: matches });
						}
					}
				}
			}

			// Add the remaining (directly-bound) handlers
			if ( delegateCount < handlers.length ) {
				handlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });
			}

			return handlerQueue;
		},

		// Includes some event props shared by KeyEvent and MouseEvent
		props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

		fixHooks: {},

		keyHooks: {
			props: "char charCode key keyCode".split(" "),
			filter: function( event, original ) {

				// Add which for key events
				if ( event.which == null ) {
					event.which = original.charCode != null ? original.charCode : original.keyCode;
				}

				return event;
			}
		},

		mouseHooks: {
			props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
			filter: function( event, original ) {
				var eventDoc, doc, body,
					button = original.button;

				// Calculate pageX/Y if missing and clientX/Y available
				if ( event.pageX == null && original.clientX != null ) {
					eventDoc = event.target.ownerDocument || document;
					doc = eventDoc.documentElement;
					body = eventDoc.body;

					event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
					event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
				}

				// Add which for click: 1 === left; 2 === middle; 3 === right
				// Note: button is not normalized, so don't use it
				if ( !event.which && button !== undefined ) {
					event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
				}

				return event;
			}
		},

		fix: function( event ) {
			if ( event[ jQuery.expando ] ) {
				return event;
			}

			// Create a writable copy of the event object and normalize some properties
			var i, prop, copy,
				type = event.type,
				originalEvent = event,
				fixHook = this.fixHooks[ type ];

			if ( !fixHook ) {
				this.fixHooks[ type ] = fixHook =
					rmouseEvent.test( type ) ? this.mouseHooks :
					rkeyEvent.test( type ) ? this.keyHooks :
					{};
			}
			copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

			event = new jQuery.Event( originalEvent );

			i = copy.length;
			while ( i-- ) {
				prop = copy[ i ];
				event[ prop ] = originalEvent[ prop ];
			}

			// Support: Cordova 2.5 (WebKit) (#13255)
			// All events should have a target; Cordova deviceready doesn't
			if ( !event.target ) {
				event.target = document;
			}

			// Support: Safari 6.0+, Chrome<28
			// Target should not be a text node (#504, #13143)
			if ( event.target.nodeType === 3 ) {
				event.target = event.target.parentNode;
			}

			return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
		},

		special: {
			load: {
				// Prevent triggered image.load events from bubbling to window.load
				noBubble: true
			},
			focus: {
				// Fire native event if possible so blur/focus sequence is correct
				trigger: function() {
					if ( this !== safeActiveElement() && this.focus ) {
						this.focus();
						return false;
					}
				},
				delegateType: "focusin"
			},
			blur: {
				trigger: function() {
					if ( this === safeActiveElement() && this.blur ) {
						this.blur();
						return false;
					}
				},
				delegateType: "focusout"
			},
			click: {
				// For checkbox, fire native event so checked state will be right
				trigger: function() {
					if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
						this.click();
						return false;
					}
				},

				// For cross-browser consistency, don't fire native .click() on links
				_default: function( event ) {
					return jQuery.nodeName( event.target, "a" );
				}
			},

			beforeunload: {
				postDispatch: function( event ) {

					// Support: Firefox 20+
					// Firefox doesn't alert if the returnValue field is not set.
					if ( event.result !== undefined && event.originalEvent ) {
						event.originalEvent.returnValue = event.result;
					}
				}
			}
		},

		simulate: function( type, elem, event, bubble ) {
			// Piggyback on a donor event to simulate a different one.
			// Fake originalEvent to avoid donor's stopPropagation, but if the
			// simulated event prevents default then we do the same on the donor.
			var e = jQuery.extend(
				new jQuery.Event(),
				event,
				{
					type: type,
					isSimulated: true,
					originalEvent: {}
				}
			);
			if ( bubble ) {
				jQuery.event.trigger( e, null, elem );
			} else {
				jQuery.event.dispatch.call( elem, e );
			}
			if ( e.isDefaultPrevented() ) {
				event.preventDefault();
			}
		}
	};

	jQuery.removeEvent = function( elem, type, handle ) {
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle, false );
		}
	};

	jQuery.Event = function( src, props ) {
		// Allow instantiation without the 'new' keyword
		if ( !(this instanceof jQuery.Event) ) {
			return new jQuery.Event( src, props );
		}

		// Event object
		if ( src && src.type ) {
			this.originalEvent = src;
			this.type = src.type;

			// Events bubbling up the document may have been marked as prevented
			// by a handler lower down the tree; reflect the correct value.
			this.isDefaultPrevented = src.defaultPrevented ||
					src.defaultPrevented === undefined &&
					// Support: Android<4.0
					src.returnValue === false ?
				returnTrue :
				returnFalse;

		// Event type
		} else {
			this.type = src;
		}

		// Put explicitly provided properties onto the event object
		if ( props ) {
			jQuery.extend( this, props );
		}

		// Create a timestamp if incoming event doesn't have one
		this.timeStamp = src && src.timeStamp || jQuery.now();

		// Mark it as fixed
		this[ jQuery.expando ] = true;
	};

	// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
	// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
	jQuery.Event.prototype = {
		isDefaultPrevented: returnFalse,
		isPropagationStopped: returnFalse,
		isImmediatePropagationStopped: returnFalse,

		preventDefault: function() {
			var e = this.originalEvent;

			this.isDefaultPrevented = returnTrue;

			if ( e && e.preventDefault ) {
				e.preventDefault();
			}
		},
		stopPropagation: function() {
			var e = this.originalEvent;

			this.isPropagationStopped = returnTrue;

			if ( e && e.stopPropagation ) {
				e.stopPropagation();
			}
		},
		stopImmediatePropagation: function() {
			var e = this.originalEvent;

			this.isImmediatePropagationStopped = returnTrue;

			if ( e && e.stopImmediatePropagation ) {
				e.stopImmediatePropagation();
			}

			this.stopPropagation();
		}
	};

	// Create mouseenter/leave events using mouseover/out and event-time checks
	// Support: Chrome 15+
	jQuery.each({
		mouseenter: "mouseover",
		mouseleave: "mouseout",
		pointerenter: "pointerover",
		pointerleave: "pointerout"
	}, function( orig, fix ) {
		jQuery.event.special[ orig ] = {
			delegateType: fix,
			bindType: fix,

			handle: function( event ) {
				var ret,
					target = this,
					related = event.relatedTarget,
					handleObj = event.handleObj;

				// For mousenter/leave call the handler if related is outside the target.
				// NB: No relatedTarget if the mouse left/entered the browser window
				if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
					event.type = handleObj.origType;
					ret = handleObj.handler.apply( this, arguments );
					event.type = fix;
				}
				return ret;
			}
		};
	});

	// Support: Firefox, Chrome, Safari
	// Create "bubbling" focus and blur events
	if ( !support.focusinBubbles ) {
		jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

			// Attach a single capturing handler on the document while someone wants focusin/focusout
			var handler = function( event ) {
					jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
				};

			jQuery.event.special[ fix ] = {
				setup: function() {
					var doc = this.ownerDocument || this,
						attaches = data_priv.access( doc, fix );

					if ( !attaches ) {
						doc.addEventListener( orig, handler, true );
					}
					data_priv.access( doc, fix, ( attaches || 0 ) + 1 );
				},
				teardown: function() {
					var doc = this.ownerDocument || this,
						attaches = data_priv.access( doc, fix ) - 1;

					if ( !attaches ) {
						doc.removeEventListener( orig, handler, true );
						data_priv.remove( doc, fix );

					} else {
						data_priv.access( doc, fix, attaches );
					}
				}
			};
		});
	}

	jQuery.fn.extend({

		on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
			var origFn, type;

			// Types can be a map of types/handlers
			if ( typeof types === "object" ) {
				// ( types-Object, selector, data )
				if ( typeof selector !== "string" ) {
					// ( types-Object, data )
					data = data || selector;
					selector = undefined;
				}
				for ( type in types ) {
					this.on( type, selector, data, types[ type ], one );
				}
				return this;
			}

			if ( data == null && fn == null ) {
				// ( types, fn )
				fn = selector;
				data = selector = undefined;
			} else if ( fn == null ) {
				if ( typeof selector === "string" ) {
					// ( types, selector, fn )
					fn = data;
					data = undefined;
				} else {
					// ( types, data, fn )
					fn = data;
					data = selector;
					selector = undefined;
				}
			}
			if ( fn === false ) {
				fn = returnFalse;
			} else if ( !fn ) {
				return this;
			}

			if ( one === 1 ) {
				origFn = fn;
				fn = function( event ) {
					// Can use an empty set, since event contains the info
					jQuery().off( event );
					return origFn.apply( this, arguments );
				};
				// Use same guid so caller can remove using origFn
				fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
			}
			return this.each( function() {
				jQuery.event.add( this, types, fn, data, selector );
			});
		},
		one: function( types, selector, data, fn ) {
			return this.on( types, selector, data, fn, 1 );
		},
		off: function( types, selector, fn ) {
			var handleObj, type;
			if ( types && types.preventDefault && types.handleObj ) {
				// ( event )  dispatched jQuery.Event
				handleObj = types.handleObj;
				jQuery( types.delegateTarget ).off(
					handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
					handleObj.selector,
					handleObj.handler
				);
				return this;
			}
			if ( typeof types === "object" ) {
				// ( types-object [, selector] )
				for ( type in types ) {
					this.off( type, selector, types[ type ] );
				}
				return this;
			}
			if ( selector === false || typeof selector === "function" ) {
				// ( types [, fn] )
				fn = selector;
				selector = undefined;
			}
			if ( fn === false ) {
				fn = returnFalse;
			}
			return this.each(function() {
				jQuery.event.remove( this, types, fn, selector );
			});
		},

		trigger: function( type, data ) {
			return this.each(function() {
				jQuery.event.trigger( type, data, this );
			});
		},
		triggerHandler: function( type, data ) {
			var elem = this[0];
			if ( elem ) {
				return jQuery.event.trigger( type, data, elem, true );
			}
		}
	});


	var
		rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
		rtagName = /<([\w:]+)/,
		rhtml = /<|&#?\w+;/,
		rnoInnerhtml = /<(?:script|style|link)/i,
		// checked="checked" or checked
		rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
		rscriptType = /^$|\/(?:java|ecma)script/i,
		rscriptTypeMasked = /^true\/(.*)/,
		rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,

		// We have to close these tags to support XHTML (#13200)
		wrapMap = {

			// Support: IE9
			option: [ 1, "<select multiple='multiple'>", "</select>" ],

			thead: [ 1, "<table>", "</table>" ],
			col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
			tr: [ 2, "<table><tbody>", "</tbody></table>" ],
			td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

			_default: [ 0, "", "" ]
		};

	// Support: IE9
	wrapMap.optgroup = wrapMap.option;

	wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
	wrapMap.th = wrapMap.td;

	// Support: 1.x compatibility
	// Manipulating tables requires a tbody
	function manipulationTarget( elem, content ) {
		return jQuery.nodeName( elem, "table" ) &&
			jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ?

			elem.getElementsByTagName("tbody")[0] ||
				elem.appendChild( elem.ownerDocument.createElement("tbody") ) :
			elem;
	}

	// Replace/restore the type attribute of script elements for safe DOM manipulation
	function disableScript( elem ) {
		elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
		return elem;
	}
	function restoreScript( elem ) {
		var match = rscriptTypeMasked.exec( elem.type );

		if ( match ) {
			elem.type = match[ 1 ];
		} else {
			elem.removeAttribute("type");
		}

		return elem;
	}

	// Mark scripts as having already been evaluated
	function setGlobalEval( elems, refElements ) {
		var i = 0,
			l = elems.length;

		for ( ; i < l; i++ ) {
			data_priv.set(
				elems[ i ], "globalEval", !refElements || data_priv.get( refElements[ i ], "globalEval" )
			);
		}
	}

	function cloneCopyEvent( src, dest ) {
		var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

		if ( dest.nodeType !== 1 ) {
			return;
		}

		// 1. Copy private data: events, handlers, etc.
		if ( data_priv.hasData( src ) ) {
			pdataOld = data_priv.access( src );
			pdataCur = data_priv.set( dest, pdataOld );
			events = pdataOld.events;

			if ( events ) {
				delete pdataCur.handle;
				pdataCur.events = {};

				for ( type in events ) {
					for ( i = 0, l = events[ type ].length; i < l; i++ ) {
						jQuery.event.add( dest, type, events[ type ][ i ] );
					}
				}
			}
		}

		// 2. Copy user data
		if ( data_user.hasData( src ) ) {
			udataOld = data_user.access( src );
			udataCur = jQuery.extend( {}, udataOld );

			data_user.set( dest, udataCur );
		}
	}

	function getAll( context, tag ) {
		var ret = context.getElementsByTagName ? context.getElementsByTagName( tag || "*" ) :
				context.querySelectorAll ? context.querySelectorAll( tag || "*" ) :
				[];

		return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
			jQuery.merge( [ context ], ret ) :
			ret;
	}

	// Fix IE bugs, see support tests
	function fixInput( src, dest ) {
		var nodeName = dest.nodeName.toLowerCase();

		// Fails to persist the checked state of a cloned checkbox or radio button.
		if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
			dest.checked = src.checked;

		// Fails to return the selected option to the default selected state when cloning options
		} else if ( nodeName === "input" || nodeName === "textarea" ) {
			dest.defaultValue = src.defaultValue;
		}
	}

	jQuery.extend({
		clone: function( elem, dataAndEvents, deepDataAndEvents ) {
			var i, l, srcElements, destElements,
				clone = elem.cloneNode( true ),
				inPage = jQuery.contains( elem.ownerDocument, elem );

			// Fix IE cloning issues
			if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
					!jQuery.isXMLDoc( elem ) ) {

				// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
				destElements = getAll( clone );
				srcElements = getAll( elem );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					fixInput( srcElements[ i ], destElements[ i ] );
				}
			}

			// Copy the events from the original to the clone
			if ( dataAndEvents ) {
				if ( deepDataAndEvents ) {
					srcElements = srcElements || getAll( elem );
					destElements = destElements || getAll( clone );

					for ( i = 0, l = srcElements.length; i < l; i++ ) {
						cloneCopyEvent( srcElements[ i ], destElements[ i ] );
					}
				} else {
					cloneCopyEvent( elem, clone );
				}
			}

			// Preserve script evaluation history
			destElements = getAll( clone, "script" );
			if ( destElements.length > 0 ) {
				setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
			}

			// Return the cloned set
			return clone;
		},

		buildFragment: function( elems, context, scripts, selection ) {
			var elem, tmp, tag, wrap, contains, j,
				fragment = context.createDocumentFragment(),
				nodes = [],
				i = 0,
				l = elems.length;

			for ( ; i < l; i++ ) {
				elem = elems[ i ];

				if ( elem || elem === 0 ) {

					// Add nodes directly
					if ( jQuery.type( elem ) === "object" ) {
						// Support: QtWebKit, PhantomJS
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

					// Convert non-html into a text node
					} else if ( !rhtml.test( elem ) ) {
						nodes.push( context.createTextNode( elem ) );

					// Convert html into DOM nodes
					} else {
						tmp = tmp || fragment.appendChild( context.createElement("div") );

						// Deserialize a standard representation
						tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
						wrap = wrapMap[ tag ] || wrapMap._default;
						tmp.innerHTML = wrap[ 1 ] + elem.replace( rxhtmlTag, "<$1></$2>" ) + wrap[ 2 ];

						// Descend through wrappers to the right content
						j = wrap[ 0 ];
						while ( j-- ) {
							tmp = tmp.lastChild;
						}

						// Support: QtWebKit, PhantomJS
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( nodes, tmp.childNodes );

						// Remember the top-level container
						tmp = fragment.firstChild;

						// Ensure the created nodes are orphaned (#12392)
						tmp.textContent = "";
					}
				}
			}

			// Remove wrapper from fragment
			fragment.textContent = "";

			i = 0;
			while ( (elem = nodes[ i++ ]) ) {

				// #4087 - If origin and destination elements are the same, and this is
				// that element, do not do anything
				if ( selection && jQuery.inArray( elem, selection ) !== -1 ) {
					continue;
				}

				contains = jQuery.contains( elem.ownerDocument, elem );

				// Append to fragment
				tmp = getAll( fragment.appendChild( elem ), "script" );

				// Preserve script evaluation history
				if ( contains ) {
					setGlobalEval( tmp );
				}

				// Capture executables
				if ( scripts ) {
					j = 0;
					while ( (elem = tmp[ j++ ]) ) {
						if ( rscriptType.test( elem.type || "" ) ) {
							scripts.push( elem );
						}
					}
				}
			}

			return fragment;
		},

		cleanData: function( elems ) {
			var data, elem, type, key,
				special = jQuery.event.special,
				i = 0;

			for ( ; (elem = elems[ i ]) !== undefined; i++ ) {
				if ( jQuery.acceptData( elem ) ) {
					key = elem[ data_priv.expando ];

					if ( key && (data = data_priv.cache[ key ]) ) {
						if ( data.events ) {
							for ( type in data.events ) {
								if ( special[ type ] ) {
									jQuery.event.remove( elem, type );

								// This is a shortcut to avoid jQuery.event.remove's overhead
								} else {
									jQuery.removeEvent( elem, type, data.handle );
								}
							}
						}
						if ( data_priv.cache[ key ] ) {
							// Discard any remaining `private` data
							delete data_priv.cache[ key ];
						}
					}
				}
				// Discard any remaining `user` data
				delete data_user.cache[ elem[ data_user.expando ] ];
			}
		}
	});

	jQuery.fn.extend({
		text: function( value ) {
			return access( this, function( value ) {
				return value === undefined ?
					jQuery.text( this ) :
					this.empty().each(function() {
						if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
							this.textContent = value;
						}
					});
			}, null, value, arguments.length );
		},

		append: function() {
			return this.domManip( arguments, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					var target = manipulationTarget( this, elem );
					target.appendChild( elem );
				}
			});
		},

		prepend: function() {
			return this.domManip( arguments, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					var target = manipulationTarget( this, elem );
					target.insertBefore( elem, target.firstChild );
				}
			});
		},

		before: function() {
			return this.domManip( arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this );
				}
			});
		},

		after: function() {
			return this.domManip( arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this.nextSibling );
				}
			});
		},

		remove: function( selector, keepData /* Internal Use Only */ ) {
			var elem,
				elems = selector ? jQuery.filter( selector, this ) : this,
				i = 0;

			for ( ; (elem = elems[i]) != null; i++ ) {
				if ( !keepData && elem.nodeType === 1 ) {
					jQuery.cleanData( getAll( elem ) );
				}

				if ( elem.parentNode ) {
					if ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {
						setGlobalEval( getAll( elem, "script" ) );
					}
					elem.parentNode.removeChild( elem );
				}
			}

			return this;
		},

		empty: function() {
			var elem,
				i = 0;

			for ( ; (elem = this[i]) != null; i++ ) {
				if ( elem.nodeType === 1 ) {

					// Prevent memory leaks
					jQuery.cleanData( getAll( elem, false ) );

					// Remove any remaining nodes
					elem.textContent = "";
				}
			}

			return this;
		},

		clone: function( dataAndEvents, deepDataAndEvents ) {
			dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
			deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

			return this.map(function() {
				return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
			});
		},

		html: function( value ) {
			return access( this, function( value ) {
				var elem = this[ 0 ] || {},
					i = 0,
					l = this.length;

				if ( value === undefined && elem.nodeType === 1 ) {
					return elem.innerHTML;
				}

				// See if we can take a shortcut and just use innerHTML
				if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
					!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

					value = value.replace( rxhtmlTag, "<$1></$2>" );

					try {
						for ( ; i < l; i++ ) {
							elem = this[ i ] || {};

							// Remove element nodes and prevent memory leaks
							if ( elem.nodeType === 1 ) {
								jQuery.cleanData( getAll( elem, false ) );
								elem.innerHTML = value;
							}
						}

						elem = 0;

					// If using innerHTML throws an exception, use the fallback method
					} catch( e ) {}
				}

				if ( elem ) {
					this.empty().append( value );
				}
			}, null, value, arguments.length );
		},

		replaceWith: function() {
			var arg = arguments[ 0 ];

			// Make the changes, replacing each context element with the new content
			this.domManip( arguments, function( elem ) {
				arg = this.parentNode;

				jQuery.cleanData( getAll( this ) );

				if ( arg ) {
					arg.replaceChild( elem, this );
				}
			});

			// Force removal if there was no new content (e.g., from empty arguments)
			return arg && (arg.length || arg.nodeType) ? this : this.remove();
		},

		detach: function( selector ) {
			return this.remove( selector, true );
		},

		domManip: function( args, callback ) {

			// Flatten any nested arrays
			args = concat.apply( [], args );

			var fragment, first, scripts, hasScripts, node, doc,
				i = 0,
				l = this.length,
				set = this,
				iNoClone = l - 1,
				value = args[ 0 ],
				isFunction = jQuery.isFunction( value );

			// We can't cloneNode fragments that contain checked, in WebKit
			if ( isFunction ||
					( l > 1 && typeof value === "string" &&
						!support.checkClone && rchecked.test( value ) ) ) {
				return this.each(function( index ) {
					var self = set.eq( index );
					if ( isFunction ) {
						args[ 0 ] = value.call( this, index, self.html() );
					}
					self.domManip( args, callback );
				});
			}

			if ( l ) {
				fragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, this );
				first = fragment.firstChild;

				if ( fragment.childNodes.length === 1 ) {
					fragment = first;
				}

				if ( first ) {
					scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
					hasScripts = scripts.length;

					// Use the original fragment for the last item instead of the first because it can end up
					// being emptied incorrectly in certain situations (#8070).
					for ( ; i < l; i++ ) {
						node = fragment;

						if ( i !== iNoClone ) {
							node = jQuery.clone( node, true, true );

							// Keep references to cloned scripts for later restoration
							if ( hasScripts ) {
								// Support: QtWebKit
								// jQuery.merge because push.apply(_, arraylike) throws
								jQuery.merge( scripts, getAll( node, "script" ) );
							}
						}

						callback.call( this[ i ], node, i );
					}

					if ( hasScripts ) {
						doc = scripts[ scripts.length - 1 ].ownerDocument;

						// Reenable scripts
						jQuery.map( scripts, restoreScript );

						// Evaluate executable scripts on first document insertion
						for ( i = 0; i < hasScripts; i++ ) {
							node = scripts[ i ];
							if ( rscriptType.test( node.type || "" ) &&
								!data_priv.access( node, "globalEval" ) && jQuery.contains( doc, node ) ) {

								if ( node.src ) {
									// Optional AJAX dependency, but won't run scripts if not present
									if ( jQuery._evalUrl ) {
										jQuery._evalUrl( node.src );
									}
								} else {
									jQuery.globalEval( node.textContent.replace( rcleanScript, "" ) );
								}
							}
						}
					}
				}
			}

			return this;
		}
	});

	jQuery.each({
		appendTo: "append",
		prependTo: "prepend",
		insertBefore: "before",
		insertAfter: "after",
		replaceAll: "replaceWith"
	}, function( name, original ) {
		jQuery.fn[ name ] = function( selector ) {
			var elems,
				ret = [],
				insert = jQuery( selector ),
				last = insert.length - 1,
				i = 0;

			for ( ; i <= last; i++ ) {
				elems = i === last ? this : this.clone( true );
				jQuery( insert[ i ] )[ original ]( elems );

				// Support: QtWebKit
				// .get() because push.apply(_, arraylike) throws
				push.apply( ret, elems.get() );
			}

			return this.pushStack( ret );
		};
	});


	var iframe,
		elemdisplay = {};

	/**
	 * Retrieve the actual display of a element
	 * @param {String} name nodeName of the element
	 * @param {Object} doc Document object
	 */
	// Called only from within defaultDisplay
	function actualDisplay( name, doc ) {
		var style,
			elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),

			// getDefaultComputedStyle might be reliably used only on attached element
			display = window.getDefaultComputedStyle && ( style = window.getDefaultComputedStyle( elem[ 0 ] ) ) ?

				// Use of this method is a temporary fix (more like optimization) until something better comes along,
				// since it was removed from specification and supported only in FF
				style.display : jQuery.css( elem[ 0 ], "display" );

		// We don't have any data stored on the element,
		// so use "detach" method as fast way to get rid of the element
		elem.detach();

		return display;
	}

	/**
	 * Try to determine the default display value of an element
	 * @param {String} nodeName
	 */
	function defaultDisplay( nodeName ) {
		var doc = document,
			display = elemdisplay[ nodeName ];

		if ( !display ) {
			display = actualDisplay( nodeName, doc );

			// If the simple way fails, read from inside an iframe
			if ( display === "none" || !display ) {

				// Use the already-created iframe if possible
				iframe = (iframe || jQuery( "<iframe frameborder='0' width='0' height='0'/>" )).appendTo( doc.documentElement );

				// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
				doc = iframe[ 0 ].contentDocument;

				// Support: IE
				doc.write();
				doc.close();

				display = actualDisplay( nodeName, doc );
				iframe.detach();
			}

			// Store the correct default display
			elemdisplay[ nodeName ] = display;
		}

		return display;
	}
	var rmargin = (/^margin/);

	var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

	var getStyles = function( elem ) {
			// Support: IE<=11+, Firefox<=30+ (#15098, #14150)
			// IE throws on elements created in popups
			// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
			if ( elem.ownerDocument.defaultView.opener ) {
				return elem.ownerDocument.defaultView.getComputedStyle( elem, null );
			}

			return window.getComputedStyle( elem, null );
		};



	function curCSS( elem, name, computed ) {
		var width, minWidth, maxWidth, ret,
			style = elem.style;

		computed = computed || getStyles( elem );

		// Support: IE9
		// getPropertyValue is only needed for .css('filter') (#12537)
		if ( computed ) {
			ret = computed.getPropertyValue( name ) || computed[ name ];
		}

		if ( computed ) {

			if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
				ret = jQuery.style( elem, name );
			}

			// Support: iOS < 6
			// A tribute to the "awesome hack by Dean Edwards"
			// iOS < 6 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
			// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
			if ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {

				// Remember the original values
				width = style.width;
				minWidth = style.minWidth;
				maxWidth = style.maxWidth;

				// Put in the new values to get a computed value out
				style.minWidth = style.maxWidth = style.width = ret;
				ret = computed.width;

				// Revert the changed values
				style.width = width;
				style.minWidth = minWidth;
				style.maxWidth = maxWidth;
			}
		}

		return ret !== undefined ?
			// Support: IE
			// IE returns zIndex value as an integer.
			ret + "" :
			ret;
	}


	function addGetHookIf( conditionFn, hookFn ) {
		// Define the hook, we'll check on the first run if it's really needed.
		return {
			get: function() {
				if ( conditionFn() ) {
					// Hook not needed (or it's not possible to use it due
					// to missing dependency), remove it.
					delete this.get;
					return;
				}

				// Hook needed; redefine it so that the support test is not executed again.
				return (this.get = hookFn).apply( this, arguments );
			}
		};
	}


	(function() {
		var pixelPositionVal, boxSizingReliableVal,
			docElem = document.documentElement,
			container = document.createElement( "div" ),
			div = document.createElement( "div" );

		if ( !div.style ) {
			return;
		}

		// Support: IE9-11+
		// Style of cloned element affects source element cloned (#8908)
		div.style.backgroundClip = "content-box";
		div.cloneNode( true ).style.backgroundClip = "";
		support.clearCloneStyle = div.style.backgroundClip === "content-box";

		container.style.cssText = "border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;" +
			"position:absolute";
		container.appendChild( div );

		// Executing both pixelPosition & boxSizingReliable tests require only one layout
		// so they're executed at the same time to save the second computation.
		function computePixelPositionAndBoxSizingReliable() {
			div.style.cssText =
				// Support: Firefox<29, Android 2.3
				// Vendor-prefix box-sizing
				"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;" +
				"box-sizing:border-box;display:block;margin-top:1%;top:1%;" +
				"border:1px;padding:1px;width:4px;position:absolute";
			div.innerHTML = "";
			docElem.appendChild( container );

			var divStyle = window.getComputedStyle( div, null );
			pixelPositionVal = divStyle.top !== "1%";
			boxSizingReliableVal = divStyle.width === "4px";

			docElem.removeChild( container );
		}

		// Support: node.js jsdom
		// Don't assume that getComputedStyle is a property of the global object
		if ( window.getComputedStyle ) {
			jQuery.extend( support, {
				pixelPosition: function() {

					// This test is executed only once but we still do memoizing
					// since we can use the boxSizingReliable pre-computing.
					// No need to check if the test was already performed, though.
					computePixelPositionAndBoxSizingReliable();
					return pixelPositionVal;
				},
				boxSizingReliable: function() {
					if ( boxSizingReliableVal == null ) {
						computePixelPositionAndBoxSizingReliable();
					}
					return boxSizingReliableVal;
				},
				reliableMarginRight: function() {

					// Support: Android 2.3
					// Check if div with explicit width and no margin-right incorrectly
					// gets computed margin-right based on width of container. (#3333)
					// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
					// This support function is only executed once so no memoizing is needed.
					var ret,
						marginDiv = div.appendChild( document.createElement( "div" ) );

					// Reset CSS: box-sizing; display; margin; border; padding
					marginDiv.style.cssText = div.style.cssText =
						// Support: Firefox<29, Android 2.3
						// Vendor-prefix box-sizing
						"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" +
						"box-sizing:content-box;display:block;margin:0;border:0;padding:0";
					marginDiv.style.marginRight = marginDiv.style.width = "0";
					div.style.width = "1px";
					docElem.appendChild( container );

					ret = !parseFloat( window.getComputedStyle( marginDiv, null ).marginRight );

					docElem.removeChild( container );
					div.removeChild( marginDiv );

					return ret;
				}
			});
		}
	})();


	// A method for quickly swapping in/out CSS properties to get correct calculations.
	jQuery.swap = function( elem, options, callback, args ) {
		var ret, name,
			old = {};

		// Remember the old values, and insert the new ones
		for ( name in options ) {
			old[ name ] = elem.style[ name ];
			elem.style[ name ] = options[ name ];
		}

		ret = callback.apply( elem, args || [] );

		// Revert the old values
		for ( name in options ) {
			elem.style[ name ] = old[ name ];
		}

		return ret;
	};


	var
		// Swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
		// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
		rdisplayswap = /^(none|table(?!-c[ea]).+)/,
		rnumsplit = new RegExp( "^(" + pnum + ")(.*)$", "i" ),
		rrelNum = new RegExp( "^([+-])=(" + pnum + ")", "i" ),

		cssShow = { position: "absolute", visibility: "hidden", display: "block" },
		cssNormalTransform = {
			letterSpacing: "0",
			fontWeight: "400"
		},

		cssPrefixes = [ "Webkit", "O", "Moz", "ms" ];

	// Return a css property mapped to a potentially vendor prefixed property
	function vendorPropName( style, name ) {

		// Shortcut for names that are not vendor prefixed
		if ( name in style ) {
			return name;
		}

		// Check for vendor prefixed names
		var capName = name[0].toUpperCase() + name.slice(1),
			origName = name,
			i = cssPrefixes.length;

		while ( i-- ) {
			name = cssPrefixes[ i ] + capName;
			if ( name in style ) {
				return name;
			}
		}

		return origName;
	}

	function setPositiveNumber( elem, value, subtract ) {
		var matches = rnumsplit.exec( value );
		return matches ?
			// Guard against undefined "subtract", e.g., when used as in cssHooks
			Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || "px" ) :
			value;
	}

	function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
		var i = extra === ( isBorderBox ? "border" : "content" ) ?
			// If we already have the right measurement, avoid augmentation
			4 :
			// Otherwise initialize for horizontal or vertical properties
			name === "width" ? 1 : 0,

			val = 0;

		for ( ; i < 4; i += 2 ) {
			// Both box models exclude margin, so add it if we want it
			if ( extra === "margin" ) {
				val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
			}

			if ( isBorderBox ) {
				// border-box includes padding, so remove it if we want content
				if ( extra === "content" ) {
					val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
				}

				// At this point, extra isn't border nor margin, so remove border
				if ( extra !== "margin" ) {
					val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}
			} else {
				// At this point, extra isn't content, so add padding
				val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

				// At this point, extra isn't content nor padding, so add border
				if ( extra !== "padding" ) {
					val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}
			}
		}

		return val;
	}

	function getWidthOrHeight( elem, name, extra ) {

		// Start with offset property, which is equivalent to the border-box value
		var valueIsBorderBox = true,
			val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
			styles = getStyles( elem ),
			isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

		// Some non-html elements return undefined for offsetWidth, so check for null/undefined
		// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
		// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
		if ( val <= 0 || val == null ) {
			// Fall back to computed then uncomputed css if necessary
			val = curCSS( elem, name, styles );
			if ( val < 0 || val == null ) {
				val = elem.style[ name ];
			}

			// Computed unit is not pixels. Stop here and return.
			if ( rnumnonpx.test(val) ) {
				return val;
			}

			// Check for style in case a browser which returns unreliable values
			// for getComputedStyle silently falls back to the reliable elem.style
			valueIsBorderBox = isBorderBox &&
				( support.boxSizingReliable() || val === elem.style[ name ] );

			// Normalize "", auto, and prepare for extra
			val = parseFloat( val ) || 0;
		}

		// Use the active box-sizing model to add/subtract irrelevant styles
		return ( val +
			augmentWidthOrHeight(
				elem,
				name,
				extra || ( isBorderBox ? "border" : "content" ),
				valueIsBorderBox,
				styles
			)
		) + "px";
	}

	function showHide( elements, show ) {
		var display, elem, hidden,
			values = [],
			index = 0,
			length = elements.length;

		for ( ; index < length; index++ ) {
			elem = elements[ index ];
			if ( !elem.style ) {
				continue;
			}

			values[ index ] = data_priv.get( elem, "olddisplay" );
			display = elem.style.display;
			if ( show ) {
				// Reset the inline display of this element to learn if it is
				// being hidden by cascaded rules or not
				if ( !values[ index ] && display === "none" ) {
					elem.style.display = "";
				}

				// Set elements which have been overridden with display: none
				// in a stylesheet to whatever the default browser style is
				// for such an element
				if ( elem.style.display === "" && isHidden( elem ) ) {
					values[ index ] = data_priv.access( elem, "olddisplay", defaultDisplay(elem.nodeName) );
				}
			} else {
				hidden = isHidden( elem );

				if ( display !== "none" || !hidden ) {
					data_priv.set( elem, "olddisplay", hidden ? display : jQuery.css( elem, "display" ) );
				}
			}
		}

		// Set the display of most of the elements in a second loop
		// to avoid the constant reflow
		for ( index = 0; index < length; index++ ) {
			elem = elements[ index ];
			if ( !elem.style ) {
				continue;
			}
			if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
				elem.style.display = show ? values[ index ] || "" : "none";
			}
		}

		return elements;
	}

	jQuery.extend({

		// Add in style property hooks for overriding the default
		// behavior of getting and setting a style property
		cssHooks: {
			opacity: {
				get: function( elem, computed ) {
					if ( computed ) {

						// We should always get a number back from opacity
						var ret = curCSS( elem, "opacity" );
						return ret === "" ? "1" : ret;
					}
				}
			}
		},

		// Don't automatically add "px" to these possibly-unitless properties
		cssNumber: {
			"columnCount": true,
			"fillOpacity": true,
			"flexGrow": true,
			"flexShrink": true,
			"fontWeight": true,
			"lineHeight": true,
			"opacity": true,
			"order": true,
			"orphans": true,
			"widows": true,
			"zIndex": true,
			"zoom": true
		},

		// Add in properties whose names you wish to fix before
		// setting or getting the value
		cssProps: {
			"float": "cssFloat"
		},

		// Get and set the style property on a DOM Node
		style: function( elem, name, value, extra ) {

			// Don't set styles on text and comment nodes
			if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
				return;
			}

			// Make sure that we're working with the right name
			var ret, type, hooks,
				origName = jQuery.camelCase( name ),
				style = elem.style;

			name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );

			// Gets hook for the prefixed version, then unprefixed version
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

			// Check if we're setting a value
			if ( value !== undefined ) {
				type = typeof value;

				// Convert "+=" or "-=" to relative numbers (#7345)
				if ( type === "string" && (ret = rrelNum.exec( value )) ) {
					value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );
					// Fixes bug #9237
					type = "number";
				}

				// Make sure that null and NaN values aren't set (#7116)
				if ( value == null || value !== value ) {
					return;
				}

				// If a number, add 'px' to the (except for certain CSS properties)
				if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
					value += "px";
				}

				// Support: IE9-11+
				// background-* props affect original clone's values
				if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
					style[ name ] = "inherit";
				}

				// If a hook was provided, use that value, otherwise just set the specified value
				if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {
					style[ name ] = value;
				}

			} else {
				// If a hook was provided get the non-computed value from there
				if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
					return ret;
				}

				// Otherwise just get the value from the style object
				return style[ name ];
			}
		},

		css: function( elem, name, extra, styles ) {
			var val, num, hooks,
				origName = jQuery.camelCase( name );

			// Make sure that we're working with the right name
			name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );

			// Try prefixed name followed by the unprefixed name
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

			// If a hook was provided get the computed value from there
			if ( hooks && "get" in hooks ) {
				val = hooks.get( elem, true, extra );
			}

			// Otherwise, if a way to get the computed value exists, use that
			if ( val === undefined ) {
				val = curCSS( elem, name, styles );
			}

			// Convert "normal" to computed value
			if ( val === "normal" && name in cssNormalTransform ) {
				val = cssNormalTransform[ name ];
			}

			// Make numeric if forced or a qualifier was provided and val looks numeric
			if ( extra === "" || extra ) {
				num = parseFloat( val );
				return extra === true || jQuery.isNumeric( num ) ? num || 0 : val;
			}
			return val;
		}
	});

	jQuery.each([ "height", "width" ], function( i, name ) {
		jQuery.cssHooks[ name ] = {
			get: function( elem, computed, extra ) {
				if ( computed ) {

					// Certain elements can have dimension info if we invisibly show them
					// but it must have a current display style that would benefit
					return rdisplayswap.test( jQuery.css( elem, "display" ) ) && elem.offsetWidth === 0 ?
						jQuery.swap( elem, cssShow, function() {
							return getWidthOrHeight( elem, name, extra );
						}) :
						getWidthOrHeight( elem, name, extra );
				}
			},

			set: function( elem, value, extra ) {
				var styles = extra && getStyles( elem );
				return setPositiveNumber( elem, value, extra ?
					augmentWidthOrHeight(
						elem,
						name,
						extra,
						jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
						styles
					) : 0
				);
			}
		};
	});

	// Support: Android 2.3
	jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,
		function( elem, computed ) {
			if ( computed ) {
				return jQuery.swap( elem, { "display": "inline-block" },
					curCSS, [ elem, "marginRight" ] );
			}
		}
	);

	// These hooks are used by animate to expand properties
	jQuery.each({
		margin: "",
		padding: "",
		border: "Width"
	}, function( prefix, suffix ) {
		jQuery.cssHooks[ prefix + suffix ] = {
			expand: function( value ) {
				var i = 0,
					expanded = {},

					// Assumes a single number if not a string
					parts = typeof value === "string" ? value.split(" ") : [ value ];

				for ( ; i < 4; i++ ) {
					expanded[ prefix + cssExpand[ i ] + suffix ] =
						parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
				}

				return expanded;
			}
		};

		if ( !rmargin.test( prefix ) ) {
			jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
		}
	});

	jQuery.fn.extend({
		css: function( name, value ) {
			return access( this, function( elem, name, value ) {
				var styles, len,
					map = {},
					i = 0;

				if ( jQuery.isArray( name ) ) {
					styles = getStyles( elem );
					len = name.length;

					for ( ; i < len; i++ ) {
						map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
					}

					return map;
				}

				return value !== undefined ?
					jQuery.style( elem, name, value ) :
					jQuery.css( elem, name );
			}, name, value, arguments.length > 1 );
		},
		show: function() {
			return showHide( this, true );
		},
		hide: function() {
			return showHide( this );
		},
		toggle: function( state ) {
			if ( typeof state === "boolean" ) {
				return state ? this.show() : this.hide();
			}

			return this.each(function() {
				if ( isHidden( this ) ) {
					jQuery( this ).show();
				} else {
					jQuery( this ).hide();
				}
			});
		}
	});


	function Tween( elem, options, prop, end, easing ) {
		return new Tween.prototype.init( elem, options, prop, end, easing );
	}
	jQuery.Tween = Tween;

	Tween.prototype = {
		constructor: Tween,
		init: function( elem, options, prop, end, easing, unit ) {
			this.elem = elem;
			this.prop = prop;
			this.easing = easing || "swing";
			this.options = options;
			this.start = this.now = this.cur();
			this.end = end;
			this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
		},
		cur: function() {
			var hooks = Tween.propHooks[ this.prop ];

			return hooks && hooks.get ?
				hooks.get( this ) :
				Tween.propHooks._default.get( this );
		},
		run: function( percent ) {
			var eased,
				hooks = Tween.propHooks[ this.prop ];

			if ( this.options.duration ) {
				this.pos = eased = jQuery.easing[ this.easing ](
					percent, this.options.duration * percent, 0, 1, this.options.duration
				);
			} else {
				this.pos = eased = percent;
			}
			this.now = ( this.end - this.start ) * eased + this.start;

			if ( this.options.step ) {
				this.options.step.call( this.elem, this.now, this );
			}

			if ( hooks && hooks.set ) {
				hooks.set( this );
			} else {
				Tween.propHooks._default.set( this );
			}
			return this;
		}
	};

	Tween.prototype.init.prototype = Tween.prototype;

	Tween.propHooks = {
		_default: {
			get: function( tween ) {
				var result;

				if ( tween.elem[ tween.prop ] != null &&
					(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {
					return tween.elem[ tween.prop ];
				}

				// Passing an empty string as a 3rd parameter to .css will automatically
				// attempt a parseFloat and fallback to a string if the parse fails.
				// Simple values such as "10px" are parsed to Float;
				// complex values such as "rotate(1rad)" are returned as-is.
				result = jQuery.css( tween.elem, tween.prop, "" );
				// Empty strings, null, undefined and "auto" are converted to 0.
				return !result || result === "auto" ? 0 : result;
			},
			set: function( tween ) {
				// Use step hook for back compat.
				// Use cssHook if its there.
				// Use .style if available and use plain properties where available.
				if ( jQuery.fx.step[ tween.prop ] ) {
					jQuery.fx.step[ tween.prop ]( tween );
				} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {
					jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
				} else {
					tween.elem[ tween.prop ] = tween.now;
				}
			}
		}
	};

	// Support: IE9
	// Panic based approach to setting things on disconnected nodes
	Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
		set: function( tween ) {
			if ( tween.elem.nodeType && tween.elem.parentNode ) {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	};

	jQuery.easing = {
		linear: function( p ) {
			return p;
		},
		swing: function( p ) {
			return 0.5 - Math.cos( p * Math.PI ) / 2;
		}
	};

	jQuery.fx = Tween.prototype.init;

	// Back Compat <1.8 extension point
	jQuery.fx.step = {};




	var
		fxNow, timerId,
		rfxtypes = /^(?:toggle|show|hide)$/,
		rfxnum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" ),
		rrun = /queueHooks$/,
		animationPrefilters = [ defaultPrefilter ],
		tweeners = {
			"*": [ function( prop, value ) {
				var tween = this.createTween( prop, value ),
					target = tween.cur(),
					parts = rfxnum.exec( value ),
					unit = parts && parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

					// Starting value computation is required for potential unit mismatches
					start = ( jQuery.cssNumber[ prop ] || unit !== "px" && +target ) &&
						rfxnum.exec( jQuery.css( tween.elem, prop ) ),
					scale = 1,
					maxIterations = 20;

				if ( start && start[ 3 ] !== unit ) {
					// Trust units reported by jQuery.css
					unit = unit || start[ 3 ];

					// Make sure we update the tween properties later on
					parts = parts || [];

					// Iteratively approximate from a nonzero starting point
					start = +target || 1;

					do {
						// If previous iteration zeroed out, double until we get *something*.
						// Use string for doubling so we don't accidentally see scale as unchanged below
						scale = scale || ".5";

						// Adjust and apply
						start = start / scale;
						jQuery.style( tween.elem, prop, start + unit );

					// Update scale, tolerating zero or NaN from tween.cur(),
					// break the loop if scale is unchanged or perfect, or if we've just had enough
					} while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );
				}

				// Update tween properties
				if ( parts ) {
					start = tween.start = +start || +target || 0;
					tween.unit = unit;
					// If a +=/-= token was provided, we're doing a relative animation
					tween.end = parts[ 1 ] ?
						start + ( parts[ 1 ] + 1 ) * parts[ 2 ] :
						+parts[ 2 ];
				}

				return tween;
			} ]
		};

	// Animations created synchronously will run synchronously
	function createFxNow() {
		setTimeout(function() {
			fxNow = undefined;
		});
		return ( fxNow = jQuery.now() );
	}

	// Generate parameters to create a standard animation
	function genFx( type, includeWidth ) {
		var which,
			i = 0,
			attrs = { height: type };

		// If we include width, step value is 1 to do all cssExpand values,
		// otherwise step value is 2 to skip over Left and Right
		includeWidth = includeWidth ? 1 : 0;
		for ( ; i < 4 ; i += 2 - includeWidth ) {
			which = cssExpand[ i ];
			attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
		}

		if ( includeWidth ) {
			attrs.opacity = attrs.width = type;
		}

		return attrs;
	}

	function createTween( value, prop, animation ) {
		var tween,
			collection = ( tweeners[ prop ] || [] ).concat( tweeners[ "*" ] ),
			index = 0,
			length = collection.length;
		for ( ; index < length; index++ ) {
			if ( (tween = collection[ index ].call( animation, prop, value )) ) {

				// We're done with this property
				return tween;
			}
		}
	}

	function defaultPrefilter( elem, props, opts ) {
		/* jshint validthis: true */
		var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
			anim = this,
			orig = {},
			style = elem.style,
			hidden = elem.nodeType && isHidden( elem ),
			dataShow = data_priv.get( elem, "fxshow" );

		// Handle queue: false promises
		if ( !opts.queue ) {
			hooks = jQuery._queueHooks( elem, "fx" );
			if ( hooks.unqueued == null ) {
				hooks.unqueued = 0;
				oldfire = hooks.empty.fire;
				hooks.empty.fire = function() {
					if ( !hooks.unqueued ) {
						oldfire();
					}
				};
			}
			hooks.unqueued++;

			anim.always(function() {
				// Ensure the complete handler is called before this completes
				anim.always(function() {
					hooks.unqueued--;
					if ( !jQuery.queue( elem, "fx" ).length ) {
						hooks.empty.fire();
					}
				});
			});
		}

		// Height/width overflow pass
		if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {
			// Make sure that nothing sneaks out
			// Record all 3 overflow attributes because IE9-10 do not
			// change the overflow attribute when overflowX and
			// overflowY are set to the same value
			opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

			// Set display property to inline-block for height/width
			// animations on inline elements that are having width/height animated
			display = jQuery.css( elem, "display" );

			// Test default display if display is currently "none"
			checkDisplay = display === "none" ?
				data_priv.get( elem, "olddisplay" ) || defaultDisplay( elem.nodeName ) : display;

			if ( checkDisplay === "inline" && jQuery.css( elem, "float" ) === "none" ) {
				style.display = "inline-block";
			}
		}

		if ( opts.overflow ) {
			style.overflow = "hidden";
			anim.always(function() {
				style.overflow = opts.overflow[ 0 ];
				style.overflowX = opts.overflow[ 1 ];
				style.overflowY = opts.overflow[ 2 ];
			});
		}

		// show/hide pass
		for ( prop in props ) {
			value = props[ prop ];
			if ( rfxtypes.exec( value ) ) {
				delete props[ prop ];
				toggle = toggle || value === "toggle";
				if ( value === ( hidden ? "hide" : "show" ) ) {

					// If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden
					if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
						hidden = true;
					} else {
						continue;
					}
				}
				orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );

			// Any non-fx value stops us from restoring the original display value
			} else {
				display = undefined;
			}
		}

		if ( !jQuery.isEmptyObject( orig ) ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = data_priv.access( elem, "fxshow", {} );
			}

			// Store state if its toggle - enables .stop().toggle() to "reverse"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}
			if ( hidden ) {
				jQuery( elem ).show();
			} else {
				anim.done(function() {
					jQuery( elem ).hide();
				});
			}
			anim.done(function() {
				var prop;

				data_priv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			});
			for ( prop in orig ) {
				tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );

				if ( !( prop in dataShow ) ) {
					dataShow[ prop ] = tween.start;
					if ( hidden ) {
						tween.end = tween.start;
						tween.start = prop === "width" || prop === "height" ? 1 : 0;
					}
				}
			}

		// If this is a noop like .hide().hide(), restore an overwritten display value
		} else if ( (display === "none" ? defaultDisplay( elem.nodeName ) : display) === "inline" ) {
			style.display = display;
		}
	}

	function propFilter( props, specialEasing ) {
		var index, name, easing, value, hooks;

		// camelCase, specialEasing and expand cssHook pass
		for ( index in props ) {
			name = jQuery.camelCase( index );
			easing = specialEasing[ name ];
			value = props[ index ];
			if ( jQuery.isArray( value ) ) {
				easing = value[ 1 ];
				value = props[ index ] = value[ 0 ];
			}

			if ( index !== name ) {
				props[ name ] = value;
				delete props[ index ];
			}

			hooks = jQuery.cssHooks[ name ];
			if ( hooks && "expand" in hooks ) {
				value = hooks.expand( value );
				delete props[ name ];

				// Not quite $.extend, this won't overwrite existing keys.
				// Reusing 'index' because we have the correct "name"
				for ( index in value ) {
					if ( !( index in props ) ) {
						props[ index ] = value[ index ];
						specialEasing[ index ] = easing;
					}
				}
			} else {
				specialEasing[ name ] = easing;
			}
		}
	}

	function Animation( elem, properties, options ) {
		var result,
			stopped,
			index = 0,
			length = animationPrefilters.length,
			deferred = jQuery.Deferred().always( function() {
				// Don't match elem in the :animated selector
				delete tick.elem;
			}),
			tick = function() {
				if ( stopped ) {
					return false;
				}
				var currentTime = fxNow || createFxNow(),
					remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
					// Support: Android 2.3
					// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
					temp = remaining / animation.duration || 0,
					percent = 1 - temp,
					index = 0,
					length = animation.tweens.length;

				for ( ; index < length ; index++ ) {
					animation.tweens[ index ].run( percent );
				}

				deferred.notifyWith( elem, [ animation, percent, remaining ]);

				if ( percent < 1 && length ) {
					return remaining;
				} else {
					deferred.resolveWith( elem, [ animation ] );
					return false;
				}
			},
			animation = deferred.promise({
				elem: elem,
				props: jQuery.extend( {}, properties ),
				opts: jQuery.extend( true, { specialEasing: {} }, options ),
				originalProperties: properties,
				originalOptions: options,
				startTime: fxNow || createFxNow(),
				duration: options.duration,
				tweens: [],
				createTween: function( prop, end ) {
					var tween = jQuery.Tween( elem, animation.opts, prop, end,
							animation.opts.specialEasing[ prop ] || animation.opts.easing );
					animation.tweens.push( tween );
					return tween;
				},
				stop: function( gotoEnd ) {
					var index = 0,
						// If we are going to the end, we want to run all the tweens
						// otherwise we skip this part
						length = gotoEnd ? animation.tweens.length : 0;
					if ( stopped ) {
						return this;
					}
					stopped = true;
					for ( ; index < length ; index++ ) {
						animation.tweens[ index ].run( 1 );
					}

					// Resolve when we played the last frame; otherwise, reject
					if ( gotoEnd ) {
						deferred.resolveWith( elem, [ animation, gotoEnd ] );
					} else {
						deferred.rejectWith( elem, [ animation, gotoEnd ] );
					}
					return this;
				}
			}),
			props = animation.props;

		propFilter( props, animation.opts.specialEasing );

		for ( ; index < length ; index++ ) {
			result = animationPrefilters[ index ].call( animation, elem, props, animation.opts );
			if ( result ) {
				return result;
			}
		}

		jQuery.map( props, createTween, animation );

		if ( jQuery.isFunction( animation.opts.start ) ) {
			animation.opts.start.call( elem, animation );
		}

		jQuery.fx.timer(
			jQuery.extend( tick, {
				elem: elem,
				anim: animation,
				queue: animation.opts.queue
			})
		);

		// attach callbacks from options
		return animation.progress( animation.opts.progress )
			.done( animation.opts.done, animation.opts.complete )
			.fail( animation.opts.fail )
			.always( animation.opts.always );
	}

	jQuery.Animation = jQuery.extend( Animation, {

		tweener: function( props, callback ) {
			if ( jQuery.isFunction( props ) ) {
				callback = props;
				props = [ "*" ];
			} else {
				props = props.split(" ");
			}

			var prop,
				index = 0,
				length = props.length;

			for ( ; index < length ; index++ ) {
				prop = props[ index ];
				tweeners[ prop ] = tweeners[ prop ] || [];
				tweeners[ prop ].unshift( callback );
			}
		},

		prefilter: function( callback, prepend ) {
			if ( prepend ) {
				animationPrefilters.unshift( callback );
			} else {
				animationPrefilters.push( callback );
			}
		}
	});

	jQuery.speed = function( speed, easing, fn ) {
		var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
			complete: fn || !fn && easing ||
				jQuery.isFunction( speed ) && speed,
			duration: speed,
			easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
		};

		opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
			opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

		// Normalize opt.queue - true/undefined/null -> "fx"
		if ( opt.queue == null || opt.queue === true ) {
			opt.queue = "fx";
		}

		// Queueing
		opt.old = opt.complete;

		opt.complete = function() {
			if ( jQuery.isFunction( opt.old ) ) {
				opt.old.call( this );
			}

			if ( opt.queue ) {
				jQuery.dequeue( this, opt.queue );
			}
		};

		return opt;
	};

	jQuery.fn.extend({
		fadeTo: function( speed, to, easing, callback ) {

			// Show any hidden elements after setting opacity to 0
			return this.filter( isHidden ).css( "opacity", 0 ).show()

				// Animate to the value specified
				.end().animate({ opacity: to }, speed, easing, callback );
		},
		animate: function( prop, speed, easing, callback ) {
			var empty = jQuery.isEmptyObject( prop ),
				optall = jQuery.speed( speed, easing, callback ),
				doAnimation = function() {
					// Operate on a copy of prop so per-property easing won't be lost
					var anim = Animation( this, jQuery.extend( {}, prop ), optall );

					// Empty animations, or finishing resolves immediately
					if ( empty || data_priv.get( this, "finish" ) ) {
						anim.stop( true );
					}
				};
				doAnimation.finish = doAnimation;

			return empty || optall.queue === false ?
				this.each( doAnimation ) :
				this.queue( optall.queue, doAnimation );
		},
		stop: function( type, clearQueue, gotoEnd ) {
			var stopQueue = function( hooks ) {
				var stop = hooks.stop;
				delete hooks.stop;
				stop( gotoEnd );
			};

			if ( typeof type !== "string" ) {
				gotoEnd = clearQueue;
				clearQueue = type;
				type = undefined;
			}
			if ( clearQueue && type !== false ) {
				this.queue( type || "fx", [] );
			}

			return this.each(function() {
				var dequeue = true,
					index = type != null && type + "queueHooks",
					timers = jQuery.timers,
					data = data_priv.get( this );

				if ( index ) {
					if ( data[ index ] && data[ index ].stop ) {
						stopQueue( data[ index ] );
					}
				} else {
					for ( index in data ) {
						if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
							stopQueue( data[ index ] );
						}
					}
				}

				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
						timers[ index ].anim.stop( gotoEnd );
						dequeue = false;
						timers.splice( index, 1 );
					}
				}

				// Start the next in the queue if the last step wasn't forced.
				// Timers currently will call their complete callbacks, which
				// will dequeue but only if they were gotoEnd.
				if ( dequeue || !gotoEnd ) {
					jQuery.dequeue( this, type );
				}
			});
		},
		finish: function( type ) {
			if ( type !== false ) {
				type = type || "fx";
			}
			return this.each(function() {
				var index,
					data = data_priv.get( this ),
					queue = data[ type + "queue" ],
					hooks = data[ type + "queueHooks" ],
					timers = jQuery.timers,
					length = queue ? queue.length : 0;

				// Enable finishing flag on private data
				data.finish = true;

				// Empty the queue first
				jQuery.queue( this, type, [] );

				if ( hooks && hooks.stop ) {
					hooks.stop.call( this, true );
				}

				// Look for any active animations, and finish them
				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
						timers[ index ].anim.stop( true );
						timers.splice( index, 1 );
					}
				}

				// Look for any animations in the old queue and finish them
				for ( index = 0; index < length; index++ ) {
					if ( queue[ index ] && queue[ index ].finish ) {
						queue[ index ].finish.call( this );
					}
				}

				// Turn off finishing flag
				delete data.finish;
			});
		}
	});

	jQuery.each([ "toggle", "show", "hide" ], function( i, name ) {
		var cssFn = jQuery.fn[ name ];
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return speed == null || typeof speed === "boolean" ?
				cssFn.apply( this, arguments ) :
				this.animate( genFx( name, true ), speed, easing, callback );
		};
	});

	// Generate shortcuts for custom animations
	jQuery.each({
		slideDown: genFx("show"),
		slideUp: genFx("hide"),
		slideToggle: genFx("toggle"),
		fadeIn: { opacity: "show" },
		fadeOut: { opacity: "hide" },
		fadeToggle: { opacity: "toggle" }
	}, function( name, props ) {
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return this.animate( props, speed, easing, callback );
		};
	});

	jQuery.timers = [];
	jQuery.fx.tick = function() {
		var timer,
			i = 0,
			timers = jQuery.timers;

		fxNow = jQuery.now();

		for ( ; i < timers.length; i++ ) {
			timer = timers[ i ];
			// Checks the timer has not already been removed
			if ( !timer() && timers[ i ] === timer ) {
				timers.splice( i--, 1 );
			}
		}

		if ( !timers.length ) {
			jQuery.fx.stop();
		}
		fxNow = undefined;
	};

	jQuery.fx.timer = function( timer ) {
		jQuery.timers.push( timer );
		if ( timer() ) {
			jQuery.fx.start();
		} else {
			jQuery.timers.pop();
		}
	};

	jQuery.fx.interval = 13;

	jQuery.fx.start = function() {
		if ( !timerId ) {
			timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );
		}
	};

	jQuery.fx.stop = function() {
		clearInterval( timerId );
		timerId = null;
	};

	jQuery.fx.speeds = {
		slow: 600,
		fast: 200,
		// Default speed
		_default: 400
	};


	// Based off of the plugin by Clint Helfers, with permission.
	// http://blindsignals.com/index.php/2009/07/jquery-delay/
	jQuery.fn.delay = function( time, type ) {
		time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
		type = type || "fx";

		return this.queue( type, function( next, hooks ) {
			var timeout = setTimeout( next, time );
			hooks.stop = function() {
				clearTimeout( timeout );
			};
		});
	};


	(function() {
		var input = document.createElement( "input" ),
			select = document.createElement( "select" ),
			opt = select.appendChild( document.createElement( "option" ) );

		input.type = "checkbox";

		// Support: iOS<=5.1, Android<=4.2+
		// Default value for a checkbox should be "on"
		support.checkOn = input.value !== "";

		// Support: IE<=11+
		// Must access selectedIndex to make default options select
		support.optSelected = opt.selected;

		// Support: Android<=2.3
		// Options inside disabled selects are incorrectly marked as disabled
		select.disabled = true;
		support.optDisabled = !opt.disabled;

		// Support: IE<=11+
		// An input loses its value after becoming a radio
		input = document.createElement( "input" );
		input.value = "t";
		input.type = "radio";
		support.radioValue = input.value === "t";
	})();


	var nodeHook, boolHook,
		attrHandle = jQuery.expr.attrHandle;

	jQuery.fn.extend({
		attr: function( name, value ) {
			return access( this, jQuery.attr, name, value, arguments.length > 1 );
		},

		removeAttr: function( name ) {
			return this.each(function() {
				jQuery.removeAttr( this, name );
			});
		}
	});

	jQuery.extend({
		attr: function( elem, name, value ) {
			var hooks, ret,
				nType = elem.nodeType;

			// don't get/set attributes on text, comment and attribute nodes
			if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}

			// Fallback to prop when attributes are not supported
			if ( typeof elem.getAttribute === strundefined ) {
				return jQuery.prop( elem, name, value );
			}

			// All attributes are lowercase
			// Grab necessary hook if one is defined
			if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
				name = name.toLowerCase();
				hooks = jQuery.attrHooks[ name ] ||
					( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );
			}

			if ( value !== undefined ) {

				if ( value === null ) {
					jQuery.removeAttr( elem, name );

				} else if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
					return ret;

				} else {
					elem.setAttribute( name, value + "" );
					return value;
				}

			} else if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
				return ret;

			} else {
				ret = jQuery.find.attr( elem, name );

				// Non-existent attributes return null, we normalize to undefined
				return ret == null ?
					undefined :
					ret;
			}
		},

		removeAttr: function( elem, value ) {
			var name, propName,
				i = 0,
				attrNames = value && value.match( rnotwhite );

			if ( attrNames && elem.nodeType === 1 ) {
				while ( (name = attrNames[i++]) ) {
					propName = jQuery.propFix[ name ] || name;

					// Boolean attributes get special treatment (#10870)
					if ( jQuery.expr.match.bool.test( name ) ) {
						// Set corresponding property to false
						elem[ propName ] = false;
					}

					elem.removeAttribute( name );
				}
			}
		},

		attrHooks: {
			type: {
				set: function( elem, value ) {
					if ( !support.radioValue && value === "radio" &&
						jQuery.nodeName( elem, "input" ) ) {
						var val = elem.value;
						elem.setAttribute( "type", value );
						if ( val ) {
							elem.value = val;
						}
						return value;
					}
				}
			}
		}
	});

	// Hooks for boolean attributes
	boolHook = {
		set: function( elem, value, name ) {
			if ( value === false ) {
				// Remove boolean attributes when set to false
				jQuery.removeAttr( elem, name );
			} else {
				elem.setAttribute( name, name );
			}
			return name;
		}
	};
	jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
		var getter = attrHandle[ name ] || jQuery.find.attr;

		attrHandle[ name ] = function( elem, name, isXML ) {
			var ret, handle;
			if ( !isXML ) {
				// Avoid an infinite loop by temporarily removing this function from the getter
				handle = attrHandle[ name ];
				attrHandle[ name ] = ret;
				ret = getter( elem, name, isXML ) != null ?
					name.toLowerCase() :
					null;
				attrHandle[ name ] = handle;
			}
			return ret;
		};
	});




	var rfocusable = /^(?:input|select|textarea|button)$/i;

	jQuery.fn.extend({
		prop: function( name, value ) {
			return access( this, jQuery.prop, name, value, arguments.length > 1 );
		},

		removeProp: function( name ) {
			return this.each(function() {
				delete this[ jQuery.propFix[ name ] || name ];
			});
		}
	});

	jQuery.extend({
		propFix: {
			"for": "htmlFor",
			"class": "className"
		},

		prop: function( elem, name, value ) {
			var ret, hooks, notxml,
				nType = elem.nodeType;

			// Don't get/set properties on text, comment and attribute nodes
			if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}

			notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

			if ( notxml ) {
				// Fix name and attach hooks
				name = jQuery.propFix[ name ] || name;
				hooks = jQuery.propHooks[ name ];
			}

			if ( value !== undefined ) {
				return hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ?
					ret :
					( elem[ name ] = value );

			} else {
				return hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ?
					ret :
					elem[ name ];
			}
		},

		propHooks: {
			tabIndex: {
				get: function( elem ) {
					return elem.hasAttribute( "tabindex" ) || rfocusable.test( elem.nodeName ) || elem.href ?
						elem.tabIndex :
						-1;
				}
			}
		}
	});

	if ( !support.optSelected ) {
		jQuery.propHooks.selected = {
			get: function( elem ) {
				var parent = elem.parentNode;
				if ( parent && parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
				return null;
			}
		};
	}

	jQuery.each([
		"tabIndex",
		"readOnly",
		"maxLength",
		"cellSpacing",
		"cellPadding",
		"rowSpan",
		"colSpan",
		"useMap",
		"frameBorder",
		"contentEditable"
	], function() {
		jQuery.propFix[ this.toLowerCase() ] = this;
	});




	var rclass = /[\t\r\n\f]/g;

	jQuery.fn.extend({
		addClass: function( value ) {
			var classes, elem, cur, clazz, j, finalValue,
				proceed = typeof value === "string" && value,
				i = 0,
				len = this.length;

			if ( jQuery.isFunction( value ) ) {
				return this.each(function( j ) {
					jQuery( this ).addClass( value.call( this, j, this.className ) );
				});
			}

			if ( proceed ) {
				// The disjunction here is for better compressibility (see removeClass)
				classes = ( value || "" ).match( rnotwhite ) || [];

				for ( ; i < len; i++ ) {
					elem = this[ i ];
					cur = elem.nodeType === 1 && ( elem.className ?
						( " " + elem.className + " " ).replace( rclass, " " ) :
						" "
					);

					if ( cur ) {
						j = 0;
						while ( (clazz = classes[j++]) ) {
							if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
								cur += clazz + " ";
							}
						}

						// only assign if different to avoid unneeded rendering.
						finalValue = jQuery.trim( cur );
						if ( elem.className !== finalValue ) {
							elem.className = finalValue;
						}
					}
				}
			}

			return this;
		},

		removeClass: function( value ) {
			var classes, elem, cur, clazz, j, finalValue,
				proceed = arguments.length === 0 || typeof value === "string" && value,
				i = 0,
				len = this.length;

			if ( jQuery.isFunction( value ) ) {
				return this.each(function( j ) {
					jQuery( this ).removeClass( value.call( this, j, this.className ) );
				});
			}
			if ( proceed ) {
				classes = ( value || "" ).match( rnotwhite ) || [];

				for ( ; i < len; i++ ) {
					elem = this[ i ];
					// This expression is here for better compressibility (see addClass)
					cur = elem.nodeType === 1 && ( elem.className ?
						( " " + elem.className + " " ).replace( rclass, " " ) :
						""
					);

					if ( cur ) {
						j = 0;
						while ( (clazz = classes[j++]) ) {
							// Remove *all* instances
							while ( cur.indexOf( " " + clazz + " " ) >= 0 ) {
								cur = cur.replace( " " + clazz + " ", " " );
							}
						}

						// Only assign if different to avoid unneeded rendering.
						finalValue = value ? jQuery.trim( cur ) : "";
						if ( elem.className !== finalValue ) {
							elem.className = finalValue;
						}
					}
				}
			}

			return this;
		},

		toggleClass: function( value, stateVal ) {
			var type = typeof value;

			if ( typeof stateVal === "boolean" && type === "string" ) {
				return stateVal ? this.addClass( value ) : this.removeClass( value );
			}

			if ( jQuery.isFunction( value ) ) {
				return this.each(function( i ) {
					jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
				});
			}

			return this.each(function() {
				if ( type === "string" ) {
					// Toggle individual class names
					var className,
						i = 0,
						self = jQuery( this ),
						classNames = value.match( rnotwhite ) || [];

					while ( (className = classNames[ i++ ]) ) {
						// Check each className given, space separated list
						if ( self.hasClass( className ) ) {
							self.removeClass( className );
						} else {
							self.addClass( className );
						}
					}

				// Toggle whole class name
				} else if ( type === strundefined || type === "boolean" ) {
					if ( this.className ) {
						// store className if set
						data_priv.set( this, "__className__", this.className );
					}

					// If the element has a class name or if we're passed `false`,
					// then remove the whole classname (if there was one, the above saved it).
					// Otherwise bring back whatever was previously saved (if anything),
					// falling back to the empty string if nothing was stored.
					this.className = this.className || value === false ? "" : data_priv.get( this, "__className__" ) || "";
				}
			});
		},

		hasClass: function( selector ) {
			var className = " " + selector + " ",
				i = 0,
				l = this.length;
			for ( ; i < l; i++ ) {
				if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) >= 0 ) {
					return true;
				}
			}

			return false;
		}
	});




	var rreturn = /\r/g;

	jQuery.fn.extend({
		val: function( value ) {
			var hooks, ret, isFunction,
				elem = this[0];

			if ( !arguments.length ) {
				if ( elem ) {
					hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];

					if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
						return ret;
					}

					ret = elem.value;

					return typeof ret === "string" ?
						// Handle most common string cases
						ret.replace(rreturn, "") :
						// Handle cases where value is null/undef or number
						ret == null ? "" : ret;
				}

				return;
			}

			isFunction = jQuery.isFunction( value );

			return this.each(function( i ) {
				var val;

				if ( this.nodeType !== 1 ) {
					return;
				}

				if ( isFunction ) {
					val = value.call( this, i, jQuery( this ).val() );
				} else {
					val = value;
				}

				// Treat null/undefined as ""; convert numbers to string
				if ( val == null ) {
					val = "";

				} else if ( typeof val === "number" ) {
					val += "";

				} else if ( jQuery.isArray( val ) ) {
					val = jQuery.map( val, function( value ) {
						return value == null ? "" : value + "";
					});
				}

				hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

				// If set returns undefined, fall back to normal setting
				if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
					this.value = val;
				}
			});
		}
	});

	jQuery.extend({
		valHooks: {
			option: {
				get: function( elem ) {
					var val = jQuery.find.attr( elem, "value" );
					return val != null ?
						val :
						// Support: IE10-11+
						// option.text throws exceptions (#14686, #14858)
						jQuery.trim( jQuery.text( elem ) );
				}
			},
			select: {
				get: function( elem ) {
					var value, option,
						options = elem.options,
						index = elem.selectedIndex,
						one = elem.type === "select-one" || index < 0,
						values = one ? null : [],
						max = one ? index + 1 : options.length,
						i = index < 0 ?
							max :
							one ? index : 0;

					// Loop through all the selected options
					for ( ; i < max; i++ ) {
						option = options[ i ];

						// IE6-9 doesn't update selected after form reset (#2551)
						if ( ( option.selected || i === index ) &&
								// Don't return options that are disabled or in a disabled optgroup
								( support.optDisabled ? !option.disabled : option.getAttribute( "disabled" ) === null ) &&
								( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

							// Get the specific value for the option
							value = jQuery( option ).val();

							// We don't need an array for one selects
							if ( one ) {
								return value;
							}

							// Multi-Selects return an array
							values.push( value );
						}
					}

					return values;
				},

				set: function( elem, value ) {
					var optionSet, option,
						options = elem.options,
						values = jQuery.makeArray( value ),
						i = options.length;

					while ( i-- ) {
						option = options[ i ];
						if ( (option.selected = jQuery.inArray( option.value, values ) >= 0) ) {
							optionSet = true;
						}
					}

					// Force browsers to behave consistently when non-matching value is set
					if ( !optionSet ) {
						elem.selectedIndex = -1;
					}
					return values;
				}
			}
		}
	});

	// Radios and checkboxes getter/setter
	jQuery.each([ "radio", "checkbox" ], function() {
		jQuery.valHooks[ this ] = {
			set: function( elem, value ) {
				if ( jQuery.isArray( value ) ) {
					return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
				}
			}
		};
		if ( !support.checkOn ) {
			jQuery.valHooks[ this ].get = function( elem ) {
				return elem.getAttribute("value") === null ? "on" : elem.value;
			};
		}
	});




	// Return jQuery for attributes-only inclusion


	jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
		"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
		"change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {

		// Handle event binding
		jQuery.fn[ name ] = function( data, fn ) {
			return arguments.length > 0 ?
				this.on( name, null, data, fn ) :
				this.trigger( name );
		};
	});

	jQuery.fn.extend({
		hover: function( fnOver, fnOut ) {
			return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
		},

		bind: function( types, data, fn ) {
			return this.on( types, null, data, fn );
		},
		unbind: function( types, fn ) {
			return this.off( types, null, fn );
		},

		delegate: function( selector, types, data, fn ) {
			return this.on( types, selector, data, fn );
		},
		undelegate: function( selector, types, fn ) {
			// ( namespace ) or ( selector, types [, fn] )
			return arguments.length === 1 ? this.off( selector, "**" ) : this.off( types, selector || "**", fn );
		}
	});


	var nonce = jQuery.now();

	var rquery = (/\?/);



	// Support: Android 2.3
	// Workaround failure to string-cast null input
	jQuery.parseJSON = function( data ) {
		return JSON.parse( data + "" );
	};


	// Cross-browser xml parsing
	jQuery.parseXML = function( data ) {
		var xml, tmp;
		if ( !data || typeof data !== "string" ) {
			return null;
		}

		// Support: IE9
		try {
			tmp = new DOMParser();
			xml = tmp.parseFromString( data, "text/xml" );
		} catch ( e ) {
			xml = undefined;
		}

		if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
			jQuery.error( "Invalid XML: " + data );
		}
		return xml;
	};


	var
		rhash = /#.*$/,
		rts = /([?&])_=[^&]*/,
		rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
		// #7653, #8125, #8152: local protocol detection
		rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
		rnoContent = /^(?:GET|HEAD)$/,
		rprotocol = /^\/\//,
		rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,

		/* Prefilters
		 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
		 * 2) These are called:
		 *    - BEFORE asking for a transport
		 *    - AFTER param serialization (s.data is a string if s.processData is true)
		 * 3) key is the dataType
		 * 4) the catchall symbol "*" can be used
		 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
		 */
		prefilters = {},

		/* Transports bindings
		 * 1) key is the dataType
		 * 2) the catchall symbol "*" can be used
		 * 3) selection will start with transport dataType and THEN go to "*" if needed
		 */
		transports = {},

		// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
		allTypes = "*/".concat( "*" ),

		// Document location
		ajaxLocation = window.location.href,

		// Segment location into parts
		ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

	// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
	function addToPrefiltersOrTransports( structure ) {

		// dataTypeExpression is optional and defaults to "*"
		return function( dataTypeExpression, func ) {

			if ( typeof dataTypeExpression !== "string" ) {
				func = dataTypeExpression;
				dataTypeExpression = "*";
			}

			var dataType,
				i = 0,
				dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];

			if ( jQuery.isFunction( func ) ) {
				// For each dataType in the dataTypeExpression
				while ( (dataType = dataTypes[i++]) ) {
					// Prepend if requested
					if ( dataType[0] === "+" ) {
						dataType = dataType.slice( 1 ) || "*";
						(structure[ dataType ] = structure[ dataType ] || []).unshift( func );

					// Otherwise append
					} else {
						(structure[ dataType ] = structure[ dataType ] || []).push( func );
					}
				}
			}
		};
	}

	// Base inspection function for prefilters and transports
	function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

		var inspected = {},
			seekingTransport = ( structure === transports );

		function inspect( dataType ) {
			var selected;
			inspected[ dataType ] = true;
			jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
				var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
				if ( typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {
					options.dataTypes.unshift( dataTypeOrTransport );
					inspect( dataTypeOrTransport );
					return false;
				} else if ( seekingTransport ) {
					return !( selected = dataTypeOrTransport );
				}
			});
			return selected;
		}

		return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
	}

	// A special extend for ajax options
	// that takes "flat" options (not to be deep extended)
	// Fixes #9887
	function ajaxExtend( target, src ) {
		var key, deep,
			flatOptions = jQuery.ajaxSettings.flatOptions || {};

		for ( key in src ) {
			if ( src[ key ] !== undefined ) {
				( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];
			}
		}
		if ( deep ) {
			jQuery.extend( true, target, deep );
		}

		return target;
	}

	/* Handles responses to an ajax request:
	 * - finds the right dataType (mediates between content-type and expected dataType)
	 * - returns the corresponding response
	 */
	function ajaxHandleResponses( s, jqXHR, responses ) {

		var ct, type, finalDataType, firstDataType,
			contents = s.contents,
			dataTypes = s.dataTypes;

		// Remove auto dataType and get content-type in the process
		while ( dataTypes[ 0 ] === "*" ) {
			dataTypes.shift();
			if ( ct === undefined ) {
				ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
			}
		}

		// Check if we're dealing with a known content-type
		if ( ct ) {
			for ( type in contents ) {
				if ( contents[ type ] && contents[ type ].test( ct ) ) {
					dataTypes.unshift( type );
					break;
				}
			}
		}

		// Check to see if we have a response for the expected dataType
		if ( dataTypes[ 0 ] in responses ) {
			finalDataType = dataTypes[ 0 ];
		} else {
			// Try convertible dataTypes
			for ( type in responses ) {
				if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
					finalDataType = type;
					break;
				}
				if ( !firstDataType ) {
					firstDataType = type;
				}
			}
			// Or just use first one
			finalDataType = finalDataType || firstDataType;
		}

		// If we found a dataType
		// We add the dataType to the list if needed
		// and return the corresponding response
		if ( finalDataType ) {
			if ( finalDataType !== dataTypes[ 0 ] ) {
				dataTypes.unshift( finalDataType );
			}
			return responses[ finalDataType ];
		}
	}

	/* Chain conversions given the request and the original response
	 * Also sets the responseXXX fields on the jqXHR instance
	 */
	function ajaxConvert( s, response, jqXHR, isSuccess ) {
		var conv2, current, conv, tmp, prev,
			converters = {},
			// Work with a copy of dataTypes in case we need to modify it for conversion
			dataTypes = s.dataTypes.slice();

		// Create converters map with lowercased keys
		if ( dataTypes[ 1 ] ) {
			for ( conv in s.converters ) {
				converters[ conv.toLowerCase() ] = s.converters[ conv ];
			}
		}

		current = dataTypes.shift();

		// Convert to each sequential dataType
		while ( current ) {

			if ( s.responseFields[ current ] ) {
				jqXHR[ s.responseFields[ current ] ] = response;
			}

			// Apply the dataFilter if provided
			if ( !prev && isSuccess && s.dataFilter ) {
				response = s.dataFilter( response, s.dataType );
			}

			prev = current;
			current = dataTypes.shift();

			if ( current ) {

			// There's only work to do if current dataType is non-auto
				if ( current === "*" ) {

					current = prev;

				// Convert response if prev dataType is non-auto and differs from current
				} else if ( prev !== "*" && prev !== current ) {

					// Seek a direct converter
					conv = converters[ prev + " " + current ] || converters[ "* " + current ];

					// If none found, seek a pair
					if ( !conv ) {
						for ( conv2 in converters ) {

							// If conv2 outputs current
							tmp = conv2.split( " " );
							if ( tmp[ 1 ] === current ) {

								// If prev can be converted to accepted input
								conv = converters[ prev + " " + tmp[ 0 ] ] ||
									converters[ "* " + tmp[ 0 ] ];
								if ( conv ) {
									// Condense equivalence converters
									if ( conv === true ) {
										conv = converters[ conv2 ];

									// Otherwise, insert the intermediate dataType
									} else if ( converters[ conv2 ] !== true ) {
										current = tmp[ 0 ];
										dataTypes.unshift( tmp[ 1 ] );
									}
									break;
								}
							}
						}
					}

					// Apply converter (if not an equivalence)
					if ( conv !== true ) {

						// Unless errors are allowed to bubble, catch and return them
						if ( conv && s[ "throws" ] ) {
							response = conv( response );
						} else {
							try {
								response = conv( response );
							} catch ( e ) {
								return { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current };
							}
						}
					}
				}
			}
		}

		return { state: "success", data: response };
	}

	jQuery.extend({

		// Counter for holding the number of active queries
		active: 0,

		// Last-Modified header cache for next request
		lastModified: {},
		etag: {},

		ajaxSettings: {
			url: ajaxLocation,
			type: "GET",
			isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
			global: true,
			processData: true,
			async: true,
			contentType: "application/x-www-form-urlencoded; charset=UTF-8",
			/*
			timeout: 0,
			data: null,
			dataType: null,
			username: null,
			password: null,
			cache: null,
			throws: false,
			traditional: false,
			headers: {},
			*/

			accepts: {
				"*": allTypes,
				text: "text/plain",
				html: "text/html",
				xml: "application/xml, text/xml",
				json: "application/json, text/javascript"
			},

			contents: {
				xml: /xml/,
				html: /html/,
				json: /json/
			},

			responseFields: {
				xml: "responseXML",
				text: "responseText",
				json: "responseJSON"
			},

			// Data converters
			// Keys separate source (or catchall "*") and destination types with a single space
			converters: {

				// Convert anything to text
				"* text": String,

				// Text to html (true = no transformation)
				"text html": true,

				// Evaluate text as a json expression
				"text json": jQuery.parseJSON,

				// Parse text as xml
				"text xml": jQuery.parseXML
			},

			// For options that shouldn't be deep extended:
			// you can add your own custom options here if
			// and when you create one that shouldn't be
			// deep extended (see ajaxExtend)
			flatOptions: {
				url: true,
				context: true
			}
		},

		// Creates a full fledged settings object into target
		// with both ajaxSettings and settings fields.
		// If target is omitted, writes into ajaxSettings.
		ajaxSetup: function( target, settings ) {
			return settings ?

				// Building a settings object
				ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

				// Extending ajaxSettings
				ajaxExtend( jQuery.ajaxSettings, target );
		},

		ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
		ajaxTransport: addToPrefiltersOrTransports( transports ),

		// Main method
		ajax: function( url, options ) {

			// If url is an object, simulate pre-1.5 signature
			if ( typeof url === "object" ) {
				options = url;
				url = undefined;
			}

			// Force options to be an object
			options = options || {};

			var transport,
				// URL without anti-cache param
				cacheURL,
				// Response headers
				responseHeadersString,
				responseHeaders,
				// timeout handle
				timeoutTimer,
				// Cross-domain detection vars
				parts,
				// To know if global events are to be dispatched
				fireGlobals,
				// Loop variable
				i,
				// Create the final options object
				s = jQuery.ajaxSetup( {}, options ),
				// Callbacks context
				callbackContext = s.context || s,
				// Context for global events is callbackContext if it is a DOM node or jQuery collection
				globalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?
					jQuery( callbackContext ) :
					jQuery.event,
				// Deferreds
				deferred = jQuery.Deferred(),
				completeDeferred = jQuery.Callbacks("once memory"),
				// Status-dependent callbacks
				statusCode = s.statusCode || {},
				// Headers (they are sent all at once)
				requestHeaders = {},
				requestHeadersNames = {},
				// The jqXHR state
				state = 0,
				// Default abort message
				strAbort = "canceled",
				// Fake xhr
				jqXHR = {
					readyState: 0,

					// Builds headers hashtable if needed
					getResponseHeader: function( key ) {
						var match;
						if ( state === 2 ) {
							if ( !responseHeaders ) {
								responseHeaders = {};
								while ( (match = rheaders.exec( responseHeadersString )) ) {
									responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
								}
							}
							match = responseHeaders[ key.toLowerCase() ];
						}
						return match == null ? null : match;
					},

					// Raw string
					getAllResponseHeaders: function() {
						return state === 2 ? responseHeadersString : null;
					},

					// Caches the header
					setRequestHeader: function( name, value ) {
						var lname = name.toLowerCase();
						if ( !state ) {
							name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
							requestHeaders[ name ] = value;
						}
						return this;
					},

					// Overrides response content-type header
					overrideMimeType: function( type ) {
						if ( !state ) {
							s.mimeType = type;
						}
						return this;
					},

					// Status-dependent callbacks
					statusCode: function( map ) {
						var code;
						if ( map ) {
							if ( state < 2 ) {
								for ( code in map ) {
									// Lazy-add the new callback in a way that preserves old ones
									statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
								}
							} else {
								// Execute the appropriate callbacks
								jqXHR.always( map[ jqXHR.status ] );
							}
						}
						return this;
					},

					// Cancel the request
					abort: function( statusText ) {
						var finalText = statusText || strAbort;
						if ( transport ) {
							transport.abort( finalText );
						}
						done( 0, finalText );
						return this;
					}
				};

			// Attach deferreds
			deferred.promise( jqXHR ).complete = completeDeferred.add;
			jqXHR.success = jqXHR.done;
			jqXHR.error = jqXHR.fail;

			// Remove hash character (#7531: and string promotion)
			// Add protocol if not provided (prefilters might expect it)
			// Handle falsy url in the settings object (#10093: consistency with old signature)
			// We also use the url parameter if available
			s.url = ( ( url || s.url || ajaxLocation ) + "" ).replace( rhash, "" )
				.replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

			// Alias method option to type as per ticket #12004
			s.type = options.method || options.type || s.method || s.type;

			// Extract dataTypes list
			s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];

			// A cross-domain request is in order when we have a protocol:host:port mismatch
			if ( s.crossDomain == null ) {
				parts = rurl.exec( s.url.toLowerCase() );
				s.crossDomain = !!( parts &&
					( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||
						( parts[ 3 ] || ( parts[ 1 ] === "http:" ? "80" : "443" ) ) !==
							( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? "80" : "443" ) ) )
				);
			}

			// Convert data if not already a string
			if ( s.data && s.processData && typeof s.data !== "string" ) {
				s.data = jQuery.param( s.data, s.traditional );
			}

			// Apply prefilters
			inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

			// If request was aborted inside a prefilter, stop there
			if ( state === 2 ) {
				return jqXHR;
			}

			// We can fire global events as of now if asked to
			// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
			fireGlobals = jQuery.event && s.global;

			// Watch for a new set of requests
			if ( fireGlobals && jQuery.active++ === 0 ) {
				jQuery.event.trigger("ajaxStart");
			}

			// Uppercase the type
			s.type = s.type.toUpperCase();

			// Determine if request has content
			s.hasContent = !rnoContent.test( s.type );

			// Save the URL in case we're toying with the If-Modified-Since
			// and/or If-None-Match header later on
			cacheURL = s.url;

			// More options handling for requests with no content
			if ( !s.hasContent ) {

				// If data is available, append data to url
				if ( s.data ) {
					cacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );
					// #9682: remove data so that it's not used in an eventual retry
					delete s.data;
				}

				// Add anti-cache in url if needed
				if ( s.cache === false ) {
					s.url = rts.test( cacheURL ) ?

						// If there is already a '_' parameter, set its value
						cacheURL.replace( rts, "$1_=" + nonce++ ) :

						// Otherwise add one to the end
						cacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;
				}
			}

			// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
			if ( s.ifModified ) {
				if ( jQuery.lastModified[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
				}
				if ( jQuery.etag[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
				}
			}

			// Set the correct header, if data is being sent
			if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
				jqXHR.setRequestHeader( "Content-Type", s.contentType );
			}

			// Set the Accepts header for the server, depending on the dataType
			jqXHR.setRequestHeader(
				"Accept",
				s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
					s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
					s.accepts[ "*" ]
			);

			// Check for headers option
			for ( i in s.headers ) {
				jqXHR.setRequestHeader( i, s.headers[ i ] );
			}

			// Allow custom headers/mimetypes and early abort
			if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
				// Abort if not done already and return
				return jqXHR.abort();
			}

			// Aborting is no longer a cancellation
			strAbort = "abort";

			// Install callbacks on deferreds
			for ( i in { success: 1, error: 1, complete: 1 } ) {
				jqXHR[ i ]( s[ i ] );
			}

			// Get transport
			transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

			// If no transport, we auto-abort
			if ( !transport ) {
				done( -1, "No Transport" );
			} else {
				jqXHR.readyState = 1;

				// Send global event
				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
				}
				// Timeout
				if ( s.async && s.timeout > 0 ) {
					timeoutTimer = setTimeout(function() {
						jqXHR.abort("timeout");
					}, s.timeout );
				}

				try {
					state = 1;
					transport.send( requestHeaders, done );
				} catch ( e ) {
					// Propagate exception as error if not done
					if ( state < 2 ) {
						done( -1, e );
					// Simply rethrow otherwise
					} else {
						throw e;
					}
				}
			}

			// Callback for when everything is done
			function done( status, nativeStatusText, responses, headers ) {
				var isSuccess, success, error, response, modified,
					statusText = nativeStatusText;

				// Called once
				if ( state === 2 ) {
					return;
				}

				// State is "done" now
				state = 2;

				// Clear timeout if it exists
				if ( timeoutTimer ) {
					clearTimeout( timeoutTimer );
				}

				// Dereference transport for early garbage collection
				// (no matter how long the jqXHR object will be used)
				transport = undefined;

				// Cache response headers
				responseHeadersString = headers || "";

				// Set readyState
				jqXHR.readyState = status > 0 ? 4 : 0;

				// Determine if successful
				isSuccess = status >= 200 && status < 300 || status === 304;

				// Get response data
				if ( responses ) {
					response = ajaxHandleResponses( s, jqXHR, responses );
				}

				// Convert no matter what (that way responseXXX fields are always set)
				response = ajaxConvert( s, response, jqXHR, isSuccess );

				// If successful, handle type chaining
				if ( isSuccess ) {

					// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
					if ( s.ifModified ) {
						modified = jqXHR.getResponseHeader("Last-Modified");
						if ( modified ) {
							jQuery.lastModified[ cacheURL ] = modified;
						}
						modified = jqXHR.getResponseHeader("etag");
						if ( modified ) {
							jQuery.etag[ cacheURL ] = modified;
						}
					}

					// if no content
					if ( status === 204 || s.type === "HEAD" ) {
						statusText = "nocontent";

					// if not modified
					} else if ( status === 304 ) {
						statusText = "notmodified";

					// If we have data, let's convert it
					} else {
						statusText = response.state;
						success = response.data;
						error = response.error;
						isSuccess = !error;
					}
				} else {
					// Extract error from statusText and normalize for non-aborts
					error = statusText;
					if ( status || !statusText ) {
						statusText = "error";
						if ( status < 0 ) {
							status = 0;
						}
					}
				}

				// Set data for the fake xhr object
				jqXHR.status = status;
				jqXHR.statusText = ( nativeStatusText || statusText ) + "";

				// Success/Error
				if ( isSuccess ) {
					deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
				} else {
					deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
				}

				// Status-dependent callbacks
				jqXHR.statusCode( statusCode );
				statusCode = undefined;

				if ( fireGlobals ) {
					globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
						[ jqXHR, s, isSuccess ? success : error ] );
				}

				// Complete
				completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
					// Handle the global AJAX counter
					if ( !( --jQuery.active ) ) {
						jQuery.event.trigger("ajaxStop");
					}
				}
			}

			return jqXHR;
		},

		getJSON: function( url, data, callback ) {
			return jQuery.get( url, data, callback, "json" );
		},

		getScript: function( url, callback ) {
			return jQuery.get( url, undefined, callback, "script" );
		}
	});

	jQuery.each( [ "get", "post" ], function( i, method ) {
		jQuery[ method ] = function( url, data, callback, type ) {
			// Shift arguments if data argument was omitted
			if ( jQuery.isFunction( data ) ) {
				type = type || callback;
				callback = data;
				data = undefined;
			}

			return jQuery.ajax({
				url: url,
				type: method,
				dataType: type,
				data: data,
				success: callback
			});
		};
	});


	jQuery._evalUrl = function( url ) {
		return jQuery.ajax({
			url: url,
			type: "GET",
			dataType: "script",
			async: false,
			global: false,
			"throws": true
		});
	};


	jQuery.fn.extend({
		wrapAll: function( html ) {
			var wrap;

			if ( jQuery.isFunction( html ) ) {
				return this.each(function( i ) {
					jQuery( this ).wrapAll( html.call(this, i) );
				});
			}

			if ( this[ 0 ] ) {

				// The elements to wrap the target around
				wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

				if ( this[ 0 ].parentNode ) {
					wrap.insertBefore( this[ 0 ] );
				}

				wrap.map(function() {
					var elem = this;

					while ( elem.firstElementChild ) {
						elem = elem.firstElementChild;
					}

					return elem;
				}).append( this );
			}

			return this;
		},

		wrapInner: function( html ) {
			if ( jQuery.isFunction( html ) ) {
				return this.each(function( i ) {
					jQuery( this ).wrapInner( html.call(this, i) );
				});
			}

			return this.each(function() {
				var self = jQuery( this ),
					contents = self.contents();

				if ( contents.length ) {
					contents.wrapAll( html );

				} else {
					self.append( html );
				}
			});
		},

		wrap: function( html ) {
			var isFunction = jQuery.isFunction( html );

			return this.each(function( i ) {
				jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
			});
		},

		unwrap: function() {
			return this.parent().each(function() {
				if ( !jQuery.nodeName( this, "body" ) ) {
					jQuery( this ).replaceWith( this.childNodes );
				}
			}).end();
		}
	});


	jQuery.expr.filters.hidden = function( elem ) {
		// Support: Opera <= 12.12
		// Opera reports offsetWidths and offsetHeights less than zero on some elements
		return elem.offsetWidth <= 0 && elem.offsetHeight <= 0;
	};
	jQuery.expr.filters.visible = function( elem ) {
		return !jQuery.expr.filters.hidden( elem );
	};




	var r20 = /%20/g,
		rbracket = /\[\]$/,
		rCRLF = /\r?\n/g,
		rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
		rsubmittable = /^(?:input|select|textarea|keygen)/i;

	function buildParams( prefix, obj, traditional, add ) {
		var name;

		if ( jQuery.isArray( obj ) ) {
			// Serialize array item.
			jQuery.each( obj, function( i, v ) {
				if ( traditional || rbracket.test( prefix ) ) {
					// Treat each array item as a scalar.
					add( prefix, v );

				} else {
					// Item is non-scalar (array or object), encode its numeric index.
					buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );
				}
			});

		} else if ( !traditional && jQuery.type( obj ) === "object" ) {
			// Serialize object item.
			for ( name in obj ) {
				buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
			}

		} else {
			// Serialize scalar item.
			add( prefix, obj );
		}
	}

	// Serialize an array of form elements or a set of
	// key/values into a query string
	jQuery.param = function( a, traditional ) {
		var prefix,
			s = [],
			add = function( key, value ) {
				// If value is a function, invoke it and return its value
				value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
				s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
			};

		// Set traditional to true for jQuery <= 1.3.2 behavior.
		if ( traditional === undefined ) {
			traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
		}

		// If an array was passed in, assume that it is an array of form elements.
		if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
			// Serialize the form elements
			jQuery.each( a, function() {
				add( this.name, this.value );
			});

		} else {
			// If traditional, encode the "old" way (the way 1.3.2 or older
			// did it), otherwise encode params recursively.
			for ( prefix in a ) {
				buildParams( prefix, a[ prefix ], traditional, add );
			}
		}

		// Return the resulting serialization
		return s.join( "&" ).replace( r20, "+" );
	};

	jQuery.fn.extend({
		serialize: function() {
			return jQuery.param( this.serializeArray() );
		},
		serializeArray: function() {
			return this.map(function() {
				// Can add propHook for "elements" to filter or add form elements
				var elements = jQuery.prop( this, "elements" );
				return elements ? jQuery.makeArray( elements ) : this;
			})
			.filter(function() {
				var type = this.type;

				// Use .is( ":disabled" ) so that fieldset[disabled] works
				return this.name && !jQuery( this ).is( ":disabled" ) &&
					rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
					( this.checked || !rcheckableType.test( type ) );
			})
			.map(function( i, elem ) {
				var val = jQuery( this ).val();

				return val == null ?
					null :
					jQuery.isArray( val ) ?
						jQuery.map( val, function( val ) {
							return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
						}) :
						{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
			}).get();
		}
	});


	jQuery.ajaxSettings.xhr = function() {
		try {
			return new XMLHttpRequest();
		} catch( e ) {}
	};

	var xhrId = 0,
		xhrCallbacks = {},
		xhrSuccessStatus = {
			// file protocol always yields status code 0, assume 200
			0: 200,
			// Support: IE9
			// #1450: sometimes IE returns 1223 when it should be 204
			1223: 204
		},
		xhrSupported = jQuery.ajaxSettings.xhr();

	// Support: IE9
	// Open requests must be manually aborted on unload (#5280)
	// See https://support.microsoft.com/kb/2856746 for more info
	if ( window.attachEvent ) {
		window.attachEvent( "onunload", function() {
			for ( var key in xhrCallbacks ) {
				xhrCallbacks[ key ]();
			}
		});
	}

	support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
	support.ajax = xhrSupported = !!xhrSupported;

	jQuery.ajaxTransport(function( options ) {
		var callback;

		// Cross domain only allowed if supported through XMLHttpRequest
		if ( support.cors || xhrSupported && !options.crossDomain ) {
			return {
				send: function( headers, complete ) {
					var i,
						xhr = options.xhr(),
						id = ++xhrId;

					xhr.open( options.type, options.url, options.async, options.username, options.password );

					// Apply custom fields if provided
					if ( options.xhrFields ) {
						for ( i in options.xhrFields ) {
							xhr[ i ] = options.xhrFields[ i ];
						}
					}

					// Override mime type if needed
					if ( options.mimeType && xhr.overrideMimeType ) {
						xhr.overrideMimeType( options.mimeType );
					}

					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won't change header if already provided.
					if ( !options.crossDomain && !headers["X-Requested-With"] ) {
						headers["X-Requested-With"] = "XMLHttpRequest";
					}

					// Set headers
					for ( i in headers ) {
						xhr.setRequestHeader( i, headers[ i ] );
					}

					// Callback
					callback = function( type ) {
						return function() {
							if ( callback ) {
								delete xhrCallbacks[ id ];
								callback = xhr.onload = xhr.onerror = null;

								if ( type === "abort" ) {
									xhr.abort();
								} else if ( type === "error" ) {
									complete(
										// file: protocol always yields status 0; see #8605, #14207
										xhr.status,
										xhr.statusText
									);
								} else {
									complete(
										xhrSuccessStatus[ xhr.status ] || xhr.status,
										xhr.statusText,
										// Support: IE9
										// Accessing binary-data responseText throws an exception
										// (#11426)
										typeof xhr.responseText === "string" ? {
											text: xhr.responseText
										} : undefined,
										xhr.getAllResponseHeaders()
									);
								}
							}
						};
					};

					// Listen to events
					xhr.onload = callback();
					xhr.onerror = callback("error");

					// Create the abort callback
					callback = xhrCallbacks[ id ] = callback("abort");

					try {
						// Do send the request (this may raise an exception)
						xhr.send( options.hasContent && options.data || null );
					} catch ( e ) {
						// #14683: Only rethrow if this hasn't been notified as an error yet
						if ( callback ) {
							throw e;
						}
					}
				},

				abort: function() {
					if ( callback ) {
						callback();
					}
				}
			};
		}
	});




	// Install script dataType
	jQuery.ajaxSetup({
		accepts: {
			script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
		},
		contents: {
			script: /(?:java|ecma)script/
		},
		converters: {
			"text script": function( text ) {
				jQuery.globalEval( text );
				return text;
			}
		}
	});

	// Handle cache's special case and crossDomain
	jQuery.ajaxPrefilter( "script", function( s ) {
		if ( s.cache === undefined ) {
			s.cache = false;
		}
		if ( s.crossDomain ) {
			s.type = "GET";
		}
	});

	// Bind script tag hack transport
	jQuery.ajaxTransport( "script", function( s ) {
		// This transport only deals with cross domain requests
		if ( s.crossDomain ) {
			var script, callback;
			return {
				send: function( _, complete ) {
					script = jQuery("<script>").prop({
						async: true,
						charset: s.scriptCharset,
						src: s.url
					}).on(
						"load error",
						callback = function( evt ) {
							script.remove();
							callback = null;
							if ( evt ) {
								complete( evt.type === "error" ? 404 : 200, evt.type );
							}
						}
					);
					document.head.appendChild( script[ 0 ] );
				},
				abort: function() {
					if ( callback ) {
						callback();
					}
				}
			};
		}
	});




	var oldCallbacks = [],
		rjsonp = /(=)\?(?=&|$)|\?\?/;

	// Default jsonp settings
	jQuery.ajaxSetup({
		jsonp: "callback",
		jsonpCallback: function() {
			var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
			this[ callback ] = true;
			return callback;
		}
	});

	// Detect, normalize options and install callbacks for jsonp requests
	jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

		var callbackName, overwritten, responseContainer,
			jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
				"url" :
				typeof s.data === "string" && !( s.contentType || "" ).indexOf("application/x-www-form-urlencoded") && rjsonp.test( s.data ) && "data"
			);

		// Handle iff the expected data type is "jsonp" or we have a parameter to set
		if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

			// Get callback name, remembering preexisting value associated with it
			callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
				s.jsonpCallback() :
				s.jsonpCallback;

			// Insert callback into url or form data
			if ( jsonProp ) {
				s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
			} else if ( s.jsonp !== false ) {
				s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
			}

			// Use data converter to retrieve json after script execution
			s.converters["script json"] = function() {
				if ( !responseContainer ) {
					jQuery.error( callbackName + " was not called" );
				}
				return responseContainer[ 0 ];
			};

			// force json dataType
			s.dataTypes[ 0 ] = "json";

			// Install callback
			overwritten = window[ callbackName ];
			window[ callbackName ] = function() {
				responseContainer = arguments;
			};

			// Clean-up function (fires after converters)
			jqXHR.always(function() {
				// Restore preexisting value
				window[ callbackName ] = overwritten;

				// Save back as free
				if ( s[ callbackName ] ) {
					// make sure that re-using the options doesn't screw things around
					s.jsonpCallback = originalSettings.jsonpCallback;

					// save the callback name for future use
					oldCallbacks.push( callbackName );
				}

				// Call if it was a function and we have a response
				if ( responseContainer && jQuery.isFunction( overwritten ) ) {
					overwritten( responseContainer[ 0 ] );
				}

				responseContainer = overwritten = undefined;
			});

			// Delegate to script
			return "script";
		}
	});




	// data: string of html
	// context (optional): If specified, the fragment will be created in this context, defaults to document
	// keepScripts (optional): If true, will include scripts passed in the html string
	jQuery.parseHTML = function( data, context, keepScripts ) {
		if ( !data || typeof data !== "string" ) {
			return null;
		}
		if ( typeof context === "boolean" ) {
			keepScripts = context;
			context = false;
		}
		context = context || document;

		var parsed = rsingleTag.exec( data ),
			scripts = !keepScripts && [];

		// Single tag
		if ( parsed ) {
			return [ context.createElement( parsed[1] ) ];
		}

		parsed = jQuery.buildFragment( [ data ], context, scripts );

		if ( scripts && scripts.length ) {
			jQuery( scripts ).remove();
		}

		return jQuery.merge( [], parsed.childNodes );
	};


	// Keep a copy of the old load method
	var _load = jQuery.fn.load;

	/**
	 * Load a url into a page
	 */
	jQuery.fn.load = function( url, params, callback ) {
		if ( typeof url !== "string" && _load ) {
			return _load.apply( this, arguments );
		}

		var selector, type, response,
			self = this,
			off = url.indexOf(" ");

		if ( off >= 0 ) {
			selector = jQuery.trim( url.slice( off ) );
			url = url.slice( 0, off );
		}

		// If it's a function
		if ( jQuery.isFunction( params ) ) {

			// We assume that it's the callback
			callback = params;
			params = undefined;

		// Otherwise, build a param string
		} else if ( params && typeof params === "object" ) {
			type = "POST";
		}

		// If we have elements to modify, make the request
		if ( self.length > 0 ) {
			jQuery.ajax({
				url: url,

				// if "type" variable is undefined, then "GET" method will be used
				type: type,
				dataType: "html",
				data: params
			}).done(function( responseText ) {

				// Save response for use in complete callback
				response = arguments;

				self.html( selector ?

					// If a selector was specified, locate the right elements in a dummy div
					// Exclude scripts to avoid IE 'Permission Denied' errors
					jQuery("<div>").append( jQuery.parseHTML( responseText ) ).find( selector ) :

					// Otherwise use the full result
					responseText );

			}).complete( callback && function( jqXHR, status ) {
				self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );
			});
		}

		return this;
	};




	// Attach a bunch of functions for handling common AJAX events
	jQuery.each( [ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function( i, type ) {
		jQuery.fn[ type ] = function( fn ) {
			return this.on( type, fn );
		};
	});




	jQuery.expr.filters.animated = function( elem ) {
		return jQuery.grep(jQuery.timers, function( fn ) {
			return elem === fn.elem;
		}).length;
	};




	var docElem = window.document.documentElement;

	/**
	 * Gets a window from an element
	 */
	function getWindow( elem ) {
		return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
	}

	jQuery.offset = {
		setOffset: function( elem, options, i ) {
			var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
				position = jQuery.css( elem, "position" ),
				curElem = jQuery( elem ),
				props = {};

			// Set position first, in-case top/left are set even on static elem
			if ( position === "static" ) {
				elem.style.position = "relative";
			}

			curOffset = curElem.offset();
			curCSSTop = jQuery.css( elem, "top" );
			curCSSLeft = jQuery.css( elem, "left" );
			calculatePosition = ( position === "absolute" || position === "fixed" ) &&
				( curCSSTop + curCSSLeft ).indexOf("auto") > -1;

			// Need to be able to calculate position if either
			// top or left is auto and position is either absolute or fixed
			if ( calculatePosition ) {
				curPosition = curElem.position();
				curTop = curPosition.top;
				curLeft = curPosition.left;

			} else {
				curTop = parseFloat( curCSSTop ) || 0;
				curLeft = parseFloat( curCSSLeft ) || 0;
			}

			if ( jQuery.isFunction( options ) ) {
				options = options.call( elem, i, curOffset );
			}

			if ( options.top != null ) {
				props.top = ( options.top - curOffset.top ) + curTop;
			}
			if ( options.left != null ) {
				props.left = ( options.left - curOffset.left ) + curLeft;
			}

			if ( "using" in options ) {
				options.using.call( elem, props );

			} else {
				curElem.css( props );
			}
		}
	};

	jQuery.fn.extend({
		offset: function( options ) {
			if ( arguments.length ) {
				return options === undefined ?
					this :
					this.each(function( i ) {
						jQuery.offset.setOffset( this, options, i );
					});
			}

			var docElem, win,
				elem = this[ 0 ],
				box = { top: 0, left: 0 },
				doc = elem && elem.ownerDocument;

			if ( !doc ) {
				return;
			}

			docElem = doc.documentElement;

			// Make sure it's not a disconnected DOM node
			if ( !jQuery.contains( docElem, elem ) ) {
				return box;
			}

			// Support: BlackBerry 5, iOS 3 (original iPhone)
			// If we don't have gBCR, just use 0,0 rather than error
			if ( typeof elem.getBoundingClientRect !== strundefined ) {
				box = elem.getBoundingClientRect();
			}
			win = getWindow( doc );
			return {
				top: box.top + win.pageYOffset - docElem.clientTop,
				left: box.left + win.pageXOffset - docElem.clientLeft
			};
		},

		position: function() {
			if ( !this[ 0 ] ) {
				return;
			}

			var offsetParent, offset,
				elem = this[ 0 ],
				parentOffset = { top: 0, left: 0 };

			// Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent
			if ( jQuery.css( elem, "position" ) === "fixed" ) {
				// Assume getBoundingClientRect is there when computed position is fixed
				offset = elem.getBoundingClientRect();

			} else {
				// Get *real* offsetParent
				offsetParent = this.offsetParent();

				// Get correct offsets
				offset = this.offset();
				if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
					parentOffset = offsetParent.offset();
				}

				// Add offsetParent borders
				parentOffset.top += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
			}

			// Subtract parent offsets and element margins
			return {
				top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
				left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
			};
		},

		offsetParent: function() {
			return this.map(function() {
				var offsetParent = this.offsetParent || docElem;

				while ( offsetParent && ( !jQuery.nodeName( offsetParent, "html" ) && jQuery.css( offsetParent, "position" ) === "static" ) ) {
					offsetParent = offsetParent.offsetParent;
				}

				return offsetParent || docElem;
			});
		}
	});

	// Create scrollLeft and scrollTop methods
	jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
		var top = "pageYOffset" === prop;

		jQuery.fn[ method ] = function( val ) {
			return access( this, function( elem, method, val ) {
				var win = getWindow( elem );

				if ( val === undefined ) {
					return win ? win[ prop ] : elem[ method ];
				}

				if ( win ) {
					win.scrollTo(
						!top ? val : window.pageXOffset,
						top ? val : window.pageYOffset
					);

				} else {
					elem[ method ] = val;
				}
			}, method, val, arguments.length, null );
		};
	});

	// Support: Safari<7+, Chrome<37+
	// Add the top/left cssHooks using jQuery.fn.position
	// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
	// Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280
	// getComputedStyle returns percent when specified for top/left/bottom/right;
	// rather than make the css module depend on the offset module, just check for it here
	jQuery.each( [ "top", "left" ], function( i, prop ) {
		jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
			function( elem, computed ) {
				if ( computed ) {
					computed = curCSS( elem, prop );
					// If curCSS returns percentage, fallback to offset
					return rnumnonpx.test( computed ) ?
						jQuery( elem ).position()[ prop ] + "px" :
						computed;
				}
			}
		);
	});


	// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
	jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
		jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name }, function( defaultExtra, funcName ) {
			// Margin is only for outerHeight, outerWidth
			jQuery.fn[ funcName ] = function( margin, value ) {
				var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
					extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

				return access( this, function( elem, type, value ) {
					var doc;

					if ( jQuery.isWindow( elem ) ) {
						// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
						// isn't a whole lot we can do. See pull request at this URL for discussion:
						// https://github.com/jquery/jquery/pull/764
						return elem.document.documentElement[ "client" + name ];
					}

					// Get document width or height
					if ( elem.nodeType === 9 ) {
						doc = elem.documentElement;

						// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
						// whichever is greatest
						return Math.max(
							elem.body[ "scroll" + name ], doc[ "scroll" + name ],
							elem.body[ "offset" + name ], doc[ "offset" + name ],
							doc[ "client" + name ]
						);
					}

					return value === undefined ?
						// Get width or height on the element, requesting but not forcing parseFloat
						jQuery.css( elem, type, extra ) :

						// Set width or height on the element
						jQuery.style( elem, type, value, extra );
				}, type, chainable ? margin : undefined, chainable, null );
			};
		});
	});


	// The number of elements contained in the matched element set
	jQuery.fn.size = function() {
		return this.length;
	};

	jQuery.fn.andSelf = jQuery.fn.addBack;




	// Register as a named AMD module, since jQuery can be concatenated with other
	// files that may use define, but not via a proper concatenation script that
	// understands anonymous AMD modules. A named AMD is safest and most robust
	// way to register. Lowercase jquery is used because AMD module names are
	// derived from file names, and jQuery is normally delivered in a lowercase
	// file name. Do this after creating the global so that if an AMD module wants
	// to call noConflict to hide this version of jQuery, it will work.

	// Note that for maximum portability, libraries that are not jQuery should
	// declare themselves as anonymous modules, and avoid setting a global if an
	// AMD loader is present. jQuery is a special case. For more information, see
	// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

	if ( true ) {
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
			return jQuery;
		}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}




	var
		// Map over jQuery in case of overwrite
		_jQuery = window.jQuery,

		// Map over the $ in case of overwrite
		_$ = window.$;

	jQuery.noConflict = function( deep ) {
		if ( window.$ === jQuery ) {
			window.$ = _$;
		}

		if ( deep && window.jQuery === jQuery ) {
			window.jQuery = _jQuery;
		}

		return jQuery;
	};

	// Expose jQuery and $ identifiers, even in AMD
	// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
	// and CommonJS for browser emulators (#13566)
	if ( typeof noGlobal === strundefined ) {
		window.jQuery = window.$ = jQuery;
	}




	return jQuery;

	}));


/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
	    _ = __webpack_require__(18);

	    var that = {};
	    var config = {};
	    that.get = function(){
	        return _.cloneDeep(config);
	    };

	    that.set = function(newConfig){
	        config = _.cloneDeep(newConfig);
	    };

	    module.exports = that;
	})();



/***/ }
/******/ ]);